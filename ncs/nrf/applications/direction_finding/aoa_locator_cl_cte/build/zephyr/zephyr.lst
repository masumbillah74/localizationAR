
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00000000 <_vector_table>:

	return 0;
}

void *z_get_fd_obj(int fd, const struct fd_op_vtable *vtable, int err)
{
   0:	20006ca0 	.word	0x20006ca0
   4:	00002ad1 	.word	0x00002ad1
	struct fd_entry *fd_entry;

	if (_check_fd(fd) < 0) {
   8:	0000e013 	.word	0x0000e013
   c:	00002b01 	.word	0x00002b01
		return NULL;
	}

	fd_entry = &fdtable[fd];

	if (vtable != NULL && fd_entry->vtable != vtable) {
  10:	00002b01 	.word	0x00002b01
  14:	00002b01 	.word	0x00002b01
  18:	00002b01 	.word	0x00002b01
	...
		errno = err;
		return NULL;
  2c:	0000283d 	.word	0x0000283d
		return NULL;
  30:	00002b01 	.word	0x00002b01
  34:	00000000 	.word	0x00000000
		forced_pm_state = SYS_POWER_STATE_AUTO;
		sys_pm_notify_power_state_exit(pm_state);
		_sys_pm_power_state_exit_post_ops(pm_state);
	}

	return pm_state;
  38:	000027f5 	.word	0x000027f5
}
  3c:	0000df49 	.word	0x0000df49

00000040 <_irq_vector_table>:
		   sys_pm_policy_next_state(ticks) : forced_pm_state;
  40:	00002a91 0000f09f 00002a91 00002a91     .*.......*...*..
		sys_pm_notify_power_state_exit(pm_state);
  50:	00002a91 00002a91 00002a91 00002a91     .*...*...*...*..
		_sys_pm_power_state_exit_post_ops(pm_state);
  60:	00002a91 00002a91 00002a91 00002a91     .*...*...*...*..
  70:	00002a91 00002a91 00002a91 00002a91     .*...*...*...*..
  80:	00002a91 00002a91 00002a91 00002a91     .*...*...*...*..
  90:	00002a91 00002a91 00002a91 00002a91     .*...*...*...*..
  a0:	00002a91 00002a91 00002a91 00002a91     .*...*...*...*..
  b0:	00002a91 00002a91 00002a91 00002a91     .*...*...*...*..
  c0:	00002a91 00002a91 00002a91 00002a91     .*...*...*...*..
  d0:	00002a91 00002a91 00002a91 00002a91     .*...*...*...*..
  e0:	00002a91 00002a91 00002a91 00002a91     .*...*...*...*..
  f0:	00002a91 00002a91 00002a91 00002a91     .*...*...*...*..

Disassembly of section text:

00000100 <memchr>:
     100:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     104:	2a10      	cmp	r2, #16
     106:	db2b      	blt.n	160 <CONFIG_IDLE_STACK_SIZE+0x20>
     108:	f010 0f07 	tst.w	r0, #7
     10c:	d008      	beq.n	120 <memchr+0x20>
     10e:	f810 3b01 	ldrb.w	r3, [r0], #1
     112:	3a01      	subs	r2, #1
     114:	428b      	cmp	r3, r1
     116:	d02d      	beq.n	174 <CONFIG_IDLE_STACK_SIZE+0x34>
     118:	f010 0f07 	tst.w	r0, #7
     11c:	b342      	cbz	r2, 170 <CONFIG_IDLE_STACK_SIZE+0x30>
     11e:	d1f6      	bne.n	10e <memchr+0xe>
     120:	b4f0      	push	{r4, r5, r6, r7}
     122:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
     126:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
     12a:	f022 0407 	bic.w	r4, r2, #7
     12e:	f07f 0700 	mvns.w	r7, #0
     132:	2300      	movs	r3, #0
     134:	e8f0 5602 	ldrd	r5, r6, [r0], #8
     138:	3c08      	subs	r4, #8
     13a:	ea85 0501 	eor.w	r5, r5, r1
     13e:	ea86 0601 	eor.w	r6, r6, r1
     142:	fa85 f547 	uadd8	r5, r5, r7
     146:	faa3 f587 	sel	r5, r3, r7
     14a:	fa86 f647 	uadd8	r6, r6, r7
     14e:	faa5 f687 	sel	r6, r5, r7
     152:	b98e      	cbnz	r6, 178 <CONFIG_IDLE_STACK_SIZE+0x38>
     154:	d1ee      	bne.n	134 <memchr+0x34>
     156:	bcf0      	pop	{r4, r5, r6, r7}
     158:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     15c:	f002 0207 	and.w	r2, r2, #7
     160:	b132      	cbz	r2, 170 <CONFIG_IDLE_STACK_SIZE+0x30>
     162:	f810 3b01 	ldrb.w	r3, [r0], #1
     166:	3a01      	subs	r2, #1
     168:	ea83 0301 	eor.w	r3, r3, r1
     16c:	b113      	cbz	r3, 174 <CONFIG_IDLE_STACK_SIZE+0x34>
     16e:	d1f8      	bne.n	162 <CONFIG_IDLE_STACK_SIZE+0x22>
     170:	2000      	movs	r0, #0
     172:	4770      	bx	lr
     174:	3801      	subs	r0, #1
     176:	4770      	bx	lr
     178:	2d00      	cmp	r5, #0
     17a:	bf06      	itte	eq
     17c:	4635      	moveq	r5, r6
     17e:	3803      	subeq	r0, #3
     180:	3807      	subne	r0, #7
     182:	f015 0f01 	tst.w	r5, #1
     186:	d107      	bne.n	198 <CONFIG_IDLE_STACK_SIZE+0x58>
     188:	3001      	adds	r0, #1
     18a:	f415 7f80 	tst.w	r5, #256	; 0x100
     18e:	bf02      	ittt	eq
     190:	3001      	addeq	r0, #1
     192:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
     196:	3001      	addeq	r0, #1
     198:	bcf0      	pop	{r4, r5, r6, r7}
     19a:	3801      	subs	r0, #1
     19c:	4770      	bx	lr
     19e:	bf00      	nop

000001a0 <__aeabi_frsub>:
     1a0:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
     1a4:	e002      	b.n	1ac <__addsf3>
     1a6:	bf00      	nop

000001a8 <__aeabi_fsub>:
     1a8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

000001ac <__addsf3>:
     1ac:	0042      	lsls	r2, r0, #1
     1ae:	bf1f      	itttt	ne
     1b0:	ea5f 0341 	movsne.w	r3, r1, lsl #1
     1b4:	ea92 0f03 	teqne	r2, r3
     1b8:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
     1bc:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
     1c0:	d06a      	beq.n	298 <CONFIG_BT_HCI_TX_STACK_SIZE+0x18>
     1c2:	ea4f 6212 	mov.w	r2, r2, lsr #24
     1c6:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
     1ca:	bfc1      	itttt	gt
     1cc:	18d2      	addgt	r2, r2, r3
     1ce:	4041      	eorgt	r1, r0
     1d0:	4048      	eorgt	r0, r1
     1d2:	4041      	eorgt	r1, r0
     1d4:	bfb8      	it	lt
     1d6:	425b      	neglt	r3, r3
     1d8:	2b19      	cmp	r3, #25
     1da:	bf88      	it	hi
     1dc:	4770      	bxhi	lr
     1de:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
     1e2:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
     1e6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
     1ea:	bf18      	it	ne
     1ec:	4240      	negne	r0, r0
     1ee:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
     1f2:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
     1f6:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
     1fa:	bf18      	it	ne
     1fc:	4249      	negne	r1, r1
     1fe:	ea92 0f03 	teq	r2, r3
     202:	d03f      	beq.n	284 <CONFIG_BT_HCI_TX_STACK_SIZE+0x4>
     204:	f1a2 0201 	sub.w	r2, r2, #1
     208:	fa41 fc03 	asr.w	ip, r1, r3
     20c:	eb10 000c 	adds.w	r0, r0, ip
     210:	f1c3 0320 	rsb	r3, r3, #32
     214:	fa01 f103 	lsl.w	r1, r1, r3
     218:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
     21c:	d502      	bpl.n	224 <CONFIG_FLASH_SIZE+0x24>
     21e:	4249      	negs	r1, r1
     220:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
     224:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
     228:	d313      	bcc.n	252 <CONFIG_FLASH_SIZE+0x52>
     22a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
     22e:	d306      	bcc.n	23e <CONFIG_FLASH_SIZE+0x3e>
     230:	0840      	lsrs	r0, r0, #1
     232:	ea4f 0131 	mov.w	r1, r1, rrx
     236:	f102 0201 	add.w	r2, r2, #1
     23a:	2afe      	cmp	r2, #254	; 0xfe
     23c:	d251      	bcs.n	2e2 <CONFIG_BT_HCI_TX_STACK_SIZE+0x62>
     23e:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
     242:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
     246:	bf08      	it	eq
     248:	f020 0001 	biceq.w	r0, r0, #1
     24c:	ea40 0003 	orr.w	r0, r0, r3
     250:	4770      	bx	lr
     252:	0049      	lsls	r1, r1, #1
     254:	eb40 0000 	adc.w	r0, r0, r0
     258:	3a01      	subs	r2, #1
     25a:	bf28      	it	cs
     25c:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
     260:	d2ed      	bcs.n	23e <CONFIG_FLASH_SIZE+0x3e>
     262:	fab0 fc80 	clz	ip, r0
     266:	f1ac 0c08 	sub.w	ip, ip, #8
     26a:	ebb2 020c 	subs.w	r2, r2, ip
     26e:	fa00 f00c 	lsl.w	r0, r0, ip
     272:	bfaa      	itet	ge
     274:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
     278:	4252      	neglt	r2, r2
     27a:	4318      	orrge	r0, r3
     27c:	bfbc      	itt	lt
     27e:	40d0      	lsrlt	r0, r2
     280:	4318      	orrlt	r0, r3
     282:	4770      	bx	lr
     284:	f092 0f00 	teq	r2, #0
     288:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
     28c:	bf06      	itte	eq
     28e:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
     292:	3201      	addeq	r2, #1
     294:	3b01      	subne	r3, #1
     296:	e7b5      	b.n	204 <CONFIG_FLASH_SIZE+0x4>
     298:	ea4f 0341 	mov.w	r3, r1, lsl #1
     29c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
     2a0:	bf18      	it	ne
     2a2:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
     2a6:	d021      	beq.n	2ec <CONFIG_BT_HCI_TX_STACK_SIZE+0x6c>
     2a8:	ea92 0f03 	teq	r2, r3
     2ac:	d004      	beq.n	2b8 <CONFIG_BT_HCI_TX_STACK_SIZE+0x38>
     2ae:	f092 0f00 	teq	r2, #0
     2b2:	bf08      	it	eq
     2b4:	4608      	moveq	r0, r1
     2b6:	4770      	bx	lr
     2b8:	ea90 0f01 	teq	r0, r1
     2bc:	bf1c      	itt	ne
     2be:	2000      	movne	r0, #0
     2c0:	4770      	bxne	lr
     2c2:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
     2c6:	d104      	bne.n	2d2 <CONFIG_BT_HCI_TX_STACK_SIZE+0x52>
     2c8:	0040      	lsls	r0, r0, #1
     2ca:	bf28      	it	cs
     2cc:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
     2d0:	4770      	bx	lr
     2d2:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
     2d6:	bf3c      	itt	cc
     2d8:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
     2dc:	4770      	bxcc	lr
     2de:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
     2e2:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
     2e6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
     2ea:	4770      	bx	lr
     2ec:	ea7f 6222 	mvns.w	r2, r2, asr #24
     2f0:	bf16      	itet	ne
     2f2:	4608      	movne	r0, r1
     2f4:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
     2f8:	4601      	movne	r1, r0
     2fa:	0242      	lsls	r2, r0, #9
     2fc:	bf06      	itte	eq
     2fe:	ea5f 2341 	movseq.w	r3, r1, lsl #9
     302:	ea90 0f01 	teqeq	r0, r1
     306:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
     30a:	4770      	bx	lr

0000030c <__aeabi_ui2f>:
     30c:	f04f 0300 	mov.w	r3, #0
     310:	e004      	b.n	31c <__aeabi_i2f+0x8>
     312:	bf00      	nop

00000314 <__aeabi_i2f>:
     314:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
     318:	bf48      	it	mi
     31a:	4240      	negmi	r0, r0
     31c:	ea5f 0c00 	movs.w	ip, r0
     320:	bf08      	it	eq
     322:	4770      	bxeq	lr
     324:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
     328:	4601      	mov	r1, r0
     32a:	f04f 0000 	mov.w	r0, #0
     32e:	e01c      	b.n	36a <__aeabi_l2f+0x2a>

00000330 <__aeabi_ul2f>:
     330:	ea50 0201 	orrs.w	r2, r0, r1
     334:	bf08      	it	eq
     336:	4770      	bxeq	lr
     338:	f04f 0300 	mov.w	r3, #0
     33c:	e00a      	b.n	354 <__aeabi_l2f+0x14>
     33e:	bf00      	nop

00000340 <__aeabi_l2f>:
     340:	ea50 0201 	orrs.w	r2, r0, r1
     344:	bf08      	it	eq
     346:	4770      	bxeq	lr
     348:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
     34c:	d502      	bpl.n	354 <__aeabi_l2f+0x14>
     34e:	4240      	negs	r0, r0
     350:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     354:	ea5f 0c01 	movs.w	ip, r1
     358:	bf02      	ittt	eq
     35a:	4684      	moveq	ip, r0
     35c:	4601      	moveq	r1, r0
     35e:	2000      	moveq	r0, #0
     360:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
     364:	bf08      	it	eq
     366:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
     36a:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
     36e:	fabc f28c 	clz	r2, ip
     372:	3a08      	subs	r2, #8
     374:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
     378:	db10      	blt.n	39c <__aeabi_l2f+0x5c>
     37a:	fa01 fc02 	lsl.w	ip, r1, r2
     37e:	4463      	add	r3, ip
     380:	fa00 fc02 	lsl.w	ip, r0, r2
     384:	f1c2 0220 	rsb	r2, r2, #32
     388:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
     38c:	fa20 f202 	lsr.w	r2, r0, r2
     390:	eb43 0002 	adc.w	r0, r3, r2
     394:	bf08      	it	eq
     396:	f020 0001 	biceq.w	r0, r0, #1
     39a:	4770      	bx	lr
     39c:	f102 0220 	add.w	r2, r2, #32
     3a0:	fa01 fc02 	lsl.w	ip, r1, r2
     3a4:	f1c2 0220 	rsb	r2, r2, #32
     3a8:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
     3ac:	fa21 f202 	lsr.w	r2, r1, r2
     3b0:	eb43 0002 	adc.w	r0, r3, r2
     3b4:	bf08      	it	eq
     3b6:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
     3ba:	4770      	bx	lr

000003bc <__aeabi_f2iz>:
     3bc:	ea4f 0240 	mov.w	r2, r0, lsl #1
     3c0:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
     3c4:	d30f      	bcc.n	3e6 <__aeabi_f2iz+0x2a>
     3c6:	f04f 039e 	mov.w	r3, #158	; 0x9e
     3ca:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
     3ce:	d90d      	bls.n	3ec <CONFIG_BT_CTLR_DFE_SAMPLE_SPACING_NS+0x4>
     3d0:	ea4f 2300 	mov.w	r3, r0, lsl #8
     3d4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     3d8:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
     3dc:	fa23 f002 	lsr.w	r0, r3, r2
     3e0:	bf18      	it	ne
     3e2:	4240      	negne	r0, r0
     3e4:	4770      	bx	lr
     3e6:	f04f 0000 	mov.w	r0, #0
     3ea:	4770      	bx	lr
     3ec:	f112 0f61 	cmn.w	r2, #97	; 0x61
     3f0:	d101      	bne.n	3f6 <CONFIG_BT_CTLR_DFE_SAMPLE_SPACING_NS+0xe>
     3f2:	0242      	lsls	r2, r0, #9
     3f4:	d105      	bne.n	402 <CONFIG_BT_RX_STACK_SIZE+0x2>
     3f6:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
     3fa:	bf08      	it	eq
     3fc:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
     400:	4770      	bx	lr
     402:	f04f 0000 	mov.w	r0, #0
     406:	4770      	bx	lr

00000408 <__aeabi_uldivmod>:
     408:	b953      	cbnz	r3, 420 <__aeabi_uldivmod+0x18>
     40a:	b94a      	cbnz	r2, 420 <__aeabi_uldivmod+0x18>
     40c:	2900      	cmp	r1, #0
     40e:	bf08      	it	eq
     410:	2800      	cmpeq	r0, #0
     412:	bf1c      	itt	ne
     414:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
     418:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
     41c:	f000 b96e 	b.w	6fc <__aeabi_idiv0>
     420:	f1ad 0c08 	sub.w	ip, sp, #8
     424:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     428:	f000 f806 	bl	438 <__udivmoddi4>
     42c:	f8dd e004 	ldr.w	lr, [sp, #4]
     430:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     434:	b004      	add	sp, #16
     436:	4770      	bx	lr

00000438 <__udivmoddi4>:
     438:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     43c:	9d08      	ldr	r5, [sp, #32]
     43e:	460e      	mov	r6, r1
     440:	4604      	mov	r4, r0
     442:	468c      	mov	ip, r1
     444:	2b00      	cmp	r3, #0
     446:	f040 8081 	bne.w	54c <CONFIG_BT_HCI_ECC_STACK_SIZE+0x100>
     44a:	428a      	cmp	r2, r1
     44c:	4617      	mov	r7, r2
     44e:	d945      	bls.n	4dc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x90>
     450:	fab2 f282 	clz	r2, r2
     454:	b14a      	cbz	r2, 46a <CONFIG_BT_HCI_ECC_STACK_SIZE+0x1e>
     456:	f1c2 0120 	rsb	r1, r2, #32
     45a:	fa06 f302 	lsl.w	r3, r6, r2
     45e:	fa20 f101 	lsr.w	r1, r0, r1
     462:	4097      	lsls	r7, r2
     464:	ea41 0c03 	orr.w	ip, r1, r3
     468:	4094      	lsls	r4, r2
     46a:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     46e:	0c23      	lsrs	r3, r4, #16
     470:	fbbc f6fe 	udiv	r6, ip, lr
     474:	b2b9      	uxth	r1, r7
     476:	fb0e cc16 	mls	ip, lr, r6, ip
     47a:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
     47e:	fb06 f001 	mul.w	r0, r6, r1
     482:	4298      	cmp	r0, r3
     484:	d909      	bls.n	49a <CONFIG_BT_HCI_ECC_STACK_SIZE+0x4e>
     486:	18fb      	adds	r3, r7, r3
     488:	f106 3cff 	add.w	ip, r6, #4294967295	; 0xffffffff
     48c:	f080 8115 	bcs.w	6ba <CONFIG_BT_COMPANY_ID+0xc9>
     490:	4298      	cmp	r0, r3
     492:	f240 8112 	bls.w	6ba <CONFIG_BT_COMPANY_ID+0xc9>
     496:	3e02      	subs	r6, #2
     498:	443b      	add	r3, r7
     49a:	1a1b      	subs	r3, r3, r0
     49c:	b2a4      	uxth	r4, r4
     49e:	fbb3 f0fe 	udiv	r0, r3, lr
     4a2:	fb0e 3310 	mls	r3, lr, r0, r3
     4a6:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     4aa:	fb00 f101 	mul.w	r1, r0, r1
     4ae:	42a1      	cmp	r1, r4
     4b0:	d909      	bls.n	4c6 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x7a>
     4b2:	193c      	adds	r4, r7, r4
     4b4:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
     4b8:	f080 8101 	bcs.w	6be <CONFIG_BT_COMPANY_ID+0xcd>
     4bc:	42a1      	cmp	r1, r4
     4be:	f240 80fe 	bls.w	6be <CONFIG_BT_COMPANY_ID+0xcd>
     4c2:	3802      	subs	r0, #2
     4c4:	443c      	add	r4, r7
     4c6:	1a64      	subs	r4, r4, r1
     4c8:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
     4cc:	2100      	movs	r1, #0
     4ce:	b11d      	cbz	r5, 4d8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x8c>
     4d0:	40d4      	lsrs	r4, r2
     4d2:	2300      	movs	r3, #0
     4d4:	e9c5 4300 	strd	r4, r3, [r5]
     4d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     4dc:	b902      	cbnz	r2, 4e0 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x94>
     4de:	deff      	udf	#255	; 0xff
     4e0:	fab2 f282 	clz	r2, r2
     4e4:	2a00      	cmp	r2, #0
     4e6:	d14f      	bne.n	588 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x13c>
     4e8:	1bcb      	subs	r3, r1, r7
     4ea:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     4ee:	fa1f f887 	uxth.w	r8, r7
     4f2:	2101      	movs	r1, #1
     4f4:	fbb3 fcfe 	udiv	ip, r3, lr
     4f8:	0c26      	lsrs	r6, r4, #16
     4fa:	fb0e 331c 	mls	r3, lr, ip, r3
     4fe:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
     502:	fb08 f30c 	mul.w	r3, r8, ip
     506:	42b3      	cmp	r3, r6
     508:	d907      	bls.n	51a <CONFIG_BT_HCI_ECC_STACK_SIZE+0xce>
     50a:	19be      	adds	r6, r7, r6
     50c:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
     510:	d202      	bcs.n	518 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xcc>
     512:	42b3      	cmp	r3, r6
     514:	f200 80eb 	bhi.w	6ee <CONFIG_BT_COMPANY_ID+0xfd>
     518:	4684      	mov	ip, r0
     51a:	1af6      	subs	r6, r6, r3
     51c:	b2a3      	uxth	r3, r4
     51e:	fbb6 f0fe 	udiv	r0, r6, lr
     522:	fb0e 6610 	mls	r6, lr, r0, r6
     526:	ea43 4406 	orr.w	r4, r3, r6, lsl #16
     52a:	fb08 f800 	mul.w	r8, r8, r0
     52e:	45a0      	cmp	r8, r4
     530:	d907      	bls.n	542 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xf6>
     532:	193c      	adds	r4, r7, r4
     534:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
     538:	d202      	bcs.n	540 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xf4>
     53a:	45a0      	cmp	r8, r4
     53c:	f200 80d2 	bhi.w	6e4 <CONFIG_BT_COMPANY_ID+0xf3>
     540:	4618      	mov	r0, r3
     542:	eba4 0408 	sub.w	r4, r4, r8
     546:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
     54a:	e7c0      	b.n	4ce <CONFIG_BT_HCI_ECC_STACK_SIZE+0x82>
     54c:	428b      	cmp	r3, r1
     54e:	d908      	bls.n	562 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x116>
     550:	2d00      	cmp	r5, #0
     552:	f000 80af 	beq.w	6b4 <CONFIG_BT_COMPANY_ID+0xc3>
     556:	2100      	movs	r1, #0
     558:	e9c5 0600 	strd	r0, r6, [r5]
     55c:	4608      	mov	r0, r1
     55e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     562:	fab3 f183 	clz	r1, r3
     566:	2900      	cmp	r1, #0
     568:	d149      	bne.n	5fe <CONFIG_BT_COMPANY_ID+0xd>
     56a:	42b3      	cmp	r3, r6
     56c:	d302      	bcc.n	574 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x128>
     56e:	4282      	cmp	r2, r0
     570:	f200 80bb 	bhi.w	6ea <CONFIG_BT_COMPANY_ID+0xf9>
     574:	1a84      	subs	r4, r0, r2
     576:	eb66 0303 	sbc.w	r3, r6, r3
     57a:	2001      	movs	r0, #1
     57c:	469c      	mov	ip, r3
     57e:	2d00      	cmp	r5, #0
     580:	d0aa      	beq.n	4d8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x8c>
     582:	e9c5 4c00 	strd	r4, ip, [r5]
     586:	e7a7      	b.n	4d8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x8c>
     588:	f1c2 0320 	rsb	r3, r2, #32
     58c:	4097      	lsls	r7, r2
     58e:	40d8      	lsrs	r0, r3
     590:	4091      	lsls	r1, r2
     592:	40de      	lsrs	r6, r3
     594:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     598:	4308      	orrs	r0, r1
     59a:	ea4f 4c10 	mov.w	ip, r0, lsr #16
     59e:	fbb6 f1fe 	udiv	r1, r6, lr
     5a2:	fa1f f887 	uxth.w	r8, r7
     5a6:	fb0e 6611 	mls	r6, lr, r1, r6
     5aa:	ea4c 4606 	orr.w	r6, ip, r6, lsl #16
     5ae:	fb01 f308 	mul.w	r3, r1, r8
     5b2:	42b3      	cmp	r3, r6
     5b4:	fa04 f402 	lsl.w	r4, r4, r2
     5b8:	d909      	bls.n	5ce <CONFIG_BT_HCI_ECC_STACK_SIZE+0x182>
     5ba:	19be      	adds	r6, r7, r6
     5bc:	f101 3cff 	add.w	ip, r1, #4294967295	; 0xffffffff
     5c0:	f080 808e 	bcs.w	6e0 <CONFIG_BT_COMPANY_ID+0xef>
     5c4:	42b3      	cmp	r3, r6
     5c6:	f240 808b 	bls.w	6e0 <CONFIG_BT_COMPANY_ID+0xef>
     5ca:	3902      	subs	r1, #2
     5cc:	443e      	add	r6, r7
     5ce:	1af3      	subs	r3, r6, r3
     5d0:	b286      	uxth	r6, r0
     5d2:	fbb3 f0fe 	udiv	r0, r3, lr
     5d6:	fb0e 3310 	mls	r3, lr, r0, r3
     5da:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
     5de:	fb00 f308 	mul.w	r3, r0, r8
     5e2:	42b3      	cmp	r3, r6
     5e4:	d907      	bls.n	5f6 <CONFIG_BT_COMPANY_ID+0x5>
     5e6:	19be      	adds	r6, r7, r6
     5e8:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
     5ec:	d274      	bcs.n	6d8 <CONFIG_BT_COMPANY_ID+0xe7>
     5ee:	42b3      	cmp	r3, r6
     5f0:	d972      	bls.n	6d8 <CONFIG_BT_COMPANY_ID+0xe7>
     5f2:	3802      	subs	r0, #2
     5f4:	443e      	add	r6, r7
     5f6:	1af3      	subs	r3, r6, r3
     5f8:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
     5fc:	e77a      	b.n	4f4 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xa8>
     5fe:	f1c1 0720 	rsb	r7, r1, #32
     602:	fa03 f401 	lsl.w	r4, r3, r1
     606:	fa22 f307 	lsr.w	r3, r2, r7
     60a:	431c      	orrs	r4, r3
     60c:	fa20 f907 	lsr.w	r9, r0, r7
     610:	fa06 f301 	lsl.w	r3, r6, r1
     614:	ea4f 4c14 	mov.w	ip, r4, lsr #16
     618:	40fe      	lsrs	r6, r7
     61a:	ea49 0903 	orr.w	r9, r9, r3
     61e:	ea4f 4319 	mov.w	r3, r9, lsr #16
     622:	fbb6 fefc 	udiv	lr, r6, ip
     626:	fa1f f884 	uxth.w	r8, r4
     62a:	fb0c 661e 	mls	r6, ip, lr, r6
     62e:	ea43 4606 	orr.w	r6, r3, r6, lsl #16
     632:	fb0e fa08 	mul.w	sl, lr, r8
     636:	45b2      	cmp	sl, r6
     638:	fa02 f201 	lsl.w	r2, r2, r1
     63c:	fa00 f301 	lsl.w	r3, r0, r1
     640:	d908      	bls.n	654 <CONFIG_BT_COMPANY_ID+0x63>
     642:	19a6      	adds	r6, r4, r6
     644:	f10e 30ff 	add.w	r0, lr, #4294967295	; 0xffffffff
     648:	d248      	bcs.n	6dc <CONFIG_BT_COMPANY_ID+0xeb>
     64a:	45b2      	cmp	sl, r6
     64c:	d946      	bls.n	6dc <CONFIG_BT_COMPANY_ID+0xeb>
     64e:	f1ae 0e02 	sub.w	lr, lr, #2
     652:	4426      	add	r6, r4
     654:	eba6 060a 	sub.w	r6, r6, sl
     658:	fa1f f989 	uxth.w	r9, r9
     65c:	fbb6 f0fc 	udiv	r0, r6, ip
     660:	fb0c 6610 	mls	r6, ip, r0, r6
     664:	ea49 4606 	orr.w	r6, r9, r6, lsl #16
     668:	fb00 f808 	mul.w	r8, r0, r8
     66c:	45b0      	cmp	r8, r6
     66e:	d907      	bls.n	680 <CONFIG_BT_COMPANY_ID+0x8f>
     670:	19a6      	adds	r6, r4, r6
     672:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
     676:	d22d      	bcs.n	6d4 <CONFIG_BT_COMPANY_ID+0xe3>
     678:	45b0      	cmp	r8, r6
     67a:	d92b      	bls.n	6d4 <CONFIG_BT_COMPANY_ID+0xe3>
     67c:	3802      	subs	r0, #2
     67e:	4426      	add	r6, r4
     680:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     684:	eba6 0608 	sub.w	r6, r6, r8
     688:	fba0 8902 	umull	r8, r9, r0, r2
     68c:	454e      	cmp	r6, r9
     68e:	46c4      	mov	ip, r8
     690:	46ce      	mov	lr, r9
     692:	d318      	bcc.n	6c6 <CONFIG_BT_COMPANY_ID+0xd5>
     694:	d015      	beq.n	6c2 <CONFIG_BT_COMPANY_ID+0xd1>
     696:	b375      	cbz	r5, 6f6 <CONFIG_BT_COMPANY_ID+0x105>
     698:	ebb3 020c 	subs.w	r2, r3, ip
     69c:	eb66 060e 	sbc.w	r6, r6, lr
     6a0:	fa06 f707 	lsl.w	r7, r6, r7
     6a4:	fa22 f301 	lsr.w	r3, r2, r1
     6a8:	40ce      	lsrs	r6, r1
     6aa:	431f      	orrs	r7, r3
     6ac:	e9c5 7600 	strd	r7, r6, [r5]
     6b0:	2100      	movs	r1, #0
     6b2:	e711      	b.n	4d8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x8c>
     6b4:	4629      	mov	r1, r5
     6b6:	4628      	mov	r0, r5
     6b8:	e70e      	b.n	4d8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x8c>
     6ba:	4666      	mov	r6, ip
     6bc:	e6ed      	b.n	49a <CONFIG_BT_HCI_ECC_STACK_SIZE+0x4e>
     6be:	4618      	mov	r0, r3
     6c0:	e701      	b.n	4c6 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x7a>
     6c2:	4543      	cmp	r3, r8
     6c4:	d2e7      	bcs.n	696 <CONFIG_BT_COMPANY_ID+0xa5>
     6c6:	ebb8 0c02 	subs.w	ip, r8, r2
     6ca:	eb69 0404 	sbc.w	r4, r9, r4
     6ce:	3801      	subs	r0, #1
     6d0:	46a6      	mov	lr, r4
     6d2:	e7e0      	b.n	696 <CONFIG_BT_COMPANY_ID+0xa5>
     6d4:	4660      	mov	r0, ip
     6d6:	e7d3      	b.n	680 <CONFIG_BT_COMPANY_ID+0x8f>
     6d8:	4660      	mov	r0, ip
     6da:	e78c      	b.n	5f6 <CONFIG_BT_COMPANY_ID+0x5>
     6dc:	4686      	mov	lr, r0
     6de:	e7b9      	b.n	654 <CONFIG_BT_COMPANY_ID+0x63>
     6e0:	4661      	mov	r1, ip
     6e2:	e774      	b.n	5ce <CONFIG_BT_HCI_ECC_STACK_SIZE+0x182>
     6e4:	3802      	subs	r0, #2
     6e6:	443c      	add	r4, r7
     6e8:	e72b      	b.n	542 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xf6>
     6ea:	4608      	mov	r0, r1
     6ec:	e747      	b.n	57e <CONFIG_BT_HCI_ECC_STACK_SIZE+0x132>
     6ee:	f1ac 0c02 	sub.w	ip, ip, #2
     6f2:	443e      	add	r6, r7
     6f4:	e711      	b.n	51a <CONFIG_BT_HCI_ECC_STACK_SIZE+0xce>
     6f6:	4629      	mov	r1, r5
     6f8:	e6ee      	b.n	4d8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x8c>
     6fa:	bf00      	nop

000006fc <__aeabi_idiv0>:
     6fc:	4770      	bx	lr
     6fe:	bf00      	nop

00000700 <strcmp>:
     700:	f810 2b01 	ldrb.w	r2, [r0], #1
     704:	f811 3b01 	ldrb.w	r3, [r1], #1
     708:	2a01      	cmp	r2, #1
     70a:	bf28      	it	cs
     70c:	429a      	cmpcs	r2, r3
     70e:	d0f7      	beq.n	700 <strcmp>
     710:	1ad0      	subs	r0, r2, r3
     712:	4770      	bx	lr
     714:	0000      	movs	r0, r0
	...

00000718 <ull_scan_params_set>:
	return 0;
}

void ull_scan_params_set(struct lll_scan *lll, u8_t type, u16_t interval,
			 u16_t window, u8_t filter_policy)
{
     718:	b510      	push	{r4, lr}
     71a:	4604      	mov	r4, r0
	 * 0110b - invalid
	 * 0111b - invalid
	 * 1000b - Ext. Coded passive
	 * 1001b - Ext. Coded active
	 */
	lll->type = type;
     71c:	7a00      	ldrb	r0, [r0, #8]
     71e:	f361 10c7 	bfi	r0, r1, #7, #1

#if defined(CONFIG_BT_CTLR_ADV_EXT)
	lll->phy = type >> 1;
#endif /* CONFIG_BT_CTLR_ADV_EXT */

	lll->filter_policy = filter_policy;
     722:	f89d 1008 	ldrb.w	r1, [sp, #8]
     726:	f361 00c4 	bfi	r0, r1, #3, #2
     72a:	7220      	strb	r0, [r4, #8]
	lll->interval = interval;
     72c:	82e2      	strh	r2, [r4, #22]
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
     72e:	480a      	ldr	r0, [pc, #40]	; (758 <ull_scan_params_set+0x40>)
     730:	fba3 0100 	umull	r0, r1, r3, r0
     734:	2291      	movs	r2, #145	; 0x91
     736:	fb02 1103 	mla	r1, r2, r3, r1
     73a:	a305      	add	r3, pc, #20	; (adr r3, 750 <ull_scan_params_set+0x38>)
     73c:	e9d3 2300 	ldrd	r2, r3, [r3]
     740:	f7ff fe62 	bl	408 <__aeabi_uldivmod>
     744:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
     748:	61a0      	str	r0, [r4, #24]
}
     74a:	bd10      	pop	{r4, pc}
     74c:	f3af 8000 	nop.w
     750:	1afd498d 	.word	0x1afd498d
     754:	00000007 	.word	0x00000007
     758:	84e72a00 	.word	0x84e72a00
     75c:	00000000 	.word	0x00000000

00000760 <ull_scan_enable>:

u8_t ull_scan_enable(struct ll_scan_set *scan)
{
     760:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     764:	b08d      	sub	sp, #52	; 0x34
     766:	4604      	mov	r4, r0
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
     768:	2302      	movs	r3, #2
     76a:	930b      	str	r3, [sp, #44]	; 0x2c


#if  defined(CONFIG_BT_CTLR_DFE_ADV_SINGLE_CHANNEL_MODE)
	lll->chan = (CONFIG_BT_CTLR_DFE_ADV_SINGLE_CHANNEL_NUMBER - BT_CTRL_ADV_CHANNEL_START);
#else
	lll->chan = 0;
     76c:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
#endif  /* CONFIG_BT_CTLR_DFE_ADV_SINGLE_CHANNEL_MODE */

	lll->init_addr_type = scan->own_addr_type;
     770:	f890 0038 	ldrb.w	r0, [r0, #56]	; 0x38
     774:	f3c0 0040 	ubfx	r0, r0, #1, #1
     778:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
     77c:	f360 1386 	bfi	r3, r0, #6, #1
     780:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
	ll_addr_get(lll->init_addr_type, lll->init_addr);
     784:	f104 0125 	add.w	r1, r4, #37	; 0x25
     788:	f005 fab6 	bl	5cf8 <ll_addr_get>
	return hdr->ref--;
}

static inline void ull_hdr_init(struct ull_hdr *hdr)
{
	hdr->disabled_cb = hdr->disabled_param = NULL;
     78c:	2500      	movs	r5, #0
     78e:	61a5      	str	r5, [r4, #24]
     790:	6165      	str	r5, [r4, #20]

static inline void lll_hdr_init(void *lll, void *parent)
{
	struct lll_hdr *hdr = lll;

	hdr->parent = parent;
     792:	61e4      	str	r4, [r4, #28]
	hdr->is_stop = 0U;
     794:	f894 3020 	ldrb.w	r3, [r4, #32]
     798:	f365 0300 	bfi	r3, r5, #0, #1
     79c:	f884 3020 	strb.w	r3, [r4, #32]
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */

	ull_hdr_init(&scan->ull);
	lll_hdr_init(lll, scan);

	ticks_interval = HAL_TICKER_US_TO_TICKS((u64_t)lll->interval * 625U);
     7a0:	8e66      	ldrh	r6, [r4, #50]	; 0x32
     7a2:	4833      	ldr	r0, [pc, #204]	; (870 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x70>)
     7a4:	fba6 0100 	umull	r0, r1, r6, r0
     7a8:	2391      	movs	r3, #145	; 0x91
     7aa:	fb03 1106 	mla	r1, r3, r6, r1
     7ae:	a32e      	add	r3, pc, #184	; (adr r3, 868 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x68>)
     7b0:	e9d3 2300 	ldrd	r2, r3, [r3]
     7b4:	f7ff fe28 	bl	408 <__aeabi_uldivmod>
     7b8:	f020 4a7f 	bic.w	sl, r0, #4278190080	; 0xff000000

	/* TODO: active_to_start feature port */
	scan->evt.ticks_active_to_start = 0U;
     7bc:	6065      	str	r5, [r4, #4]
	scan->evt.ticks_xtal_to_start =
     7be:	2331      	movs	r3, #49	; 0x31
     7c0:	6023      	str	r3, [r4, #0]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US);
	scan->evt.ticks_preempt_to_start =
     7c2:	60a5      	str	r5, [r4, #8]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_PREEMPT_MIN_US);
	if ((lll->ticks_window +
     7c4:	6b63      	ldr	r3, [r4, #52]	; 0x34
     7c6:	3309      	adds	r3, #9
	     HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US)) <
	    (ticks_interval -
     7c8:	f1aa 0231 	sub.w	r2, sl, #49	; 0x31
	if ((lll->ticks_window +
     7cc:	4293      	cmp	r3, r2
     7ce:	d245      	bcs.n	85c <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x5c>
	     HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US))) {
		scan->evt.ticks_slot =
     7d0:	60e3      	str	r3, [r4, #12]
		ticks_slot_overhead = ticks_slot_offset;
	} else {
		ticks_slot_overhead = 0U;
	}

	ticks_anchor = ticker_ticks_now_get();
     7d2:	f00d ff9f 	bl	e714 <ticker_ticks_now_get>
     7d6:	4683      	mov	fp, r0
#endif /* CONFIG_BT_CENTRAL && CONFIG_BT_CTLR_SCHED_ADVANCED */

	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
			   TICKER_USER_ID_THREAD, TICKER_ID_SCAN_BASE,
			   ticks_anchor, 0, ticks_interval,
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
     7d8:	8e61      	ldrh	r1, [r4, #50]	; 0x32
     7da:	4e25      	ldr	r6, [pc, #148]	; (870 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x70>)
     7dc:	fba1 6706 	umull	r6, r7, r1, r6
     7e0:	2391      	movs	r3, #145	; 0x91
     7e2:	fb03 7701 	mla	r7, r3, r1, r7
     7e6:	a320      	add	r3, pc, #128	; (adr r3, 868 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x68>)
     7e8:	e9d3 2300 	ldrd	r2, r3, [r3]
     7ec:	4630      	mov	r0, r6
     7ee:	4639      	mov	r1, r7
     7f0:	f7ff fe0a 	bl	408 <__aeabi_uldivmod>
     7f4:	2500      	movs	r5, #0
     7f6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
     7fa:	4b1e      	ldr	r3, [pc, #120]	; (874 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x74>)
     7fc:	fba0 8903 	umull	r8, r9, r0, r3
     800:	2307      	movs	r3, #7
     802:	fb03 9900 	mla	r9, r3, r0, r9
     806:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
     80a:	2300      	movs	r3, #0
     80c:	ebb6 0008 	subs.w	r0, r6, r8
     810:	eb67 0109 	sbc.w	r1, r7, r9
     814:	f7ff fdf8 	bl	408 <__aeabi_uldivmod>
			   TICKER_NULL_LAZY,
			   (scan->evt.ticks_slot + ticks_slot_overhead),
     818:	68e3      	ldr	r3, [r4, #12]
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     81a:	ae0b      	add	r6, sp, #44	; 0x2c
     81c:	9608      	str	r6, [sp, #32]
     81e:	4a16      	ldr	r2, [pc, #88]	; (878 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x78>)
     820:	9207      	str	r2, [sp, #28]
     822:	9406      	str	r4, [sp, #24]
     824:	4a15      	ldr	r2, [pc, #84]	; (87c <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x7c>)
     826:	9205      	str	r2, [sp, #20]
     828:	9304      	str	r3, [sp, #16]
     82a:	9503      	str	r5, [sp, #12]
     82c:	9002      	str	r0, [sp, #8]
     82e:	f8cd a004 	str.w	sl, [sp, #4]
     832:	9500      	str	r5, [sp, #0]
     834:	465b      	mov	r3, fp
     836:	2202      	movs	r2, #2
     838:	2103      	movs	r1, #3
     83a:	4628      	mov	r0, r5
     83c:	f00d ff4f 	bl	e6de <ticker_start>
			   ticker_cb, scan,
			   ull_ticker_status_give, (void *)&ret_cb);

	ret = ull_ticker_status_take(ret, &ret_cb);
     840:	4631      	mov	r1, r6
     842:	f006 f979 	bl	6b38 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
     846:	b968      	cbnz	r0, 864 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x64>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	scan->is_enabled = 1U;
     848:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
     84c:	f043 0301 	orr.w	r3, r3, #1
     850:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
	{
		ull_filter_adv_scan_state_cb(BIT(1));
	}
#endif

	return 0;
     854:	4628      	mov	r0, r5
}
     856:	b00d      	add	sp, #52	; 0x34
     858:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		scan->evt.ticks_slot =
     85c:	60e2      	str	r2, [r4, #12]
		lll->ticks_window = 0;
     85e:	2300      	movs	r3, #0
     860:	6363      	str	r3, [r4, #52]	; 0x34
     862:	e7b6      	b.n	7d2 <CONFIG_BT_CTLR_DFE_SWITCH_SPACING_NS+0x2>
		return BT_HCI_ERR_CMD_DISALLOWED;
     864:	200c      	movs	r0, #12
     866:	e7f6      	b.n	856 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x56>
     868:	1afd498d 	.word	0x1afd498d
     86c:	00000007 	.word	0x00000007
     870:	84e72a00 	.word	0x84e72a00
     874:	1afd498d 	.word	0x1afd498d
     878:	00006b29 	.word	0x00006b29
     87c:	00006fc1 	.word	0x00006fc1

00000880 <main>:
 *
 * Following steps: data receive, mapping and their forwarding
 * is done in never ending loop.
 */
void main(void)
{
     880:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	printk("Starting AoA Locator CL!\r\n");
     882:	4841      	ldr	r0, [pc, #260]	; (988 <main+0x108>)
     884:	f00c fbd3 	bl	d02e <printk>
	/* initialize UART interface to provide I/Q samples */
	struct if_data* iface = if_initialization();
     888:	f000 f8d8 	bl	a3c <if_initialization>

	if (iface == NULL) {
     88c:	b300      	cbz	r0, 8d0 <main+0x50>
		return;
	}

	int err;

	err = protocol_initialization(iface);
     88e:	f000 fa1d 	bl	ccc <protocol_initialization>
	if (err) {
     892:	bb08      	cbnz	r0, 8d8 <main+0x58>
	const struct dfe_sampling_config* sampl_conf = NULL;
	const struct dfe_antenna_config* ant_conf = NULL;
	const struct dfe_ant_gpio* ant_gpio = NULL;
	u8_t ant_gpio_len = 0;

	sampl_conf = dfe_get_sampling_config();
     894:	f000 faba 	bl	e0c <dfe_get_sampling_config>
     898:	4605      	mov	r5, r0
	ant_conf = dfe_get_antenna_config();
     89a:	f000 fabb 	bl	e14 <dfe_get_antenna_config>
     89e:	4606      	mov	r6, r0
	ant_gpio_len = dfe_get_ant_gpios_config_len();
     8a0:	f00c f968 	bl	cb74 <dfe_get_ant_gpios_config_len>
     8a4:	4607      	mov	r7, r0
	ant_gpio = dfe_get_ant_gpios_config();
     8a6:	f000 fab9 	bl	e1c <dfe_get_ant_gpios_config>
     8aa:	4604      	mov	r4, r0

	assert(sampl_conf != NULL);
     8ac:	b1c5      	cbz	r5, 8e0 <main+0x60>
	assert(ant_conf != NULL);
     8ae:	b1ee      	cbz	r6, 8ec <main+0x6c>
	assert(ant_gpio != NULL);
     8b0:	b310      	cbz	r0, 8f8 <main+0x78>
	assert(ant_gpio_len != 0);
     8b2:	b33f      	cbz	r7, 904 <main+0x84>

	printk("Initialize DFE\r\n");
     8b4:	4835      	ldr	r0, [pc, #212]	; (98c <main+0x10c>)
     8b6:	f00c fbba 	bl	d02e <printk>
	err = dfe_init(sampl_conf, ant_conf, ant_gpio, ant_gpio_len);
     8ba:	463b      	mov	r3, r7
     8bc:	4622      	mov	r2, r4
     8be:	4631      	mov	r1, r6
     8c0:	4628      	mov	r0, r5
     8c2:	f000 faaf 	bl	e24 <dfe_init>
	if (err) {
     8c6:	b318      	cbz	r0, 910 <main+0x90>
		printk("Locator stopped!\r\n");
     8c8:	4831      	ldr	r0, [pc, #196]	; (990 <main+0x110>)
     8ca:	f00c fbb0 	bl	d02e <printk>
		return;
     8ce:	e006      	b.n	8de <main+0x5e>
		printk("Locator stopped!\r\n");
     8d0:	482f      	ldr	r0, [pc, #188]	; (990 <main+0x110>)
     8d2:	f00c fbac 	bl	d02e <printk>
		return;
     8d6:	e002      	b.n	8de <main+0x5e>
		printk("Locator stopped!\r\n");
     8d8:	482d      	ldr	r0, [pc, #180]	; (990 <main+0x110>)
     8da:	f00c fba8 	bl	d02e <printk>
		{
			printk("\r\nNo data received.");
		}
		k_sleep(K_MSEC(CONFIG_AOA_LOCATOR_DATA_SEND_WAIT_MS));
	}
}
     8de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	assert(sampl_conf != NULL);
     8e0:	4b2c      	ldr	r3, [pc, #176]	; (994 <main+0x114>)
     8e2:	4a2d      	ldr	r2, [pc, #180]	; (998 <main+0x118>)
     8e4:	2146      	movs	r1, #70	; 0x46
     8e6:	482d      	ldr	r0, [pc, #180]	; (99c <main+0x11c>)
     8e8:	f00b f9e0 	bl	bcac <__assert_func>
	assert(ant_conf != NULL);
     8ec:	4b2c      	ldr	r3, [pc, #176]	; (9a0 <main+0x120>)
     8ee:	4a2a      	ldr	r2, [pc, #168]	; (998 <main+0x118>)
     8f0:	2147      	movs	r1, #71	; 0x47
     8f2:	482a      	ldr	r0, [pc, #168]	; (99c <main+0x11c>)
     8f4:	f00b f9da 	bl	bcac <__assert_func>
	assert(ant_gpio != NULL);
     8f8:	4b2a      	ldr	r3, [pc, #168]	; (9a4 <main+0x124>)
     8fa:	4a27      	ldr	r2, [pc, #156]	; (998 <main+0x118>)
     8fc:	2148      	movs	r1, #72	; 0x48
     8fe:	4827      	ldr	r0, [pc, #156]	; (99c <main+0x11c>)
     900:	f00b f9d4 	bl	bcac <__assert_func>
	assert(ant_gpio_len != 0);
     904:	4b28      	ldr	r3, [pc, #160]	; (9a8 <main+0x128>)
     906:	4a24      	ldr	r2, [pc, #144]	; (998 <main+0x118>)
     908:	2149      	movs	r1, #73	; 0x49
     90a:	4824      	ldr	r0, [pc, #144]	; (99c <main+0x11c>)
     90c:	f00b f9ce 	bl	bcac <__assert_func>
	printk("Initialize Bluetooth\r\n");
     910:	4826      	ldr	r0, [pc, #152]	; (9ac <main+0x12c>)
     912:	f00c fb8c 	bl	d02e <printk>
	ble_initialization();
     916:	f000 fa11 	bl	d3c <ble_initialization>
     91a:	e007      	b.n	92c <main+0xac>
			printk("\r\nNo data received.");
     91c:	4824      	ldr	r0, [pc, #144]	; (9b0 <main+0x130>)
     91e:	f00c fb86 	bl	d02e <printk>
		parm0.val = timeout;
		return (s32_t) arch_syscall_invoke2(parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_sleep(timeout);
     922:	f240 501f 	movw	r0, #1311	; 0x51f
     926:	2100      	movs	r1, #0
     928:	f00a fcb6 	bl	b298 <z_impl_k_sleep>
		memset(&df_data_packet, 0, sizeof(df_data_packet));
     92c:	4c21      	ldr	r4, [pc, #132]	; (9b4 <main+0x134>)
     92e:	2294      	movs	r2, #148	; 0x94
     930:	2100      	movs	r1, #0
     932:	4620      	mov	r0, r4
     934:	f00f fe43 	bl	105be <memset>
		memset(&df_data_mapped, 0, sizeof(df_data_mapped));
     938:	f44f 72b1 	mov.w	r2, #354	; 0x162
     93c:	2100      	movs	r1, #0
     93e:	481e      	ldr	r0, [pc, #120]	; (9b8 <main+0x138>)
     940:	f00f fe3d 	bl	105be <memset>
		parm0.val = timeout;
		return (int) arch_syscall_invoke4(*(uintptr_t *)&msgq, *(uintptr_t *)&data, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_MSGQ_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_get(msgq, data, timeout);
     944:	f44f 4200 	mov.w	r2, #32768	; 0x8000
     948:	2300      	movs	r3, #0
     94a:	4621      	mov	r1, r4
     94c:	481b      	ldr	r0, [pc, #108]	; (9bc <main+0x13c>)
     94e:	f009 ff99 	bl	a884 <z_impl_k_msgq_get>
		if (df_data_packet.hdr.length != 0) {
     952:	8823      	ldrh	r3, [r4, #0]
     954:	2b00      	cmp	r3, #0
     956:	d0e1      	beq.n	91c <main+0x9c>
			printk("\r\nData arrived...\r\n");
     958:	4819      	ldr	r0, [pc, #100]	; (9c0 <main+0x140>)
     95a:	f00c fb68 	bl	d02e <printk>
			dfe_map_iq_samples_to_antennas(&df_data_mapped,
     95e:	4c16      	ldr	r4, [pc, #88]	; (9b8 <main+0x138>)
     960:	4633      	mov	r3, r6
     962:	462a      	mov	r2, r5
     964:	4913      	ldr	r1, [pc, #76]	; (9b4 <main+0x134>)
     966:	4620      	mov	r0, r4
     968:	f000 fb9c 	bl	10a4 <dfe_map_iq_samples_to_antennas>
			err = protocol_handling(sampl_conf, &df_data_mapped);
     96c:	4621      	mov	r1, r4
     96e:	4628      	mov	r0, r5
     970:	f000 f9bc 	bl	cec <protocol_handling>
			if (err) {
     974:	2800      	cmp	r0, #0
     976:	d0d4      	beq.n	922 <main+0xa2>
				printk("Error in protocol handling!\r\n");
     978:	4812      	ldr	r0, [pc, #72]	; (9c4 <main+0x144>)
     97a:	f00c fb58 	bl	d02e <printk>
				printk("Locator stopped!\r\n");
     97e:	4804      	ldr	r0, [pc, #16]	; (990 <main+0x110>)
     980:	f00c fb55 	bl	d02e <printk>
				return;
     984:	e7ab      	b.n	8de <main+0x5e>
     986:	bf00      	nop
     988:	00010d58 	.word	0x00010d58
     98c:	00010df4 	.word	0x00010df4
     990:	00010d74 	.word	0x00010d74
     994:	00010d88 	.word	0x00010d88
     998:	00010e68 	.word	0x00010e68
     99c:	00010d9c 	.word	0x00010d9c
     9a0:	00010db8 	.word	0x00010db8
     9a4:	00010dcc 	.word	0x00010dcc
     9a8:	00010de0 	.word	0x00010de0
     9ac:	00010e08 	.word	0x00010e08
     9b0:	00010e54 	.word	0x00010e54
     9b4:	20000714 	.word	0x20000714
     9b8:	200005b0 	.word	0x200005b0
     9bc:	200004d8 	.word	0x200004d8
     9c0:	00010e20 	.word	0x00010e20
     9c4:	00010e34 	.word	0x00010e34

000009c8 <uart_send>:
		}
	}
}

static void uart_send(uint8_t *buffer, uint16_t length)
{
     9c8:	b570      	push	{r4, r5, r6, lr}
     9ca:	4606      	mov	r6, r0
     9cc:	460d      	mov	r5, r1
	size_t i = 0;

	for(i=0; i<length; i++)
     9ce:	2400      	movs	r4, #0
     9d0:	42a5      	cmp	r5, r4
     9d2:	d907      	bls.n	9e4 <uart_send+0x1c>
	{
		uart_poll_out(g_if.dev, buffer[i]);
     9d4:	4b04      	ldr	r3, [pc, #16]	; (9e8 <uart_send+0x20>)
     9d6:	6818      	ldr	r0, [r3, #0]
     9d8:	5d31      	ldrb	r1, [r6, r4]
				      unsigned char out_char);

static inline void z_impl_uart_poll_out(struct device *dev,
						unsigned char out_char)
{
	const struct uart_driver_api *api =
     9da:	6883      	ldr	r3, [r0, #8]
		(const struct uart_driver_api *)dev->driver_api;

	api->poll_out(dev, out_char);
     9dc:	685b      	ldr	r3, [r3, #4]
     9de:	4798      	blx	r3
	for(i=0; i<length; i++)
     9e0:	3401      	adds	r4, #1
     9e2:	e7f5      	b.n	9d0 <uart_send+0x8>
	}
}
     9e4:	bd70      	pop	{r4, r5, r6, pc}
     9e6:	bf00      	nop
     9e8:	200007a8 	.word	0x200007a8

000009ec <if_uart_app_isr>:
{
     9ec:	b510      	push	{r4, lr}
     9ee:	4604      	mov	r4, r0
 */
__syscall int uart_irq_update(struct device *dev);

static inline int z_impl_uart_irq_update(struct device *dev)
{
	const struct uart_driver_api *api =
     9f0:	68a3      	ldr	r3, [r4, #8]
		(const struct uart_driver_api *)dev->driver_api;

	if (api->irq_update) {
     9f2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
     9f4:	b1c3      	cbz	r3, a28 <if_uart_app_isr+0x3c>
		return api->irq_update(dev);
     9f6:	4620      	mov	r0, r4
     9f8:	4798      	blx	r3
	while (uart_irq_update(dev) && uart_irq_is_pending(dev))
     9fa:	b1a8      	cbz	r0, a28 <if_uart_app_isr+0x3c>
	const struct uart_driver_api *api =
     9fc:	68a3      	ldr	r3, [r4, #8]
	if (api->irq_is_pending)	{
     9fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
     a00:	b193      	cbz	r3, a28 <if_uart_app_isr+0x3c>
		return api->irq_is_pending(dev);
     a02:	4620      	mov	r0, r4
     a04:	4798      	blx	r3
     a06:	b178      	cbz	r0, a28 <if_uart_app_isr+0x3c>
	const struct uart_driver_api *api =
     a08:	68a3      	ldr	r3, [r4, #8]
	if (api->irq_rx_ready) {
     a0a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     a0c:	b11b      	cbz	r3, a16 <if_uart_app_isr+0x2a>
		return api->irq_rx_ready(dev);
     a0e:	4620      	mov	r0, r4
     a10:	4798      	blx	r3
		if (!uart_irq_rx_ready(dev))
     a12:	2800      	cmp	r0, #0
     a14:	d1ec      	bne.n	9f0 <if_uart_app_isr+0x4>
	const struct uart_driver_api *api =
     a16:	68a3      	ldr	r3, [r4, #8]
	if (api->irq_tx_ready) {
     a18:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     a1a:	b113      	cbz	r3, a22 <if_uart_app_isr+0x36>
		return api->irq_tx_ready(dev);
     a1c:	4620      	mov	r0, r4
     a1e:	4798      	blx	r3
			if (uart_irq_tx_ready(dev))
     a20:	b918      	cbnz	r0, a2a <if_uart_app_isr+0x3e>
				printk("[UART] - spurious interrupt");
     a22:	4804      	ldr	r0, [pc, #16]	; (a34 <if_uart_app_isr+0x48>)
     a24:	f00c fb03 	bl	d02e <printk>
}
     a28:	bd10      	pop	{r4, pc}
				printk("[UART] - transmit ready");
     a2a:	4803      	ldr	r0, [pc, #12]	; (a38 <if_uart_app_isr+0x4c>)
     a2c:	f00c faff 	bl	d02e <printk>
     a30:	e7fa      	b.n	a28 <if_uart_app_isr+0x3c>
     a32:	bf00      	nop
     a34:	00010e88 	.word	0x00010e88
     a38:	00010e70 	.word	0x00010e70

00000a3c <if_initialization>:
{
     a3c:	b510      	push	{r4, lr}
	if (z_syscall_trap()) {
		return (struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
     a3e:	4815      	ldr	r0, [pc, #84]	; (a94 <if_initialization+0x58>)
     a40:	f009 fc42 	bl	a2c8 <z_impl_device_get_binding>
     a44:	4604      	mov	r4, r0
	g_if.dev = device_get_binding(CONFIG_AOA_LOCATOR_UART_PORT);
     a46:	4b14      	ldr	r3, [pc, #80]	; (a98 <if_initialization+0x5c>)
     a48:	6018      	str	r0, [r3, #0]
	if (!g_if.dev) {
     a4a:	b1f0      	cbz	r0, a8a <if_initialization+0x4e>
	const struct uart_driver_api *api =
     a4c:	6883      	ldr	r3, [r0, #8]
	if (api->irq_rx_disable) {
     a4e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
     a50:	b103      	cbz	r3, a54 <if_initialization+0x18>
		api->irq_rx_disable(dev);
     a52:	4798      	blx	r3
	uart_irq_tx_disable(g_if.dev);
     a54:	4b10      	ldr	r3, [pc, #64]	; (a98 <if_initialization+0x5c>)
     a56:	6818      	ldr	r0, [r3, #0]
	const struct uart_driver_api *api =
     a58:	6883      	ldr	r3, [r0, #8]
	if (api->irq_tx_disable) {
     a5a:	6a1b      	ldr	r3, [r3, #32]
     a5c:	b103      	cbz	r3, a60 <if_initialization+0x24>
		api->irq_tx_disable(dev);
     a5e:	4798      	blx	r3
	uart_irq_callback_set(g_if.dev, if_uart_app_isr);
     a60:	4b0d      	ldr	r3, [pc, #52]	; (a98 <if_initialization+0x5c>)
     a62:	6818      	ldr	r0, [r3, #0]
static inline void uart_irq_callback_user_data_set(
					struct device *dev,
					uart_irq_callback_user_data_t cb,
					void *user_data)
{
	const struct uart_driver_api *api =
     a64:	6883      	ldr	r3, [r0, #8]
		(const struct uart_driver_api *)dev->driver_api;

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
     a66:	b123      	cbz	r3, a72 <if_initialization+0x36>
     a68:	6c9b      	ldr	r3, [r3, #72]	; 0x48
     a6a:	b113      	cbz	r3, a72 <if_initialization+0x36>
		api->irq_callback_set(dev, cb, user_data);
     a6c:	4602      	mov	r2, r0
     a6e:	490b      	ldr	r1, [pc, #44]	; (a9c <if_initialization+0x60>)
     a70:	4798      	blx	r3
	uart_irq_rx_enable(g_if.dev);
     a72:	4b09      	ldr	r3, [pc, #36]	; (a98 <if_initialization+0x5c>)
     a74:	6818      	ldr	r0, [r3, #0]
	const struct uart_driver_api *api =
     a76:	6883      	ldr	r3, [r0, #8]
	if (api->irq_rx_enable) {
     a78:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     a7a:	b103      	cbz	r3, a7e <if_initialization+0x42>
		api->irq_rx_enable(dev);
     a7c:	4798      	blx	r3
	g_if.send = uart_send;
     a7e:	4c06      	ldr	r4, [pc, #24]	; (a98 <if_initialization+0x5c>)
     a80:	4b07      	ldr	r3, [pc, #28]	; (aa0 <if_initialization+0x64>)
     a82:	f8c4 3808 	str.w	r3, [r4, #2056]	; 0x808
}
     a86:	4620      	mov	r0, r4
     a88:	bd10      	pop	{r4, pc}
		printk("[UART] - Device not found or cannot be used\r\n");
     a8a:	4806      	ldr	r0, [pc, #24]	; (aa4 <if_initialization+0x68>)
     a8c:	f00c facf 	bl	d02e <printk>
		return NULL;
     a90:	e7f9      	b.n	a86 <if_initialization+0x4a>
     a92:	bf00      	nop
     a94:	00010ea4 	.word	0x00010ea4
     a98:	200007a8 	.word	0x200007a8
     a9c:	000009ed 	.word	0x000009ed
     aa0:	000009c9 	.word	0x000009c9
     aa4:	00010eac 	.word	0x00010eac

00000aa8 <protocol_convert_to_string>:
 * @return Number of characters stored in transmission buffer.
 */
static u16_t protocol_convert_to_string(const struct dfe_sampling_config* sampl_conf,
					   const struct dfe_mapped_packet *mapped_data,
					   char *buffer, uint16_t length)
{
     aa8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     aac:	b08b      	sub	sp, #44	; 0x2c
     aae:	4606      	mov	r6, r0
     ab0:	9005      	str	r0, [sp, #20]
     ab2:	460f      	mov	r7, r1
     ab4:	4615      	mov	r5, r2
     ab6:	9206      	str	r2, [sp, #24]
	printk("DF_BEGIN\r\n");
     ab8:	4c78      	ldr	r4, [pc, #480]	; (c9c <protocol_convert_to_string+0x1f4>)
     aba:	4620      	mov	r0, r4
     abc:	f00c fab7 	bl	d02e <printk>
	u16_t strlen = sprintf(buffer, "DF_BEGIN\r\n");
     ac0:	4623      	mov	r3, r4
     ac2:	cb03      	ldmia	r3!, {r0, r1}
     ac4:	6028      	str	r0, [r5, #0]
     ac6:	6069      	str	r1, [r5, #4]
     ac8:	881a      	ldrh	r2, [r3, #0]
     aca:	789b      	ldrb	r3, [r3, #2]
     acc:	812a      	strh	r2, [r5, #8]
     ace:	4628      	mov	r0, r5
     ad0:	f800 3f0a 	strb.w	r3, [r0, #10]!

	strlen += sprintf(&buffer[strlen], "SW:%d\r\n", (int)sampl_conf->switch_spacing);
     ad4:	8972      	ldrh	r2, [r6, #10]
     ad6:	4972      	ldr	r1, [pc, #456]	; (ca0 <protocol_convert_to_string+0x1f8>)
     ad8:	f00b fb54 	bl	c184 <siprintf>
     adc:	300a      	adds	r0, #10
     ade:	b204      	sxth	r4, r0
	strlen += sprintf(&buffer[strlen], "RR:%d\r\n", (int)sampl_conf->sample_spacing_ref);
     ae0:	79b2      	ldrb	r2, [r6, #6]
     ae2:	4970      	ldr	r1, [pc, #448]	; (ca4 <protocol_convert_to_string+0x1fc>)
     ae4:	fa15 f080 	uxtah	r0, r5, r0
     ae8:	f00b fb4c 	bl	c184 <siprintf>
     aec:	4420      	add	r0, r4
     aee:	b204      	sxth	r4, r0
	strlen += sprintf(&buffer[strlen], "SS:%d\r\n", (int)sampl_conf->sample_spacing);
     af0:	79f2      	ldrb	r2, [r6, #7]
     af2:	496d      	ldr	r1, [pc, #436]	; (ca8 <protocol_convert_to_string+0x200>)
     af4:	fa15 f080 	uxtah	r0, r5, r0
     af8:	f00b fb44 	bl	c184 <siprintf>
     afc:	4420      	add	r0, r4
     afe:	b204      	sxth	r4, r0
	strlen += sprintf(&buffer[strlen], "FR:%d\r\n", (int)mapped_data->header.frequency);
     b00:	687a      	ldr	r2, [r7, #4]
     b02:	496a      	ldr	r1, [pc, #424]	; (cac <protocol_convert_to_string+0x204>)
     b04:	fa15 f080 	uxtah	r0, r5, r0
     b08:	f00b fb3c 	bl	c184 <siprintf>
     b0c:	4420      	add	r0, r4
     b0e:	b204      	sxth	r4, r0

	strlen += sprintf(&buffer[strlen], "ME:%d\r\n", (int)0);
     b10:	2200      	movs	r2, #0
     b12:	4967      	ldr	r1, [pc, #412]	; (cb0 <protocol_convert_to_string+0x208>)
     b14:	fa15 f080 	uxtah	r0, r5, r0
     b18:	f00b fb34 	bl	c184 <siprintf>
     b1c:	1da0      	adds	r0, r4, #6
     b1e:	b204      	sxth	r4, r0
	strlen += sprintf(&buffer[strlen], "MA:%d\r\n", (int)0);
     b20:	2200      	movs	r2, #0
     b22:	4964      	ldr	r1, [pc, #400]	; (cb4 <protocol_convert_to_string+0x20c>)
     b24:	fa15 f080 	uxtah	r0, r5, r0
     b28:	f00b fb2c 	bl	c184 <siprintf>
     b2c:	1da0      	adds	r0, r4, #6
     b2e:	b204      	sxth	r4, r0
	strlen += sprintf(&buffer[strlen], "KE:%d\r\n", (int)0);
     b30:	2200      	movs	r2, #0
     b32:	4961      	ldr	r1, [pc, #388]	; (cb8 <protocol_convert_to_string+0x210>)
     b34:	fa15 f080 	uxtah	r0, r5, r0
     b38:	f00b fb24 	bl	c184 <siprintf>
     b3c:	1da0      	adds	r0, r4, #6
     b3e:	b204      	sxth	r4, r0
	strlen += sprintf(&buffer[strlen], "KA:%d\r\n", (int)0);
     b40:	2200      	movs	r2, #0
     b42:	495e      	ldr	r1, [pc, #376]	; (cbc <protocol_convert_to_string+0x214>)
     b44:	fa15 f080 	uxtah	r0, r5, r0
     b48:	f00b fb1c 	bl	c184 <siprintf>
     b4c:	3406      	adds	r4, #6
     b4e:	fa1f fb84 	uxth.w	fp, r4

	u16_t time_u = dfe_get_sample_spacing_ref_ns(sampl_conf->sample_spacing_ref) / SAMPLING_TIME_UNIT;
     b52:	79b0      	ldrb	r0, [r6, #6]
     b54:	f00c f82b 	bl	cbae <dfe_get_sample_spacing_ref_ns>
     b58:	4b59      	ldr	r3, [pc, #356]	; (cc0 <protocol_convert_to_string+0x218>)
     b5a:	fba3 2300 	umull	r2, r3, r3, r0
     b5e:	f3c3 03cf 	ubfx	r3, r3, #3, #16
     b62:	9304      	str	r3, [sp, #16]
	u16_t ref_idx;

	for(ref_idx = 0; ref_idx < mapped_data->ref_data.samples_num; ++ref_idx)
     b64:	2400      	movs	r4, #0
     b66:	e021      	b.n	bac <protocol_convert_to_string+0x104>
	{
		strlen += sprintf(&buffer[strlen], "IQ:%d,%d,%d,%d,%d\r\n", ref_idx,
     b68:	f897 9049 	ldrb.w	r9, [r7, #73]	; 0x49
     b6c:	1c65      	adds	r5, r4, #1
     b6e:	eb07 03c5 	add.w	r3, r7, r5, lsl #3
     b72:	f8d3 a004 	ldr.w	sl, [r3, #4]
     b76:	f857 0035 	ldr.w	r0, [r7, r5, lsl #3]
     b7a:	9b04      	ldr	r3, [sp, #16]
     b7c:	fb04 f803 	mul.w	r8, r4, r3
     b80:	9b06      	ldr	r3, [sp, #24]
     b82:	eb03 060b 	add.w	r6, r3, fp
     b86:	f7ff fc19 	bl	3bc <__aeabi_f2iz>
     b8a:	9002      	str	r0, [sp, #8]
     b8c:	4650      	mov	r0, sl
     b8e:	f7ff fc15 	bl	3bc <__aeabi_f2iz>
     b92:	9001      	str	r0, [sp, #4]
     b94:	f8cd 9000 	str.w	r9, [sp]
     b98:	4643      	mov	r3, r8
     b9a:	4622      	mov	r2, r4
     b9c:	4949      	ldr	r1, [pc, #292]	; (cc4 <protocol_convert_to_string+0x21c>)
     b9e:	4630      	mov	r0, r6
     ba0:	f00b faf0 	bl	c184 <siprintf>
     ba4:	4483      	add	fp, r0
     ba6:	fa1f fb8b 	uxth.w	fp, fp
	for(ref_idx = 0; ref_idx < mapped_data->ref_data.samples_num; ++ref_idx)
     baa:	b2ac      	uxth	r4, r5
     bac:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
     bb0:	42a3      	cmp	r3, r4
     bb2:	d8d9      	bhi.n	b68 <protocol_convert_to_string+0xc0>
				 (int)mapped_data->ref_data.data[ref_idx].i);
	}
	/* compute delay  between last sample in reference period and first sample
	 * in antenna switching period.
	 */
	u16_t delay =  dfe_delay_before_first_sampl(sampl_conf) / SAMPLING_TIME_UNIT;
     bb4:	9e05      	ldr	r6, [sp, #20]
     bb6:	4630      	mov	r0, r6
     bb8:	f000 fb3c 	bl	1234 <dfe_delay_before_first_sampl>
     bbc:	4d40      	ldr	r5, [pc, #256]	; (cc0 <protocol_convert_to_string+0x218>)
     bbe:	fba5 2300 	umull	r2, r3, r5, r0
     bc2:	f3c3 03cf 	ubfx	r3, r3, #3, #16
	delay += (time_u * (ref_idx-1));
     bc6:	9407      	str	r4, [sp, #28]
     bc8:	3c01      	subs	r4, #1
     bca:	9a04      	ldr	r2, [sp, #16]
     bcc:	fb14 3302 	smlabb	r3, r4, r2, r3
     bd0:	b29b      	uxth	r3, r3
     bd2:	9308      	str	r3, [sp, #32]
	time_u = dfe_get_sample_spacing_ns(sampl_conf->sample_spacing) / SAMPLING_TIME_UNIT;
     bd4:	79f0      	ldrb	r0, [r6, #7]
     bd6:	f00b ffcf 	bl	cb78 <dfe_get_sample_spacing_ns>
     bda:	fba5 3500 	umull	r3, r5, r5, r0
     bde:	f3c5 03cf 	ubfx	r3, r5, #3, #16
     be2:	9309      	str	r3, [sp, #36]	; 0x24

	for(u16_t idx=0; idx<mapped_data->header.length; ++idx)
     be4:	2300      	movs	r3, #0
     be6:	9305      	str	r3, [sp, #20]
     be8:	46d8      	mov	r8, fp
     bea:	e040      	b.n	c6e <protocol_convert_to_string+0x1c6>
	{
		const struct dfe_samples* sampl_data = &mapped_data->sampl_data[idx];

		for(u16_t jdx = 0; jdx < sampl_data->samples_num; ++jdx)
		{
			u16_t idx_offset = (sampl_data->samples_num * idx) + jdx;
     bec:	9a05      	ldr	r2, [sp, #20]
     bee:	fb13 f202 	smulbb	r2, r3, r2
     bf2:	fa05 f282 	sxtah	r2, r5, r2
     bf6:	b292      	uxth	r2, r2

			strlen += sprintf(&buffer[strlen], "IQ:%d,%d,%d,%d,%d\r\n", ref_idx + idx_offset,
     bf8:	eb06 0386 	add.w	r3, r6, r6, lsl #2
     bfc:	eb07 0343 	add.w	r3, r7, r3, lsl #1
     c00:	f893 a053 	ldrb.w	sl, [r3, #83]	; 0x53
     c04:	eb06 0386 	add.w	r3, r6, r6, lsl #2
     c08:	005b      	lsls	r3, r3, #1
     c0a:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
     c0e:	443b      	add	r3, r7
     c10:	f8d3 b04e 	ldr.w	fp, [r3, #78]	; 0x4e
     c14:	f8d3 004a 	ldr.w	r0, [r3, #74]	; 0x4a
     c18:	9b09      	ldr	r3, [sp, #36]	; 0x24
     c1a:	9908      	ldr	r1, [sp, #32]
     c1c:	fb02 1903 	mla	r9, r2, r3, r1
     c20:	9b07      	ldr	r3, [sp, #28]
     c22:	4413      	add	r3, r2
     c24:	9304      	str	r3, [sp, #16]
     c26:	9906      	ldr	r1, [sp, #24]
     c28:	eb01 0408 	add.w	r4, r1, r8
     c2c:	f7ff fbc6 	bl	3bc <__aeabi_f2iz>
     c30:	9002      	str	r0, [sp, #8]
     c32:	4658      	mov	r0, fp
     c34:	f7ff fbc2 	bl	3bc <__aeabi_f2iz>
     c38:	9001      	str	r0, [sp, #4]
     c3a:	f8cd a000 	str.w	sl, [sp]
     c3e:	464b      	mov	r3, r9
     c40:	9a04      	ldr	r2, [sp, #16]
     c42:	4920      	ldr	r1, [pc, #128]	; (cc4 <protocol_convert_to_string+0x21c>)
     c44:	4620      	mov	r0, r4
     c46:	f00b fa9d 	bl	c184 <siprintf>
     c4a:	4480      	add	r8, r0
     c4c:	fa1f f888 	uxth.w	r8, r8
		for(u16_t jdx = 0; jdx < sampl_data->samples_num; ++jdx)
     c50:	3501      	adds	r5, #1
     c52:	b2ad      	uxth	r5, r5
     c54:	eb06 0386 	add.w	r3, r6, r6, lsl #2
     c58:	eb07 0343 	add.w	r3, r7, r3, lsl #1
     c5c:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
     c60:	b29a      	uxth	r2, r3
     c62:	42aa      	cmp	r2, r5
     c64:	d8c2      	bhi.n	bec <protocol_convert_to_string+0x144>
	for(u16_t idx=0; idx<mapped_data->header.length; ++idx)
     c66:	9b05      	ldr	r3, [sp, #20]
     c68:	3301      	adds	r3, #1
     c6a:	b29b      	uxth	r3, r3
     c6c:	9305      	str	r3, [sp, #20]
     c6e:	683b      	ldr	r3, [r7, #0]
     c70:	9a05      	ldr	r2, [sp, #20]
     c72:	429a      	cmp	r2, r3
     c74:	d202      	bcs.n	c7c <protocol_convert_to_string+0x1d4>
		const struct dfe_samples* sampl_data = &mapped_data->sampl_data[idx];
     c76:	9e05      	ldr	r6, [sp, #20]
		for(u16_t jdx = 0; jdx < sampl_data->samples_num; ++jdx)
     c78:	2500      	movs	r5, #0
     c7a:	e7eb      	b.n	c54 <protocol_convert_to_string+0x1ac>
					 (int)sampl_data->data[jdx].q,
					 (int)sampl_data->data[jdx].i);
		}
	}

	strlen += sprintf(&buffer[strlen], "DF_END\r\n");
     c7c:	9c06      	ldr	r4, [sp, #24]
     c7e:	eb04 0208 	add.w	r2, r4, r8
     c82:	4b11      	ldr	r3, [pc, #68]	; (cc8 <protocol_convert_to_string+0x220>)
     c84:	cb03      	ldmia	r3!, {r0, r1}
     c86:	f844 0008 	str.w	r0, [r4, r8]
     c8a:	6051      	str	r1, [r2, #4]
     c8c:	781b      	ldrb	r3, [r3, #0]
     c8e:	7213      	strb	r3, [r2, #8]
     c90:	f108 0008 	add.w	r0, r8, #8

	return strlen;
}
     c94:	b280      	uxth	r0, r0
     c96:	b00b      	add	sp, #44	; 0x2c
     c98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     c9c:	00010edc 	.word	0x00010edc
     ca0:	00010ee8 	.word	0x00010ee8
     ca4:	00010ef0 	.word	0x00010ef0
     ca8:	00010ef8 	.word	0x00010ef8
     cac:	00010f00 	.word	0x00010f00
     cb0:	00010f08 	.word	0x00010f08
     cb4:	00010f10 	.word	0x00010f10
     cb8:	00010f18 	.word	0x00010f18
     cbc:	00010f20 	.word	0x00010f20
     cc0:	10624dd3 	.word	0x10624dd3
     cc4:	00010f28 	.word	0x00010f28
     cc8:	00010f3c 	.word	0x00010f3c

00000ccc <protocol_initialization>:
{
     ccc:	b508      	push	{r3, lr}
	if (iface == NULL) {
     cce:	b118      	cbz	r0, cd8 <protocol_initialization+0xc>
	g_protocol_data.uart = iface;
     cd0:	4a04      	ldr	r2, [pc, #16]	; (ce4 <protocol_initialization+0x18>)
     cd2:	6010      	str	r0, [r2, #0]
	return 0;
     cd4:	2000      	movs	r0, #0
}
     cd6:	bd08      	pop	{r3, pc}
		printk("[PROTOCOL] - iface is NULL, cannot initialize\r\n");
     cd8:	4803      	ldr	r0, [pc, #12]	; (ce8 <protocol_initialization+0x1c>)
     cda:	f00c f9a8 	bl	d02e <printk>
		return -EINVAL;
     cde:	f06f 0015 	mvn.w	r0, #21
     ce2:	e7f8      	b.n	cd6 <protocol_initialization+0xa>
     ce4:	20000fb4 	.word	0x20000fb4
     ce8:	00010f48 	.word	0x00010f48

00000cec <protocol_handling>:
{
     cec:	b538      	push	{r3, r4, r5, lr}
	assert(sampl_conf != NULL);
     cee:	b178      	cbz	r0, d10 <protocol_handling+0x24>
	assert(mapped_data != NULL);
     cf0:	b1a1      	cbz	r1, d1c <protocol_handling+0x30>
	length = protocol_convert_to_string(sampl_conf, mapped_data,
     cf2:	4c0d      	ldr	r4, [pc, #52]	; (d28 <protocol_handling+0x3c>)
     cf4:	f44f 5320 	mov.w	r3, #10240	; 0x2800
     cf8:	4622      	mov	r2, r4
     cfa:	f7ff fed5 	bl	aa8 <protocol_convert_to_string>
     cfe:	4601      	mov	r1, r0
	g_protocol_data.uart->send(g_protocol_data.string_packet, length);
     d00:	f854 3c04 	ldr.w	r3, [r4, #-4]
     d04:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
     d08:	4620      	mov	r0, r4
     d0a:	4798      	blx	r3
}
     d0c:	2000      	movs	r0, #0
     d0e:	bd38      	pop	{r3, r4, r5, pc}
	assert(sampl_conf != NULL);
     d10:	4b06      	ldr	r3, [pc, #24]	; (d2c <protocol_handling+0x40>)
     d12:	4a07      	ldr	r2, [pc, #28]	; (d30 <protocol_handling+0x44>)
     d14:	2128      	movs	r1, #40	; 0x28
     d16:	4807      	ldr	r0, [pc, #28]	; (d34 <protocol_handling+0x48>)
     d18:	f00a ffc8 	bl	bcac <__assert_func>
	assert(mapped_data != NULL);
     d1c:	4b06      	ldr	r3, [pc, #24]	; (d38 <protocol_handling+0x4c>)
     d1e:	4a04      	ldr	r2, [pc, #16]	; (d30 <protocol_handling+0x44>)
     d20:	2129      	movs	r1, #41	; 0x29
     d22:	4804      	ldr	r0, [pc, #16]	; (d34 <protocol_handling+0x48>)
     d24:	f00a ffc2 	bl	bcac <__assert_func>
     d28:	20000fb8 	.word	0x20000fb8
     d2c:	00010d88 	.word	0x00010d88
     d30:	00010fac 	.word	0x00010fac
     d34:	00010f78 	.word	0x00010f78
     d38:	00010f98 	.word	0x00010f98

00000d3c <ble_initialization>:

#include "ble.h"


int ble_initialization(void)
{
     d3c:	b510      	push	{r4, lr}
     d3e:	b086      	sub	sp, #24
	struct bt_le_scan_param scan_param = {
     d40:	2400      	movs	r4, #0
     d42:	9401      	str	r4, [sp, #4]
     d44:	9402      	str	r4, [sp, #8]
     d46:	9404      	str	r4, [sp, #16]
     d48:	9405      	str	r4, [sp, #20]
     d4a:	2320      	movs	r3, #32
     d4c:	f8ad 300c 	strh.w	r3, [sp, #12]
     d50:	f8ad 300e 	strh.w	r3, [sp, #14]
		.interval   = 0x0020,
		.window     = 0x0020,
	};
	int err;

	printk("[BT] Initialization started\r\n");
     d54:	480e      	ldr	r0, [pc, #56]	; (d90 <ble_initialization+0x54>)
     d56:	f00c f96a 	bl	d02e <printk>

	err = bt_enable(NULL);
     d5a:	4620      	mov	r0, r4
     d5c:	f003 ffc8 	bl	4cf0 <bt_enable>
	if (err)
     d60:	b958      	cbnz	r0, d7a <ble_initialization+0x3e>
	{
		printk("[BT] Initialization failed (err %d)\r\n", err);
		return err;
	}

	printk("[BT] Starting scanning\r\n");
     d62:	480c      	ldr	r0, [pc, #48]	; (d94 <ble_initialization+0x58>)
     d64:	f00c f963 	bl	d02e <printk>
	err = bt_le_scan_start(&scan_param, NULL);
     d68:	2100      	movs	r1, #0
     d6a:	a801      	add	r0, sp, #4
     d6c:	f004 f85c 	bl	4e28 <bt_le_scan_start>
	if (err)
     d70:	4604      	mov	r4, r0
     d72:	b940      	cbnz	r0, d86 <ble_initialization+0x4a>
	{
		printk("[BT] Start scanning failed (err %d)\n", err);
		return err;
	}
	return 0;
}
     d74:	4620      	mov	r0, r4
     d76:	b006      	add	sp, #24
     d78:	bd10      	pop	{r4, pc}
     d7a:	4604      	mov	r4, r0
		printk("[BT] Initialization failed (err %d)\r\n", err);
     d7c:	4601      	mov	r1, r0
     d7e:	4806      	ldr	r0, [pc, #24]	; (d98 <ble_initialization+0x5c>)
     d80:	f00c f955 	bl	d02e <printk>
		return err;
     d84:	e7f6      	b.n	d74 <ble_initialization+0x38>
		printk("[BT] Start scanning failed (err %d)\n", err);
     d86:	4601      	mov	r1, r0
     d88:	4804      	ldr	r0, [pc, #16]	; (d9c <ble_initialization+0x60>)
     d8a:	f00c f950 	bl	d02e <printk>
		return err;
     d8e:	e7f1      	b.n	d74 <ble_initialization+0x38>
     d90:	00010fc0 	.word	0x00010fc0
     d94:	00011008 	.word	0x00011008
     d98:	00010fe0 	.word	0x00010fe0
     d9c:	00011024 	.word	0x00011024

00000da0 <get_switching_duration_ns>:

	return 0;
}

static u32_t get_switching_duration_ns(const struct dfe_sampling_config *sampling_conf)
{
     da0:	b508      	push	{r3, lr}
	assert(sampling_conf != NULL);
     da2:	b158      	cbz	r0, dbc <get_switching_duration_ns+0x1c>
     da4:	4602      	mov	r2, r0

	u32_t swiching_duration_us = ((sampling_conf->number_of_8us * DFE_US(8)) -
     da6:	7880      	ldrb	r0, [r0, #2]
			(sampling_conf->guard_period_us + sampling_conf->ref_period_us));
     da8:	7b93      	ldrb	r3, [r2, #14]
     daa:	7bd2      	ldrb	r2, [r2, #15]
     dac:	4413      	add	r3, r2
	u32_t swiching_duration_us = ((sampling_conf->number_of_8us * DFE_US(8)) -
     dae:	ebc3 03c0 	rsb	r3, r3, r0, lsl #3

	return (swiching_duration_us * DFE_NS(1000));
}
     db2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
     db6:	fb00 f003 	mul.w	r0, r0, r3
     dba:	bd08      	pop	{r3, pc}
	assert(sampling_conf != NULL);
     dbc:	4b03      	ldr	r3, [pc, #12]	; (dcc <get_switching_duration_ns+0x2c>)
     dbe:	4a04      	ldr	r2, [pc, #16]	; (dd0 <get_switching_duration_ns+0x30>)
     dc0:	f240 115f 	movw	r1, #351	; 0x15f
     dc4:	4803      	ldr	r0, [pc, #12]	; (dd4 <get_switching_duration_ns+0x34>)
     dc6:	f00a ff71 	bl	bcac <__assert_func>
     dca:	bf00      	nop
     dcc:	0001104c 	.word	0x0001104c
     dd0:	00011394 	.word	0x00011394
     dd4:	00011064 	.word	0x00011064

00000dd8 <get_effective_ant_num>:

static uint8_t get_effective_ant_num(const struct dfe_sampling_config *sampling_conf)
{
     dd8:	b538      	push	{r3, r4, r5, lr}
	assert(sampling_conf != NULL);
     dda:	b150      	cbz	r0, df2 <get_effective_ant_num+0x1a>
     ddc:	4605      	mov	r5, r0

	u32_t switching_duration_ns = get_switching_duration_ns(sampling_conf);
     dde:	f7ff ffdf 	bl	da0 <get_switching_duration_ns>
     de2:	4604      	mov	r4, r0
	u32_t switch_spacing_ns = get_switch_spacing_ns(sampling_conf->switch_spacing);
     de4:	7aa8      	ldrb	r0, [r5, #10]
     de6:	f00b feb0 	bl	cb4a <get_switch_spacing_ns>

	return (uint8_t)(switching_duration_ns / switch_spacing_ns);
     dea:	fbb4 f0f0 	udiv	r0, r4, r0
}
     dee:	b2c0      	uxtb	r0, r0
     df0:	bd38      	pop	{r3, r4, r5, pc}
	assert(sampling_conf != NULL);
     df2:	4b03      	ldr	r3, [pc, #12]	; (e00 <get_effective_ant_num+0x28>)
     df4:	4a03      	ldr	r2, [pc, #12]	; (e04 <get_effective_ant_num+0x2c>)
     df6:	f240 1169 	movw	r1, #361	; 0x169
     dfa:	4803      	ldr	r0, [pc, #12]	; (e08 <get_effective_ant_num+0x30>)
     dfc:	f00a ff56 	bl	bcac <__assert_func>
     e00:	0001104c 	.word	0x0001104c
     e04:	000113b0 	.word	0x000113b0
     e08:	00011064 	.word	0x00011064

00000e0c <dfe_get_sampling_config>:
}
     e0c:	4800      	ldr	r0, [pc, #0]	; (e10 <dfe_get_sampling_config+0x4>)
     e0e:	4770      	bx	lr
     e10:	000114a0 	.word	0x000114a0

00000e14 <dfe_get_antenna_config>:
}
     e14:	4800      	ldr	r0, [pc, #0]	; (e18 <dfe_get_antenna_config+0x4>)
     e16:	4770      	bx	lr
     e18:	00011434 	.word	0x00011434

00000e1c <dfe_get_ant_gpios_config>:
}
     e1c:	4800      	ldr	r0, [pc, #0]	; (e20 <dfe_get_ant_gpios_config+0x4>)
     e1e:	4770      	bx	lr
     e20:	00011498 	.word	0x00011498

00000e24 <dfe_init>:
{
     e24:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     e28:	b083      	sub	sp, #12
     e2a:	af02      	add	r7, sp, #8
	assert(sampl_conf != NULL);
     e2c:	2800      	cmp	r0, #0
     e2e:	d07f      	beq.n	f30 <dfe_init+0x10c>
     e30:	460d      	mov	r5, r1
     e32:	4616      	mov	r6, r2
     e34:	4698      	mov	r8, r3
     e36:	4604      	mov	r4, r0
	assert(ant_conf != NULL);
     e38:	2900      	cmp	r1, #0
     e3a:	d07f      	beq.n	f3c <dfe_init+0x118>
	assert(ant_gpio != NULL);
     e3c:	2a00      	cmp	r2, #0
     e3e:	f000 8083 	beq.w	f48 <dfe_init+0x124>
	assert(ant_gpio_len != 0);
     e42:	2b00      	cmp	r3, #0
     e44:	f000 8086 	beq.w	f54 <dfe_init+0x130>
	err = dfe_set_mode(sampl_conf->dfe_mode);
     e48:	7800      	ldrb	r0, [r0, #0]
     e4a:	f006 f981 	bl	7150 <dfe_set_mode>
	if (err) {
     e4e:	2800      	cmp	r0, #0
     e50:	f040 8086 	bne.w	f60 <dfe_init+0x13c>
	err = dfe_set_duration(sampl_conf->number_of_8us);
     e54:	78a0      	ldrb	r0, [r4, #2]
     e56:	f006 f98b 	bl	7170 <dfe_set_duration>
	if(err) {
     e5a:	4681      	mov	r9, r0
     e5c:	2800      	cmp	r0, #0
     e5e:	f040 8085 	bne.w	f6c <dfe_init+0x148>
	err = dfe_set_start_point(sampl_conf->start_of_sampl);
     e62:	7860      	ldrb	r0, [r4, #1]
     e64:	f006 f994 	bl	7190 <dfe_set_start_point>
	if(err) {
     e68:	4681      	mov	r9, r0
     e6a:	2800      	cmp	r0, #0
     e6c:	f040 8086 	bne.w	f7c <dfe_init+0x158>
	dfe_set_sample_on_crc_error(sampl_conf->en_sampling_on_crc_error);
     e70:	78e0      	ldrb	r0, [r4, #3]
     e72:	f006 f999 	bl	71a8 <dfe_set_sample_on_crc_error>
	dfe_set_trig_dfe_start_task_only(true);
     e76:	2001      	movs	r0, #1
     e78:	f006 f99c 	bl	71b4 <dfe_set_trig_dfe_start_task_only>
	err = dfe_set_sampling_spacing_ref(sampl_conf->sample_spacing_ref);
     e7c:	79a0      	ldrb	r0, [r4, #6]
     e7e:	f006 f99f 	bl	71c0 <dfe_set_sampling_spacing_ref>
	if(err) {
     e82:	4681      	mov	r9, r0
     e84:	2800      	cmp	r0, #0
     e86:	d17d      	bne.n	f84 <dfe_init+0x160>
	err = dfe_set_sampling_type(sampl_conf->sampling_type);
     e88:	7960      	ldrb	r0, [r4, #5]
     e8a:	f006 f9a7 	bl	71dc <dfe_set_sampling_type>
	if(err) {
     e8e:	4681      	mov	r9, r0
     e90:	2800      	cmp	r0, #0
     e92:	d17b      	bne.n	f8c <dfe_init+0x168>
	err = dfe_set_sample_spacing(sampl_conf->sample_spacing);
     e94:	79e0      	ldrb	r0, [r4, #7]
     e96:	f006 f9ad 	bl	71f4 <dfe_set_sample_spacing>
	if(err) {
     e9a:	4681      	mov	r9, r0
     e9c:	2800      	cmp	r0, #0
     e9e:	d179      	bne.n	f94 <dfe_init+0x170>
	err = dfe_set_backoff_gain(0);
     ea0:	2000      	movs	r0, #0
     ea2:	f006 f9b5 	bl	7210 <dfe_set_backoff_gain>
	if(err) {
     ea6:	4681      	mov	r9, r0
     ea8:	2800      	cmp	r0, #0
     eaa:	d177      	bne.n	f9c <dfe_init+0x178>
	err = dfe_set_switch_offset(sampl_conf->switch_offset);
     eac:	f9b4 000c 	ldrsh.w	r0, [r4, #12]
     eb0:	b2c0      	uxtb	r0, r0
     eb2:	f006 f9c7 	bl	7244 <dfe_set_switch_offset>
	if(err) {
     eb6:	4681      	mov	r9, r0
     eb8:	2800      	cmp	r0, #0
     eba:	d173      	bne.n	fa4 <dfe_init+0x180>
	err = dfe_set_sample_offset(sampl_conf->sample_offset);
     ebc:	f9b4 0008 	ldrsh.w	r0, [r4, #8]
     ec0:	b2c0      	uxtb	r0, r0
     ec2:	f006 f9c5 	bl	7250 <dfe_set_sample_offset>
	if(err) {
     ec6:	4681      	mov	r9, r0
     ec8:	2800      	cmp	r0, #0
     eca:	d16f      	bne.n	fac <dfe_init+0x188>
	err = dfe_set_ant_switch_spacing(sampl_conf->switch_spacing);
     ecc:	7aa0      	ldrb	r0, [r4, #10]
     ece:	f006 f9ab 	bl	7228 <dfe_set_ant_switch_spacing>
	if(err) {
     ed2:	4681      	mov	r9, r0
     ed4:	2800      	cmp	r0, #0
     ed6:	d16d      	bne.n	fb4 <dfe_init+0x190>
	err = dfe_set_ant_gpios(ant_gpio, ant_gpio_len);
     ed8:	4641      	mov	r1, r8
     eda:	4630      	mov	r0, r6
     edc:	f006 f9be 	bl	725c <dfe_set_ant_gpios>
	if(err) {
     ee0:	4681      	mov	r9, r0
     ee2:	2800      	cmp	r0, #0
     ee4:	d16a      	bne.n	fbc <dfe_init+0x198>
	u8_t pattern_array[ant_conf->antennae_switch_idx_len];
     ee6:	f895 1043 	ldrb.w	r1, [r5, #67]	; 0x43
     eea:	1dcb      	adds	r3, r1, #7
     eec:	f403 73fc 	and.w	r3, r3, #504	; 0x1f8
     ef0:	ebad 0d03 	sub.w	sp, sp, r3
     ef4:	ac02      	add	r4, sp, #8
				       ant_conf->antennae_switch_idx,
     ef6:	f105 0313 	add.w	r3, r5, #19
	err = create_switching_pattern_array(pattern_array,
     efa:	9101      	str	r1, [sp, #4]
     efc:	9300      	str	r3, [sp, #0]
     efe:	7cab      	ldrb	r3, [r5, #18]
     f00:	1caa      	adds	r2, r5, #2
     f02:	4620      	mov	r0, r4
     f04:	f00b fde7 	bl	cad6 <create_switching_pattern_array>
	if(err) {
     f08:	4681      	mov	r9, r0
     f0a:	2800      	cmp	r0, #0
     f0c:	d15a      	bne.n	fc4 <dfe_init+0x1a0>
	err = dfe_set_ant_gpio_patterns(ant_conf->ant_gpio_pattern[ant_conf->idle_ant_idx],
     f0e:	7868      	ldrb	r0, [r5, #1]
					ant_conf->ant_gpio_pattern[ant_conf->ref_ant_idx],
     f10:	7829      	ldrb	r1, [r5, #0]
	err = dfe_set_ant_gpio_patterns(ant_conf->ant_gpio_pattern[ant_conf->idle_ant_idx],
     f12:	4429      	add	r1, r5
     f14:	4428      	add	r0, r5
     f16:	f895 3043 	ldrb.w	r3, [r5, #67]	; 0x43
     f1a:	4622      	mov	r2, r4
     f1c:	7889      	ldrb	r1, [r1, #2]
     f1e:	7880      	ldrb	r0, [r0, #2]
     f20:	f006 f9c2 	bl	72a8 <dfe_set_ant_gpio_patterns>
	if(err) {
     f24:	4681      	mov	r9, r0
     f26:	b320      	cbz	r0, f72 <dfe_init+0x14e>
		printk("Error! Initialization of gpio patterns failed!\r\n");
     f28:	4828      	ldr	r0, [pc, #160]	; (fcc <dfe_init+0x1a8>)
     f2a:	f00c f880 	bl	d02e <printk>
		return err;
     f2e:	e020      	b.n	f72 <dfe_init+0x14e>
	assert(sampl_conf != NULL);
     f30:	4b27      	ldr	r3, [pc, #156]	; (fd0 <dfe_init+0x1ac>)
     f32:	4a28      	ldr	r2, [pc, #160]	; (fd4 <dfe_init+0x1b0>)
     f34:	21a4      	movs	r1, #164	; 0xa4
     f36:	4828      	ldr	r0, [pc, #160]	; (fd8 <dfe_init+0x1b4>)
     f38:	f00a feb8 	bl	bcac <__assert_func>
	assert(ant_conf != NULL);
     f3c:	4b27      	ldr	r3, [pc, #156]	; (fdc <dfe_init+0x1b8>)
     f3e:	4a25      	ldr	r2, [pc, #148]	; (fd4 <dfe_init+0x1b0>)
     f40:	21a5      	movs	r1, #165	; 0xa5
     f42:	4825      	ldr	r0, [pc, #148]	; (fd8 <dfe_init+0x1b4>)
     f44:	f00a feb2 	bl	bcac <__assert_func>
	assert(ant_gpio != NULL);
     f48:	4b25      	ldr	r3, [pc, #148]	; (fe0 <dfe_init+0x1bc>)
     f4a:	4a22      	ldr	r2, [pc, #136]	; (fd4 <dfe_init+0x1b0>)
     f4c:	21a6      	movs	r1, #166	; 0xa6
     f4e:	4822      	ldr	r0, [pc, #136]	; (fd8 <dfe_init+0x1b4>)
     f50:	f00a feac 	bl	bcac <__assert_func>
	assert(ant_gpio_len != 0);
     f54:	4b23      	ldr	r3, [pc, #140]	; (fe4 <dfe_init+0x1c0>)
     f56:	4a1f      	ldr	r2, [pc, #124]	; (fd4 <dfe_init+0x1b0>)
     f58:	21a7      	movs	r1, #167	; 0xa7
     f5a:	481f      	ldr	r0, [pc, #124]	; (fd8 <dfe_init+0x1b4>)
     f5c:	f00a fea6 	bl	bcac <__assert_func>
		printk("[DFE] - DFE mode is unknown\n");
     f60:	4821      	ldr	r0, [pc, #132]	; (fe8 <dfe_init+0x1c4>)
     f62:	f00c f864 	bl	d02e <printk>
		return -EINVAL;
     f66:	f06f 0915 	mvn.w	r9, #21
     f6a:	e002      	b.n	f72 <dfe_init+0x14e>
		printk("Error! Number of 8us periods is out of allowed range!\r\n");
     f6c:	481f      	ldr	r0, [pc, #124]	; (fec <dfe_init+0x1c8>)
     f6e:	f00c f85e 	bl	d02e <printk>
}
     f72:	4648      	mov	r0, r9
     f74:	3704      	adds	r7, #4
     f76:	46bd      	mov	sp, r7
     f78:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		printk("Error! DFE start point value is out of allowed range!\r\n");
     f7c:	481c      	ldr	r0, [pc, #112]	; (ff0 <dfe_init+0x1cc>)
     f7e:	f00c f856 	bl	d02e <printk>
		return err;
     f82:	e7f6      	b.n	f72 <dfe_init+0x14e>
		printk("Error! Reference sample spacing value is out of range!\r\n");
     f84:	481b      	ldr	r0, [pc, #108]	; (ff4 <dfe_init+0x1d0>)
     f86:	f00c f852 	bl	d02e <printk>
		return err;
     f8a:	e7f2      	b.n	f72 <dfe_init+0x14e>
		printk("Error! Sampling type value is out of range!\r\n");
     f8c:	481a      	ldr	r0, [pc, #104]	; (ff8 <dfe_init+0x1d4>)
     f8e:	f00c f84e 	bl	d02e <printk>
		return err;
     f92:	e7ee      	b.n	f72 <dfe_init+0x14e>
		printk("Error! Sample spacing value is out of range!\r\n");
     f94:	4819      	ldr	r0, [pc, #100]	; (ffc <dfe_init+0x1d8>)
     f96:	f00c f84a 	bl	d02e <printk>
		return err;
     f9a:	e7ea      	b.n	f72 <dfe_init+0x14e>
		printk("Error! Gain backoff value is out of range!\r\n");
     f9c:	4818      	ldr	r0, [pc, #96]	; (1000 <CONFIG_FPROTECT_BLOCK_SIZE>)
     f9e:	f00c f846 	bl	d02e <printk>
		return err;
     fa2:	e7e6      	b.n	f72 <dfe_init+0x14e>
		printk("Error! Switch offset value is out of range!\r\n");
     fa4:	4817      	ldr	r0, [pc, #92]	; (1004 <CONFIG_FPROTECT_BLOCK_SIZE+0x4>)
     fa6:	f00c f842 	bl	d02e <printk>
		return err;
     faa:	e7e2      	b.n	f72 <dfe_init+0x14e>
		printk("Error! Sampling offset value is out of range!\r\n");
     fac:	4816      	ldr	r0, [pc, #88]	; (1008 <CONFIG_FPROTECT_BLOCK_SIZE+0x8>)
     fae:	f00c f83e 	bl	d02e <printk>
		return err;
     fb2:	e7de      	b.n	f72 <dfe_init+0x14e>
		printk("Error! Antenna switch spacing is out of range!\r\n");
     fb4:	4815      	ldr	r0, [pc, #84]	; (100c <CONFIG_FPROTECT_BLOCK_SIZE+0xc>)
     fb6:	f00c f83a 	bl	d02e <printk>
		return err;
     fba:	e7da      	b.n	f72 <dfe_init+0x14e>
		printk("Error! Number of GPIO for antennas switching is to large!\r\n");
     fbc:	4814      	ldr	r0, [pc, #80]	; (1010 <CONFIG_FPROTECT_BLOCK_SIZE+0x10>)
     fbe:	f00c f836 	bl	d02e <printk>
		return err;
     fc2:	e7d6      	b.n	f72 <dfe_init+0x14e>
		printk("Error! Preparation of switch patterns array failed!\r\n");
     fc4:	4813      	ldr	r0, [pc, #76]	; (1014 <CONFIG_FPROTECT_BLOCK_SIZE+0x14>)
     fc6:	f00c f832 	bl	d02e <printk>
		return err;
     fca:	e7d2      	b.n	f72 <dfe_init+0x14e>
     fcc:	000112f0 	.word	0x000112f0
     fd0:	00010d88 	.word	0x00010d88
     fd4:	00011368 	.word	0x00011368
     fd8:	00011064 	.word	0x00011064
     fdc:	00010db8 	.word	0x00010db8
     fe0:	00010dcc 	.word	0x00010dcc
     fe4:	00010de0 	.word	0x00010de0
     fe8:	0001108c 	.word	0x0001108c
     fec:	000110ac 	.word	0x000110ac
     ff0:	000110e4 	.word	0x000110e4
     ff4:	0001111c 	.word	0x0001111c
     ff8:	00011158 	.word	0x00011158
     ffc:	00011188 	.word	0x00011188
    1000:	000111b8 	.word	0x000111b8
    1004:	000111e8 	.word	0x000111e8
    1008:	00011218 	.word	0x00011218
    100c:	00011248 	.word	0x00011248
    1010:	0001127c 	.word	0x0001127c
    1014:	000112b8 	.word	0x000112b8

00001018 <get_sampling_slot_samples_num>:
	}
	return sampling_ns;
}

static u16_t get_sampling_slot_samples_num(const struct dfe_sampling_config *sampling_conf)
{
    1018:	b538      	push	{r3, r4, r5, lr}
	assert(sampling_conf != NULL);
    101a:	b178      	cbz	r0, 103c <get_sampling_slot_samples_num+0x24>
    101c:	4605      	mov	r5, r0

	u16_t sample_spacing_ns = dfe_get_sample_spacing_ns(sampling_conf->sample_spacing);
    101e:	79c0      	ldrb	r0, [r0, #7]
    1020:	f00b fdaa 	bl	cb78 <dfe_get_sample_spacing_ns>
    1024:	4604      	mov	r4, r0
	u16_t swich_spacing_ns = get_switch_spacing_ns(sampling_conf->switch_spacing);
    1026:	7aa8      	ldrb	r0, [r5, #10]
    1028:	f00b fd8f 	bl	cb4a <get_switch_spacing_ns>
	 * swich slot and sample slot. Because of that in case of over sampling
	 * we take as valid samples only half of them. In case sampling duration
	 * is greater or equal all samples are valid.
	 * of
	 */
	assert(sample_spacing_ns != 0);
    102c:	b16c      	cbz	r4, 104a <get_sampling_slot_samples_num+0x32>

	if (swich_spacing_ns > sample_spacing_ns) {
    102e:	4284      	cmp	r4, r0
    1030:	d212      	bcs.n	1058 <get_sampling_slot_samples_num+0x40>
		return swich_spacing_ns / (sample_spacing_ns * 2);
    1032:	0064      	lsls	r4, r4, #1
    1034:	fb90 f0f4 	sdiv	r0, r0, r4
    1038:	b280      	uxth	r0, r0
    103a:	e00e      	b.n	105a <get_sampling_slot_samples_num+0x42>
	assert(sampling_conf != NULL);
    103c:	4b07      	ldr	r3, [pc, #28]	; (105c <get_sampling_slot_samples_num+0x44>)
    103e:	4a08      	ldr	r2, [pc, #32]	; (1060 <get_sampling_slot_samples_num+0x48>)
    1040:	f240 11c1 	movw	r1, #449	; 0x1c1
    1044:	4807      	ldr	r0, [pc, #28]	; (1064 <get_sampling_slot_samples_num+0x4c>)
    1046:	f00a fe31 	bl	bcac <__assert_func>
	assert(sample_spacing_ns != 0);
    104a:	4b07      	ldr	r3, [pc, #28]	; (1068 <get_sampling_slot_samples_num+0x50>)
    104c:	4a04      	ldr	r2, [pc, #16]	; (1060 <get_sampling_slot_samples_num+0x48>)
    104e:	f240 11cb 	movw	r1, #459	; 0x1cb
    1052:	4804      	ldr	r0, [pc, #16]	; (1064 <get_sampling_slot_samples_num+0x4c>)
    1054:	f00a fe2a 	bl	bcac <__assert_func>
	} else {
		return sample_spacing_ns / sample_spacing_ns;
    1058:	2001      	movs	r0, #1
	}
}
    105a:	bd38      	pop	{r3, r4, r5, pc}
    105c:	0001104c 	.word	0x0001104c
    1060:	000113c8 	.word	0x000113c8
    1064:	00011064 	.word	0x00011064
    1068:	00011324 	.word	0x00011324

0000106c <get_ref_samples_num>:

static u16_t get_ref_samples_num(const struct dfe_sampling_config* sampling_conf)
{
    106c:	b510      	push	{r4, lr}
	assert(sampling_conf != NULL);
    106e:	b160      	cbz	r0, 108a <get_ref_samples_num+0x1e>
    1070:	4604      	mov	r4, r0

	u16_t sample_spacing_ns = dfe_get_sample_spacing_ref_ns(sampling_conf->sample_spacing_ref);
    1072:	7980      	ldrb	r0, [r0, #6]
    1074:	f00b fd9b 	bl	cbae <dfe_get_sample_spacing_ref_ns>
	return sampling_conf->ref_period_us * DFE_NS(1000) / sample_spacing_ns;
    1078:	7be2      	ldrb	r2, [r4, #15]
    107a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    107e:	fb03 f302 	mul.w	r3, r3, r2
    1082:	fb93 f0f0 	sdiv	r0, r3, r0
}
    1086:	b280      	uxth	r0, r0
    1088:	bd10      	pop	{r4, pc}
	assert(sampling_conf != NULL);
    108a:	4b03      	ldr	r3, [pc, #12]	; (1098 <get_ref_samples_num+0x2c>)
    108c:	4a03      	ldr	r2, [pc, #12]	; (109c <get_ref_samples_num+0x30>)
    108e:	f44f 71eb 	mov.w	r1, #470	; 0x1d6
    1092:	4803      	ldr	r0, [pc, #12]	; (10a0 <get_ref_samples_num+0x34>)
    1094:	f00a fe0a 	bl	bcac <__assert_func>
    1098:	0001104c 	.word	0x0001104c
    109c:	000113e8 	.word	0x000113e8
    10a0:	00011064 	.word	0x00011064

000010a4 <dfe_map_iq_samples_to_antennas>:
{
    10a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    10a8:	b087      	sub	sp, #28
    10aa:	9305      	str	r3, [sp, #20]
	assert(raw_data != NULL);
    10ac:	9101      	str	r1, [sp, #4]
    10ae:	b169      	cbz	r1, 10cc <dfe_map_iq_samples_to_antennas+0x28>
    10b0:	4681      	mov	r9, r0
    10b2:	4614      	mov	r4, r2
	assert(mapped_data != NULL);
    10b4:	b188      	cbz	r0, 10da <dfe_map_iq_samples_to_antennas+0x36>
	u16_t ref_samples_num = get_ref_samples_num(sampling_conf);
    10b6:	4610      	mov	r0, r2
    10b8:	f7ff ffd8 	bl	106c <get_ref_samples_num>
    10bc:	4683      	mov	fp, r0
	mapped_data->ref_data.antenna_id = ant_config->ref_ant_idx;
    10be:	9b05      	ldr	r3, [sp, #20]
    10c0:	781b      	ldrb	r3, [r3, #0]
    10c2:	f889 3049 	strb.w	r3, [r9, #73]	; 0x49
	for(uint16_t idx = 0; idx < ref_samples_num; ++idx) {
    10c6:	2300      	movs	r3, #0
    10c8:	9e01      	ldr	r6, [sp, #4]
    10ca:	e01e      	b.n	110a <dfe_map_iq_samples_to_antennas+0x66>
	assert(raw_data != NULL);
    10cc:	4b53      	ldr	r3, [pc, #332]	; (121c <dfe_map_iq_samples_to_antennas+0x178>)
    10ce:	4a54      	ldr	r2, [pc, #336]	; (1220 <dfe_map_iq_samples_to_antennas+0x17c>)
    10d0:	f44f 7184 	mov.w	r1, #264	; 0x108
    10d4:	4853      	ldr	r0, [pc, #332]	; (1224 <dfe_map_iq_samples_to_antennas+0x180>)
    10d6:	f00a fde9 	bl	bcac <__assert_func>
	assert(mapped_data != NULL);
    10da:	4b53      	ldr	r3, [pc, #332]	; (1228 <dfe_map_iq_samples_to_antennas+0x184>)
    10dc:	4a50      	ldr	r2, [pc, #320]	; (1220 <dfe_map_iq_samples_to_antennas+0x17c>)
    10de:	f240 1109 	movw	r1, #265	; 0x109
    10e2:	4850      	ldr	r0, [pc, #320]	; (1224 <dfe_map_iq_samples_to_antennas+0x180>)
    10e4:	f00a fde2 	bl	bcac <__assert_func>
		mapped_data->ref_data.data[idx].i = raw_data->data[idx].iq.i;
    10e8:	eb06 0783 	add.w	r7, r6, r3, lsl #2
    10ec:	1c5d      	adds	r5, r3, #1
    10ee:	f9b7 0004 	ldrsh.w	r0, [r7, #4]
    10f2:	f7ff f90f 	bl	314 <__aeabi_i2f>
    10f6:	f849 0035 	str.w	r0, [r9, r5, lsl #3]
		mapped_data->ref_data.data[idx].q = raw_data->data[idx].iq.q;
    10fa:	f9b7 0006 	ldrsh.w	r0, [r7, #6]
    10fe:	f7ff f909 	bl	314 <__aeabi_i2f>
    1102:	eb09 03c5 	add.w	r3, r9, r5, lsl #3
    1106:	6058      	str	r0, [r3, #4]
	for(uint16_t idx = 0; idx < ref_samples_num; ++idx) {
    1108:	b2ab      	uxth	r3, r5
    110a:	455b      	cmp	r3, fp
    110c:	d3ec      	bcc.n	10e8 <dfe_map_iq_samples_to_antennas+0x44>
	mapped_data->ref_data.samples_num = ref_samples_num;
    110e:	f889 b048 	strb.w	fp, [r9, #72]	; 0x48
	u16_t effective_ant_num = get_effective_ant_num(sampling_conf);
    1112:	4620      	mov	r0, r4
    1114:	f7ff fe60 	bl	dd8 <get_effective_ant_num>
    1118:	b283      	uxth	r3, r0
    111a:	9300      	str	r3, [sp, #0]
	u8_t samples_num = get_sampling_slot_samples_num(sampling_conf);
    111c:	4620      	mov	r0, r4
    111e:	f7ff ff7b 	bl	1018 <get_sampling_slot_samples_num>
    1122:	9002      	str	r0, [sp, #8]
    1124:	fa5f fa80 	uxtb.w	sl, r0

static inline bool is_oversampling_enabled(const struct dfe_sampling_config *sampling_conf)
{
	assert(sampling_conf != NULL);
    1128:	b184      	cbz	r4, 114c <dfe_map_iq_samples_to_antennas+0xa8>

	if (sampling_conf->switch_spacing > sampling_conf->sample_spacing) {
    112a:	8963      	ldrh	r3, [r4, #10]
    112c:	79e2      	ldrb	r2, [r4, #7]
    112e:	429a      	cmp	r2, r3
    1130:	d313      	bcc.n	115a <dfe_map_iq_samples_to_antennas+0xb6>
		effective_ant_num = (effective_ant_num*2);
    1132:	9b00      	ldr	r3, [sp, #0]
    1134:	0058      	lsls	r0, r3, #1
    1136:	b283      	uxth	r3, r0
    1138:	9300      	str	r3, [sp, #0]
		return false;
	} else {
		return true;
    113a:	2301      	movs	r3, #1
    113c:	9304      	str	r3, [sp, #16]
	for(u16_t ant_idx = 0; ant_idx < effective_ant_num; ++ant_idx) {
    113e:	f04f 0800 	mov.w	r8, #0
    1142:	f8cd b00c 	str.w	fp, [sp, #12]
    1146:	f8dd b014 	ldr.w	fp, [sp, #20]
    114a:	e025      	b.n	1198 <dfe_map_iq_samples_to_antennas+0xf4>
	assert(sampling_conf != NULL);
    114c:	4b37      	ldr	r3, [pc, #220]	; (122c <dfe_map_iq_samples_to_antennas+0x188>)
    114e:	4a38      	ldr	r2, [pc, #224]	; (1230 <dfe_map_iq_samples_to_antennas+0x18c>)
    1150:	f44f 71ef 	mov.w	r1, #478	; 0x1de
    1154:	4833      	ldr	r0, [pc, #204]	; (1224 <dfe_map_iq_samples_to_antennas+0x180>)
    1156:	f00a fda9 	bl	bcac <__assert_func>
		return false;
    115a:	2300      	movs	r3, #0
    115c:	9304      	str	r3, [sp, #16]
    115e:	e7ee      	b.n	113e <dfe_map_iq_samples_to_antennas+0x9a>
			u8_t idx = ant_idx % ant_config->antennae_switch_idx_len;
    1160:	f89b 2043 	ldrb.w	r2, [fp, #67]	; 0x43
    1164:	fb98 f3f2 	sdiv	r3, r8, r2
    1168:	fb02 8313 	mls	r3, r2, r3, r8
			ant = ant_config->antennae_switch_idx[idx];
    116c:	fa5b f383 	uxtab	r3, fp, r3
    1170:	7cda      	ldrb	r2, [r3, #19]
		sample->antenna_id = ant;
    1172:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    1176:	eb09 0343 	add.w	r3, r9, r3, lsl #1
    117a:	f883 2053 	strb.w	r2, [r3, #83]	; 0x53
		for(u8_t sample_idx = 0; sample_idx < samples_num; ++sample_idx) {
    117e:	2600      	movs	r6, #0
    1180:	4556      	cmp	r6, sl
    1182:	d322      	bcc.n	11ca <dfe_map_iq_samples_to_antennas+0x126>
		sample->samples_num = samples_num;
    1184:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    1188:	eb09 0444 	add.w	r4, r9, r4, lsl #1
    118c:	f884 a052 	strb.w	sl, [r4, #82]	; 0x52
	for(u16_t ant_idx = 0; ant_idx < effective_ant_num; ++ant_idx) {
    1190:	f108 0801 	add.w	r8, r8, #1
    1194:	fa1f f888 	uxth.w	r8, r8
    1198:	9b00      	ldr	r3, [sp, #0]
    119a:	4543      	cmp	r3, r8
    119c:	d934      	bls.n	1208 <dfe_map_iq_samples_to_antennas+0x164>
		struct dfe_samples *sample = &mapped_data->sampl_data[ant_idx];
    119e:	4644      	mov	r4, r8
		if (oversampl) {
    11a0:	9b04      	ldr	r3, [sp, #16]
    11a2:	2b00      	cmp	r3, #0
    11a4:	d0dc      	beq.n	1160 <dfe_map_iq_samples_to_antennas+0xbc>
			if (ant_idx & 0x1) {
    11a6:	f018 0f01 	tst.w	r8, #1
    11aa:	d10c      	bne.n	11c6 <dfe_map_iq_samples_to_antennas+0x122>
				u8_t idx = (ant_idx >> 1) % ant_config->antennae_switch_idx_len;
    11ac:	ea4f 0358 	mov.w	r3, r8, lsr #1
    11b0:	f89b 1043 	ldrb.w	r1, [fp, #67]	; 0x43
    11b4:	461a      	mov	r2, r3
    11b6:	fb93 f3f1 	sdiv	r3, r3, r1
    11ba:	fb01 2313 	mls	r3, r1, r3, r2
				ant = ant_config->antennae_switch_idx[idx];
    11be:	fa5b f383 	uxtab	r3, fp, r3
    11c2:	7cda      	ldrb	r2, [r3, #19]
    11c4:	e7d5      	b.n	1172 <dfe_map_iq_samples_to_antennas+0xce>
				ant = 255;
    11c6:	22ff      	movs	r2, #255	; 0xff
    11c8:	e7d3      	b.n	1172 <dfe_map_iq_samples_to_antennas+0xce>
			effective_sample_idx = ref_samples_num + (ant_idx * samples_num) + sample_idx;
    11ca:	9b02      	ldr	r3, [sp, #8]
    11cc:	9a03      	ldr	r2, [sp, #12]
    11ce:	fb18 2703 	smlabb	r7, r8, r3, r2
    11d2:	fa46 f787 	sxtab	r7, r6, r7
    11d6:	b2ff      	uxtb	r7, r7
			sample->data[sample_idx].i = raw_data->data[effective_sample_idx].iq.i;
    11d8:	9b01      	ldr	r3, [sp, #4]
    11da:	eb03 0787 	add.w	r7, r3, r7, lsl #2
    11de:	eb04 0584 	add.w	r5, r4, r4, lsl #2
    11e2:	006d      	lsls	r5, r5, #1
    11e4:	eb05 05c6 	add.w	r5, r5, r6, lsl #3
    11e8:	444d      	add	r5, r9
    11ea:	f9b7 0004 	ldrsh.w	r0, [r7, #4]
    11ee:	f7ff f891 	bl	314 <__aeabi_i2f>
    11f2:	f8c5 004a 	str.w	r0, [r5, #74]	; 0x4a
			sample->data[sample_idx].q = raw_data->data[effective_sample_idx].iq.q;
    11f6:	f9b7 0006 	ldrsh.w	r0, [r7, #6]
    11fa:	f7ff f88b 	bl	314 <__aeabi_i2f>
    11fe:	f8c5 004e 	str.w	r0, [r5, #78]	; 0x4e
		for(u8_t sample_idx = 0; sample_idx < samples_num; ++sample_idx) {
    1202:	3601      	adds	r6, #1
    1204:	b2f6      	uxtb	r6, r6
    1206:	e7bb      	b.n	1180 <dfe_map_iq_samples_to_antennas+0xdc>
	mapped_data->header.length = effective_ant_num;
    1208:	f8c9 3000 	str.w	r3, [r9]
	mapped_data->header.frequency = raw_data->hdr.frequency;
    120c:	9b01      	ldr	r3, [sp, #4]
    120e:	885b      	ldrh	r3, [r3, #2]
    1210:	f8c9 3004 	str.w	r3, [r9, #4]
}
    1214:	b007      	add	sp, #28
    1216:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    121a:	bf00      	nop
    121c:	0001133c 	.word	0x0001133c
    1220:	00011374 	.word	0x00011374
    1224:	00011064 	.word	0x00011064
    1228:	00010f98 	.word	0x00010f98
    122c:	0001104c 	.word	0x0001104c
    1230:	000113fc 	.word	0x000113fc

00001234 <dfe_delay_before_first_sampl>:
	}
}

u16_t dfe_delay_before_first_sampl(const struct dfe_sampling_config* sampling_conf)
{
    1234:	b538      	push	{r3, r4, r5, lr}
	assert(sampling_conf != NULL);
    1236:	b160      	cbz	r0, 1252 <dfe_delay_before_first_sampl+0x1e>
    1238:	4605      	mov	r5, r0

	u16_t swich_spacing_ns = get_switch_spacing_ns(sampling_conf->switch_spacing);
    123a:	7a80      	ldrb	r0, [r0, #10]
    123c:	f00b fc85 	bl	cb4a <get_switch_spacing_ns>
    1240:	4604      	mov	r4, r0
	u16_t ref_spacing_ns = dfe_get_sample_spacing_ref_ns(sampling_conf->sample_spacing_ref);
    1242:	79a8      	ldrb	r0, [r5, #6]
    1244:	f00b fcb3 	bl	cbae <dfe_get_sample_spacing_ref_ns>

	assert(swich_spacing_ns != 0);
    1248:	b154      	cbz	r4, 1260 <dfe_delay_before_first_sampl+0x2c>
	return (swich_spacing_ns >> 1) + ref_spacing_ns;
    124a:	eb00 0054 	add.w	r0, r0, r4, lsr #1
}
    124e:	b280      	uxth	r0, r0
    1250:	bd38      	pop	{r3, r4, r5, pc}
	assert(sampling_conf != NULL);
    1252:	4b07      	ldr	r3, [pc, #28]	; (1270 <dfe_delay_before_first_sampl+0x3c>)
    1254:	4a07      	ldr	r2, [pc, #28]	; (1274 <dfe_delay_before_first_sampl+0x40>)
    1256:	f240 11e9 	movw	r1, #489	; 0x1e9
    125a:	4807      	ldr	r0, [pc, #28]	; (1278 <dfe_delay_before_first_sampl+0x44>)
    125c:	f00a fd26 	bl	bcac <__assert_func>
	assert(swich_spacing_ns != 0);
    1260:	4b06      	ldr	r3, [pc, #24]	; (127c <dfe_delay_before_first_sampl+0x48>)
    1262:	4a04      	ldr	r2, [pc, #16]	; (1274 <dfe_delay_before_first_sampl+0x40>)
    1264:	f44f 71f7 	mov.w	r1, #494	; 0x1ee
    1268:	4803      	ldr	r0, [pc, #12]	; (1278 <dfe_delay_before_first_sampl+0x44>)
    126a:	f00a fd1f 	bl	bcac <__assert_func>
    126e:	bf00      	nop
    1270:	0001104c 	.word	0x0001104c
    1274:	00011414 	.word	0x00011414
    1278:	00011064 	.word	0x00011064
    127c:	00011350 	.word	0x00011350

00001280 <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
    1280:	b508      	push	{r3, lr}
	struct out_context *ctx = ctx_p;

	ctx->count++;
    1282:	680b      	ldr	r3, [r1, #0]
    1284:	3301      	adds	r3, #1
    1286:	600b      	str	r3, [r1, #0]
	return _char_out(c);
    1288:	4b01      	ldr	r3, [pc, #4]	; (1290 <char_out+0x10>)
    128a:	681b      	ldr	r3, [r3, #0]
    128c:	4798      	blx	r3
}
    128e:	bd08      	pop	{r3, pc}
    1290:	200000f8 	.word	0x200000f8

00001294 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
    1294:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1298:	4681      	mov	r9, r0
    129a:	468a      	mov	sl, r1
    129c:	4615      	mov	r5, r2
    129e:	469b      	mov	fp, r3
	if (sizeof(long) == 8) {
		pos *= 10000000000;
	}

	/* make sure we don't skip if value is zero */
	if (min_width <= 0) {
    12a0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    12a2:	2b00      	cmp	r3, #0
    12a4:	dd05      	ble.n	12b2 <_printk_dec_ulong+0x1e>
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
			found_largest_digit = 1;
    12a6:	f04f 0801 	mov.w	r8, #1
    12aa:	260a      	movs	r6, #10
    12ac:	2700      	movs	r7, #0
    12ae:	4c21      	ldr	r4, [pc, #132]	; (1334 <_printk_dec_ulong+0xa0>)
    12b0:	e013      	b.n	12da <_printk_dec_ulong+0x46>
		min_width = 1;
    12b2:	2301      	movs	r3, #1
    12b4:	930a      	str	r3, [sp, #40]	; 0x28
    12b6:	e7f6      	b.n	12a6 <_printk_dec_ulong+0x12>
			out((int)(remainder / pos + 48), ctx);
    12b8:	fbb5 f0f4 	udiv	r0, r5, r4
    12bc:	4651      	mov	r1, sl
    12be:	3030      	adds	r0, #48	; 0x30
    12c0:	47c8      	blx	r9
			digits++;
    12c2:	f108 0801 	add.w	r8, r8, #1
			found_largest_digit = 1;
    12c6:	2701      	movs	r7, #1
		} else if (remaining <= min_width
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
    12c8:	3e01      	subs	r6, #1
		remainder %= pos;
    12ca:	fbb5 f3f4 	udiv	r3, r5, r4
    12ce:	fb04 5513 	mls	r5, r4, r3, r5
		pos /= 10;
    12d2:	4b19      	ldr	r3, [pc, #100]	; (1338 <_printk_dec_ulong+0xa4>)
    12d4:	fba3 3404 	umull	r3, r4, r3, r4
    12d8:	08e4      	lsrs	r4, r4, #3
	while (pos >= 10) {
    12da:	2c09      	cmp	r4, #9
    12dc:	d914      	bls.n	1308 <_printk_dec_ulong+0x74>
		if (found_largest_digit != 0 || remainder >= pos) {
    12de:	2f00      	cmp	r7, #0
    12e0:	d1ea      	bne.n	12b8 <_printk_dec_ulong+0x24>
    12e2:	42ac      	cmp	r4, r5
    12e4:	d9e8      	bls.n	12b8 <_printk_dec_ulong+0x24>
		} else if (remaining <= min_width
    12e6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    12e8:	429e      	cmp	r6, r3
    12ea:	dced      	bgt.n	12c8 <_printk_dec_ulong+0x34>
				&& padding < PAD_SPACE_AFTER) {
    12ec:	f1bb 0f02 	cmp.w	fp, #2
    12f0:	d8ea      	bhi.n	12c8 <_printk_dec_ulong+0x34>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    12f2:	f1bb 0f01 	cmp.w	fp, #1
    12f6:	d005      	beq.n	1304 <_printk_dec_ulong+0x70>
    12f8:	2020      	movs	r0, #32
    12fa:	4651      	mov	r1, sl
    12fc:	47c8      	blx	r9
			digits++;
    12fe:	f108 0801 	add.w	r8, r8, #1
    1302:	e7e1      	b.n	12c8 <_printk_dec_ulong+0x34>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    1304:	2030      	movs	r0, #48	; 0x30
    1306:	e7f8      	b.n	12fa <_printk_dec_ulong+0x66>
	}
	out((int)(remainder + 48), ctx);
    1308:	4651      	mov	r1, sl
    130a:	f105 0030 	add.w	r0, r5, #48	; 0x30
    130e:	47c8      	blx	r9

	if (padding == PAD_SPACE_AFTER) {
    1310:	f1bb 0f03 	cmp.w	fp, #3
    1314:	d001      	beq.n	131a <_printk_dec_ulong+0x86>
		remaining = min_width - digits;
		while (remaining-- > 0) {
			out(' ', ctx);
		}
	}
}
    1316:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		remaining = min_width - digits;
    131a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    131c:	eba3 0808 	sub.w	r8, r3, r8
		while (remaining-- > 0) {
    1320:	f108 34ff 	add.w	r4, r8, #4294967295	; 0xffffffff
    1324:	f1b8 0f00 	cmp.w	r8, #0
    1328:	ddf5      	ble.n	1316 <_printk_dec_ulong+0x82>
			out(' ', ctx);
    132a:	4651      	mov	r1, sl
    132c:	2020      	movs	r0, #32
    132e:	47c8      	blx	r9
		while (remaining-- > 0) {
    1330:	46a0      	mov	r8, r4
    1332:	e7f5      	b.n	1320 <_printk_dec_ulong+0x8c>
    1334:	3b9aca00 	.word	0x3b9aca00
    1338:	cccccccd 	.word	0xcccccccd

0000133c <__printk_hook_install>:
	_char_out = fn;
    133c:	4b01      	ldr	r3, [pc, #4]	; (1344 <__printk_hook_install+0x8>)
    133e:	6018      	str	r0, [r3, #0]
}
    1340:	4770      	bx	lr
    1342:	bf00      	nop
    1344:	200000f8 	.word	0x200000f8

00001348 <vprintk>:
{
    1348:	b500      	push	{lr}
    134a:	b083      	sub	sp, #12
    134c:	4602      	mov	r2, r0
    134e:	460b      	mov	r3, r1
	struct out_context ctx = { 0 };
    1350:	2100      	movs	r1, #0
    1352:	9101      	str	r1, [sp, #4]
	z_vprintk(char_out, &ctx, fmt, ap);
    1354:	a901      	add	r1, sp, #4
    1356:	4803      	ldr	r0, [pc, #12]	; (1364 <vprintk+0x1c>)
    1358:	f00b fcca 	bl	ccf0 <z_vprintk>
}
    135c:	b003      	add	sp, #12
    135e:	f85d fb04 	ldr.w	pc, [sp], #4
    1362:	bf00      	nop
    1364:	00001281 	.word	0x00001281

00001368 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
    1368:	b510      	push	{r4, lr}
    136a:	b084      	sub	sp, #16
    136c:	4604      	mov	r4, r0
	struct str_context ctx = { str, size, 0 };
    136e:	9001      	str	r0, [sp, #4]
    1370:	9102      	str	r1, [sp, #8]
    1372:	2100      	movs	r1, #0
    1374:	9103      	str	r1, [sp, #12]

	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    1376:	a901      	add	r1, sp, #4
    1378:	4805      	ldr	r0, [pc, #20]	; (1390 <vsnprintk+0x28>)
    137a:	f00b fcb9 	bl	ccf0 <z_vprintk>

	if (ctx.count < ctx.max) {
    137e:	9b03      	ldr	r3, [sp, #12]
    1380:	9a02      	ldr	r2, [sp, #8]
    1382:	4293      	cmp	r3, r2
    1384:	da01      	bge.n	138a <vsnprintk+0x22>
		str[ctx.count] = '\0';
    1386:	2200      	movs	r2, #0
    1388:	54e2      	strb	r2, [r4, r3]
	}

	return ctx.count;
}
    138a:	9803      	ldr	r0, [sp, #12]
    138c:	b004      	add	sp, #16
    138e:	bd10      	pop	{r4, pc}
    1390:	0000ccc1 	.word	0x0000ccc1

00001394 <is_rodata>:
#else
	#define RO_START 0
	#define RO_END 0
#endif

	return (((const char *)addr >= (const char *)RO_START) &&
    1394:	4b05      	ldr	r3, [pc, #20]	; (13ac <is_rodata+0x18>)
    1396:	4298      	cmp	r0, r3
    1398:	d304      	bcc.n	13a4 <is_rodata+0x10>
    139a:	4b05      	ldr	r3, [pc, #20]	; (13b0 <is_rodata+0x1c>)
    139c:	4298      	cmp	r0, r3
    139e:	d303      	bcc.n	13a8 <is_rodata+0x14>
    13a0:	2000      	movs	r0, #0
    13a2:	4770      	bx	lr
    13a4:	2000      	movs	r0, #0
    13a6:	4770      	bx	lr
    13a8:	2001      	movs	r0, #1
		((const char *)addr < (const char *)RO_END));
}
    13aa:	4770      	bx	lr
    13ac:	00010a18 	.word	0x00010a18
    13b0:	000132a4 	.word	0x000132a4

000013b4 <thread_set>:
		}
	}
}

static void thread_set(k_tid_t process_tid)
{
    13b4:	b508      	push	{r3, lr}
	proc_tid = process_tid;
    13b6:	4b06      	ldr	r3, [pc, #24]	; (13d0 <thread_set+0x1c>)
    13b8:	6018      	str	r0, [r3, #0]

	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE)) {
		return;
	}

	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    13ba:	b118      	cbz	r0, 13c4 <thread_set+0x10>
	    process_tid &&
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
    13bc:	4b05      	ldr	r3, [pc, #20]	; (13d4 <thread_set+0x20>)
    13be:	681b      	ldr	r3, [r3, #0]
	    process_tid &&
    13c0:	2b09      	cmp	r3, #9
    13c2:	dc00      	bgt.n	13c6 <thread_set+0x12>
		k_sem_give(&log_process_thread_sem);
	}
}
    13c4:	bd08      	pop	{r3, pc}
	z_impl_k_sem_give(sem);
    13c6:	4804      	ldr	r0, [pc, #16]	; (13d8 <thread_set+0x24>)
    13c8:	f009 ff98 	bl	b2fc <z_impl_k_sem_give>
}
    13cc:	e7fa      	b.n	13c4 <thread_set+0x10>
    13ce:	bf00      	nop
    13d0:	2000385c 	.word	0x2000385c
    13d4:	200037b8 	.word	0x200037b8
    13d8:	20000450 	.word	0x20000450

000013dc <log_process_thread_timer_expiry_fn>:
	__ASSERT_NO_MSG(false);
}
#endif /* !defined(CONFIG_USERSPACE) */

static void log_process_thread_timer_expiry_fn(struct k_timer *timer)
{
    13dc:	b508      	push	{r3, lr}
	z_impl_k_sem_give(sem);
    13de:	4802      	ldr	r0, [pc, #8]	; (13e8 <log_process_thread_timer_expiry_fn+0xc>)
    13e0:	f009 ff8c 	bl	b2fc <z_impl_k_sem_give>
	k_sem_give(&log_process_thread_sem);
}
    13e4:	bd08      	pop	{r3, pc}
    13e6:	bf00      	nop
    13e8:	20000450 	.word	0x20000450

000013ec <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
    13ec:	b530      	push	{r4, r5, lr}
    13ee:	b089      	sub	sp, #36	; 0x24
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
    13f0:	2200      	movs	r2, #0
    13f2:	490f      	ldr	r1, [pc, #60]	; (1430 <enable_logger+0x44>)
    13f4:	480f      	ldr	r0, [pc, #60]	; (1434 <enable_logger+0x48>)
    13f6:	f00f f83f 	bl	10478 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    13fa:	4d0f      	ldr	r5, [pc, #60]	; (1438 <enable_logger+0x4c>)
    13fc:	2200      	movs	r2, #0
    13fe:	2300      	movs	r3, #0
    1400:	e9cd 2306 	strd	r2, r3, [sp, #24]
    1404:	2400      	movs	r4, #0
    1406:	9404      	str	r4, [sp, #16]
    1408:	230e      	movs	r3, #14
    140a:	9303      	str	r3, [sp, #12]
    140c:	9402      	str	r4, [sp, #8]
    140e:	9401      	str	r4, [sp, #4]
    1410:	9400      	str	r4, [sp, #0]
    1412:	4b0a      	ldr	r3, [pc, #40]	; (143c <enable_logger+0x50>)
    1414:	f44f 7240 	mov.w	r2, #768	; 0x300
    1418:	4909      	ldr	r1, [pc, #36]	; (1440 <enable_logger+0x54>)
    141a:	4628      	mov	r0, r5
    141c:	f00e ff67 	bl	102ee <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    1420:	4908      	ldr	r1, [pc, #32]	; (1444 <enable_logger+0x58>)
    1422:	4628      	mov	r0, r5
    1424:	f00e ff52 	bl	102cc <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
    1428:	4620      	mov	r0, r4
    142a:	b009      	add	sp, #36	; 0x24
    142c:	bd30      	pop	{r4, r5, pc}
    142e:	bf00      	nop
    1430:	000013dd 	.word	0x000013dd
    1434:	20000578 	.word	0x20000578
    1438:	200037e8 	.word	0x200037e8
    143c:	00001991 	.word	0x00001991
    1440:	20005960 	.word	0x20005960
    1444:	000114b0 	.word	0x000114b0

00001448 <z_log_get_s_mask>:
{
    1448:	b470      	push	{r4, r5, r6}
    144a:	4603      	mov	r3, r0
	u32_t mask = 0;
    144c:	2000      	movs	r0, #0
	u32_t arg = 0;
    144e:	4605      	mov	r5, r0
	bool arm = false;
    1450:	4604      	mov	r4, r0
	while ((curr = *str++) && arg < nargs) {
    1452:	e001      	b.n	1458 <z_log_get_s_mask+0x10>
			arm = !arm;
    1454:	f084 0401 	eor.w	r4, r4, #1
	while ((curr = *str++) && arg < nargs) {
    1458:	f813 2b01 	ldrb.w	r2, [r3], #1
    145c:	b19a      	cbz	r2, 1486 <z_log_get_s_mask+0x3e>
    145e:	428d      	cmp	r5, r1
    1460:	d211      	bcs.n	1486 <z_log_get_s_mask+0x3e>
		if (curr == '%') {
    1462:	2a25      	cmp	r2, #37	; 0x25
    1464:	d0f6      	beq.n	1454 <z_log_get_s_mask+0xc>
		} else if (arm && isalpha((int)curr)) {
    1466:	2c00      	cmp	r4, #0
    1468:	d0f6      	beq.n	1458 <z_log_get_s_mask+0x10>
    146a:	4e08      	ldr	r6, [pc, #32]	; (148c <z_log_get_s_mask+0x44>)
    146c:	5d96      	ldrb	r6, [r2, r6]
    146e:	f016 0f03 	tst.w	r6, #3
    1472:	d0f1      	beq.n	1458 <z_log_get_s_mask+0x10>
			if (curr == 's') {
    1474:	2a73      	cmp	r2, #115	; 0x73
    1476:	d002      	beq.n	147e <z_log_get_s_mask+0x36>
			arg++;
    1478:	3501      	adds	r5, #1
			arm = false;
    147a:	2400      	movs	r4, #0
    147c:	e7ec      	b.n	1458 <z_log_get_s_mask+0x10>
				mask |= BIT(arg);
    147e:	2201      	movs	r2, #1
    1480:	40aa      	lsls	r2, r5
    1482:	4310      	orrs	r0, r2
    1484:	e7f8      	b.n	1478 <z_log_get_s_mask+0x30>
}
    1486:	bc70      	pop	{r4, r5, r6}
    1488:	4770      	bx	lr
    148a:	bf00      	nop
    148c:	00013171 	.word	0x00013171

00001490 <log_core_init>:
{
    1490:	b508      	push	{r3, lr}
		log_msg_pool_init();
    1492:	f000 fca9 	bl	1de8 <log_msg_pool_init>
		log_list_init(&list);
    1496:	4808      	ldr	r0, [pc, #32]	; (14b8 <log_core_init+0x28>)
    1498:	f00c f8d0 	bl	d63c <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
    149c:	2304      	movs	r3, #4
    149e:	2228      	movs	r2, #40	; 0x28
    14a0:	4906      	ldr	r1, [pc, #24]	; (14bc <log_core_init+0x2c>)
    14a2:	4807      	ldr	r0, [pc, #28]	; (14c0 <log_core_init+0x30>)
    14a4:	f00e fc39 	bl	fd1a <k_mem_slab_init>
		timestamp_func = k_cycle_get_32_wrapper;
    14a8:	4b06      	ldr	r3, [pc, #24]	; (14c4 <log_core_init+0x34>)
    14aa:	4a07      	ldr	r2, [pc, #28]	; (14c8 <log_core_init+0x38>)
    14ac:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
    14ae:	f44f 4000 	mov.w	r0, #32768	; 0x8000
    14b2:	f000 feaf 	bl	2214 <log_output_timestamp_freq_set>
}
    14b6:	bd08      	pop	{r3, pc}
    14b8:	200037c4 	.word	0x200037c4
    14bc:	20007de0 	.word	0x20007de0
    14c0:	200037cc 	.word	0x200037cc
    14c4:	200000fc 	.word	0x200000fc
    14c8:	0000d671 	.word	0x0000d671

000014cc <dropped_notify>:
{
    14cc:	b538      	push	{r3, r4, r5, lr}
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    14ce:	4b12      	ldr	r3, [pc, #72]	; (1518 <dropped_notify+0x4c>)
    14d0:	2400      	movs	r4, #0
    14d2:	f3bf 8f5b 	dmb	ish
    14d6:	e853 5f00 	ldrex	r5, [r3]
    14da:	e843 4200 	strex	r2, r4, [r3]
    14de:	2a00      	cmp	r2, #0
    14e0:	d1f9      	bne.n	14d6 <dropped_notify+0xa>
    14e2:	f3bf 8f5b 	dmb	ish
	for (int i = 0; i < log_backend_count_get(); i++) {
    14e6:	e000      	b.n	14ea <dropped_notify+0x1e>
    14e8:	3401      	adds	r4, #1
    14ea:	4b0c      	ldr	r3, [pc, #48]	; (151c <dropped_notify+0x50>)
    14ec:	4a0c      	ldr	r2, [pc, #48]	; (1520 <dropped_notify+0x54>)
    14ee:	1a9b      	subs	r3, r3, r2
    14f0:	ebb4 1f23 	cmp.w	r4, r3, asr #4
    14f4:	da0f      	bge.n	1516 <dropped_notify+0x4a>
 *
 * @return    Pointer to the backend instance.
 */
static inline const struct log_backend *log_backend_get(u32_t idx)
{
	return &__log_backends_start[idx];
    14f6:	480a      	ldr	r0, [pc, #40]	; (1520 <dropped_notify+0x54>)
    14f8:	eb00 1004 	add.w	r0, r0, r4, lsl #4
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
    14fc:	6843      	ldr	r3, [r0, #4]
    14fe:	795b      	ldrb	r3, [r3, #5]
		if (log_backend_is_active(backend)) {
    1500:	2b00      	cmp	r3, #0
    1502:	d0f1      	beq.n	14e8 <dropped_notify+0x1c>
	if (backend->api->dropped != NULL) {
    1504:	0123      	lsls	r3, r4, #4
    1506:	4a06      	ldr	r2, [pc, #24]	; (1520 <dropped_notify+0x54>)
    1508:	58d3      	ldr	r3, [r2, r3]
    150a:	68db      	ldr	r3, [r3, #12]
    150c:	2b00      	cmp	r3, #0
    150e:	d0eb      	beq.n	14e8 <dropped_notify+0x1c>
		backend->api->dropped(backend, cnt);
    1510:	4629      	mov	r1, r5
    1512:	4798      	blx	r3
    1514:	e7e8      	b.n	14e8 <dropped_notify+0x1c>
}
    1516:	bd38      	pop	{r3, r4, r5, pc}
    1518:	200037bc 	.word	0x200037bc
    151c:	00010cf8 	.word	0x00010cf8
    1520:	00010cd8 	.word	0x00010cd8

00001524 <log_dropped>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    1524:	4b06      	ldr	r3, [pc, #24]	; (1540 <log_dropped+0x1c>)
    1526:	f3bf 8f5b 	dmb	ish
    152a:	e853 2f00 	ldrex	r2, [r3]
    152e:	3201      	adds	r2, #1
    1530:	e843 2100 	strex	r1, r2, [r3]
    1534:	2900      	cmp	r1, #0
    1536:	d1f8      	bne.n	152a <log_dropped+0x6>
    1538:	f3bf 8f5b 	dmb	ish
}
    153c:	4770      	bx	lr
    153e:	bf00      	nop
    1540:	200037bc 	.word	0x200037bc

00001544 <log_source_name_get>:
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
    1544:	4b05      	ldr	r3, [pc, #20]	; (155c <log_source_name_get+0x18>)
    1546:	4a06      	ldr	r2, [pc, #24]	; (1560 <log_source_name_get+0x1c>)
    1548:	1a9b      	subs	r3, r3, r2
    154a:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
    154e:	d202      	bcs.n	1556 <log_source_name_get+0x12>
 * @param source_id Source ID.
 * @return Name.
 */
static inline const char *log_name_get(u32_t source_id)
{
	return __log_const_start[source_id].name;
    1550:	f852 0031 	ldr.w	r0, [r2, r1, lsl #3]
    1554:	4770      	bx	lr
    1556:	2000      	movs	r0, #0
}
    1558:	4770      	bx	lr
    155a:	bf00      	nop
    155c:	00010cd8 	.word	0x00010cd8
    1560:	00010c18 	.word	0x00010c18

00001564 <log_backend_enable>:
{
    1564:	b508      	push	{r3, lr}
	id += backend - log_backend_get(0);
    1566:	4b0b      	ldr	r3, [pc, #44]	; (1594 <log_backend_enable+0x30>)
    1568:	1ac3      	subs	r3, r0, r3
    156a:	111b      	asrs	r3, r3, #4
    156c:	3301      	adds	r3, #1
	backend->cb->id = id;
    156e:	6842      	ldr	r2, [r0, #4]
    1570:	7113      	strb	r3, [r2, #4]
	backend->cb->ctx = ctx;
    1572:	6843      	ldr	r3, [r0, #4]
    1574:	6019      	str	r1, [r3, #0]
	backend->cb->active = true;
    1576:	6843      	ldr	r3, [r0, #4]
    1578:	2201      	movs	r2, #1
    157a:	715a      	strb	r2, [r3, #5]
	if (!backend_attached) {
    157c:	4b06      	ldr	r3, [pc, #24]	; (1598 <log_backend_enable+0x34>)
    157e:	781b      	ldrb	r3, [r3, #0]
    1580:	b11b      	cbz	r3, 158a <log_backend_enable+0x26>
	backend_attached = true;
    1582:	4b05      	ldr	r3, [pc, #20]	; (1598 <log_backend_enable+0x34>)
    1584:	2201      	movs	r2, #1
    1586:	701a      	strb	r2, [r3, #0]
}
    1588:	bd08      	pop	{r3, pc}
	z_impl_k_sem_give(sem);
    158a:	4804      	ldr	r0, [pc, #16]	; (159c <log_backend_enable+0x38>)
    158c:	f009 feb6 	bl	b2fc <z_impl_k_sem_give>
}
    1590:	e7f7      	b.n	1582 <log_backend_enable+0x1e>
    1592:	bf00      	nop
    1594:	00010cd8 	.word	0x00010cd8
    1598:	2000594a 	.word	0x2000594a
    159c:	20000450 	.word	0x20000450

000015a0 <log_init>:
{
    15a0:	b570      	push	{r4, r5, r6, lr}
	return __log_backends_end - __log_backends_start;
    15a2:	4b19      	ldr	r3, [pc, #100]	; (1608 <log_init+0x68>)
    15a4:	4a19      	ldr	r2, [pc, #100]	; (160c <log_init+0x6c>)
    15a6:	1a9b      	subs	r3, r3, r2
	assert(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
    15a8:	2b9f      	cmp	r3, #159	; 0x9f
    15aa:	d80f      	bhi.n	15cc <log_init+0x2c>
    15ac:	111e      	asrs	r6, r3, #4
    15ae:	4b18      	ldr	r3, [pc, #96]	; (1610 <log_init+0x70>)
    15b0:	f3bf 8f5b 	dmb	ish
    15b4:	e853 2f00 	ldrex	r2, [r3]
    15b8:	1c51      	adds	r1, r2, #1
    15ba:	e843 1000 	strex	r0, r1, [r3]
    15be:	2800      	cmp	r0, #0
    15c0:	d1f8      	bne.n	15b4 <log_init+0x14>
    15c2:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&initialized) != 0) {
    15c6:	b9f2      	cbnz	r2, 1606 <log_init+0x66>
	for (i = 0; i < log_backend_count_get(); i++) {
    15c8:	2400      	movs	r4, #0
    15ca:	e00c      	b.n	15e6 <log_init+0x46>
	assert(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
    15cc:	4b11      	ldr	r3, [pc, #68]	; (1614 <log_init+0x74>)
    15ce:	4a12      	ldr	r2, [pc, #72]	; (1618 <log_init+0x78>)
    15d0:	f44f 71f9 	mov.w	r1, #498	; 0x1f2
    15d4:	4811      	ldr	r0, [pc, #68]	; (161c <log_init+0x7c>)
    15d6:	f00a fb69 	bl	bcac <__assert_func>
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
    15da:	2204      	movs	r2, #4
    15dc:	2100      	movs	r1, #0
    15de:	4628      	mov	r0, r5
    15e0:	f7ff ffc0 	bl	1564 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
    15e4:	3401      	adds	r4, #1
    15e6:	42b4      	cmp	r4, r6
    15e8:	da0d      	bge.n	1606 <log_init+0x66>
	return &__log_backends_start[idx];
    15ea:	4d08      	ldr	r5, [pc, #32]	; (160c <log_init+0x6c>)
    15ec:	eb05 1504 	add.w	r5, r5, r4, lsl #4
		if (backend->autostart) {
    15f0:	7b2b      	ldrb	r3, [r5, #12]
    15f2:	2b00      	cmp	r3, #0
    15f4:	d0f6      	beq.n	15e4 <log_init+0x44>
			if (backend->api->init != NULL) {
    15f6:	0123      	lsls	r3, r4, #4
    15f8:	4a04      	ldr	r2, [pc, #16]	; (160c <log_init+0x6c>)
    15fa:	58d3      	ldr	r3, [r2, r3]
    15fc:	695b      	ldr	r3, [r3, #20]
    15fe:	2b00      	cmp	r3, #0
    1600:	d0eb      	beq.n	15da <log_init+0x3a>
				backend->api->init();
    1602:	4798      	blx	r3
    1604:	e7e9      	b.n	15da <log_init+0x3a>
}
    1606:	bd70      	pop	{r4, r5, r6, pc}
    1608:	00010cf8 	.word	0x00010cf8
    160c:	00010cd8 	.word	0x00010cd8
    1610:	200037c0 	.word	0x200037c0
    1614:	00011520 	.word	0x00011520
    1618:	000115b4 	.word	0x000115b4
    161c:	000114b8 	.word	0x000114b8

00001620 <log_strdup>:
{
    1620:	b570      	push	{r4, r5, r6, lr}
    1622:	b082      	sub	sp, #8
    1624:	4604      	mov	r4, r0
	    is_rodata(str) || _is_user_context()) {
    1626:	f7ff feb5 	bl	1394 <is_rodata>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
    162a:	bb10      	cbnz	r0, 1672 <log_strdup+0x52>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
    162c:	2200      	movs	r2, #0
    162e:	2300      	movs	r3, #0
    1630:	a901      	add	r1, sp, #4
    1632:	4811      	ldr	r0, [pc, #68]	; (1678 <log_strdup+0x58>)
    1634:	f009 f85c 	bl	a6f0 <k_mem_slab_alloc>
	if (err != 0) {
    1638:	b108      	cbz	r0, 163e <log_strdup+0x1e>
		return (char *)log_strdup_fail_msg;
    163a:	4c10      	ldr	r4, [pc, #64]	; (167c <log_strdup+0x5c>)
    163c:	e019      	b.n	1672 <log_strdup+0x52>
	(void)atomic_set(&dup->refcount, 1);
    163e:	9b01      	ldr	r3, [sp, #4]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    1640:	2201      	movs	r2, #1
    1642:	f3bf 8f5b 	dmb	ish
    1646:	e853 1f00 	ldrex	r1, [r3]
    164a:	e843 2000 	strex	r0, r2, [r3]
    164e:	2800      	cmp	r0, #0
    1650:	d1f9      	bne.n	1646 <log_strdup+0x26>
    1652:	f3bf 8f5b 	dmb	ish
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
    1656:	9d01      	ldr	r5, [sp, #4]
    1658:	1d2e      	adds	r6, r5, #4
#if __GNUC_PREREQ__(4,8) || defined(__clang__)
__ssp_bos_icheck3_restrict(stpncpy, char *, const char *)
#endif
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
__ssp_bos_icheck2_restrict(strcat, char *, const char *)
__ssp_bos_icheck3_restrict(strncpy, char *, const char *)
    165a:	221f      	movs	r2, #31
    165c:	4621      	mov	r1, r4
    165e:	4630      	mov	r0, r6
    1660:	f00f f849 	bl	106f6 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
    1664:	237e      	movs	r3, #126	; 0x7e
    1666:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
    166a:	2300      	movs	r3, #0
    166c:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
	return dup->buf;
    1670:	4634      	mov	r4, r6
}
    1672:	4620      	mov	r0, r4
    1674:	b002      	add	sp, #8
    1676:	bd70      	pop	{r4, r5, r6, pc}
    1678:	200037cc 	.word	0x200037cc
    167c:	00011554 	.word	0x00011554

00001680 <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (u8_t *)buf);
    1680:	b138      	cbz	r0, 1692 <log_is_strdup+0x12>
    1682:	4a07      	ldr	r2, [pc, #28]	; (16a0 <log_is_strdup+0x20>)
    1684:	4290      	cmp	r0, r2
    1686:	d306      	bcc.n	1696 <log_is_strdup+0x16>
    1688:	32a0      	adds	r2, #160	; 0xa0
    168a:	4290      	cmp	r0, r2
    168c:	d305      	bcc.n	169a <log_is_strdup+0x1a>
    168e:	2000      	movs	r0, #0
    1690:	4770      	bx	lr
    1692:	2000      	movs	r0, #0
    1694:	4770      	bx	lr
    1696:	2000      	movs	r0, #0
    1698:	4770      	bx	lr
    169a:	2001      	movs	r0, #1
}
    169c:	4770      	bx	lr
    169e:	bf00      	nop
    16a0:	20007de0 	.word	0x20007de0

000016a4 <detect_missed_strdup>:
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    16a4:	7a03      	ldrb	r3, [r0, #8]
	if (!log_msg_is_std(msg)) {
    16a6:	f013 0f01 	tst.w	r3, #1
    16aa:	d000      	beq.n	16ae <detect_missed_strdup+0xa>
    16ac:	4770      	bx	lr
{
    16ae:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    16b2:	b083      	sub	sp, #12
    16b4:	4606      	mov	r6, r0
	msg_str = log_msg_str_get(msg);
    16b6:	f00c f898 	bl	d7ea <log_msg_str_get>
    16ba:	4607      	mov	r7, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    16bc:	4630      	mov	r0, r6
    16be:	f00c f87f 	bl	d7c0 <log_msg_nargs_get>
    16c2:	4601      	mov	r1, r0
    16c4:	4638      	mov	r0, r7
    16c6:	f7ff febf 	bl	1448 <z_log_get_s_mask>
    16ca:	4605      	mov	r5, r0
	while (mask) {
    16cc:	e004      	b.n	16d8 <detect_missed_strdup+0x34>
		mask &= ~BIT(idx);
    16ce:	2301      	movs	r3, #1
    16d0:	fa03 f404 	lsl.w	r4, r3, r4
    16d4:	ea25 0504 	bic.w	r5, r5, r4
	while (mask) {
    16d8:	b36d      	cbz	r5, 1736 <detect_missed_strdup+0x92>
		idx = 31 - __builtin_clz(mask);
    16da:	fab5 f485 	clz	r4, r5
    16de:	f1c4 041f 	rsb	r4, r4, #31
		str = (const char *)log_msg_arg_get(msg, idx);
    16e2:	4621      	mov	r1, r4
    16e4:	4630      	mov	r0, r6
    16e6:	f00c f86e 	bl	d7c6 <log_msg_arg_get>
    16ea:	4681      	mov	r9, r0
		if (!is_rodata(str) && !log_is_strdup(str) &&
    16ec:	f7ff fe52 	bl	1394 <is_rodata>
    16f0:	2800      	cmp	r0, #0
    16f2:	d1ec      	bne.n	16ce <detect_missed_strdup+0x2a>
    16f4:	4648      	mov	r0, r9
    16f6:	f7ff ffc3 	bl	1680 <log_is_strdup>
    16fa:	2800      	cmp	r0, #0
    16fc:	d1e7      	bne.n	16ce <detect_missed_strdup+0x2a>
    16fe:	4b0f      	ldr	r3, [pc, #60]	; (173c <detect_missed_strdup+0x98>)
    1700:	4599      	cmp	r9, r3
    1702:	d0e4      	beq.n	16ce <detect_missed_strdup+0x2a>
	return msg->hdr.ids.source_id;
    1704:	8971      	ldrh	r1, [r6, #10]
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
    1706:	0989      	lsrs	r1, r1, #6
    1708:	f7ff ff1c 	bl	1544 <log_source_name_get>
    170c:	4602      	mov	r2, r0
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
    170e:	2301      	movs	r3, #1
    1710:	f363 0802 	bfi	r8, r3, #0, #3
    1714:	f36f 08c5 	bfc	r8, #3, #3
    1718:	4b09      	ldr	r3, [pc, #36]	; (1740 <detect_missed_strdup+0x9c>)
    171a:	490a      	ldr	r1, [pc, #40]	; (1744 <detect_missed_strdup+0xa0>)
    171c:	1a5b      	subs	r3, r3, r1
    171e:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    1722:	f363 188f 	bfi	r8, r3, #6, #10
    1726:	f8ad 8000 	strh.w	r8, [sp]
    172a:	463b      	mov	r3, r7
    172c:	4621      	mov	r1, r4
    172e:	4806      	ldr	r0, [pc, #24]	; (1748 <detect_missed_strdup+0xa4>)
    1730:	f000 f87a 	bl	1828 <log_3>
    1734:	e7cb      	b.n	16ce <detect_missed_strdup+0x2a>
}
    1736:	b003      	add	sp, #12
    1738:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    173c:	00011554 	.word	0x00011554
    1740:	00010ca0 	.word	0x00010ca0
    1744:	00010c18 	.word	0x00010c18
    1748:	00011570 	.word	0x00011570

0000174c <msg_process>:
{
    174c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    174e:	4606      	mov	r6, r0
	if (!bypass) {
    1750:	bb19      	cbnz	r1, 179a <msg_process+0x4e>
		    !panic_mode) {
    1752:	4b14      	ldr	r3, [pc, #80]	; (17a4 <msg_process+0x58>)
    1754:	781b      	ldrb	r3, [r3, #0]
		if (IS_ENABLED(CONFIG_LOG_DETECT_MISSED_STRDUP) &&
    1756:	b10b      	cbz	r3, 175c <msg_process+0x10>
{
    1758:	2400      	movs	r4, #0
    175a:	e003      	b.n	1764 <msg_process+0x18>
			detect_missed_strdup(msg);
    175c:	f7ff ffa2 	bl	16a4 <detect_missed_strdup>
    1760:	e7fa      	b.n	1758 <msg_process+0xc>
		for (int i = 0; i < log_backend_count_get(); i++) {
    1762:	3401      	adds	r4, #1
    1764:	4b10      	ldr	r3, [pc, #64]	; (17a8 <msg_process+0x5c>)
    1766:	4a11      	ldr	r2, [pc, #68]	; (17ac <msg_process+0x60>)
    1768:	1a9b      	subs	r3, r3, r2
    176a:	ebb4 1f23 	cmp.w	r4, r3, asr #4
    176e:	da14      	bge.n	179a <msg_process+0x4e>
    1770:	4d0e      	ldr	r5, [pc, #56]	; (17ac <msg_process+0x60>)
    1772:	eb05 1504 	add.w	r5, r5, r4, lsl #4
	return backend->cb->active;
    1776:	686b      	ldr	r3, [r5, #4]
    1778:	795b      	ldrb	r3, [r3, #5]
			if (log_backend_is_active(backend) &&
    177a:	2b00      	cmp	r3, #0
    177c:	d0f1      	beq.n	1762 <msg_process+0x16>
			    msg_filter_check(backend, msg)) {
    177e:	4631      	mov	r1, r6
    1780:	4628      	mov	r0, r5
    1782:	f00b ff73 	bl	d66c <msg_filter_check>
			if (log_backend_is_active(backend) &&
    1786:	2800      	cmp	r0, #0
    1788:	d0eb      	beq.n	1762 <msg_process+0x16>
	backend->api->put(backend, msg);
    178a:	0127      	lsls	r7, r4, #4
    178c:	4b07      	ldr	r3, [pc, #28]	; (17ac <msg_process+0x60>)
    178e:	59db      	ldr	r3, [r3, r7]
    1790:	681b      	ldr	r3, [r3, #0]
    1792:	4631      	mov	r1, r6
    1794:	4628      	mov	r0, r5
    1796:	4798      	blx	r3
}
    1798:	e7e3      	b.n	1762 <msg_process+0x16>
	log_msg_put(msg);
    179a:	4630      	mov	r0, r6
    179c:	f00c f827 	bl	d7ee <log_msg_put>
}
    17a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    17a2:	bf00      	nop
    17a4:	2000594b 	.word	0x2000594b
    17a8:	00010cf8 	.word	0x00010cf8
    17ac:	00010cd8 	.word	0x00010cd8

000017b0 <z_impl_log_process>:
{
    17b0:	b538      	push	{r3, r4, r5, lr}
    17b2:	4604      	mov	r4, r0
	if (!backend_attached && !bypass) {
    17b4:	4b18      	ldr	r3, [pc, #96]	; (1818 <z_impl_log_process+0x68>)
    17b6:	781b      	ldrb	r3, [r3, #0]
    17b8:	b903      	cbnz	r3, 17bc <z_impl_log_process+0xc>
    17ba:	b340      	cbz	r0, 180e <z_impl_log_process+0x5e>
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
    17bc:	f04f 0320 	mov.w	r3, #32
    17c0:	f3ef 8511 	mrs	r5, BASEPRI
    17c4:	f383 8811 	msr	BASEPRI, r3
    17c8:	f3bf 8f6f 	isb	sy
	msg = log_list_head_get(&list);
    17cc:	4813      	ldr	r0, [pc, #76]	; (181c <z_impl_log_process+0x6c>)
    17ce:	f00b ff45 	bl	d65c <log_list_head_get>
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
    17d2:	f385 8811 	msr	BASEPRI, r5
    17d6:	f3bf 8f6f 	isb	sy
	if (msg != NULL) {
    17da:	b170      	cbz	r0, 17fa <z_impl_log_process+0x4a>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    17dc:	4b10      	ldr	r3, [pc, #64]	; (1820 <z_impl_log_process+0x70>)
    17de:	f3bf 8f5b 	dmb	ish
    17e2:	e853 2f00 	ldrex	r2, [r3]
    17e6:	3a01      	subs	r2, #1
    17e8:	e843 2100 	strex	r1, r2, [r3]
    17ec:	2900      	cmp	r1, #0
    17ee:	d1f8      	bne.n	17e2 <z_impl_log_process+0x32>
    17f0:	f3bf 8f5b 	dmb	ish
		msg_process(msg, bypass);
    17f4:	4621      	mov	r1, r4
    17f6:	f7ff ffa9 	bl	174c <msg_process>
	if (!bypass && dropped_cnt) {
    17fa:	b914      	cbnz	r4, 1802 <z_impl_log_process+0x52>
    17fc:	4b09      	ldr	r3, [pc, #36]	; (1824 <z_impl_log_process+0x74>)
    17fe:	681b      	ldr	r3, [r3, #0]
    1800:	b933      	cbnz	r3, 1810 <z_impl_log_process+0x60>
	return (log_list_head_peek(&list) != NULL);
    1802:	4806      	ldr	r0, [pc, #24]	; (181c <z_impl_log_process+0x6c>)
    1804:	f00b ff28 	bl	d658 <log_list_head_peek>
    1808:	3800      	subs	r0, #0
    180a:	bf18      	it	ne
    180c:	2001      	movne	r0, #1
}
    180e:	bd38      	pop	{r3, r4, r5, pc}
		dropped_notify();
    1810:	f7ff fe5c 	bl	14cc <dropped_notify>
    1814:	e7f5      	b.n	1802 <z_impl_log_process+0x52>
    1816:	bf00      	nop
    1818:	2000594a 	.word	0x2000594a
    181c:	200037c4 	.word	0x200037c4
    1820:	200037b8 	.word	0x200037b8
    1824:	200037bc 	.word	0x200037bc

00001828 <log_3>:
{
    1828:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    182c:	b082      	sub	sp, #8
    182e:	4680      	mov	r8, r0
    1830:	460f      	mov	r7, r1
    1832:	4616      	mov	r6, r2
    1834:	461d      	mov	r5, r3
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    1836:	f000 fafb 	bl	1e30 <log_msg_chunk_alloc>

	if (msg != NULL) {
    183a:	4604      	mov	r4, r0
    183c:	b140      	cbz	r0, 1850 <log_3+0x28>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
    183e:	2301      	movs	r3, #1
    1840:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
    1842:	2200      	movs	r2, #0
    1844:	8102      	strh	r2, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
    1846:	f04f 0300 	mov.w	r3, #0
    184a:	f362 0300 	bfi	r3, r2, #0, #1
    184e:	7203      	strb	r3, [r0, #8]
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();

	if (msg != NULL) {
    1850:	b14c      	cbz	r4, 1866 <log_3+0x3e>
		msg->str = str;
    1852:	f8c4 8010 	str.w	r8, [r4, #16]
		msg->hdr.params.std.nargs = 3U;
    1856:	7a63      	ldrb	r3, [r4, #9]
    1858:	2203      	movs	r2, #3
    185a:	f362 1307 	bfi	r3, r2, #4, #4
    185e:	7263      	strb	r3, [r4, #9]
		msg->payload.single.args[0] = arg1;
    1860:	6167      	str	r7, [r4, #20]
		msg->payload.single.args[1] = arg2;
    1862:	61a6      	str	r6, [r4, #24]
		msg->payload.single.args[2] = arg3;
    1864:	61e5      	str	r5, [r4, #28]
		if (msg == NULL) {
    1866:	2c00      	cmp	r4, #0
    1868:	d030      	beq.n	18cc <log_3+0xa4>
	msg->hdr.ids = src_level;
    186a:	f8bd 3020 	ldrh.w	r3, [sp, #32]
    186e:	8163      	strh	r3, [r4, #10]
	msg->hdr.timestamp = timestamp_func();
    1870:	4b2a      	ldr	r3, [pc, #168]	; (191c <log_3+0xf4>)
    1872:	681b      	ldr	r3, [r3, #0]
    1874:	4798      	blx	r3
    1876:	60e0      	str	r0, [r4, #12]
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    1878:	4b29      	ldr	r3, [pc, #164]	; (1920 <log_3+0xf8>)
    187a:	f3bf 8f5b 	dmb	ish
    187e:	e853 2f00 	ldrex	r2, [r3]
    1882:	3201      	adds	r2, #1
    1884:	e843 2100 	strex	r1, r2, [r3]
    1888:	2900      	cmp	r1, #0
    188a:	d1f8      	bne.n	187e <log_3+0x56>
    188c:	f3bf 8f5b 	dmb	ish
	__asm__ volatile(
    1890:	f04f 0320 	mov.w	r3, #32
    1894:	f3ef 8511 	mrs	r5, BASEPRI
    1898:	f383 8811 	msr	BASEPRI, r3
    189c:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    18a0:	4621      	mov	r1, r4
    18a2:	4820      	ldr	r0, [pc, #128]	; (1924 <log_3+0xfc>)
    18a4:	f00b fece 	bl	d644 <log_list_add_tail>
	__asm__ volatile(
    18a8:	f385 8811 	msr	BASEPRI, r5
    18ac:	f3bf 8f6f 	isb	sy
	if (panic_mode) {
    18b0:	4b1d      	ldr	r3, [pc, #116]	; (1928 <log_3+0x100>)
    18b2:	781b      	ldrb	r3, [r3, #0]
    18b4:	b96b      	cbnz	r3, 18d2 <log_3+0xaa>
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    18b6:	4b1d      	ldr	r3, [pc, #116]	; (192c <log_3+0x104>)
    18b8:	681b      	ldr	r3, [r3, #0]
    18ba:	b11b      	cbz	r3, 18c4 <log_3+0x9c>
    18bc:	4a18      	ldr	r2, [pc, #96]	; (1920 <log_3+0xf8>)
    18be:	6812      	ldr	r2, [r2, #0]
    18c0:	2a01      	cmp	r2, #1
    18c2:	d016      	beq.n	18f2 <log_3+0xca>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    18c4:	4a16      	ldr	r2, [pc, #88]	; (1920 <log_3+0xf8>)
    18c6:	6812      	ldr	r2, [r2, #0]
    18c8:	2a0a      	cmp	r2, #10
    18ca:	d01d      	beq.n	1908 <log_3+0xe0>
}
    18cc:	b002      	add	sp, #8
    18ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__asm__ volatile(
    18d2:	f04f 0320 	mov.w	r3, #32
    18d6:	f3ef 8411 	mrs	r4, BASEPRI
    18da:	f383 8811 	msr	BASEPRI, r3
    18de:	f3bf 8f6f 	isb	sy
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
    18e2:	2000      	movs	r0, #0
    18e4:	f7ff ff64 	bl	17b0 <z_impl_log_process>
	__asm__ volatile(
    18e8:	f384 8811 	msr	BASEPRI, r4
    18ec:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
    18f0:	e7ec      	b.n	18cc <log_3+0xa4>
	z_impl_k_timer_start(timer, duration, period);
    18f2:	2200      	movs	r2, #0
    18f4:	2300      	movs	r3, #0
    18f6:	e9cd 2300 	strd	r2, r3, [sp]
    18fa:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    18fe:	2300      	movs	r3, #0
    1900:	480b      	ldr	r0, [pc, #44]	; (1930 <log_3+0x108>)
    1902:	f009 ff6b 	bl	b7dc <z_impl_k_timer_start>
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    1906:	e7e1      	b.n	18cc <log_3+0xa4>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    1908:	2b00      	cmp	r3, #0
    190a:	d0df      	beq.n	18cc <log_3+0xa4>
	z_impl_k_timer_stop(timer);
    190c:	4808      	ldr	r0, [pc, #32]	; (1930 <log_3+0x108>)
    190e:	f00e fdbf 	bl	10490 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
    1912:	4808      	ldr	r0, [pc, #32]	; (1934 <log_3+0x10c>)
    1914:	f009 fcf2 	bl	b2fc <z_impl_k_sem_give>
}
    1918:	e7d8      	b.n	18cc <log_3+0xa4>
    191a:	bf00      	nop
    191c:	200000fc 	.word	0x200000fc
    1920:	200037b8 	.word	0x200037b8
    1924:	200037c4 	.word	0x200037c4
    1928:	2000594b 	.word	0x2000594b
    192c:	2000385c 	.word	0x2000385c
    1930:	20000578 	.word	0x20000578
    1934:	20000450 	.word	0x20000450

00001938 <z_impl_log_panic>:
	if (panic_mode) {
    1938:	4b12      	ldr	r3, [pc, #72]	; (1984 <z_impl_log_panic+0x4c>)
    193a:	781b      	ldrb	r3, [r3, #0]
    193c:	b103      	cbz	r3, 1940 <z_impl_log_panic+0x8>
    193e:	4770      	bx	lr
{
    1940:	b510      	push	{r4, lr}
	log_init();
    1942:	f7ff fe2d 	bl	15a0 <log_init>
	for (int i = 0; i < log_backend_count_get(); i++) {
    1946:	2400      	movs	r4, #0
    1948:	e000      	b.n	194c <z_impl_log_panic+0x14>
    194a:	3401      	adds	r4, #1
    194c:	4b0e      	ldr	r3, [pc, #56]	; (1988 <z_impl_log_panic+0x50>)
    194e:	4a0f      	ldr	r2, [pc, #60]	; (198c <z_impl_log_panic+0x54>)
    1950:	1a9b      	subs	r3, r3, r2
    1952:	ebb4 1f23 	cmp.w	r4, r3, asr #4
    1956:	da0c      	bge.n	1972 <z_impl_log_panic+0x3a>
	return &__log_backends_start[idx];
    1958:	480c      	ldr	r0, [pc, #48]	; (198c <z_impl_log_panic+0x54>)
    195a:	eb00 1004 	add.w	r0, r0, r4, lsl #4
	return backend->cb->active;
    195e:	6843      	ldr	r3, [r0, #4]
    1960:	795b      	ldrb	r3, [r3, #5]
		if (log_backend_is_active(backend)) {
    1962:	2b00      	cmp	r3, #0
    1964:	d0f1      	beq.n	194a <z_impl_log_panic+0x12>
	backend->api->panic(backend);
    1966:	0123      	lsls	r3, r4, #4
    1968:	4a08      	ldr	r2, [pc, #32]	; (198c <z_impl_log_panic+0x54>)
    196a:	58d3      	ldr	r3, [r2, r3]
    196c:	691b      	ldr	r3, [r3, #16]
    196e:	4798      	blx	r3
}
    1970:	e7eb      	b.n	194a <z_impl_log_panic+0x12>
    1972:	2000      	movs	r0, #0
    1974:	f7ff ff1c 	bl	17b0 <z_impl_log_process>
		while (log_process(false) == true) {
    1978:	2800      	cmp	r0, #0
    197a:	d1fa      	bne.n	1972 <z_impl_log_panic+0x3a>
	panic_mode = true;
    197c:	4b01      	ldr	r3, [pc, #4]	; (1984 <z_impl_log_panic+0x4c>)
    197e:	2201      	movs	r2, #1
    1980:	701a      	strb	r2, [r3, #0]
}
    1982:	bd10      	pop	{r4, pc}
    1984:	2000594b 	.word	0x2000594b
    1988:	00010cf8 	.word	0x00010cf8
    198c:	00010cd8 	.word	0x00010cd8

00001990 <log_process_thread_func>:
{
    1990:	b508      	push	{r3, lr}
	log_init();
    1992:	f7ff fe05 	bl	15a0 <log_init>
	return z_impl_k_current_get();
    1996:	f009 fcab 	bl	b2f0 <z_impl_k_current_get>
	thread_set(k_current_get());
    199a:	f7ff fd0b 	bl	13b4 <thread_set>
    199e:	e006      	b.n	19ae <log_process_thread_func+0x1e>
	return z_impl_k_sem_take(sem, timeout);
    19a0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    19a4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    19a8:	4804      	ldr	r0, [pc, #16]	; (19bc <log_process_thread_func+0x2c>)
    19aa:	f009 fccf 	bl	b34c <z_impl_k_sem_take>
    19ae:	2000      	movs	r0, #0
    19b0:	f7ff fefe 	bl	17b0 <z_impl_log_process>
		if (log_process(false) == false) {
    19b4:	2800      	cmp	r0, #0
    19b6:	d1fa      	bne.n	19ae <log_process_thread_func+0x1e>
    19b8:	e7f2      	b.n	19a0 <log_process_thread_func+0x10>
    19ba:	bf00      	nop
    19bc:	20000450 	.word	0x20000450

000019c0 <log_1>:
{
    19c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    19c2:	b083      	sub	sp, #12
    19c4:	4606      	mov	r6, r0
    19c6:	460d      	mov	r5, r1
    19c8:	4617      	mov	r7, r2
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    19ca:	f000 fa31 	bl	1e30 <log_msg_chunk_alloc>
	if (msg != NULL) {
    19ce:	4604      	mov	r4, r0
    19d0:	b140      	cbz	r0, 19e4 <log_1+0x24>
		msg->hdr.ref_cnt = 1;
    19d2:	2301      	movs	r3, #1
    19d4:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
    19d6:	2100      	movs	r1, #0
    19d8:	8101      	strh	r1, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
    19da:	f04f 0300 	mov.w	r3, #0
    19de:	f361 0300 	bfi	r3, r1, #0, #1
    19e2:	7203      	strb	r3, [r0, #8]
	if (msg != NULL) {
    19e4:	b134      	cbz	r4, 19f4 <log_1+0x34>
		msg->str = str;
    19e6:	6126      	str	r6, [r4, #16]
		msg->hdr.params.std.nargs = 1U;
    19e8:	7a63      	ldrb	r3, [r4, #9]
    19ea:	2201      	movs	r2, #1
    19ec:	f362 1307 	bfi	r3, r2, #4, #4
    19f0:	7263      	strb	r3, [r4, #9]
		msg->payload.single.args[0] = arg1;
    19f2:	6165      	str	r5, [r4, #20]
		if (msg == NULL) {
    19f4:	2c00      	cmp	r4, #0
    19f6:	d02e      	beq.n	1a56 <log_1+0x96>
	msg->hdr.ids = src_level;
    19f8:	8167      	strh	r7, [r4, #10]
	msg->hdr.timestamp = timestamp_func();
    19fa:	4b2a      	ldr	r3, [pc, #168]	; (1aa4 <log_1+0xe4>)
    19fc:	681b      	ldr	r3, [r3, #0]
    19fe:	4798      	blx	r3
    1a00:	60e0      	str	r0, [r4, #12]
    1a02:	4b29      	ldr	r3, [pc, #164]	; (1aa8 <log_1+0xe8>)
    1a04:	f3bf 8f5b 	dmb	ish
    1a08:	e853 2f00 	ldrex	r2, [r3]
    1a0c:	3201      	adds	r2, #1
    1a0e:	e843 2100 	strex	r1, r2, [r3]
    1a12:	2900      	cmp	r1, #0
    1a14:	d1f8      	bne.n	1a08 <log_1+0x48>
    1a16:	f3bf 8f5b 	dmb	ish
	__asm__ volatile(
    1a1a:	f04f 0320 	mov.w	r3, #32
    1a1e:	f3ef 8511 	mrs	r5, BASEPRI
    1a22:	f383 8811 	msr	BASEPRI, r3
    1a26:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    1a2a:	4621      	mov	r1, r4
    1a2c:	481f      	ldr	r0, [pc, #124]	; (1aac <log_1+0xec>)
    1a2e:	f00b fe09 	bl	d644 <log_list_add_tail>
	__asm__ volatile(
    1a32:	f385 8811 	msr	BASEPRI, r5
    1a36:	f3bf 8f6f 	isb	sy
	if (panic_mode) {
    1a3a:	4b1d      	ldr	r3, [pc, #116]	; (1ab0 <log_1+0xf0>)
    1a3c:	781b      	ldrb	r3, [r3, #0]
    1a3e:	b963      	cbnz	r3, 1a5a <log_1+0x9a>
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    1a40:	4b1c      	ldr	r3, [pc, #112]	; (1ab4 <log_1+0xf4>)
    1a42:	681b      	ldr	r3, [r3, #0]
    1a44:	b11b      	cbz	r3, 1a4e <log_1+0x8e>
    1a46:	4a18      	ldr	r2, [pc, #96]	; (1aa8 <log_1+0xe8>)
    1a48:	6812      	ldr	r2, [r2, #0]
    1a4a:	2a01      	cmp	r2, #1
    1a4c:	d015      	beq.n	1a7a <log_1+0xba>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    1a4e:	4a16      	ldr	r2, [pc, #88]	; (1aa8 <log_1+0xe8>)
    1a50:	6812      	ldr	r2, [r2, #0]
    1a52:	2a0a      	cmp	r2, #10
    1a54:	d01c      	beq.n	1a90 <log_1+0xd0>
}
    1a56:	b003      	add	sp, #12
    1a58:	bdf0      	pop	{r4, r5, r6, r7, pc}
	__asm__ volatile(
    1a5a:	f04f 0320 	mov.w	r3, #32
    1a5e:	f3ef 8411 	mrs	r4, BASEPRI
    1a62:	f383 8811 	msr	BASEPRI, r3
    1a66:	f3bf 8f6f 	isb	sy
    1a6a:	2000      	movs	r0, #0
    1a6c:	f7ff fea0 	bl	17b0 <z_impl_log_process>
	__asm__ volatile(
    1a70:	f384 8811 	msr	BASEPRI, r4
    1a74:	f3bf 8f6f 	isb	sy
}
    1a78:	e7ed      	b.n	1a56 <log_1+0x96>
	z_impl_k_timer_start(timer, duration, period);
    1a7a:	2200      	movs	r2, #0
    1a7c:	2300      	movs	r3, #0
    1a7e:	e9cd 2300 	strd	r2, r3, [sp]
    1a82:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    1a86:	2300      	movs	r3, #0
    1a88:	480b      	ldr	r0, [pc, #44]	; (1ab8 <log_1+0xf8>)
    1a8a:	f009 fea7 	bl	b7dc <z_impl_k_timer_start>
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    1a8e:	e7e2      	b.n	1a56 <log_1+0x96>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    1a90:	2b00      	cmp	r3, #0
    1a92:	d0e0      	beq.n	1a56 <log_1+0x96>
	z_impl_k_timer_stop(timer);
    1a94:	4808      	ldr	r0, [pc, #32]	; (1ab8 <log_1+0xf8>)
    1a96:	f00e fcfb 	bl	10490 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
    1a9a:	4808      	ldr	r0, [pc, #32]	; (1abc <log_1+0xfc>)
    1a9c:	f009 fc2e 	bl	b2fc <z_impl_k_sem_give>
}
    1aa0:	e7d9      	b.n	1a56 <log_1+0x96>
    1aa2:	bf00      	nop
    1aa4:	200000fc 	.word	0x200000fc
    1aa8:	200037b8 	.word	0x200037b8
    1aac:	200037c4 	.word	0x200037c4
    1ab0:	2000594b 	.word	0x2000594b
    1ab4:	2000385c 	.word	0x2000385c
    1ab8:	20000578 	.word	0x20000578
    1abc:	20000450 	.word	0x20000450

00001ac0 <log_2>:
{
    1ac0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1ac4:	b082      	sub	sp, #8
    1ac6:	4607      	mov	r7, r0
    1ac8:	460e      	mov	r6, r1
    1aca:	4615      	mov	r5, r2
    1acc:	4698      	mov	r8, r3
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    1ace:	f000 f9af 	bl	1e30 <log_msg_chunk_alloc>
	if (msg != NULL) {
    1ad2:	4604      	mov	r4, r0
    1ad4:	b140      	cbz	r0, 1ae8 <log_2+0x28>
		msg->hdr.ref_cnt = 1;
    1ad6:	2301      	movs	r3, #1
    1ad8:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
    1ada:	2200      	movs	r2, #0
    1adc:	8102      	strh	r2, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
    1ade:	f04f 0300 	mov.w	r3, #0
    1ae2:	f362 0300 	bfi	r3, r2, #0, #1
    1ae6:	7203      	strb	r3, [r0, #8]
	if (msg != NULL) {
    1ae8:	b13c      	cbz	r4, 1afa <log_2+0x3a>
		msg->str = str;
    1aea:	6127      	str	r7, [r4, #16]
		msg->hdr.params.std.nargs = 2U;
    1aec:	7a63      	ldrb	r3, [r4, #9]
    1aee:	2202      	movs	r2, #2
    1af0:	f362 1307 	bfi	r3, r2, #4, #4
    1af4:	7263      	strb	r3, [r4, #9]
		msg->payload.single.args[0] = arg1;
    1af6:	6166      	str	r6, [r4, #20]
		msg->payload.single.args[1] = arg2;
    1af8:	61a5      	str	r5, [r4, #24]
		if (msg == NULL) {
    1afa:	2c00      	cmp	r4, #0
    1afc:	d02f      	beq.n	1b5e <log_2+0x9e>
	msg->hdr.ids = src_level;
    1afe:	f8a4 800a 	strh.w	r8, [r4, #10]
	msg->hdr.timestamp = timestamp_func();
    1b02:	4b2a      	ldr	r3, [pc, #168]	; (1bac <log_2+0xec>)
    1b04:	681b      	ldr	r3, [r3, #0]
    1b06:	4798      	blx	r3
    1b08:	60e0      	str	r0, [r4, #12]
    1b0a:	4b29      	ldr	r3, [pc, #164]	; (1bb0 <log_2+0xf0>)
    1b0c:	f3bf 8f5b 	dmb	ish
    1b10:	e853 2f00 	ldrex	r2, [r3]
    1b14:	3201      	adds	r2, #1
    1b16:	e843 2100 	strex	r1, r2, [r3]
    1b1a:	2900      	cmp	r1, #0
    1b1c:	d1f8      	bne.n	1b10 <log_2+0x50>
    1b1e:	f3bf 8f5b 	dmb	ish
	__asm__ volatile(
    1b22:	f04f 0320 	mov.w	r3, #32
    1b26:	f3ef 8511 	mrs	r5, BASEPRI
    1b2a:	f383 8811 	msr	BASEPRI, r3
    1b2e:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    1b32:	4621      	mov	r1, r4
    1b34:	481f      	ldr	r0, [pc, #124]	; (1bb4 <log_2+0xf4>)
    1b36:	f00b fd85 	bl	d644 <log_list_add_tail>
	__asm__ volatile(
    1b3a:	f385 8811 	msr	BASEPRI, r5
    1b3e:	f3bf 8f6f 	isb	sy
	if (panic_mode) {
    1b42:	4b1d      	ldr	r3, [pc, #116]	; (1bb8 <log_2+0xf8>)
    1b44:	781b      	ldrb	r3, [r3, #0]
    1b46:	b96b      	cbnz	r3, 1b64 <log_2+0xa4>
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    1b48:	4b1c      	ldr	r3, [pc, #112]	; (1bbc <log_2+0xfc>)
    1b4a:	681b      	ldr	r3, [r3, #0]
    1b4c:	b11b      	cbz	r3, 1b56 <log_2+0x96>
    1b4e:	4a18      	ldr	r2, [pc, #96]	; (1bb0 <log_2+0xf0>)
    1b50:	6812      	ldr	r2, [r2, #0]
    1b52:	2a01      	cmp	r2, #1
    1b54:	d016      	beq.n	1b84 <log_2+0xc4>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    1b56:	4a16      	ldr	r2, [pc, #88]	; (1bb0 <log_2+0xf0>)
    1b58:	6812      	ldr	r2, [r2, #0]
    1b5a:	2a0a      	cmp	r2, #10
    1b5c:	d01d      	beq.n	1b9a <log_2+0xda>
}
    1b5e:	b002      	add	sp, #8
    1b60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__asm__ volatile(
    1b64:	f04f 0320 	mov.w	r3, #32
    1b68:	f3ef 8411 	mrs	r4, BASEPRI
    1b6c:	f383 8811 	msr	BASEPRI, r3
    1b70:	f3bf 8f6f 	isb	sy
    1b74:	2000      	movs	r0, #0
    1b76:	f7ff fe1b 	bl	17b0 <z_impl_log_process>
	__asm__ volatile(
    1b7a:	f384 8811 	msr	BASEPRI, r4
    1b7e:	f3bf 8f6f 	isb	sy
}
    1b82:	e7ec      	b.n	1b5e <log_2+0x9e>
	z_impl_k_timer_start(timer, duration, period);
    1b84:	2200      	movs	r2, #0
    1b86:	2300      	movs	r3, #0
    1b88:	e9cd 2300 	strd	r2, r3, [sp]
    1b8c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    1b90:	2300      	movs	r3, #0
    1b92:	480b      	ldr	r0, [pc, #44]	; (1bc0 <log_2+0x100>)
    1b94:	f009 fe22 	bl	b7dc <z_impl_k_timer_start>
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    1b98:	e7e1      	b.n	1b5e <log_2+0x9e>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    1b9a:	2b00      	cmp	r3, #0
    1b9c:	d0df      	beq.n	1b5e <log_2+0x9e>
	z_impl_k_timer_stop(timer);
    1b9e:	4808      	ldr	r0, [pc, #32]	; (1bc0 <log_2+0x100>)
    1ba0:	f00e fc76 	bl	10490 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
    1ba4:	4807      	ldr	r0, [pc, #28]	; (1bc4 <log_2+0x104>)
    1ba6:	f009 fba9 	bl	b2fc <z_impl_k_sem_give>
}
    1baa:	e7d8      	b.n	1b5e <log_2+0x9e>
    1bac:	200000fc 	.word	0x200000fc
    1bb0:	200037b8 	.word	0x200037b8
    1bb4:	200037c4 	.word	0x200037c4
    1bb8:	2000594b 	.word	0x2000594b
    1bbc:	2000385c 	.word	0x2000385c
    1bc0:	20000578 	.word	0x20000578
    1bc4:	20000450 	.word	0x20000450

00001bc8 <log_n>:
{
    1bc8:	b530      	push	{r4, r5, lr}
    1bca:	b083      	sub	sp, #12
    1bcc:	461c      	mov	r4, r3
		struct log_msg *msg = log_msg_create_n(str, args, narg);
    1bce:	f00b fe52 	bl	d876 <log_msg_create_n>
		if (msg == NULL) {
    1bd2:	2800      	cmp	r0, #0
    1bd4:	d02f      	beq.n	1c36 <log_n+0x6e>
    1bd6:	4605      	mov	r5, r0
	msg->hdr.ids = src_level;
    1bd8:	8144      	strh	r4, [r0, #10]
	msg->hdr.timestamp = timestamp_func();
    1bda:	4b2a      	ldr	r3, [pc, #168]	; (1c84 <log_n+0xbc>)
    1bdc:	681b      	ldr	r3, [r3, #0]
    1bde:	4798      	blx	r3
    1be0:	60e8      	str	r0, [r5, #12]
    1be2:	4b29      	ldr	r3, [pc, #164]	; (1c88 <log_n+0xc0>)
    1be4:	f3bf 8f5b 	dmb	ish
    1be8:	e853 2f00 	ldrex	r2, [r3]
    1bec:	3201      	adds	r2, #1
    1bee:	e843 2100 	strex	r1, r2, [r3]
    1bf2:	2900      	cmp	r1, #0
    1bf4:	d1f8      	bne.n	1be8 <log_n+0x20>
    1bf6:	f3bf 8f5b 	dmb	ish
	__asm__ volatile(
    1bfa:	f04f 0320 	mov.w	r3, #32
    1bfe:	f3ef 8411 	mrs	r4, BASEPRI
    1c02:	f383 8811 	msr	BASEPRI, r3
    1c06:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    1c0a:	4629      	mov	r1, r5
    1c0c:	481f      	ldr	r0, [pc, #124]	; (1c8c <log_n+0xc4>)
    1c0e:	f00b fd19 	bl	d644 <log_list_add_tail>
	__asm__ volatile(
    1c12:	f384 8811 	msr	BASEPRI, r4
    1c16:	f3bf 8f6f 	isb	sy
	if (panic_mode) {
    1c1a:	4b1d      	ldr	r3, [pc, #116]	; (1c90 <log_n+0xc8>)
    1c1c:	781b      	ldrb	r3, [r3, #0]
    1c1e:	b963      	cbnz	r3, 1c3a <log_n+0x72>
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    1c20:	4b1c      	ldr	r3, [pc, #112]	; (1c94 <log_n+0xcc>)
    1c22:	681b      	ldr	r3, [r3, #0]
    1c24:	b11b      	cbz	r3, 1c2e <log_n+0x66>
    1c26:	4a18      	ldr	r2, [pc, #96]	; (1c88 <log_n+0xc0>)
    1c28:	6812      	ldr	r2, [r2, #0]
    1c2a:	2a01      	cmp	r2, #1
    1c2c:	d015      	beq.n	1c5a <log_n+0x92>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    1c2e:	4a16      	ldr	r2, [pc, #88]	; (1c88 <log_n+0xc0>)
    1c30:	6812      	ldr	r2, [r2, #0]
    1c32:	2a0a      	cmp	r2, #10
    1c34:	d01c      	beq.n	1c70 <log_n+0xa8>
}
    1c36:	b003      	add	sp, #12
    1c38:	bd30      	pop	{r4, r5, pc}
	__asm__ volatile(
    1c3a:	f04f 0320 	mov.w	r3, #32
    1c3e:	f3ef 8411 	mrs	r4, BASEPRI
    1c42:	f383 8811 	msr	BASEPRI, r3
    1c46:	f3bf 8f6f 	isb	sy
    1c4a:	2000      	movs	r0, #0
    1c4c:	f7ff fdb0 	bl	17b0 <z_impl_log_process>
	__asm__ volatile(
    1c50:	f384 8811 	msr	BASEPRI, r4
    1c54:	f3bf 8f6f 	isb	sy
}
    1c58:	e7ed      	b.n	1c36 <log_n+0x6e>
	z_impl_k_timer_start(timer, duration, period);
    1c5a:	2200      	movs	r2, #0
    1c5c:	2300      	movs	r3, #0
    1c5e:	e9cd 2300 	strd	r2, r3, [sp]
    1c62:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    1c66:	2300      	movs	r3, #0
    1c68:	480b      	ldr	r0, [pc, #44]	; (1c98 <log_n+0xd0>)
    1c6a:	f009 fdb7 	bl	b7dc <z_impl_k_timer_start>
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    1c6e:	e7e2      	b.n	1c36 <log_n+0x6e>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    1c70:	2b00      	cmp	r3, #0
    1c72:	d0e0      	beq.n	1c36 <log_n+0x6e>
	z_impl_k_timer_stop(timer);
    1c74:	4808      	ldr	r0, [pc, #32]	; (1c98 <log_n+0xd0>)
    1c76:	f00e fc0b 	bl	10490 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
    1c7a:	4808      	ldr	r0, [pc, #32]	; (1c9c <log_n+0xd4>)
    1c7c:	f009 fb3e 	bl	b2fc <z_impl_k_sem_give>
}
    1c80:	e7d9      	b.n	1c36 <log_n+0x6e>
    1c82:	bf00      	nop
    1c84:	200000fc 	.word	0x200000fc
    1c88:	200037b8 	.word	0x200037b8
    1c8c:	200037c4 	.word	0x200037c4
    1c90:	2000594b 	.word	0x2000594b
    1c94:	2000385c 	.word	0x2000385c
    1c98:	20000578 	.word	0x20000578
    1c9c:	20000450 	.word	0x20000450

00001ca0 <log_0>:
{
    1ca0:	b570      	push	{r4, r5, r6, lr}
    1ca2:	b082      	sub	sp, #8
    1ca4:	4605      	mov	r5, r0
    1ca6:	460e      	mov	r6, r1
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    1ca8:	f000 f8c2 	bl	1e30 <log_msg_chunk_alloc>
	if (msg != NULL) {
    1cac:	4604      	mov	r4, r0
    1cae:	b140      	cbz	r0, 1cc2 <log_0+0x22>
		msg->hdr.ref_cnt = 1;
    1cb0:	2301      	movs	r3, #1
    1cb2:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
    1cb4:	2200      	movs	r2, #0
    1cb6:	8102      	strh	r2, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
    1cb8:	f04f 0300 	mov.w	r3, #0
    1cbc:	f362 0300 	bfi	r3, r2, #0, #1
    1cc0:	7203      	strb	r3, [r0, #8]
	if (msg != NULL) {
    1cc2:	b104      	cbz	r4, 1cc6 <log_0+0x26>
		msg->str = str;
    1cc4:	6125      	str	r5, [r4, #16]
		if (msg == NULL) {
    1cc6:	2c00      	cmp	r4, #0
    1cc8:	d02e      	beq.n	1d28 <log_0+0x88>
	msg->hdr.ids = src_level;
    1cca:	8166      	strh	r6, [r4, #10]
	msg->hdr.timestamp = timestamp_func();
    1ccc:	4b29      	ldr	r3, [pc, #164]	; (1d74 <log_0+0xd4>)
    1cce:	681b      	ldr	r3, [r3, #0]
    1cd0:	4798      	blx	r3
    1cd2:	60e0      	str	r0, [r4, #12]
    1cd4:	4b28      	ldr	r3, [pc, #160]	; (1d78 <log_0+0xd8>)
    1cd6:	f3bf 8f5b 	dmb	ish
    1cda:	e853 2f00 	ldrex	r2, [r3]
    1cde:	3201      	adds	r2, #1
    1ce0:	e843 2100 	strex	r1, r2, [r3]
    1ce4:	2900      	cmp	r1, #0
    1ce6:	d1f8      	bne.n	1cda <log_0+0x3a>
    1ce8:	f3bf 8f5b 	dmb	ish
	__asm__ volatile(
    1cec:	f04f 0320 	mov.w	r3, #32
    1cf0:	f3ef 8511 	mrs	r5, BASEPRI
    1cf4:	f383 8811 	msr	BASEPRI, r3
    1cf8:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    1cfc:	4621      	mov	r1, r4
    1cfe:	481f      	ldr	r0, [pc, #124]	; (1d7c <log_0+0xdc>)
    1d00:	f00b fca0 	bl	d644 <log_list_add_tail>
	__asm__ volatile(
    1d04:	f385 8811 	msr	BASEPRI, r5
    1d08:	f3bf 8f6f 	isb	sy
	if (panic_mode) {
    1d0c:	4b1c      	ldr	r3, [pc, #112]	; (1d80 <log_0+0xe0>)
    1d0e:	781b      	ldrb	r3, [r3, #0]
    1d10:	b963      	cbnz	r3, 1d2c <log_0+0x8c>
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    1d12:	4b1c      	ldr	r3, [pc, #112]	; (1d84 <log_0+0xe4>)
    1d14:	681b      	ldr	r3, [r3, #0]
    1d16:	b11b      	cbz	r3, 1d20 <log_0+0x80>
    1d18:	4a17      	ldr	r2, [pc, #92]	; (1d78 <log_0+0xd8>)
    1d1a:	6812      	ldr	r2, [r2, #0]
    1d1c:	2a01      	cmp	r2, #1
    1d1e:	d015      	beq.n	1d4c <log_0+0xac>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    1d20:	4a15      	ldr	r2, [pc, #84]	; (1d78 <log_0+0xd8>)
    1d22:	6812      	ldr	r2, [r2, #0]
    1d24:	2a0a      	cmp	r2, #10
    1d26:	d01c      	beq.n	1d62 <log_0+0xc2>
}
    1d28:	b002      	add	sp, #8
    1d2a:	bd70      	pop	{r4, r5, r6, pc}
	__asm__ volatile(
    1d2c:	f04f 0320 	mov.w	r3, #32
    1d30:	f3ef 8411 	mrs	r4, BASEPRI
    1d34:	f383 8811 	msr	BASEPRI, r3
    1d38:	f3bf 8f6f 	isb	sy
    1d3c:	2000      	movs	r0, #0
    1d3e:	f7ff fd37 	bl	17b0 <z_impl_log_process>
	__asm__ volatile(
    1d42:	f384 8811 	msr	BASEPRI, r4
    1d46:	f3bf 8f6f 	isb	sy
}
    1d4a:	e7ed      	b.n	1d28 <log_0+0x88>
	z_impl_k_timer_start(timer, duration, period);
    1d4c:	2200      	movs	r2, #0
    1d4e:	2300      	movs	r3, #0
    1d50:	e9cd 2300 	strd	r2, r3, [sp]
    1d54:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    1d58:	2300      	movs	r3, #0
    1d5a:	480b      	ldr	r0, [pc, #44]	; (1d88 <log_0+0xe8>)
    1d5c:	f009 fd3e 	bl	b7dc <z_impl_k_timer_start>
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    1d60:	e7e2      	b.n	1d28 <log_0+0x88>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    1d62:	2b00      	cmp	r3, #0
    1d64:	d0e0      	beq.n	1d28 <log_0+0x88>
	z_impl_k_timer_stop(timer);
    1d66:	4808      	ldr	r0, [pc, #32]	; (1d88 <log_0+0xe8>)
    1d68:	f00e fb92 	bl	10490 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
    1d6c:	4807      	ldr	r0, [pc, #28]	; (1d8c <log_0+0xec>)
    1d6e:	f009 fac5 	bl	b2fc <z_impl_k_sem_give>
}
    1d72:	e7d9      	b.n	1d28 <log_0+0x88>
    1d74:	200000fc 	.word	0x200000fc
    1d78:	200037b8 	.word	0x200037b8
    1d7c:	200037c4 	.word	0x200037c4
    1d80:	2000594b 	.word	0x2000594b
    1d84:	2000385c 	.word	0x2000385c
    1d88:	20000578 	.word	0x20000578
    1d8c:	20000450 	.word	0x20000450

00001d90 <log_free>:
{
    1d90:	b500      	push	{lr}
    1d92:	b083      	sub	sp, #12
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
    1d94:	3804      	subs	r0, #4
    1d96:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    1d98:	f3bf 8f5b 	dmb	ish
    1d9c:	e850 3f00 	ldrex	r3, [r0]
    1da0:	1e5a      	subs	r2, r3, #1
    1da2:	e840 2100 	strex	r1, r2, [r0]
    1da6:	2900      	cmp	r1, #0
    1da8:	d1f8      	bne.n	1d9c <log_free+0xc>
    1daa:	f3bf 8f5b 	dmb	ish
	if (atomic_dec(&dup->refcount) == 1) {
    1dae:	2b01      	cmp	r3, #1
    1db0:	d002      	beq.n	1db8 <log_free+0x28>
}
    1db2:	b003      	add	sp, #12
    1db4:	f85d fb04 	ldr.w	pc, [sp], #4
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
    1db8:	a901      	add	r1, sp, #4
    1dba:	4802      	ldr	r0, [pc, #8]	; (1dc4 <log_free+0x34>)
    1dbc:	f008 fcce 	bl	a75c <k_mem_slab_free>
}
    1dc0:	e7f7      	b.n	1db2 <log_free+0x22>
    1dc2:	bf00      	nop
    1dc4:	200037cc 	.word	0x200037cc

00001dc8 <cont_free>:
{
	atomic_inc(&msg->hdr.ref_cnt);
}

static void cont_free(struct log_msg_cont *cont)
{
    1dc8:	b510      	push	{r4, lr}
    1dca:	b082      	sub	sp, #8
    1dcc:	9001      	str	r0, [sp, #4]
	struct log_msg_cont *next;

	while (cont != NULL) {
    1dce:	9b01      	ldr	r3, [sp, #4]
    1dd0:	b133      	cbz	r3, 1de0 <cont_free+0x18>
		next = cont->next;
    1dd2:	681c      	ldr	r4, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    1dd4:	a901      	add	r1, sp, #4
    1dd6:	4803      	ldr	r0, [pc, #12]	; (1de4 <cont_free+0x1c>)
    1dd8:	f008 fcc0 	bl	a75c <k_mem_slab_free>
		cont = next;
    1ddc:	9401      	str	r4, [sp, #4]
    1dde:	e7f6      	b.n	1dce <cont_free+0x6>
	}
}
    1de0:	b002      	add	sp, #8
    1de2:	bd10      	pop	{r4, pc}
    1de4:	20003860 	.word	0x20003860

00001de8 <log_msg_pool_init>:
{
    1de8:	b508      	push	{r3, lr}
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
    1dea:	2320      	movs	r3, #32
    1dec:	461a      	mov	r2, r3
    1dee:	4902      	ldr	r1, [pc, #8]	; (1df8 <log_msg_pool_init+0x10>)
    1df0:	4802      	ldr	r0, [pc, #8]	; (1dfc <log_msg_pool_init+0x14>)
    1df2:	f00d ff92 	bl	fd1a <k_mem_slab_init>
}
    1df6:	bd08      	pop	{r3, pc}
    1df8:	20007e80 	.word	0x20007e80
    1dfc:	20003860 	.word	0x20003860

00001e00 <log_msg_no_space_handle>:

	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
    1e00:	b510      	push	{r4, lr}
    1e02:	b082      	sub	sp, #8
	union log_msg_chunk *msg = NULL;
    1e04:	2300      	movs	r3, #0
    1e06:	9301      	str	r3, [sp, #4]
    1e08:	2001      	movs	r0, #1
    1e0a:	f7ff fcd1 	bl	17b0 <z_impl_log_process>
    1e0e:	4604      	mov	r4, r0
	int err;

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			log_dropped();
    1e10:	f7ff fb88 	bl	1524 <log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
    1e14:	2200      	movs	r2, #0
    1e16:	2300      	movs	r3, #0
    1e18:	a901      	add	r1, sp, #4
    1e1a:	4804      	ldr	r0, [pc, #16]	; (1e2c <log_msg_no_space_handle+0x2c>)
    1e1c:	f008 fc68 	bl	a6f0 <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
    1e20:	b108      	cbz	r0, 1e26 <log_msg_no_space_handle+0x26>
    1e22:	2c00      	cmp	r4, #0
    1e24:	d1f0      	bne.n	1e08 <log_msg_no_space_handle+0x8>
	} else {
		log_dropped();
	}
	return msg;

}
    1e26:	9801      	ldr	r0, [sp, #4]
    1e28:	b002      	add	sp, #8
    1e2a:	bd10      	pop	{r4, pc}
    1e2c:	20003860 	.word	0x20003860

00001e30 <log_msg_chunk_alloc>:
{
    1e30:	b500      	push	{lr}
    1e32:	b083      	sub	sp, #12
	union log_msg_chunk *msg = NULL;
    1e34:	2300      	movs	r3, #0
    1e36:	9301      	str	r3, [sp, #4]
		   block_on_alloc()
    1e38:	f00b fc1e 	bl	d678 <block_on_alloc>
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    1e3c:	b150      	cbz	r0, 1e54 <log_msg_chunk_alloc+0x24>
    1e3e:	2200      	movs	r2, #0
    1e40:	2300      	movs	r3, #0
    1e42:	a901      	add	r1, sp, #4
    1e44:	4807      	ldr	r0, [pc, #28]	; (1e64 <log_msg_chunk_alloc+0x34>)
    1e46:	f008 fc53 	bl	a6f0 <k_mem_slab_alloc>
	if (err != 0) {
    1e4a:	b930      	cbnz	r0, 1e5a <log_msg_chunk_alloc+0x2a>
}
    1e4c:	9801      	ldr	r0, [sp, #4]
    1e4e:	b003      	add	sp, #12
    1e50:	f85d fb04 	ldr.w	pc, [sp], #4
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    1e54:	2200      	movs	r2, #0
    1e56:	2300      	movs	r3, #0
    1e58:	e7f3      	b.n	1e42 <log_msg_chunk_alloc+0x12>
		msg = log_msg_no_space_handle();
    1e5a:	f7ff ffd1 	bl	1e00 <log_msg_no_space_handle>
    1e5e:	9001      	str	r0, [sp, #4]
    1e60:	e7f4      	b.n	1e4c <log_msg_chunk_alloc+0x1c>
    1e62:	bf00      	nop
    1e64:	20003860 	.word	0x20003860

00001e68 <msg_free>:
{
    1e68:	b5f0      	push	{r4, r5, r6, r7, lr}
    1e6a:	b083      	sub	sp, #12
    1e6c:	9001      	str	r0, [sp, #4]
	u32_t nargs = log_msg_nargs_get(msg);
    1e6e:	4604      	mov	r4, r0
    1e70:	f00b fca6 	bl	d7c0 <log_msg_nargs_get>
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    1e74:	7a23      	ldrb	r3, [r4, #8]
	if (log_msg_is_std(msg) && nargs) {
    1e76:	f013 0f01 	tst.w	r3, #1
    1e7a:	d101      	bne.n	1e80 <msg_free+0x18>
    1e7c:	4606      	mov	r6, r0
    1e7e:	bb50      	cbnz	r0, 1ed6 <msg_free+0x6e>
	if (msg->hdr.params.generic.ext == 1) {
    1e80:	9b01      	ldr	r3, [sp, #4]
    1e82:	7a1a      	ldrb	r2, [r3, #8]
    1e84:	f012 0f02 	tst.w	r2, #2
    1e88:	d128      	bne.n	1edc <msg_free+0x74>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
    1e8a:	a901      	add	r1, sp, #4
    1e8c:	4815      	ldr	r0, [pc, #84]	; (1ee4 <msg_free+0x7c>)
    1e8e:	f008 fc65 	bl	a75c <k_mem_slab_free>
}
    1e92:	b003      	add	sp, #12
    1e94:	bdf0      	pop	{r4, r5, r6, r7, pc}
					smask = z_log_get_s_mask(
    1e96:	9801      	ldr	r0, [sp, #4]
    1e98:	f00b fca7 	bl	d7ea <log_msg_str_get>
    1e9c:	4631      	mov	r1, r6
    1e9e:	f7ff fad3 	bl	1448 <z_log_get_s_mask>
					if (smask == 0) {
    1ea2:	4607      	mov	r7, r0
    1ea4:	b988      	cbnz	r0, 1eca <msg_free+0x62>
    1ea6:	e7eb      	b.n	1e80 <msg_free+0x18>
					log_free(buf);
    1ea8:	4628      	mov	r0, r5
    1eaa:	f7ff ff71 	bl	1d90 <log_free>
		for (i = 0; i < nargs; i++) {
    1eae:	3401      	adds	r4, #1
    1eb0:	42b4      	cmp	r4, r6
    1eb2:	d2e5      	bcs.n	1e80 <msg_free+0x18>
			void *buf = (void *)log_msg_arg_get(msg, i);
    1eb4:	4621      	mov	r1, r4
    1eb6:	9801      	ldr	r0, [sp, #4]
    1eb8:	f00b fc85 	bl	d7c6 <log_msg_arg_get>
    1ebc:	4605      	mov	r5, r0
			if (log_is_strdup(buf)) {
    1ebe:	f7ff fbdf 	bl	1680 <log_is_strdup>
    1ec2:	2800      	cmp	r0, #0
    1ec4:	d0f3      	beq.n	1eae <msg_free+0x46>
				if (smask == 0) {
    1ec6:	2f00      	cmp	r7, #0
    1ec8:	d0e5      	beq.n	1e96 <msg_free+0x2e>
				if (smask & BIT(i)) {
    1eca:	fa27 f304 	lsr.w	r3, r7, r4
    1ece:	f013 0f01 	tst.w	r3, #1
    1ed2:	d0ec      	beq.n	1eae <msg_free+0x46>
    1ed4:	e7e8      	b.n	1ea8 <msg_free+0x40>
		u32_t smask = 0;
    1ed6:	2700      	movs	r7, #0
		for (i = 0; i < nargs; i++) {
    1ed8:	463c      	mov	r4, r7
    1eda:	e7e9      	b.n	1eb0 <msg_free+0x48>
		cont_free(msg->payload.ext.next);
    1edc:	6958      	ldr	r0, [r3, #20]
    1ede:	f7ff ff73 	bl	1dc8 <cont_free>
    1ee2:	e7d2      	b.n	1e8a <msg_free+0x22>
    1ee4:	20003860 	.word	0x20003860

00001ee8 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *log_output,
			   const char *fmt, ...)
{
    1ee8:	b40e      	push	{r1, r2, r3}
    1eea:	b500      	push	{lr}
    1eec:	b082      	sub	sp, #8
    1eee:	4601      	mov	r1, r0
    1ef0:	ab03      	add	r3, sp, #12
    1ef2:	f853 2b04 	ldr.w	r2, [r3], #4
	va_list args;
	int length = 0;

	va_start(args, fmt);
    1ef6:	9301      	str	r3, [sp, #4]
#if !defined(CONFIG_NEWLIB_LIBC) && !defined(CONFIG_ARCH_POSIX) && \
    defined(CONFIG_LOG_ENABLE_FANCY_OUTPUT_FORMATTING)
	length = z_prf(out_func, (void *)log_output, (char *)fmt, args);
#else
	z_vprintk(out_func, (void *)log_output, fmt, args);
    1ef8:	4804      	ldr	r0, [pc, #16]	; (1f0c <print_formatted+0x24>)
    1efa:	f00a fef9 	bl	ccf0 <z_vprintk>
#endif
	va_end(args);

	return length;
}
    1efe:	2000      	movs	r0, #0
    1f00:	b002      	add	sp, #8
    1f02:	f85d eb04 	ldr.w	lr, [sp], #4
    1f06:	b003      	add	sp, #12
    1f08:	4770      	bx	lr
    1f0a:	bf00      	nop
    1f0c:	0000dc17 	.word	0x0000dc17

00001f10 <timestamp_print>:
	log_output->control_block->offset = 0;
}

static int timestamp_print(const struct log_output *log_output,
			   u32_t flags, u32_t timestamp)
{
    1f10:	b5f0      	push	{r4, r5, r6, r7, lr}
    1f12:	b085      	sub	sp, #20
	bool format =
		(flags & LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP) |
		(flags & LOG_OUTPUT_FLAG_FORMAT_SYSLOG);


	if (!format) {
    1f14:	f011 0f44 	tst.w	r1, #68	; 0x44
    1f18:	d005      	beq.n	1f26 <timestamp_print+0x16>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
	} else if (freq != 0U) {
    1f1a:	4b1a      	ldr	r3, [pc, #104]	; (1f84 <timestamp_print+0x74>)
    1f1c:	681c      	ldr	r4, [r3, #0]
    1f1e:	b934      	cbnz	r4, 1f2e <timestamp_print+0x1e>
			length = print_formatted(log_output,
						 "[%02d:%02d:%02d.%03d,%03d] ",
						 hours, mins, seconds, ms, us);
		}
	} else {
		length = 0;
    1f20:	2000      	movs	r0, #0
	}

	return length;
}
    1f22:	b005      	add	sp, #20
    1f24:	bdf0      	pop	{r4, r5, r6, r7, pc}
		length = print_formatted(log_output, "[%08lu] ", timestamp);
    1f26:	4918      	ldr	r1, [pc, #96]	; (1f88 <timestamp_print+0x78>)
    1f28:	f7ff ffde 	bl	1ee8 <print_formatted>
    1f2c:	e7f9      	b.n	1f22 <timestamp_print+0x12>
		timestamp /= timestamp_div;
    1f2e:	4b17      	ldr	r3, [pc, #92]	; (1f8c <timestamp_print+0x7c>)
    1f30:	6819      	ldr	r1, [r3, #0]
    1f32:	fbb2 f1f1 	udiv	r1, r2, r1
		seconds = timestamp / freq;
    1f36:	fbb1 f5f4 	udiv	r5, r1, r4
		hours = seconds / 3600U;
    1f3a:	4a15      	ldr	r2, [pc, #84]	; (1f90 <timestamp_print+0x80>)
    1f3c:	fba2 3205 	umull	r3, r2, r2, r5
    1f40:	0ad2      	lsrs	r2, r2, #11
		seconds -= hours * 3600U;
    1f42:	f44f 6661 	mov.w	r6, #3600	; 0xe10
    1f46:	fb06 5612 	mls	r6, r6, r2, r5
		mins = seconds / 60U;
    1f4a:	4b12      	ldr	r3, [pc, #72]	; (1f94 <timestamp_print+0x84>)
    1f4c:	fba3 7306 	umull	r7, r3, r3, r6
    1f50:	095b      	lsrs	r3, r3, #5
		remainder = timestamp % freq;
    1f52:	fb04 1115 	mls	r1, r4, r5, r1
		ms = (remainder * 1000U) / freq;
    1f56:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    1f5a:	fb05 f101 	mul.w	r1, r5, r1
    1f5e:	fbb1 f7f4 	udiv	r7, r1, r4
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    1f62:	fb07 1114 	mls	r1, r7, r4, r1
    1f66:	fb05 f101 	mul.w	r1, r5, r1
    1f6a:	fbb1 f4f4 	udiv	r4, r1, r4
			length = print_formatted(log_output,
    1f6e:	9402      	str	r4, [sp, #8]
    1f70:	9701      	str	r7, [sp, #4]
    1f72:	ebc3 1103 	rsb	r1, r3, r3, lsl #4
    1f76:	eba6 0181 	sub.w	r1, r6, r1, lsl #2
    1f7a:	9100      	str	r1, [sp, #0]
    1f7c:	4906      	ldr	r1, [pc, #24]	; (1f98 <timestamp_print+0x88>)
    1f7e:	f7ff ffb3 	bl	1ee8 <print_formatted>
    1f82:	e7ce      	b.n	1f22 <timestamp_print+0x12>
    1f84:	2000387c 	.word	0x2000387c
    1f88:	000115c0 	.word	0x000115c0
    1f8c:	20003880 	.word	0x20003880
    1f90:	91a2b3c5 	.word	0x91a2b3c5
    1f94:	88888889 	.word	0x88888889
    1f98:	000115cc 	.word	0x000115cc

00001f9c <color_print>:

static void color_print(const struct log_output *log_output,
			bool color, bool start, u32_t level)
{
	if (color) {
    1f9c:	b161      	cbz	r1, 1fb8 <color_print+0x1c>
{
    1f9e:	b508      	push	{r3, lr}
		const char *color = start && (colors[level] != NULL) ?
				colors[level] : LOG_COLOR_CODE_DEFAULT;
    1fa0:	b12a      	cbz	r2, 1fae <color_print+0x12>
		const char *color = start && (colors[level] != NULL) ?
    1fa2:	4a06      	ldr	r2, [pc, #24]	; (1fbc <color_print+0x20>)
    1fa4:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    1fa8:	b912      	cbnz	r2, 1fb0 <color_print+0x14>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
    1faa:	4a05      	ldr	r2, [pc, #20]	; (1fc0 <color_print+0x24>)
    1fac:	e000      	b.n	1fb0 <color_print+0x14>
    1fae:	4a04      	ldr	r2, [pc, #16]	; (1fc0 <color_print+0x24>)
		print_formatted(log_output, "%s", color);
    1fb0:	4904      	ldr	r1, [pc, #16]	; (1fc4 <color_print+0x28>)
    1fb2:	f7ff ff99 	bl	1ee8 <print_formatted>
	}
}
    1fb6:	bd08      	pop	{r3, pc}
    1fb8:	4770      	bx	lr
    1fba:	bf00      	nop
    1fbc:	00011640 	.word	0x00011640
    1fc0:	000115e8 	.word	0x000115e8
    1fc4:	00011e98 	.word	0x00011e98

00001fc8 <newline_print>:
	if (IS_ENABLED(CONFIG_LOG_BACKEND_NET) &&
	    flags & LOG_OUTPUT_FLAG_FORMAT_SYSLOG) {
		return;
	}

	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    1fc8:	f011 0f10 	tst.w	r1, #16
    1fcc:	d10b      	bne.n	1fe6 <newline_print+0x1e>
{
    1fce:	b508      	push	{r3, lr}
		return;
	}

	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    1fd0:	f011 0f20 	tst.w	r1, #32
    1fd4:	d003      	beq.n	1fde <newline_print+0x16>
		print_formatted(ctx, "\n");
    1fd6:	4904      	ldr	r1, [pc, #16]	; (1fe8 <newline_print+0x20>)
    1fd8:	f7ff ff86 	bl	1ee8 <print_formatted>
	} else {
		print_formatted(ctx, "\r\n");
	}
}
    1fdc:	bd08      	pop	{r3, pc}
		print_formatted(ctx, "\r\n");
    1fde:	4903      	ldr	r1, [pc, #12]	; (1fec <newline_print+0x24>)
    1fe0:	f7ff ff82 	bl	1ee8 <print_formatted>
    1fe4:	e7fa      	b.n	1fdc <newline_print+0x14>
    1fe6:	4770      	bx	lr
    1fe8:	000112ec 	.word	0x000112ec
    1fec:	00010d70 	.word	0x00010d70

00001ff0 <hexdump_line_print>:
}

static void hexdump_line_print(const struct log_output *log_output,
			       const u8_t *data, u32_t length,
			       int prefix_offset, u32_t flags)
{
    1ff0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1ff4:	4605      	mov	r5, r0
    1ff6:	460f      	mov	r7, r1
    1ff8:	4616      	mov	r6, r2
    1ffa:	4698      	mov	r8, r3
	newline_print(log_output, flags);
    1ffc:	9906      	ldr	r1, [sp, #24]
    1ffe:	f7ff ffe3 	bl	1fc8 <newline_print>

	for (int i = 0; i < prefix_offset; i++) {
    2002:	2400      	movs	r4, #0
    2004:	4544      	cmp	r4, r8
    2006:	da05      	bge.n	2014 <hexdump_line_print+0x24>
		print_formatted(log_output, " ");
    2008:	4924      	ldr	r1, [pc, #144]	; (209c <hexdump_line_print+0xac>)
    200a:	4628      	mov	r0, r5
    200c:	f7ff ff6c 	bl	1ee8 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
    2010:	3401      	adds	r4, #1
    2012:	e7f7      	b.n	2004 <hexdump_line_print+0x14>
	}

	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    2014:	2400      	movs	r4, #0
    2016:	e009      	b.n	202c <hexdump_line_print+0x3c>
		if (i > 0 && !(i % 8)) {
			print_formatted(log_output, " ");
    2018:	4920      	ldr	r1, [pc, #128]	; (209c <hexdump_line_print+0xac>)
    201a:	4628      	mov	r0, r5
    201c:	f7ff ff64 	bl	1ee8 <print_formatted>
    2020:	e00b      	b.n	203a <hexdump_line_print+0x4a>
		}

		if (i < length) {
			print_formatted(log_output, "%02x ", data[i]);
		} else {
			print_formatted(log_output, "   ");
    2022:	491f      	ldr	r1, [pc, #124]	; (20a0 <hexdump_line_print+0xb0>)
    2024:	4628      	mov	r0, r5
    2026:	f7ff ff5f 	bl	1ee8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    202a:	3401      	adds	r4, #1
    202c:	2c0f      	cmp	r4, #15
    202e:	dc0c      	bgt.n	204a <hexdump_line_print+0x5a>
		if (i > 0 && !(i % 8)) {
    2030:	2c00      	cmp	r4, #0
    2032:	dd02      	ble.n	203a <hexdump_line_print+0x4a>
    2034:	f014 0f07 	tst.w	r4, #7
    2038:	d0ee      	beq.n	2018 <hexdump_line_print+0x28>
		if (i < length) {
    203a:	42b4      	cmp	r4, r6
    203c:	d2f1      	bcs.n	2022 <hexdump_line_print+0x32>
			print_formatted(log_output, "%02x ", data[i]);
    203e:	5d3a      	ldrb	r2, [r7, r4]
    2040:	4918      	ldr	r1, [pc, #96]	; (20a4 <hexdump_line_print+0xb4>)
    2042:	4628      	mov	r0, r5
    2044:	f7ff ff50 	bl	1ee8 <print_formatted>
    2048:	e7ef      	b.n	202a <hexdump_line_print+0x3a>
		}
	}

	print_formatted(log_output, "|");
    204a:	4917      	ldr	r1, [pc, #92]	; (20a8 <hexdump_line_print+0xb8>)
    204c:	4628      	mov	r0, r5
    204e:	f7ff ff4b 	bl	1ee8 <print_formatted>

	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    2052:	2400      	movs	r4, #0
    2054:	e009      	b.n	206a <hexdump_line_print+0x7a>
		if (i > 0 && !(i % 8)) {
			print_formatted(log_output, " ");
    2056:	4911      	ldr	r1, [pc, #68]	; (209c <hexdump_line_print+0xac>)
    2058:	4628      	mov	r0, r5
    205a:	f7ff ff45 	bl	1ee8 <print_formatted>
    205e:	e00b      	b.n	2078 <hexdump_line_print+0x88>
		}

		if (i < length) {
			char c = (char)data[i];

			print_formatted(log_output, "%c",
    2060:	4912      	ldr	r1, [pc, #72]	; (20ac <hexdump_line_print+0xbc>)
    2062:	4628      	mov	r0, r5
    2064:	f7ff ff40 	bl	1ee8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    2068:	3401      	adds	r4, #1
    206a:	2c0f      	cmp	r4, #15
    206c:	dc13      	bgt.n	2096 <hexdump_line_print+0xa6>
		if (i > 0 && !(i % 8)) {
    206e:	2c00      	cmp	r4, #0
    2070:	dd02      	ble.n	2078 <hexdump_line_print+0x88>
    2072:	f014 0f07 	tst.w	r4, #7
    2076:	d0ee      	beq.n	2056 <hexdump_line_print+0x66>
		if (i < length) {
    2078:	42b4      	cmp	r4, r6
    207a:	d207      	bcs.n	208c <hexdump_line_print+0x9c>
			char c = (char)data[i];
    207c:	5d3a      	ldrb	r2, [r7, r4]
			      isprint((int)c) ? c : '.');
    207e:	4b0c      	ldr	r3, [pc, #48]	; (20b0 <hexdump_line_print+0xc0>)
    2080:	5cd3      	ldrb	r3, [r2, r3]
			print_formatted(log_output, "%c",
    2082:	f013 0f97 	tst.w	r3, #151	; 0x97
    2086:	d1eb      	bne.n	2060 <hexdump_line_print+0x70>
    2088:	222e      	movs	r2, #46	; 0x2e
    208a:	e7e9      	b.n	2060 <hexdump_line_print+0x70>
		} else {
			print_formatted(log_output, " ");
    208c:	4903      	ldr	r1, [pc, #12]	; (209c <hexdump_line_print+0xac>)
    208e:	4628      	mov	r0, r5
    2090:	f7ff ff2a 	bl	1ee8 <print_formatted>
    2094:	e7e8      	b.n	2068 <hexdump_line_print+0x78>
		}
	}
}
    2096:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    209a:	bf00      	nop
    209c:	00011614 	.word	0x00011614
    20a0:	000115f8 	.word	0x000115f8
    20a4:	000115f0 	.word	0x000115f0
    20a8:	000115fc 	.word	0x000115fc
    20ac:	00011600 	.word	0x00011600
    20b0:	00013171 	.word	0x00013171

000020b4 <ids_print>:
{
    20b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    20b6:	4604      	mov	r4, r0
    20b8:	4616      	mov	r6, r2
    20ba:	461d      	mov	r5, r3
	if (level_on) {
    20bc:	b949      	cbnz	r1, 20d2 <ids_print+0x1e>
	int total = 0;
    20be:	2700      	movs	r7, #0
	total += print_formatted(log_output,
    20c0:	b186      	cbz	r6, 20e4 <ids_print+0x30>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
    20c2:	2301      	movs	r3, #1
    20c4:	9a07      	ldr	r2, [sp, #28]
    20c6:	4093      	lsls	r3, r2
				(func_on &&
    20c8:	f013 0f10 	tst.w	r3, #16
    20cc:	d116      	bne.n	20fc <ids_print+0x48>
	total += print_formatted(log_output,
    20ce:	4e0c      	ldr	r6, [pc, #48]	; (2100 <ids_print+0x4c>)
    20d0:	e009      	b.n	20e6 <ids_print+0x32>
		total += print_formatted(log_output, "<%s> ", severity[level]);
    20d2:	4b0c      	ldr	r3, [pc, #48]	; (2104 <ids_print+0x50>)
    20d4:	9a07      	ldr	r2, [sp, #28]
    20d6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    20da:	490b      	ldr	r1, [pc, #44]	; (2108 <ids_print+0x54>)
    20dc:	f7ff ff04 	bl	1ee8 <print_formatted>
    20e0:	4607      	mov	r7, r0
    20e2:	e7ed      	b.n	20c0 <ids_print+0xc>
	total += print_formatted(log_output,
    20e4:	4e06      	ldr	r6, [pc, #24]	; (2100 <ids_print+0x4c>)
    20e6:	9906      	ldr	r1, [sp, #24]
    20e8:	4628      	mov	r0, r5
    20ea:	f7ff fa2b 	bl	1544 <log_source_name_get>
    20ee:	4602      	mov	r2, r0
    20f0:	4631      	mov	r1, r6
    20f2:	4620      	mov	r0, r4
    20f4:	f7ff fef8 	bl	1ee8 <print_formatted>
}
    20f8:	4438      	add	r0, r7
    20fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	total += print_formatted(log_output,
    20fc:	4e03      	ldr	r6, [pc, #12]	; (210c <ids_print+0x58>)
    20fe:	e7f2      	b.n	20e6 <ids_print+0x32>
    2100:	00011604 	.word	0x00011604
    2104:	0001167c 	.word	0x0001167c
    2108:	00011610 	.word	0x00011610
    210c:	0001160c 	.word	0x0001160c

00002110 <hexdump_print>:

static void hexdump_print(struct log_msg *msg,
			  const struct log_output *log_output,
			  int prefix_offset, u32_t flags)
{
    2110:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    2114:	b089      	sub	sp, #36	; 0x24
    2116:	4607      	mov	r7, r0
    2118:	460e      	mov	r6, r1
    211a:	4691      	mov	r9, r2
    211c:	4698      	mov	r8, r3
	u32_t offset = 0U;
	u8_t buf[HEXDUMP_BYTES_IN_LINE];
	size_t length;

	print_formatted(log_output, "%s", log_msg_str_get(msg));
    211e:	f00b fb64 	bl	d7ea <log_msg_str_get>
    2122:	4602      	mov	r2, r0
    2124:	490e      	ldr	r1, [pc, #56]	; (2160 <hexdump_print+0x50>)
    2126:	4630      	mov	r0, r6
    2128:	f7ff fede 	bl	1ee8 <print_formatted>
	u32_t offset = 0U;
    212c:	2400      	movs	r4, #0

	do {
		length = sizeof(buf);
    212e:	2510      	movs	r5, #16
    2130:	9503      	str	r5, [sp, #12]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    2132:	4623      	mov	r3, r4
    2134:	aa03      	add	r2, sp, #12
    2136:	eb0d 0105 	add.w	r1, sp, r5
    213a:	4638      	mov	r0, r7
    213c:	f00b fbaf 	bl	d89e <log_msg_hexdump_data_get>

		if (length) {
    2140:	9a03      	ldr	r2, [sp, #12]
    2142:	b152      	cbz	r2, 215a <hexdump_print+0x4a>
			hexdump_line_print(log_output, buf, length,
    2144:	f8cd 8000 	str.w	r8, [sp]
    2148:	464b      	mov	r3, r9
    214a:	eb0d 0105 	add.w	r1, sp, r5
    214e:	4630      	mov	r0, r6
    2150:	f7ff ff4e 	bl	1ff0 <hexdump_line_print>
					   prefix_offset, flags);
			offset += length;
    2154:	9d03      	ldr	r5, [sp, #12]
    2156:	442c      	add	r4, r5
		length = sizeof(buf);
    2158:	e7e9      	b.n	212e <hexdump_print+0x1e>
		} else {
			break;
		}
	} while (true);
}
    215a:	b009      	add	sp, #36	; 0x24
    215c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    2160:	00011e98 	.word	0x00011e98

00002164 <raw_string_print>:

static void raw_string_print(struct log_msg *msg,
			     const struct log_output *log_output)
{
    2164:	b5f0      	push	{r4, r5, r6, r7, lr}
    2166:	b083      	sub	sp, #12
    2168:	4606      	mov	r6, r0
    216a:	460c      	mov	r4, r1
	__ASSERT_NO_MSG(log_output->size);

	size_t offset = 0;
	size_t length;
	bool eol = false;
    216c:	2700      	movs	r7, #0
	size_t offset = 0;
    216e:	463d      	mov	r5, r7
    2170:	e00d      	b.n	218e <raw_string_print+0x2a>
		/* Sting is stored in a hexdump message. */
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
		log_output->control_block->offset = length;

		if (length != 0) {
			eol = (log_output->buf[length - 1] == '\n');
    2172:	68a2      	ldr	r2, [r4, #8]
    2174:	4413      	add	r3, r2
    2176:	f813 7c01 	ldrb.w	r7, [r3, #-1]
    217a:	2f0a      	cmp	r7, #10
    217c:	bf14      	ite	ne
    217e:	2700      	movne	r7, #0
    2180:	2701      	moveq	r7, #1
		}

		log_output_flush(log_output);
    2182:	4620      	mov	r0, r4
    2184:	f00b fd3a 	bl	dbfc <log_output_flush>
		offset += length;
    2188:	9b01      	ldr	r3, [sp, #4]
    218a:	441d      	add	r5, r3
	} while (length > 0);
    218c:	b173      	cbz	r3, 21ac <raw_string_print+0x48>
		length = log_output->size;
    218e:	68e3      	ldr	r3, [r4, #12]
    2190:	9301      	str	r3, [sp, #4]
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
    2192:	462b      	mov	r3, r5
    2194:	aa01      	add	r2, sp, #4
    2196:	68a1      	ldr	r1, [r4, #8]
    2198:	4630      	mov	r0, r6
    219a:	f00b fb80 	bl	d89e <log_msg_hexdump_data_get>
		log_output->control_block->offset = length;
    219e:	6863      	ldr	r3, [r4, #4]
    21a0:	9a01      	ldr	r2, [sp, #4]
    21a2:	601a      	str	r2, [r3, #0]
		if (length != 0) {
    21a4:	9b01      	ldr	r3, [sp, #4]
    21a6:	2b00      	cmp	r3, #0
    21a8:	d0eb      	beq.n	2182 <raw_string_print+0x1e>
    21aa:	e7e2      	b.n	2172 <raw_string_print+0xe>

	if (eol) {
    21ac:	b90f      	cbnz	r7, 21b2 <raw_string_print+0x4e>
		print_formatted(log_output, "\r");
	}
}
    21ae:	b003      	add	sp, #12
    21b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		print_formatted(log_output, "\r");
    21b2:	4902      	ldr	r1, [pc, #8]	; (21bc <raw_string_print+0x58>)
    21b4:	4620      	mov	r0, r4
    21b6:	f7ff fe97 	bl	1ee8 <print_formatted>
}
    21ba:	e7f8      	b.n	21ae <raw_string_print+0x4a>
    21bc:	00011618 	.word	0x00011618

000021c0 <log_output_dropped_process>:
	postfix_print(log_output, flags, level);
	log_output_flush(log_output);
}

void log_output_dropped_process(const struct log_output *log_output, u32_t cnt)
{
    21c0:	b570      	push	{r4, r5, r6, lr}
    21c2:	b082      	sub	sp, #8
	char buf[5];
	int len;
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = log_output->func;
    21c4:	6804      	ldr	r4, [r0, #0]
	struct device *dev = (struct device *)log_output->control_block->ctx;
    21c6:	6843      	ldr	r3, [r0, #4]
    21c8:	685d      	ldr	r5, [r3, #4]

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    21ca:	f242 730f 	movw	r3, #9999	; 0x270f
    21ce:	428b      	cmp	r3, r1
    21d0:	bf28      	it	cs
    21d2:	460b      	movcs	r3, r1
    21d4:	4a0c      	ldr	r2, [pc, #48]	; (2208 <log_output_dropped_process+0x48>)
    21d6:	2105      	movs	r1, #5
    21d8:	4668      	mov	r0, sp
    21da:	f00a ff36 	bl	d04a <snprintk>
    21de:	4606      	mov	r6, r0

	buffer_write(outf, (u8_t *)prefix, sizeof(prefix) - 1, dev);
    21e0:	462b      	mov	r3, r5
    21e2:	220b      	movs	r2, #11
    21e4:	4909      	ldr	r1, [pc, #36]	; (220c <log_output_dropped_process+0x4c>)
    21e6:	4620      	mov	r0, r4
    21e8:	f00b fb61 	bl	d8ae <buffer_write>
	buffer_write(outf, buf, len, dev);
    21ec:	462b      	mov	r3, r5
    21ee:	4632      	mov	r2, r6
    21f0:	4669      	mov	r1, sp
    21f2:	4620      	mov	r0, r4
    21f4:	f00b fb5b 	bl	d8ae <buffer_write>
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
    21f8:	462b      	mov	r3, r5
    21fa:	221b      	movs	r2, #27
    21fc:	4904      	ldr	r1, [pc, #16]	; (2210 <log_output_dropped_process+0x50>)
    21fe:	4620      	mov	r0, r4
    2200:	f00b fb55 	bl	d8ae <buffer_write>
}
    2204:	b002      	add	sp, #8
    2206:	bd70      	pop	{r4, r5, r6, pc}
    2208:	0001161c 	.word	0x0001161c
    220c:	00011670 	.word	0x00011670
    2210:	00011654 	.word	0x00011654

00002214 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(u32_t frequency)
{
	timestamp_div = 1U;
    2214:	4b07      	ldr	r3, [pc, #28]	; (2234 <log_output_timestamp_freq_set+0x20>)
    2216:	2201      	movs	r2, #1
    2218:	601a      	str	r2, [r3, #0]
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
    221a:	4b07      	ldr	r3, [pc, #28]	; (2238 <log_output_timestamp_freq_set+0x24>)
    221c:	4298      	cmp	r0, r3
    221e:	d905      	bls.n	222c <log_output_timestamp_freq_set+0x18>
		frequency /= 2U;
    2220:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
    2222:	4a04      	ldr	r2, [pc, #16]	; (2234 <log_output_timestamp_freq_set+0x20>)
    2224:	6813      	ldr	r3, [r2, #0]
    2226:	005b      	lsls	r3, r3, #1
    2228:	6013      	str	r3, [r2, #0]
    222a:	e7f6      	b.n	221a <log_output_timestamp_freq_set+0x6>
	}

	freq = frequency;
    222c:	4b03      	ldr	r3, [pc, #12]	; (223c <log_output_timestamp_freq_set+0x28>)
    222e:	6018      	str	r0, [r3, #0]
}
    2230:	4770      	bx	lr
    2232:	bf00      	nop
    2234:	20003880 	.word	0x20003880
    2238:	000f4240 	.word	0x000f4240
    223c:	2000387c 	.word	0x2000387c

00002240 <log_backend_uart_init>:

	log_backend_std_put(&log_output, flag, msg);
}

static void log_backend_uart_init(void)
{
    2240:	b508      	push	{r3, lr}
    2242:	4806      	ldr	r0, [pc, #24]	; (225c <log_backend_uart_init+0x1c>)
    2244:	f008 f840 	bl	a2c8 <z_impl_device_get_binding>
	struct device *dev;

	dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
	assert(dev);
    2248:	b110      	cbz	r0, 2250 <log_backend_uart_init+0x10>
 * @param ctx		User context.
 */
static inline void log_output_ctx_set(const struct log_output *log_output,
				      void *ctx)
{
	log_output->control_block->ctx = ctx;
    224a:	4a05      	ldr	r2, [pc, #20]	; (2260 <log_backend_uart_init+0x20>)
    224c:	6050      	str	r0, [r2, #4]

	log_output_ctx_set(&log_output, dev);
}
    224e:	bd08      	pop	{r3, pc}
	assert(dev);
    2250:	4b04      	ldr	r3, [pc, #16]	; (2264 <log_backend_uart_init+0x24>)
    2252:	4a05      	ldr	r2, [pc, #20]	; (2268 <log_backend_uart_init+0x28>)
    2254:	212d      	movs	r1, #45	; 0x2d
    2256:	4805      	ldr	r0, [pc, #20]	; (226c <log_backend_uart_init+0x2c>)
    2258:	f009 fd28 	bl	bcac <__assert_func>
    225c:	00010ea4 	.word	0x00010ea4
    2260:	2000388c 	.word	0x2000388c
    2264:	00011690 	.word	0x00011690
    2268:	00011718 	.word	0x00011718
    226c:	00011694 	.word	0x00011694

00002270 <panic>:

static void panic(struct log_backend const *const backend)
{
    2270:	b508      	push	{r3, lr}
 * @param log_output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const log_output)
{
	log_output_flush(log_output);
    2272:	4802      	ldr	r0, [pc, #8]	; (227c <panic+0xc>)
    2274:	f00b fcc2 	bl	dbfc <log_output_flush>
	log_backend_std_panic(&log_output);
}
    2278:	bd08      	pop	{r3, pc}
    227a:	bf00      	nop
    227c:	00011748 	.word	0x00011748

00002280 <dropped>:

static void dropped(const struct log_backend *const backend, u32_t cnt)
{
    2280:	b508      	push	{r3, lr}
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const log_output, u32_t cnt)
{
	log_output_dropped_process(log_output, cnt);
    2282:	4802      	ldr	r0, [pc, #8]	; (228c <dropped+0xc>)
    2284:	f7ff ff9c 	bl	21c0 <log_output_dropped_process>
	ARG_UNUSED(backend);

	log_backend_std_dropped(&log_output, cnt);
}
    2288:	bd08      	pop	{r3, pc}
    228a:	bf00      	nop
    228c:	00011748 	.word	0x00011748

00002290 <put>:
{
    2290:	b510      	push	{r4, lr}
    2292:	460c      	mov	r4, r1
	log_msg_get(msg);
    2294:	4608      	mov	r0, r1
    2296:	f00b fa86 	bl	d7a6 <log_msg_get>
	log_output_msg_process(log_output, msg, flags);
    229a:	220f      	movs	r2, #15
    229c:	4621      	mov	r1, r4
    229e:	4803      	ldr	r0, [pc, #12]	; (22ac <put+0x1c>)
    22a0:	f00b fcd5 	bl	dc4e <log_output_msg_process>
	log_msg_put(msg);
    22a4:	4620      	mov	r0, r4
    22a6:	f00b faa2 	bl	d7ee <log_msg_put>
}
    22aa:	bd10      	pop	{r4, pc}
    22ac:	00011748 	.word	0x00011748

000022b0 <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
    22b0:	4b01      	ldr	r3, [pc, #4]	; (22b8 <log_backend_rtt_init+0x8>)
    22b2:	2201      	movs	r2, #1
    22b4:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
    22b6:	4770      	bx	lr
    22b8:	2000594d 	.word	0x2000594d

000022bc <on_failed_write>:
{
    22bc:	b508      	push	{r3, lr}
	if (retry_cnt == 0) {
    22be:	b918      	cbnz	r0, 22c8 <on_failed_write+0xc>
		host_present = false;
    22c0:	4b08      	ldr	r3, [pc, #32]	; (22e4 <on_failed_write+0x28>)
    22c2:	2200      	movs	r2, #0
    22c4:	701a      	strb	r2, [r3, #0]
}
    22c6:	bd08      	pop	{r3, pc}
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
    22c8:	4b07      	ldr	r3, [pc, #28]	; (22e8 <on_failed_write+0x2c>)
    22ca:	781b      	ldrb	r3, [r3, #0]
	} else if (is_sync_mode()) {
    22cc:	b123      	cbz	r3, 22d8 <on_failed_write+0x1c>
	z_impl_k_busy_wait(usec_to_wait);
    22ce:	f241 3088 	movw	r0, #5000	; 0x1388
    22d2:	f00d fff7 	bl	102c4 <z_impl_k_busy_wait>
}
    22d6:	e7f6      	b.n	22c6 <on_failed_write+0xa>
	return z_impl_k_sleep(timeout);
    22d8:	20a4      	movs	r0, #164	; 0xa4
    22da:	2100      	movs	r1, #0
    22dc:	f008 ffdc 	bl	b298 <z_impl_k_sleep>
}
    22e0:	e7f1      	b.n	22c6 <on_failed_write+0xa>
    22e2:	bf00      	nop
    22e4:	2000594d 	.word	0x2000594d
    22e8:	2000594e 	.word	0x2000594e

000022ec <on_write>:
{
    22ec:	b538      	push	{r3, r4, r5, lr}
    22ee:	4604      	mov	r4, r0
	host_present = true;
    22f0:	4b0a      	ldr	r3, [pc, #40]	; (231c <on_write+0x30>)
    22f2:	2201      	movs	r2, #1
    22f4:	701a      	strb	r2, [r3, #0]
	return panic_mode;
    22f6:	4b0a      	ldr	r3, [pc, #40]	; (2320 <on_write+0x34>)
    22f8:	781b      	ldrb	r3, [r3, #0]
	if (is_panic_mode()) {
    22fa:	b903      	cbnz	r3, 22fe <on_write+0x12>
}
    22fc:	bd38      	pop	{r3, r4, r5, pc}
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
    22fe:	2000      	movs	r0, #0
    2300:	f000 fa4e 	bl	27a0 <SEGGER_RTT_HasDataUp>
    2304:	2800      	cmp	r0, #0
    2306:	d0f9      	beq.n	22fc <on_write+0x10>
    2308:	4b04      	ldr	r3, [pc, #16]	; (231c <on_write+0x30>)
    230a:	781b      	ldrb	r3, [r3, #0]
    230c:	2b00      	cmp	r3, #0
    230e:	d0f5      	beq.n	22fc <on_write+0x10>
			on_failed_write(retry_cnt--);
    2310:	1e65      	subs	r5, r4, #1
    2312:	4620      	mov	r0, r4
    2314:	f7ff ffd2 	bl	22bc <on_failed_write>
    2318:	462c      	mov	r4, r5
    231a:	e7f0      	b.n	22fe <on_write+0x12>
    231c:	2000594d 	.word	0x2000594d
    2320:	2000594e 	.word	0x2000594e

00002324 <data_out_block_mode>:
{
    2324:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2326:	4606      	mov	r6, r0
    2328:	460d      	mov	r5, r1
	int retry_cnt = CONFIG_LOG_BACKEND_RTT_RETRY_CNT;
    232a:	2704      	movs	r7, #4
    232c:	e012      	b.n	2354 <data_out_block_mode+0x30>
	return z_impl_k_mutex_lock(mutex, timeout);
    232e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2332:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2336:	4817      	ldr	r0, [pc, #92]	; (2394 <data_out_block_mode+0x70>)
    2338:	f008 fb08 	bl	a94c <z_impl_k_mutex_lock>
			RTT_LOCK();
    233c:	e00e      	b.n	235c <data_out_block_mode+0x38>
	return z_impl_k_mutex_unlock(mutex);
    233e:	4815      	ldr	r0, [pc, #84]	; (2394 <data_out_block_mode+0x70>)
    2340:	f008 fb8e 	bl	aa60 <z_impl_k_mutex_unlock>
    2344:	e014      	b.n	2370 <data_out_block_mode+0x4c>
			on_write(retry_cnt);
    2346:	4638      	mov	r0, r7
    2348:	f7ff ffd0 	bl	22ec <on_write>
	} while ((ret == 0) && host_present);
    234c:	b9dc      	cbnz	r4, 2386 <data_out_block_mode+0x62>
    234e:	4b12      	ldr	r3, [pc, #72]	; (2398 <data_out_block_mode+0x74>)
    2350:	781b      	ldrb	r3, [r3, #0]
    2352:	b1c3      	cbz	r3, 2386 <data_out_block_mode+0x62>
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
    2354:	4b11      	ldr	r3, [pc, #68]	; (239c <data_out_block_mode+0x78>)
    2356:	781b      	ldrb	r3, [r3, #0]
		if (!is_sync_mode()) {
    2358:	2b00      	cmp	r3, #0
    235a:	d0e8      	beq.n	232e <data_out_block_mode+0xa>
		ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
    235c:	462a      	mov	r2, r5
    235e:	4631      	mov	r1, r6
    2360:	2000      	movs	r0, #0
    2362:	f000 f9b9 	bl	26d8 <SEGGER_RTT_WriteSkipNoLock>
    2366:	4604      	mov	r4, r0
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
    2368:	4b0c      	ldr	r3, [pc, #48]	; (239c <data_out_block_mode+0x78>)
    236a:	781b      	ldrb	r3, [r3, #0]
		if (!is_sync_mode()) {
    236c:	2b00      	cmp	r3, #0
    236e:	d0e6      	beq.n	233e <data_out_block_mode+0x1a>
		if (ret) {
    2370:	2c00      	cmp	r4, #0
    2372:	d1e8      	bne.n	2346 <data_out_block_mode+0x22>
		} else if (host_present) {
    2374:	4b08      	ldr	r3, [pc, #32]	; (2398 <data_out_block_mode+0x74>)
    2376:	781b      	ldrb	r3, [r3, #0]
    2378:	2b00      	cmp	r3, #0
    237a:	d0e7      	beq.n	234c <data_out_block_mode+0x28>
			retry_cnt--;
    237c:	3f01      	subs	r7, #1
			on_failed_write(retry_cnt);
    237e:	4638      	mov	r0, r7
    2380:	f7ff ff9c 	bl	22bc <on_failed_write>
    2384:	e7e2      	b.n	234c <data_out_block_mode+0x28>
	return ((ret == 0) && host_present) ? 0 : length;
    2386:	b914      	cbnz	r4, 238e <data_out_block_mode+0x6a>
    2388:	4b03      	ldr	r3, [pc, #12]	; (2398 <data_out_block_mode+0x74>)
    238a:	781b      	ldrb	r3, [r3, #0]
    238c:	b903      	cbnz	r3, 2390 <data_out_block_mode+0x6c>
    238e:	462c      	mov	r4, r5
}
    2390:	4620      	mov	r0, r4
    2392:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2394:	200004ac 	.word	0x200004ac
    2398:	2000594d 	.word	0x2000594d
    239c:	2000594e 	.word	0x2000594e

000023a0 <panic>:

static void panic(struct log_backend const *const backend)
{
    23a0:	b508      	push	{r3, lr}
	log_output_flush(log_output);
    23a2:	4803      	ldr	r0, [pc, #12]	; (23b0 <panic+0x10>)
    23a4:	f00b fc2a 	bl	dbfc <log_output_flush>
	log_backend_std_panic(&log_output);
	panic_mode = true;
    23a8:	4b02      	ldr	r3, [pc, #8]	; (23b4 <panic+0x14>)
    23aa:	2201      	movs	r2, #1
    23ac:	701a      	strb	r2, [r3, #0]
}
    23ae:	bd08      	pop	{r3, pc}
    23b0:	00011780 	.word	0x00011780
    23b4:	2000594e 	.word	0x2000594e

000023b8 <dropped>:

static void dropped(const struct log_backend *const backend, u32_t cnt)
{
    23b8:	b508      	push	{r3, lr}
	log_output_dropped_process(log_output, cnt);
    23ba:	4802      	ldr	r0, [pc, #8]	; (23c4 <dropped+0xc>)
    23bc:	f7ff ff00 	bl	21c0 <log_output_dropped_process>
	ARG_UNUSED(backend);

	log_backend_std_dropped(&log_output, cnt);
}
    23c0:	bd08      	pop	{r3, pc}
    23c2:	bf00      	nop
    23c4:	00011780 	.word	0x00011780

000023c8 <put>:
{
    23c8:	b510      	push	{r4, lr}
    23ca:	460c      	mov	r4, r1
	log_msg_get(msg);
    23cc:	4608      	mov	r0, r1
    23ce:	f00b f9ea 	bl	d7a6 <log_msg_get>
	log_output_msg_process(log_output, msg, flags);
    23d2:	220f      	movs	r2, #15
    23d4:	4621      	mov	r1, r4
    23d6:	4803      	ldr	r0, [pc, #12]	; (23e4 <put+0x1c>)
    23d8:	f00b fc39 	bl	dc4e <log_output_msg_process>
	log_msg_put(msg);
    23dc:	4620      	mov	r0, r4
    23de:	f00b fa06 	bl	d7ee <log_msg_put>
}
    23e2:	bd10      	pop	{r4, pc}
    23e4:	00011780 	.word	0x00011780

000023e8 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
    23e8:	b510      	push	{r4, lr}
    23ea:	4604      	mov	r4, r0
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
    23ec:	280a      	cmp	r0, #10
    23ee:	d007      	beq.n	2400 <console_out+0x18>
		uart_poll_out(uart_console_dev, '\r');
	}
	uart_poll_out(uart_console_dev, c);
    23f0:	4b07      	ldr	r3, [pc, #28]	; (2410 <console_out+0x28>)
    23f2:	6818      	ldr	r0, [r3, #0]
    23f4:	b2e1      	uxtb	r1, r4
	const struct uart_driver_api *api =
    23f6:	6883      	ldr	r3, [r0, #8]
	api->poll_out(dev, out_char);
    23f8:	685b      	ldr	r3, [r3, #4]
    23fa:	4798      	blx	r3

	return c;
}
    23fc:	4620      	mov	r0, r4
    23fe:	bd10      	pop	{r4, pc}
		uart_poll_out(uart_console_dev, '\r');
    2400:	4b03      	ldr	r3, [pc, #12]	; (2410 <console_out+0x28>)
    2402:	6818      	ldr	r0, [r3, #0]
	const struct uart_driver_api *api =
    2404:	6883      	ldr	r3, [r0, #8]
	api->poll_out(dev, out_char);
    2406:	685b      	ldr	r3, [r3, #4]
    2408:	210d      	movs	r1, #13
    240a:	4798      	blx	r3
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_poll_out(dev, out_char);
}
    240c:	e7f0      	b.n	23f0 <console_out+0x8>
    240e:	bf00      	nop
    2410:	200038bc 	.word	0x200038bc

00002414 <uart_console_hook_install>:
 *
 * @return N/A
 */

static void uart_console_hook_install(void)
{
    2414:	b510      	push	{r4, lr}
	__stdout_hook_install(console_out);
    2416:	4c04      	ldr	r4, [pc, #16]	; (2428 <uart_console_hook_install+0x14>)
    2418:	4620      	mov	r0, r4
    241a:	f001 f819 	bl	3450 <__stdout_hook_install>
	__printk_hook_install(console_out);
    241e:	4620      	mov	r0, r4
    2420:	f7fe ff8c 	bl	133c <__printk_hook_install>
}
    2424:	bd10      	pop	{r4, pc}
    2426:	bf00      	nop
    2428:	000023e9 	.word	0x000023e9

0000242c <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
    242c:	b508      	push	{r3, lr}
    242e:	4804      	ldr	r0, [pc, #16]	; (2440 <uart_console_init+0x14>)
    2430:	f007 ff4a 	bl	a2c8 <z_impl_device_get_binding>

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    2434:	4b03      	ldr	r3, [pc, #12]	; (2444 <uart_console_init+0x18>)
    2436:	6018      	str	r0, [r3, #0]
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
    2438:	f7ff ffec 	bl	2414 <uart_console_hook_install>

	return 0;
}
    243c:	2000      	movs	r0, #0
    243e:	bd08      	pop	{r3, pc}
    2440:	00010ea4 	.word	0x00010ea4
    2444:	200038bc 	.word	0x200038bc

00002448 <nrf_power_clock_isr>:
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
    2448:	b508      	push	{r3, lr}
	ARG_UNUSED(arg);
	struct device *dev = DEVICE_GET(clock_nrf);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
    244a:	2101      	movs	r1, #1
    244c:	f44f 7080 	mov.w	r0, #256	; 0x100
    2450:	f00b fc4b 	bl	dcea <clock_event_check_and_clean>
    2454:	b128      	cbz	r0, 2462 <nrf_power_clock_isr+0x1a>
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    2456:	2100      	movs	r1, #0
    2458:	480a      	ldr	r0, [pc, #40]	; (2484 <nrf_power_clock_isr+0x3c>)
    245a:	f00b fc6c 	bl	dd36 <get_sub_data>

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
    245e:	7a43      	ldrb	r3, [r0, #9]
    2460:	b133      	cbz	r3, 2470 <nrf_power_clock_isr+0x28>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
		}
	}

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_LFCLKSTARTED,
    2462:	2102      	movs	r1, #2
    2464:	f44f 7082 	mov.w	r0, #260	; 0x104
    2468:	f00b fc3f 	bl	dcea <clock_event_check_and_clean>
    246c:	b928      	cbnz	r0, 247a <nrf_power_clock_isr+0x32>
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
    246e:	bd08      	pop	{r3, pc}
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    2470:	2100      	movs	r1, #0
    2472:	4804      	ldr	r0, [pc, #16]	; (2484 <nrf_power_clock_isr+0x3c>)
    2474:	f00b fd34 	bl	dee0 <clkstarted_handle>
    2478:	e7f3      	b.n	2462 <nrf_power_clock_isr+0x1a>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    247a:	2101      	movs	r1, #1
    247c:	4801      	ldr	r0, [pc, #4]	; (2484 <nrf_power_clock_isr+0x3c>)
    247e:	f00b fd2f 	bl	dee0 <clkstarted_handle>
}
    2482:	e7f4      	b.n	246e <nrf_power_clock_isr+0x26>
    2484:	200003cc 	.word	0x200003cc

00002488 <set_comparator>:
	return (a - b) & COUNTER_MAX;
}

static void set_comparator(u32_t cyc)
{
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    2488:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE  void nrf_rtc_cc_set(NRF_RTC_Type * p_reg, uint32_t ch, uint32_t cc_val)
{
    p_reg->CC[ch] = cc_val;
    248c:	4b01      	ldr	r3, [pc, #4]	; (2494 <set_comparator+0xc>)
    248e:	f8c3 0540 	str.w	r0, [r3, #1344]	; 0x540
}
    2492:	4770      	bx	lr
    2494:	40011000 	.word	0x40011000

00002498 <get_comparator>:
}

NRF_STATIC_INLINE  uint32_t nrf_rtc_cc_get(NRF_RTC_Type const * p_reg, uint32_t ch)
{
    return p_reg->CC[ch];
    2498:	4b01      	ldr	r3, [pc, #4]	; (24a0 <get_comparator+0x8>)
    249a:	f8d3 0540 	ldr.w	r0, [r3, #1344]	; 0x540

static u32_t get_comparator(void)
{
	return nrf_rtc_cc_get(RTC, 0);
}
    249e:	4770      	bx	lr
    24a0:	40011000 	.word	0x40011000

000024a4 <event_clear>:

static void event_clear(void)
{
    24a4:	b082      	sub	sp, #8
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE void nrf_rtc_event_clear(NRF_RTC_Type * p_reg, nrf_rtc_event_t event)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    24a6:	4b04      	ldr	r3, [pc, #16]	; (24b8 <event_clear+0x14>)
    24a8:	2200      	movs	r2, #0
    24aa:	601a      	str	r2, [r3, #0]
#if __CORTEX_M == 0x04
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    24ac:	681b      	ldr	r3, [r3, #0]
    24ae:	9301      	str	r3, [sp, #4]
    (void)dummy;
    24b0:	9b01      	ldr	r3, [sp, #4]
	nrf_rtc_event_clear(RTC, NRF_RTC_EVENT_COMPARE_0);
}
    24b2:	b002      	add	sp, #8
    24b4:	4770      	bx	lr
    24b6:	bf00      	nop
    24b8:	40011140 	.word	0x40011140

000024bc <event_enable>:
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
    24bc:	4b02      	ldr	r3, [pc, #8]	; (24c8 <event_enable+0xc>)
    24be:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    24c2:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344

static void event_enable(void)
{
	nrf_rtc_event_enable(RTC, NRF_RTC_INT_COMPARE0_MASK);
}
    24c6:	4770      	bx	lr
    24c8:	40011000 	.word	0x40011000

000024cc <int_disable>:
    p_reg->INTENCLR = mask;
    24cc:	4b02      	ldr	r3, [pc, #8]	; (24d8 <int_disable+0xc>)
    24ce:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    24d2:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

static void int_disable(void)
{
	nrf_rtc_int_disable(RTC, NRF_RTC_INT_COMPARE0_MASK);
}
    24d6:	4770      	bx	lr
    24d8:	40011000 	.word	0x40011000

000024dc <int_enable>:
    p_reg->INTENSET = mask;
    24dc:	4b02      	ldr	r3, [pc, #8]	; (24e8 <int_enable+0xc>)
    24de:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    24e2:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

static void int_enable(void)
{
	nrf_rtc_int_enable(RTC, NRF_RTC_INT_COMPARE0_MASK);
}
    24e6:	4770      	bx	lr
    24e8:	40011000 	.word	0x40011000

000024ec <counter>:
     return p_reg->COUNTER;
    24ec:	4b01      	ldr	r3, [pc, #4]	; (24f4 <counter+0x8>)
    24ee:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

static u32_t counter(void)
{
	return nrf_rtc_counter_get(RTC);
}
    24f2:	4770      	bx	lr
    24f4:	40011000 	.word	0x40011000

000024f8 <rtc1_nrf_isr>:
 * probably better abstract that at some point (e.g. query and reset
 * it by pointer at runtime, maybe?) so we don't have this leaky
 * symbol.
 */
void rtc1_nrf_isr(void *arg)
{
    24f8:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(arg);
	event_clear();
    24fa:	f7ff ffd3 	bl	24a4 <event_clear>

	u32_t t = get_comparator();
    24fe:	f7ff ffcb 	bl	2498 <get_comparator>
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
    2502:	4d05      	ldr	r5, [pc, #20]	; (2518 <rtc1_nrf_isr+0x20>)
    2504:	682c      	ldr	r4, [r5, #0]
    2506:	4621      	mov	r1, r4
    2508:	f00b fd20 	bl	df4c <counter_sub>

	last_count += dticks * CYC_PER_TICK;
    250c:	4404      	add	r4, r0
    250e:	602c      	str	r4, [r5, #0]
		 * so it won't get preempted by the interrupt.
		 */
		set_absolute_ticks(last_count + CYC_PER_TICK);
	}

	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    2510:	f009 f8c2 	bl	b698 <z_clock_announce>
}
    2514:	bd38      	pop	{r3, r4, r5, pc}
    2516:	bf00      	nop
    2518:	200038d8 	.word	0x200038d8

0000251c <prevent_false_prev_evt>:
{
    251c:	b538      	push	{r3, r4, r5, lr}
	u32_t now = counter();
    251e:	f7ff ffe5 	bl	24ec <counter>
    2522:	4604      	mov	r4, r0
	prev_val = get_comparator();
    2524:	f7ff ffb8 	bl	2498 <get_comparator>
    2528:	4605      	mov	r5, r0
	event_clear();
    252a:	f7ff ffbb 	bl	24a4 <event_clear>
	set_comparator(now);
    252e:	4620      	mov	r0, r4
    2530:	f7ff ffaa 	bl	2488 <set_comparator>
	event_enable();
    2534:	f7ff ffc2 	bl	24bc <event_enable>
	if (counter_sub(prev_val, now) == 1) {
    2538:	4621      	mov	r1, r4
    253a:	4628      	mov	r0, r5
    253c:	f00b fd06 	bl	df4c <counter_sub>
    2540:	2801      	cmp	r0, #1
    2542:	d005      	beq.n	2550 <prevent_false_prev_evt+0x34>
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2544:	4b05      	ldr	r3, [pc, #20]	; (255c <prevent_false_prev_evt+0x40>)
    2546:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    254a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
    254e:	bd38      	pop	{r3, r4, r5, pc}
	z_impl_k_busy_wait(usec_to_wait);
    2550:	200f      	movs	r0, #15
    2552:	f00d feb7 	bl	102c4 <z_impl_k_busy_wait>
		event_clear();
    2556:	f7ff ffa5 	bl	24a4 <event_clear>
    255a:	e7f3      	b.n	2544 <prevent_false_prev_evt+0x28>
    255c:	e000e100 	.word	0xe000e100

00002560 <z_clock_driver_init>:

int z_clock_driver_init(struct device *device)
{
    2560:	b538      	push	{r3, r4, r5, lr}
    2562:	4813      	ldr	r0, [pc, #76]	; (25b0 <z_clock_driver_init+0x50>)
    2564:	f007 feb0 	bl	a2c8 <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_LABEL(DT_INST(0, nordic_nrf_clock)));
	if (!clock) {
    2568:	b1f0      	cbz	r0, 25a8 <z_clock_driver_init+0x48>
 * @return 0 on success, negative errno on failure.
 */
static inline int clock_control_on(struct device *dev,
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
    256a:	6882      	ldr	r2, [r0, #8]
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
    256c:	6812      	ldr	r2, [r2, #0]
    256e:	2101      	movs	r1, #1
    2570:	4790      	blx	r2
    p_reg->PRESCALER = val;
    2572:	4d10      	ldr	r5, [pc, #64]	; (25b4 <z_clock_driver_init+0x54>)
    2574:	2400      	movs	r4, #0
    2576:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508

	clock_control_on(clock, CLOCK_CONTROL_NRF_SUBSYS_LF);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	event_clear();
    257a:	f7ff ff93 	bl	24a4 <event_clear>
    257e:	4b0e      	ldr	r3, [pc, #56]	; (25b8 <z_clock_driver_init+0x58>)
    2580:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    2584:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	NVIC_ClearPendingIRQ(RTC1_IRQn);
	int_enable();
    2588:	f7ff ffa8 	bl	24dc <int_enable>

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
    258c:	4622      	mov	r2, r4
    258e:	2101      	movs	r1, #1
    2590:	2011      	movs	r0, #17
    2592:	f000 f995 	bl	28c0 <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
    2596:	2011      	movs	r0, #17
    2598:	f000 f960 	bl	285c <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    259c:	2301      	movs	r3, #1
    259e:	4a07      	ldr	r2, [pc, #28]	; (25bc <z_clock_driver_init+0x5c>)
    25a0:	6013      	str	r3, [r2, #0]
    25a2:	602b      	str	r3, [r5, #0]

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
	}

	return 0;
    25a4:	4620      	mov	r0, r4
}
    25a6:	bd38      	pop	{r3, r4, r5, pc}
		return -1;
    25a8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    25ac:	e7fb      	b.n	25a6 <z_clock_driver_init+0x46>
    25ae:	bf00      	nop
    25b0:	00011798 	.word	0x00011798
    25b4:	40011000 	.word	0x40011000
    25b8:	e000e100 	.word	0xe000e100
    25bc:	40011008 	.word	0x40011008

000025c0 <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
    25c0:	b538      	push	{r3, r4, r5, lr}

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return;
	}

	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    25c2:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    25c6:	d01e      	beq.n	2606 <z_clock_set_timeout+0x46>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
    25c8:	1e44      	subs	r4, r0, #1
    25ca:	4b11      	ldr	r3, [pc, #68]	; (2610 <z_clock_set_timeout+0x50>)
    25cc:	429c      	cmp	r4, r3
    25ce:	dc01      	bgt.n	25d4 <z_clock_set_timeout+0x14>
    25d0:	2c00      	cmp	r4, #0
    25d2:	dd1b      	ble.n	260c <z_clock_set_timeout+0x4c>
    25d4:	4b0e      	ldr	r3, [pc, #56]	; (2610 <z_clock_set_timeout+0x50>)
    25d6:	429c      	cmp	r4, r3
    25d8:	dd00      	ble.n	25dc <z_clock_set_timeout+0x1c>
    25da:	4c0e      	ldr	r4, [pc, #56]	; (2614 <z_clock_set_timeout+0x54>)

	u32_t unannounced = counter_sub(counter(), last_count);
    25dc:	f7ff ff86 	bl	24ec <counter>
    25e0:	4b0d      	ldr	r3, [pc, #52]	; (2618 <z_clock_set_timeout+0x58>)
    25e2:	681d      	ldr	r5, [r3, #0]
    25e4:	4629      	mov	r1, r5
    25e6:	f00b fcb1 	bl	df4c <counter_sub>
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
    25ea:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    25ee:	d300      	bcc.n	25f2 <z_clock_set_timeout+0x32>
		ticks = 0;
    25f0:	2400      	movs	r4, #0
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    25f2:	4420      	add	r0, r4
    25f4:	3001      	adds	r0, #1
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;

	/* Due to elapsed time the calculation above might produce a
	 * duration that laps the counter.  Don't let it.
	 */
	if (cyc > MAX_CYCLES) {
    25f6:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    25fa:	d300      	bcc.n	25fe <z_clock_set_timeout+0x3e>
		cyc = MAX_CYCLES;
    25fc:	4805      	ldr	r0, [pc, #20]	; (2614 <z_clock_set_timeout+0x54>)
	}

	cyc += last_count;
	set_protected_absolute_ticks(cyc);
    25fe:	4428      	add	r0, r5
    2600:	f00b fcda 	bl	dfb8 <set_protected_absolute_ticks>
}
    2604:	bd38      	pop	{r3, r4, r5, pc}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    2606:	f500 0000 	add.w	r0, r0, #8388608	; 0x800000
    260a:	e7dd      	b.n	25c8 <z_clock_set_timeout+0x8>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
    260c:	2400      	movs	r4, #0
    260e:	e7e5      	b.n	25dc <z_clock_set_timeout+0x1c>
    2610:	007ffffe 	.word	0x007ffffe
    2614:	007fffff 	.word	0x007fffff
    2618:	200038d8 	.word	0x200038d8

0000261c <z_clock_elapsed>:

u32_t z_clock_elapsed(void)
{
    261c:	b510      	push	{r4, lr}
	__asm__ volatile(
    261e:	f04f 0320 	mov.w	r3, #32
    2622:	f3ef 8411 	mrs	r4, BASEPRI
    2626:	f383 8811 	msr	BASEPRI, r3
    262a:	f3bf 8f6f 	isb	sy
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
    262e:	f7ff ff5d 	bl	24ec <counter>
    2632:	4b04      	ldr	r3, [pc, #16]	; (2644 <z_clock_elapsed+0x28>)
    2634:	6819      	ldr	r1, [r3, #0]
    2636:	f00b fc89 	bl	df4c <counter_sub>
	__asm__ volatile(
    263a:	f384 8811 	msr	BASEPRI, r4
    263e:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
    2642:	bd10      	pop	{r4, pc}
    2644:	200038d8 	.word	0x200038d8

00002648 <z_timer_cycle_get_32>:

u32_t z_timer_cycle_get_32(void)
{
    2648:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
    264a:	f04f 0320 	mov.w	r3, #32
    264e:	f3ef 8511 	mrs	r5, BASEPRI
    2652:	f383 8811 	msr	BASEPRI, r3
    2656:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) + last_count;
    265a:	f7ff ff47 	bl	24ec <counter>
    265e:	4b05      	ldr	r3, [pc, #20]	; (2674 <z_timer_cycle_get_32+0x2c>)
    2660:	681c      	ldr	r4, [r3, #0]
    2662:	4621      	mov	r1, r4
    2664:	f00b fc72 	bl	df4c <counter_sub>
    2668:	4420      	add	r0, r4
	__asm__ volatile(
    266a:	f385 8811 	msr	BASEPRI, r5
    266e:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
    2672:	bd38      	pop	{r3, r4, r5, pc}
    2674:	200038d8 	.word	0x200038d8

00002678 <_DoInit>:
  SEGGER_RTT_CB* p;
  //
  // Initialize control block
  //
  p = &_SEGGER_RTT;
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    2678:	4b11      	ldr	r3, [pc, #68]	; (26c0 <_DoInit+0x48>)
    267a:	2203      	movs	r2, #3
    267c:	611a      	str	r2, [r3, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    267e:	615a      	str	r2, [r3, #20]
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
    2680:	4910      	ldr	r1, [pc, #64]	; (26c4 <_DoInit+0x4c>)
    2682:	6199      	str	r1, [r3, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
    2684:	4a10      	ldr	r2, [pc, #64]	; (26c8 <_DoInit+0x50>)
    2686:	61da      	str	r2, [r3, #28]
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
    2688:	f44f 6280 	mov.w	r2, #1024	; 0x400
    268c:	621a      	str	r2, [r3, #32]
  p->aUp[0].RdOff         = 0u;
    268e:	2200      	movs	r2, #0
    2690:	629a      	str	r2, [r3, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
    2692:	625a      	str	r2, [r3, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    2694:	62da      	str	r2, [r3, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
    2696:	6619      	str	r1, [r3, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
    2698:	490c      	ldr	r1, [pc, #48]	; (26cc <_DoInit+0x54>)
    269a:	6659      	str	r1, [r3, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
    269c:	2110      	movs	r1, #16
    269e:	6699      	str	r1, [r3, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
    26a0:	671a      	str	r2, [r3, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
    26a2:	66da      	str	r2, [r3, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    26a4:	675a      	str	r2, [r3, #116]	; 0x74
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  strcpy(&p->acID[7], "RTT");
    26a6:	4a0a      	ldr	r2, [pc, #40]	; (26d0 <_DoInit+0x58>)
    26a8:	6810      	ldr	r0, [r2, #0]
    26aa:	f8c3 0007 	str.w	r0, [r3, #7]
  strcpy(&p->acID[0], "SEGGER");
    26ae:	4a09      	ldr	r2, [pc, #36]	; (26d4 <_DoInit+0x5c>)
    26b0:	e892 0003 	ldmia.w	r2, {r0, r1}
    26b4:	6018      	str	r0, [r3, #0]
    26b6:	8099      	strh	r1, [r3, #4]
  p->acID[6] = ' ';
    26b8:	2220      	movs	r2, #32
    26ba:	719a      	strb	r2, [r3, #6]
}
    26bc:	4770      	bx	lr
    26be:	bf00      	nop
    26c0:	200038dc 	.word	0x200038dc
    26c4:	000117f0 	.word	0x000117f0
    26c8:	20003994 	.word	0x20003994
    26cc:	20003984 	.word	0x20003984
    26d0:	000117fc 	.word	0x000117fc
    26d4:	00011800 	.word	0x00011800

000026d8 <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    26d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    26dc:	4604      	mov	r4, r0
    26de:	460e      	mov	r6, r1
    26e0:	4615      	mov	r5, r2
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = &_SEGGER_RTT.aUp[BufferIndex];
  RdOff = pRing->RdOff;
    26e2:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    26e6:	4a2d      	ldr	r2, [pc, #180]	; (279c <SEGGER_RTT_WriteSkipNoLock+0xc4>)
    26e8:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
    26ec:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
    26ee:	6a57      	ldr	r7, [r2, #36]	; 0x24
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
    26f0:	42bb      	cmp	r3, r7
    26f2:	d84b      	bhi.n	278c <SEGGER_RTT_WriteSkipNoLock+0xb4>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
    26f4:	eb00 0240 	add.w	r2, r0, r0, lsl #1
    26f8:	4928      	ldr	r1, [pc, #160]	; (279c <SEGGER_RTT_WriteSkipNoLock+0xc4>)
    26fa:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
    26fe:	f8d2 8020 	ldr.w	r8, [r2, #32]
    2702:	eba8 0907 	sub.w	r9, r8, r7
    2706:	f109 32ff 	add.w	r2, r9, #4294967295	; 0xffffffff
    if (Avail >= NumBytes) {                            // Case 1)?
    270a:	4295      	cmp	r5, r2
    270c:	d904      	bls.n	2718 <SEGGER_RTT_WriteSkipNoLock+0x40>
CopyStraight:
      memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
      pRing->WrOff = WrOff + NumBytes;
      return 1;
    }
    Avail += RdOff;                                     // Space incl. wrap-around
    270e:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
    2710:	429d      	cmp	r5, r3
    2712:	d917      	bls.n	2744 <SEGGER_RTT_WriteSkipNoLock+0x6c>
    Avail = RdOff - WrOff - 1u;
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
    2714:	2000      	movs	r0, #0
    2716:	e03e      	b.n	2796 <SEGGER_RTT_WriteSkipNoLock+0xbe>
      memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
    2718:	f8df 8080 	ldr.w	r8, [pc, #128]	; 279c <SEGGER_RTT_WriteSkipNoLock+0xc4>
    271c:	1c63      	adds	r3, r4, #1
    271e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    2722:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
    2726:	6858      	ldr	r0, [r3, #4]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    2728:	462a      	mov	r2, r5
    272a:	4631      	mov	r1, r6
    272c:	4438      	add	r0, r7
    272e:	f00d ff38 	bl	105a2 <memcpy>
      pRing->WrOff = WrOff + NumBytes;
    2732:	443d      	add	r5, r7
    2734:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    2738:	eb08 08c4 	add.w	r8, r8, r4, lsl #3
    273c:	f8c8 5024 	str.w	r5, [r8, #36]	; 0x24
      return 1;
    2740:	2001      	movs	r0, #1
    2742:	e028      	b.n	2796 <SEGGER_RTT_WriteSkipNoLock+0xbe>
      memcpy(pRing->pBuffer + WrOff, pData, Rem);       // Copy 1st chunk
    2744:	1c43      	adds	r3, r0, #1
    2746:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    274a:	4a14      	ldr	r2, [pc, #80]	; (279c <SEGGER_RTT_WriteSkipNoLock+0xc4>)
    274c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    2750:	6858      	ldr	r0, [r3, #4]
    2752:	464a      	mov	r2, r9
    2754:	4631      	mov	r1, r6
    2756:	4438      	add	r0, r7
    2758:	f00d ff23 	bl	105a2 <memcpy>
      NumBytes -= Rem;
    275c:	eba7 0708 	sub.w	r7, r7, r8
      if (NumBytes) {
    2760:	197f      	adds	r7, r7, r5
    2762:	d00b      	beq.n	277c <SEGGER_RTT_WriteSkipNoLock+0xa4>
        memcpy(pRing->pBuffer, pData + Rem, NumBytes);
    2764:	1c63      	adds	r3, r4, #1
    2766:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    276a:	4a0c      	ldr	r2, [pc, #48]	; (279c <SEGGER_RTT_WriteSkipNoLock+0xc4>)
    276c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    2770:	463a      	mov	r2, r7
    2772:	eb06 0109 	add.w	r1, r6, r9
    2776:	6858      	ldr	r0, [r3, #4]
    2778:	f00d ff13 	bl	105a2 <memcpy>
      pRing->WrOff = NumBytes;
    277c:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    2780:	4b06      	ldr	r3, [pc, #24]	; (279c <SEGGER_RTT_WriteSkipNoLock+0xc4>)
    2782:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
    2786:	6267      	str	r7, [r4, #36]	; 0x24
      return 1;
    2788:	2001      	movs	r0, #1
    278a:	e004      	b.n	2796 <SEGGER_RTT_WriteSkipNoLock+0xbe>
    Avail = RdOff - WrOff - 1u;
    278c:	1bdb      	subs	r3, r3, r7
    278e:	3b01      	subs	r3, #1
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
    2790:	42ab      	cmp	r3, r5
    2792:	d2c1      	bcs.n	2718 <SEGGER_RTT_WriteSkipNoLock+0x40>
  return 0;     // No space in buffer
    2794:	2000      	movs	r0, #0
}
    2796:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    279a:	bf00      	nop
    279c:	200038dc 	.word	0x200038dc

000027a0 <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = &_SEGGER_RTT.aUp[BufferIndex];
  v = pRing->RdOff;
    27a0:	4b06      	ldr	r3, [pc, #24]	; (27bc <SEGGER_RTT_HasDataUp+0x1c>)
    27a2:	eb00 0240 	add.w	r2, r0, r0, lsl #1
    27a6:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    27aa:	6a92      	ldr	r2, [r2, #40]	; 0x28
  return pRing->WrOff - v;
    27ac:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    27b0:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    27b4:	6a40      	ldr	r0, [r0, #36]	; 0x24
}
    27b6:	1a80      	subs	r0, r0, r2
    27b8:	4770      	bx	lr
    27ba:	bf00      	nop
    27bc:	200038dc 	.word	0x200038dc

000027c0 <arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
    27c0:	4a09      	ldr	r2, [pc, #36]	; (27e8 <arch_swap+0x28>)
    27c2:	6893      	ldr	r3, [r2, #8]
    27c4:	66d8      	str	r0, [r3, #108]	; 0x6c
	_current->arch.swap_return_value = _k_neg_eagain;
    27c6:	4909      	ldr	r1, [pc, #36]	; (27ec <arch_swap+0x2c>)
    27c8:	6809      	ldr	r1, [r1, #0]
    27ca:	6719      	str	r1, [r3, #112]	; 0x70

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    27cc:	4908      	ldr	r1, [pc, #32]	; (27f0 <arch_swap+0x30>)
    27ce:	684b      	ldr	r3, [r1, #4]
    27d0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    27d4:	604b      	str	r3, [r1, #4]
    27d6:	2300      	movs	r3, #0
    27d8:	f383 8811 	msr	BASEPRI, r3
    27dc:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    27e0:	6893      	ldr	r3, [r2, #8]
}
    27e2:	6f18      	ldr	r0, [r3, #112]	; 0x70
    27e4:	4770      	bx	lr
    27e6:	bf00      	nop
    27e8:	20005874 	.word	0x20005874
    27ec:	00012f9c 	.word	0x00012f9c
    27f0:	e000ed00 	.word	0xe000ed00

000027f4 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    27f4:	490f      	ldr	r1, [pc, #60]	; (2834 <z_arm_pendsv+0x40>)
    ldr r2, [r1, #_kernel_offset_to_current]
    27f6:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    27f8:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
    27fc:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    27fe:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    2802:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    2806:	2020      	movs	r0, #32
    msr BASEPRI, r0
    2808:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    280c:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    2810:	4f09      	ldr	r7, [pc, #36]	; (2838 <z_arm_pendsv+0x44>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    2812:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    2816:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
    2818:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    281a:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    281c:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
    movs r3, #0
    281e:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    2820:	66d3      	str	r3, [r2, #108]	; 0x6c
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    2822:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    2826:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
    282a:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    282e:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
    2832:	4770      	bx	lr
    ldr r1, =_kernel
    2834:	20005874 	.word	0x20005874
    ldr v4, =_SCS_ICSR
    2838:	e000ed04 	.word	0xe000ed04

0000283c <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
    283c:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    2840:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    2842:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    2846:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    284a:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    284c:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    2850:	2902      	cmp	r1, #2
    beq _oops
    2852:	d0ff      	beq.n	2854 <_oops>

00002854 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    2854:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    2856:	f00b fbd6 	bl	e006 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    285a:	bd01      	pop	{r0, pc}

0000285c <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    285c:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    285e:	2b00      	cmp	r3, #0
    2860:	db08      	blt.n	2874 <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2862:	f000 001f 	and.w	r0, r0, #31
    2866:	095b      	lsrs	r3, r3, #5
    2868:	2201      	movs	r2, #1
    286a:	fa02 f000 	lsl.w	r0, r2, r0
    286e:	4a02      	ldr	r2, [pc, #8]	; (2878 <arch_irq_enable+0x1c>)
    2870:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    2874:	4770      	bx	lr
    2876:	bf00      	nop
    2878:	e000e100 	.word	0xe000e100

0000287c <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
    287c:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    287e:	2b00      	cmp	r3, #0
    2880:	db0d      	blt.n	289e <arch_irq_disable+0x22>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2882:	f000 001f 	and.w	r0, r0, #31
    2886:	095b      	lsrs	r3, r3, #5
    2888:	2201      	movs	r2, #1
    288a:	fa02 f000 	lsl.w	r0, r2, r0
    288e:	3320      	adds	r3, #32
    2890:	4a03      	ldr	r2, [pc, #12]	; (28a0 <arch_irq_disable+0x24>)
    2892:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    2896:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    289a:	f3bf 8f6f 	isb	sy
}
    289e:	4770      	bx	lr
    28a0:	e000e100 	.word	0xe000e100

000028a4 <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    28a4:	0942      	lsrs	r2, r0, #5
    28a6:	4b05      	ldr	r3, [pc, #20]	; (28bc <arch_irq_is_enabled+0x18>)
    28a8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    28ac:	f000 001f 	and.w	r0, r0, #31
    28b0:	2301      	movs	r3, #1
    28b2:	fa03 f000 	lsl.w	r0, r3, r0
}
    28b6:	4010      	ands	r0, r2
    28b8:	4770      	bx	lr
    28ba:	bf00      	nop
    28bc:	e000e100 	.word	0xe000e100

000028c0 <z_arm_irq_priority_set>:
	} else {
		prio += _IRQ_PRIO_OFFSET;
	}
#else
	ARG_UNUSED(flags);
	prio += _IRQ_PRIO_OFFSET;
    28c0:	3101      	adds	r1, #1
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    28c2:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    28c4:	2b00      	cmp	r3, #0
    28c6:	db08      	blt.n	28da <z_arm_irq_priority_set+0x1a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    28c8:	0149      	lsls	r1, r1, #5
    28ca:	b2c9      	uxtb	r1, r1
    28cc:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    28d0:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    28d4:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
    28d8:	4770      	bx	lr
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    28da:	f000 000f 	and.w	r0, r0, #15
    28de:	0149      	lsls	r1, r1, #5
    28e0:	b2c9      	uxtb	r1, r1
    28e2:	4b01      	ldr	r3, [pc, #4]	; (28e8 <z_arm_irq_priority_set+0x28>)
    28e4:	5419      	strb	r1, [r3, r0]
}
    28e6:	4770      	bx	lr
    28e8:	e000ed14 	.word	0xe000ed14

000028ec <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_SYS_POWER_MANAGEMENT
void _arch_isr_direct_pm(void)
{
    28ec:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
    28ee:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
    28f0:	4b04      	ldr	r3, [pc, #16]	; (2904 <_arch_isr_direct_pm+0x18>)
    28f2:	6a18      	ldr	r0, [r3, #32]
    28f4:	b908      	cbnz	r0, 28fa <_arch_isr_direct_pm+0xe>

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
    28f6:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
    28f8:	bd08      	pop	{r3, pc}
		_kernel.idle = 0;
    28fa:	2200      	movs	r2, #0
    28fc:	621a      	str	r2, [r3, #32]
		z_sys_power_save_idle_exit(idle_val);
    28fe:	f00d f95f 	bl	fbc0 <z_sys_power_save_idle_exit>
    2902:	e7f8      	b.n	28f6 <_arch_isr_direct_pm+0xa>
    2904:	20005874 	.word	0x20005874

00002908 <arch_new_thread>:
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     size_t stackSize, k_thread_entry_t pEntry,
		     void *parameter1, void *parameter2, void *parameter3,
		     int priority, unsigned int options)
{
    2908:	b410      	push	{r4}
			- MPU_GUARD_ALIGN_AND_SIZE;
		stackSize -= MPU_GUARD_ALIGN_AND_SIZE_FLOAT
			- MPU_GUARD_ALIGN_AND_SIZE;
	}
#endif
	stackEnd = pStackMem + stackSize;
    290a:	188c      	adds	r4, r1, r2
#endif
#ifdef CONFIG_INIT_STACKS
	memset(stack, 0xaa, stack_size);
#endif
#if defined(CONFIG_THREAD_STACK_INFO)
	thread->stack_info.start = (uintptr_t)stack;
    290c:	6601      	str	r1, [r0, #96]	; 0x60
	thread->stack_info.size = stack_size;
    290e:	6642      	str	r2, [r0, #100]	; 0x64
	 *
	 * The initial carved stack frame only needs to contain the basic
	 * stack frame (state context), because no FP operations have been
	 * performed yet for this thread.
	 */
	pInitCtx = (struct __esf *)(Z_STACK_PTR_ALIGN(stackEnd -
    2910:	f1a4 0220 	sub.w	r2, r4, #32
    2914:	f022 0207 	bic.w	r2, r2, #7
		pInitCtx->basic.pc = (u32_t)arch_user_mode_enter;
	} else {
		pInitCtx->basic.pc = (u32_t)z_thread_entry;
	}
#else
	pInitCtx->basic.pc = (u32_t)z_thread_entry;
    2918:	4909      	ldr	r1, [pc, #36]	; (2940 <arch_new_thread+0x38>)
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
    291a:	f021 0101 	bic.w	r1, r1, #1
    291e:	6191      	str	r1, [r2, #24]
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
    2920:	6013      	str	r3, [r2, #0]
	pInitCtx->basic.a2 = (u32_t)parameter1;
    2922:	9b01      	ldr	r3, [sp, #4]
    2924:	6053      	str	r3, [r2, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
    2926:	9b02      	ldr	r3, [sp, #8]
    2928:	6093      	str	r3, [r2, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
    292a:	9b03      	ldr	r3, [sp, #12]
    292c:	60d3      	str	r3, [r2, #12]

#if defined(CONFIG_CPU_CORTEX_M)
	pInitCtx->basic.xpsr =
    292e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    2932:	61d3      	str	r3, [r2, #28]
#if defined(CONFIG_COMPILER_ISA_THUMB2)
	pInitCtx->basic.xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (u32_t)pInitCtx;
    2934:	6502      	str	r2, [r0, #80]	; 0x50

	thread->arch.basepri = 0;
    2936:	2300      	movs	r3, #0
    2938:	66c3      	str	r3, [r0, #108]	; 0x6c

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    293a:	bc10      	pop	{r4}
    293c:	4770      	bx	lr
    293e:	bf00      	nop
    2940:	0000d091 	.word	0x0000d091

00002944 <arch_switch_to_main_thread>:

void arch_switch_to_main_thread(struct k_thread *main_thread,
				k_thread_stack_t *main_stack,
				size_t main_stack_size,
				k_thread_entry_t _main)
{
    2944:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2946:	4606      	mov	r6, r0
    2948:	460c      	mov	r4, r1
    294a:	4617      	mov	r7, r2
    294c:	461d      	mov	r5, r3
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
    294e:	f000 fcb1 	bl	32b4 <z_arm_configure_static_mpu_regions>
#endif

	/* get high address of the stack, i.e. its start (stack grows down) */
	char *start_of_main_stack;

	start_of_main_stack =
    2952:	443c      	add	r4, r7
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)Z_STACK_PTR_ALIGN(start_of_main_stack);
    2954:	f024 0407 	bic.w	r4, r4, #7

	_current = main_thread;
    2958:	4b07      	ldr	r3, [pc, #28]	; (2978 <arch_switch_to_main_thread+0x34>)
    295a:	609e      	str	r6, [r3, #8]

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    295c:	4628      	mov	r0, r5
    295e:	f384 8809 	msr	PSP, r4
    2962:	2100      	movs	r1, #0
    2964:	b663      	cpsie	if
    2966:	f381 8811 	msr	BASEPRI, r1
    296a:	f3bf 8f6f 	isb	sy
    296e:	2200      	movs	r2, #0
    2970:	2300      	movs	r3, #0
    2972:	f00a fb8d 	bl	d090 <z_thread_entry>
	:
	: "r" (_main), "r" (start_of_main_stack)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    2976:	bf00      	nop
    2978:	20005874 	.word	0x20005874

0000297c <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
    297c:	4901      	ldr	r1, [pc, #4]	; (2984 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
    297e:	2210      	movs	r2, #16
	str	r2, [r1]
    2980:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
    2982:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
    2984:	e000ed10 	.word	0xe000ed10

00002988 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
    2988:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
    298a:	4040      	eors	r0, r0
	msr	BASEPRI, r0
    298c:	f380 8811 	msr	BASEPRI, r0
	isb
    2990:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
    2994:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
    2998:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
    299a:	b662      	cpsie	i
	isb
    299c:	f3bf 8f6f 	isb	sy

	bx	lr
    29a0:	4770      	bx	lr
    29a2:	bf00      	nop

000029a4 <esf_dump>:
#include <kernel.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os);

static void esf_dump(const z_arch_esf_t *esf)
{
    29a4:	b570      	push	{r4, r5, r6, lr}
    29a6:	b082      	sub	sp, #8
    29a8:	4604      	mov	r4, r0
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
    29aa:	2601      	movs	r6, #1
    29ac:	f04f 0300 	mov.w	r3, #0
    29b0:	f366 0302 	bfi	r3, r6, #0, #3
    29b4:	f36f 03c5 	bfc	r3, #3, #3
    29b8:	4d1c      	ldr	r5, [pc, #112]	; (2a2c <esf_dump+0x88>)
    29ba:	4a1d      	ldr	r2, [pc, #116]	; (2a30 <esf_dump+0x8c>)
    29bc:	1aad      	subs	r5, r5, r2
    29be:	f3c5 05c9 	ubfx	r5, r5, #3, #10
    29c2:	f365 138f 	bfi	r3, r5, #6, #10
    29c6:	f8ad 3000 	strh.w	r3, [sp]
    29ca:	6883      	ldr	r3, [r0, #8]
    29cc:	6842      	ldr	r2, [r0, #4]
    29ce:	6801      	ldr	r1, [r0, #0]
    29d0:	4818      	ldr	r0, [pc, #96]	; (2a34 <esf_dump+0x90>)
    29d2:	f7fe ff29 	bl	1828 <log_3>
		esf->basic.a1, esf->basic.a2, esf->basic.a3);
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
    29d6:	f04f 0300 	mov.w	r3, #0
    29da:	f366 0302 	bfi	r3, r6, #0, #3
    29de:	f36f 03c5 	bfc	r3, #3, #3
    29e2:	f365 138f 	bfi	r3, r5, #6, #10
    29e6:	f8ad 3000 	strh.w	r3, [sp]
    29ea:	6963      	ldr	r3, [r4, #20]
    29ec:	6922      	ldr	r2, [r4, #16]
    29ee:	68e1      	ldr	r1, [r4, #12]
    29f0:	4811      	ldr	r0, [pc, #68]	; (2a38 <esf_dump+0x94>)
    29f2:	f7fe ff19 	bl	1828 <log_3>
		esf->basic.a4, esf->basic.ip, esf->basic.lr);
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
    29f6:	f04f 0200 	mov.w	r2, #0
    29fa:	f366 0202 	bfi	r2, r6, #0, #3
    29fe:	f36f 02c5 	bfc	r2, #3, #3
    2a02:	f365 128f 	bfi	r2, r5, #6, #10
    2a06:	69e1      	ldr	r1, [r4, #28]
    2a08:	480c      	ldr	r0, [pc, #48]	; (2a3c <esf_dump+0x98>)
    2a0a:	f7fe ffd9 	bl	19c0 <log_1>
			i + 2, (u32_t)esf->s[i + 2],
			i + 3, (u32_t)esf->s[i + 3]);
	}
	LOG_ERR("fpscr:  0x%08x", esf->fpscr);
#endif
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
    2a0e:	f04f 0200 	mov.w	r2, #0
    2a12:	f366 0202 	bfi	r2, r6, #0, #3
    2a16:	f36f 02c5 	bfc	r2, #3, #3
    2a1a:	f365 128f 	bfi	r2, r5, #6, #10
    2a1e:	69a1      	ldr	r1, [r4, #24]
    2a20:	4807      	ldr	r0, [pc, #28]	; (2a40 <esf_dump+0x9c>)
    2a22:	f7fe ffcd 	bl	19c0 <log_1>
		esf->basic.pc);
}
    2a26:	b002      	add	sp, #8
    2a28:	bd70      	pop	{r4, r5, r6, pc}
    2a2a:	bf00      	nop
    2a2c:	00010cb8 	.word	0x00010cb8
    2a30:	00010c18 	.word	0x00010c18
    2a34:	00011808 	.word	0x00011808
    2a38:	00011838 	.word	0x00011838
    2a3c:	00011868 	.word	0x00011868
    2a40:	00011878 	.word	0x00011878

00002a44 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    2a44:	bf30      	wfi
    b z_SysNmiOnReset
    2a46:	f7ff bffd 	b.w	2a44 <z_SysNmiOnReset>
    2a4a:	bf00      	nop

00002a4c <z_arm_prep_c>:
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    2a4c:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    2a4e:	4b0e      	ldr	r3, [pc, #56]	; (2a88 <z_arm_prep_c+0x3c>)
    2a50:	4a0e      	ldr	r2, [pc, #56]	; (2a8c <z_arm_prep_c+0x40>)
    2a52:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    2a56:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
    2a58:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2a5c:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
    2a60:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    2a64:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    2a68:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("MRS %0, control" : "=r" (result) );
    2a6c:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
    2a70:	f023 0304 	bic.w	r3, r3, #4
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
    2a74:	f383 8814 	msr	CONTROL, r3
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
    2a78:	f007 fd92 	bl	a5a0 <z_bss_zero>
	z_data_copy();
    2a7c:	f007 fd9c 	bl	a5b8 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
    2a80:	f000 fbd8 	bl	3234 <z_arm_interrupt_init>
	z_cstart();
    2a84:	f007 fdd6 	bl	a634 <z_cstart>
    2a88:	e000ed00 	.word	0xe000ed00
    2a8c:	00000000 	.word	0x00000000

00002a90 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    2a90:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
    2a92:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    2a94:	4a0b      	ldr	r2, [pc, #44]	; (2ac4 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    2a96:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
    2a98:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    2a9a:	bf1e      	ittt	ne
	movne	r1, #0
    2a9c:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    2a9e:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
    2aa0:	f00d f88e 	blne	fbc0 <z_sys_power_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    2aa4:	b662      	cpsie	i
#endif

#endif /* CONFIG_SYS_POWER_MANAGEMENT */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    2aa6:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    2aaa:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    2aae:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 * interface function.
	 */
	cpsie i
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
    2ab2:	4905      	ldr	r1, [pc, #20]	; (2ac8 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    2ab4:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    2ab6:	c909      	ldmia	r1!, {r0, r3}
#ifdef CONFIG_EXECUTION_BENCHMARKING
	push {r0, r3}	/* Save r0 and r3 into stack */
	bl read_timer_end_of_isr
	pop {r0, r3}	/* Restore r0 and r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
    2ab8:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    2aba:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    2abe:	4903      	ldr	r1, [pc, #12]	; (2acc <_isr_wrapper+0x3c>)
	bx r1
    2ac0:	4708      	bx	r1
    2ac2:	0000      	.short	0x0000
	ldr r2, =_kernel
    2ac4:	20005874 	.word	0x20005874
	ldr r1, =_sw_isr_table
    2ac8:	00010a98 	.word	0x00010a98
	ldr r1, =z_arm_int_exit
    2acc:	00003219 	.word	0x00003219

00002ad0 <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
    2ad0:	f00b fb20 	bl	e114 <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    2ad4:	2020      	movs	r0, #32
    msr BASEPRI, r0
    2ad6:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    2ada:	4808      	ldr	r0, [pc, #32]	; (2afc <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
    2adc:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
    2ae0:	1840      	adds	r0, r0, r1
    msr PSP, r0
    2ae2:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    2ae6:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    2aea:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    2aec:	4308      	orrs	r0, r1
    msr CONTROL, r0
    2aee:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    2af2:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    2af6:	f7ff ffa9 	bl	2a4c <z_arm_prep_c>
    2afa:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
    2afc:	20006de0 	.word	0x20006de0

00002b00 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
    2b00:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    2b04:	f3ef 8109 	mrs	r1, PSP
	mov r2, lr /* EXC_RETURN */
    2b08:	4672      	mov	r2, lr

	push {r0, lr}
    2b0a:	b501      	push	{r0, lr}

	bl z_arm_fault
    2b0c:	f000 fb14 	bl	3138 <z_arm_fault>

	pop {r0, pc}
    2b10:	bd01      	pop	{r0, pc}
    2b12:	bf00      	nop

00002b14 <usage_fault>:
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t usage_fault(const z_arch_esf_t *esf)
{
    2b14:	b508      	push	{r3, lr}
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
    2b16:	f04f 0100 	mov.w	r1, #0
    2b1a:	2301      	movs	r3, #1
    2b1c:	f363 0102 	bfi	r1, r3, #0, #3
    2b20:	f36f 01c5 	bfc	r1, #3, #3
    2b24:	4b4e      	ldr	r3, [pc, #312]	; (2c60 <usage_fault+0x14c>)
    2b26:	4a4f      	ldr	r2, [pc, #316]	; (2c64 <usage_fault+0x150>)
    2b28:	1a9b      	subs	r3, r3, r2
    2b2a:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2b2e:	f363 118f 	bfi	r1, r3, #6, #10
    2b32:	484d      	ldr	r0, [pc, #308]	; (2c68 <usage_fault+0x154>)
    2b34:	f7ff f8b4 	bl	1ca0 <log_0>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    2b38:	4b4c      	ldr	r3, [pc, #304]	; (2c6c <usage_fault+0x158>)
    2b3a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2b3c:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
    2b40:	d121      	bne.n	2b86 <usage_fault+0x72>
		PR_FAULT_INFO("  Division by zero");
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    2b42:	4b4a      	ldr	r3, [pc, #296]	; (2c6c <usage_fault+0x158>)
    2b44:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2b46:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
    2b4a:	d12e      	bne.n	2baa <usage_fault+0x96>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    2b4c:	4b47      	ldr	r3, [pc, #284]	; (2c6c <usage_fault+0x158>)
    2b4e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2b50:	f413 2f00 	tst.w	r3, #524288	; 0x80000
    2b54:	d13b      	bne.n	2bce <usage_fault+0xba>
		PR_FAULT_INFO("  No coprocessor instructions");
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    2b56:	4b45      	ldr	r3, [pc, #276]	; (2c6c <usage_fault+0x158>)
    2b58:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2b5a:	f413 2f80 	tst.w	r3, #262144	; 0x40000
    2b5e:	d148      	bne.n	2bf2 <usage_fault+0xde>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    2b60:	4b42      	ldr	r3, [pc, #264]	; (2c6c <usage_fault+0x158>)
    2b62:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2b64:	f413 3f00 	tst.w	r3, #131072	; 0x20000
    2b68:	d155      	bne.n	2c16 <usage_fault+0x102>
		PR_FAULT_INFO("  Illegal use of the EPSR");
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    2b6a:	4b40      	ldr	r3, [pc, #256]	; (2c6c <usage_fault+0x158>)
    2b6c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2b6e:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    2b72:	d162      	bne.n	2c3a <usage_fault+0x126>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    2b74:	4a3d      	ldr	r2, [pc, #244]	; (2c6c <usage_fault+0x158>)
    2b76:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2b78:	ea6f 4303 	mvn.w	r3, r3, lsl #16
    2b7c:	ea6f 4313 	mvn.w	r3, r3, lsr #16
    2b80:	6293      	str	r3, [r2, #40]	; 0x28

	return reason;
}
    2b82:	2000      	movs	r0, #0
    2b84:	bd08      	pop	{r3, pc}
		PR_FAULT_INFO("  Division by zero");
    2b86:	f04f 0100 	mov.w	r1, #0
    2b8a:	2301      	movs	r3, #1
    2b8c:	f363 0102 	bfi	r1, r3, #0, #3
    2b90:	f36f 01c5 	bfc	r1, #3, #3
    2b94:	4b32      	ldr	r3, [pc, #200]	; (2c60 <usage_fault+0x14c>)
    2b96:	4a33      	ldr	r2, [pc, #204]	; (2c64 <usage_fault+0x150>)
    2b98:	1a9b      	subs	r3, r3, r2
    2b9a:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2b9e:	f363 118f 	bfi	r1, r3, #6, #10
    2ba2:	4833      	ldr	r0, [pc, #204]	; (2c70 <usage_fault+0x15c>)
    2ba4:	f7ff f87c 	bl	1ca0 <log_0>
    2ba8:	e7cb      	b.n	2b42 <usage_fault+0x2e>
		PR_FAULT_INFO("  Unaligned memory access");
    2baa:	f04f 0100 	mov.w	r1, #0
    2bae:	2301      	movs	r3, #1
    2bb0:	f363 0102 	bfi	r1, r3, #0, #3
    2bb4:	f36f 01c5 	bfc	r1, #3, #3
    2bb8:	4b29      	ldr	r3, [pc, #164]	; (2c60 <usage_fault+0x14c>)
    2bba:	4a2a      	ldr	r2, [pc, #168]	; (2c64 <usage_fault+0x150>)
    2bbc:	1a9b      	subs	r3, r3, r2
    2bbe:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2bc2:	f363 118f 	bfi	r1, r3, #6, #10
    2bc6:	482b      	ldr	r0, [pc, #172]	; (2c74 <usage_fault+0x160>)
    2bc8:	f7ff f86a 	bl	1ca0 <log_0>
    2bcc:	e7be      	b.n	2b4c <usage_fault+0x38>
		PR_FAULT_INFO("  No coprocessor instructions");
    2bce:	f04f 0100 	mov.w	r1, #0
    2bd2:	2301      	movs	r3, #1
    2bd4:	f363 0102 	bfi	r1, r3, #0, #3
    2bd8:	f36f 01c5 	bfc	r1, #3, #3
    2bdc:	4b20      	ldr	r3, [pc, #128]	; (2c60 <usage_fault+0x14c>)
    2bde:	4a21      	ldr	r2, [pc, #132]	; (2c64 <usage_fault+0x150>)
    2be0:	1a9b      	subs	r3, r3, r2
    2be2:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2be6:	f363 118f 	bfi	r1, r3, #6, #10
    2bea:	4823      	ldr	r0, [pc, #140]	; (2c78 <usage_fault+0x164>)
    2bec:	f7ff f858 	bl	1ca0 <log_0>
    2bf0:	e7b1      	b.n	2b56 <usage_fault+0x42>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
    2bf2:	f04f 0100 	mov.w	r1, #0
    2bf6:	2301      	movs	r3, #1
    2bf8:	f363 0102 	bfi	r1, r3, #0, #3
    2bfc:	f36f 01c5 	bfc	r1, #3, #3
    2c00:	4b17      	ldr	r3, [pc, #92]	; (2c60 <usage_fault+0x14c>)
    2c02:	4a18      	ldr	r2, [pc, #96]	; (2c64 <usage_fault+0x150>)
    2c04:	1a9b      	subs	r3, r3, r2
    2c06:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2c0a:	f363 118f 	bfi	r1, r3, #6, #10
    2c0e:	481b      	ldr	r0, [pc, #108]	; (2c7c <usage_fault+0x168>)
    2c10:	f7ff f846 	bl	1ca0 <log_0>
    2c14:	e7a4      	b.n	2b60 <usage_fault+0x4c>
		PR_FAULT_INFO("  Illegal use of the EPSR");
    2c16:	f04f 0100 	mov.w	r1, #0
    2c1a:	2301      	movs	r3, #1
    2c1c:	f363 0102 	bfi	r1, r3, #0, #3
    2c20:	f36f 01c5 	bfc	r1, #3, #3
    2c24:	4b0e      	ldr	r3, [pc, #56]	; (2c60 <usage_fault+0x14c>)
    2c26:	4a0f      	ldr	r2, [pc, #60]	; (2c64 <usage_fault+0x150>)
    2c28:	1a9b      	subs	r3, r3, r2
    2c2a:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2c2e:	f363 118f 	bfi	r1, r3, #6, #10
    2c32:	4813      	ldr	r0, [pc, #76]	; (2c80 <usage_fault+0x16c>)
    2c34:	f7ff f834 	bl	1ca0 <log_0>
    2c38:	e797      	b.n	2b6a <usage_fault+0x56>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
    2c3a:	f04f 0100 	mov.w	r1, #0
    2c3e:	2301      	movs	r3, #1
    2c40:	f363 0102 	bfi	r1, r3, #0, #3
    2c44:	f36f 01c5 	bfc	r1, #3, #3
    2c48:	4b05      	ldr	r3, [pc, #20]	; (2c60 <usage_fault+0x14c>)
    2c4a:	4a06      	ldr	r2, [pc, #24]	; (2c64 <usage_fault+0x150>)
    2c4c:	1a9b      	subs	r3, r3, r2
    2c4e:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2c52:	f363 118f 	bfi	r1, r3, #6, #10
    2c56:	480b      	ldr	r0, [pc, #44]	; (2c84 <usage_fault+0x170>)
    2c58:	f7ff f822 	bl	1ca0 <log_0>
    2c5c:	e78a      	b.n	2b74 <usage_fault+0x60>
    2c5e:	bf00      	nop
    2c60:	00010cb8 	.word	0x00010cb8
    2c64:	00010c18 	.word	0x00010c18
    2c68:	000118a8 	.word	0x000118a8
    2c6c:	e000ed00 	.word	0xe000ed00
    2c70:	000118c0 	.word	0x000118c0
    2c74:	000118d4 	.word	0x000118d4
    2c78:	000118f0 	.word	0x000118f0
    2c7c:	00011910 	.word	0x00011910
    2c80:	00011938 	.word	0x00011938
    2c84:	00011954 	.word	0x00011954

00002c88 <debug_monitor>:
 * See z_arm_fault_dump() for example.
 *
 * @return N/A
 */
static void debug_monitor(const z_arch_esf_t *esf)
{
    2c88:	b508      	push	{r3, lr}
	ARG_UNUSED(esf);

	PR_FAULT_INFO(
    2c8a:	f04f 0100 	mov.w	r1, #0
    2c8e:	2301      	movs	r3, #1
    2c90:	f363 0102 	bfi	r1, r3, #0, #3
    2c94:	f36f 01c5 	bfc	r1, #3, #3
    2c98:	4b05      	ldr	r3, [pc, #20]	; (2cb0 <debug_monitor+0x28>)
    2c9a:	4a06      	ldr	r2, [pc, #24]	; (2cb4 <debug_monitor+0x2c>)
    2c9c:	1a9b      	subs	r3, r3, r2
    2c9e:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2ca2:	f363 118f 	bfi	r1, r3, #6, #10
    2ca6:	4804      	ldr	r0, [pc, #16]	; (2cb8 <debug_monitor+0x30>)
    2ca8:	f7fe fffa 	bl	1ca0 <log_0>
		"***** Debug monitor exception (not implemented) *****");
}
    2cac:	bd08      	pop	{r3, pc}
    2cae:	bf00      	nop
    2cb0:	00010cb8 	.word	0x00010cb8
    2cb4:	00010c18 	.word	0x00010c18
    2cb8:	00011980 	.word	0x00011980

00002cbc <mem_manage_fault>:
{
    2cbc:	b570      	push	{r4, r5, r6, lr}
    2cbe:	4605      	mov	r5, r0
    2cc0:	460e      	mov	r6, r1
    2cc2:	4614      	mov	r4, r2
	PR_FAULT_INFO("***** MPU FAULT *****");
    2cc4:	f04f 0100 	mov.w	r1, #0
    2cc8:	2301      	movs	r3, #1
    2cca:	f363 0102 	bfi	r1, r3, #0, #3
    2cce:	f36f 01c5 	bfc	r1, #3, #3
    2cd2:	4b53      	ldr	r3, [pc, #332]	; (2e20 <mem_manage_fault+0x164>)
    2cd4:	4a53      	ldr	r2, [pc, #332]	; (2e24 <mem_manage_fault+0x168>)
    2cd6:	1a9b      	subs	r3, r3, r2
    2cd8:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2cdc:	f363 118f 	bfi	r1, r3, #6, #10
    2ce0:	4851      	ldr	r0, [pc, #324]	; (2e28 <mem_manage_fault+0x16c>)
    2ce2:	f7fe ffdd 	bl	1ca0 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    2ce6:	4b51      	ldr	r3, [pc, #324]	; (2e2c <mem_manage_fault+0x170>)
    2ce8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2cea:	f013 0f10 	tst.w	r3, #16
    2cee:	d11f      	bne.n	2d30 <mem_manage_fault+0x74>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    2cf0:	4b4e      	ldr	r3, [pc, #312]	; (2e2c <mem_manage_fault+0x170>)
    2cf2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2cf4:	f013 0f08 	tst.w	r3, #8
    2cf8:	d12c      	bne.n	2d54 <mem_manage_fault+0x98>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    2cfa:	4b4c      	ldr	r3, [pc, #304]	; (2e2c <mem_manage_fault+0x170>)
    2cfc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2cfe:	f013 0f02 	tst.w	r3, #2
    2d02:	d139      	bne.n	2d78 <mem_manage_fault+0xbc>
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    2d04:	4b49      	ldr	r3, [pc, #292]	; (2e2c <mem_manage_fault+0x170>)
    2d06:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2d08:	f013 0f01 	tst.w	r3, #1
    2d0c:	d164      	bne.n	2dd8 <mem_manage_fault+0x11c>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    2d0e:	4b47      	ldr	r3, [pc, #284]	; (2e2c <mem_manage_fault+0x170>)
    2d10:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2d12:	f013 0f20 	tst.w	r3, #32
    2d16:	d171      	bne.n	2dfc <mem_manage_fault+0x140>
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
    2d18:	4b44      	ldr	r3, [pc, #272]	; (2e2c <mem_manage_fault+0x170>)
    2d1a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    2d1c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2d1e:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
    2d22:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    2d24:	4628      	mov	r0, r5
    2d26:	f00b f97a 	bl	e01e <memory_fault_recoverable>
    2d2a:	7020      	strb	r0, [r4, #0]
}
    2d2c:	2000      	movs	r0, #0
    2d2e:	bd70      	pop	{r4, r5, r6, pc}
		PR_FAULT_INFO("  Stacking error (context area might be"
    2d30:	f04f 0100 	mov.w	r1, #0
    2d34:	2301      	movs	r3, #1
    2d36:	f363 0102 	bfi	r1, r3, #0, #3
    2d3a:	f36f 01c5 	bfc	r1, #3, #3
    2d3e:	4b38      	ldr	r3, [pc, #224]	; (2e20 <mem_manage_fault+0x164>)
    2d40:	4a38      	ldr	r2, [pc, #224]	; (2e24 <mem_manage_fault+0x168>)
    2d42:	1a9b      	subs	r3, r3, r2
    2d44:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2d48:	f363 118f 	bfi	r1, r3, #6, #10
    2d4c:	4838      	ldr	r0, [pc, #224]	; (2e30 <mem_manage_fault+0x174>)
    2d4e:	f7fe ffa7 	bl	1ca0 <log_0>
    2d52:	e7cd      	b.n	2cf0 <mem_manage_fault+0x34>
		PR_FAULT_INFO("  Unstacking error");
    2d54:	f04f 0100 	mov.w	r1, #0
    2d58:	2301      	movs	r3, #1
    2d5a:	f363 0102 	bfi	r1, r3, #0, #3
    2d5e:	f36f 01c5 	bfc	r1, #3, #3
    2d62:	4b2f      	ldr	r3, [pc, #188]	; (2e20 <mem_manage_fault+0x164>)
    2d64:	4a2f      	ldr	r2, [pc, #188]	; (2e24 <mem_manage_fault+0x168>)
    2d66:	1a9b      	subs	r3, r3, r2
    2d68:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2d6c:	f363 118f 	bfi	r1, r3, #6, #10
    2d70:	4830      	ldr	r0, [pc, #192]	; (2e34 <mem_manage_fault+0x178>)
    2d72:	f7fe ff95 	bl	1ca0 <log_0>
    2d76:	e7c0      	b.n	2cfa <mem_manage_fault+0x3e>
		PR_FAULT_INFO("  Data Access Violation");
    2d78:	f04f 0100 	mov.w	r1, #0
    2d7c:	2301      	movs	r3, #1
    2d7e:	f363 0102 	bfi	r1, r3, #0, #3
    2d82:	f36f 01c5 	bfc	r1, #3, #3
    2d86:	4b26      	ldr	r3, [pc, #152]	; (2e20 <mem_manage_fault+0x164>)
    2d88:	4a26      	ldr	r2, [pc, #152]	; (2e24 <mem_manage_fault+0x168>)
    2d8a:	1a9b      	subs	r3, r3, r2
    2d8c:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2d90:	f363 118f 	bfi	r1, r3, #6, #10
    2d94:	4828      	ldr	r0, [pc, #160]	; (2e38 <mem_manage_fault+0x17c>)
    2d96:	f7fe ff83 	bl	1ca0 <log_0>
		mmfar = SCB->MMFAR;
    2d9a:	4b24      	ldr	r3, [pc, #144]	; (2e2c <mem_manage_fault+0x170>)
    2d9c:	6b59      	ldr	r1, [r3, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    2d9e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2da0:	f013 0f80 	tst.w	r3, #128	; 0x80
    2da4:	d0ae      	beq.n	2d04 <mem_manage_fault+0x48>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
    2da6:	f04f 0200 	mov.w	r2, #0
    2daa:	2301      	movs	r3, #1
    2dac:	f363 0202 	bfi	r2, r3, #0, #3
    2db0:	f36f 02c5 	bfc	r2, #3, #3
    2db4:	4b1a      	ldr	r3, [pc, #104]	; (2e20 <mem_manage_fault+0x164>)
    2db6:	481b      	ldr	r0, [pc, #108]	; (2e24 <mem_manage_fault+0x168>)
    2db8:	1a1b      	subs	r3, r3, r0
    2dba:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2dbe:	f363 128f 	bfi	r2, r3, #6, #10
    2dc2:	481e      	ldr	r0, [pc, #120]	; (2e3c <mem_manage_fault+0x180>)
    2dc4:	f7fe fdfc 	bl	19c0 <log_1>
			if (from_hard_fault) {
    2dc8:	2e00      	cmp	r6, #0
    2dca:	d09b      	beq.n	2d04 <mem_manage_fault+0x48>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    2dcc:	4a17      	ldr	r2, [pc, #92]	; (2e2c <mem_manage_fault+0x170>)
    2dce:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2dd0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    2dd4:	6293      	str	r3, [r2, #40]	; 0x28
    2dd6:	e795      	b.n	2d04 <mem_manage_fault+0x48>
		PR_FAULT_INFO("  Instruction Access Violation");
    2dd8:	f04f 0100 	mov.w	r1, #0
    2ddc:	2301      	movs	r3, #1
    2dde:	f363 0102 	bfi	r1, r3, #0, #3
    2de2:	f36f 01c5 	bfc	r1, #3, #3
    2de6:	4b0e      	ldr	r3, [pc, #56]	; (2e20 <mem_manage_fault+0x164>)
    2de8:	4a0e      	ldr	r2, [pc, #56]	; (2e24 <mem_manage_fault+0x168>)
    2dea:	1a9b      	subs	r3, r3, r2
    2dec:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2df0:	f363 118f 	bfi	r1, r3, #6, #10
    2df4:	4812      	ldr	r0, [pc, #72]	; (2e40 <mem_manage_fault+0x184>)
    2df6:	f7fe ff53 	bl	1ca0 <log_0>
    2dfa:	e788      	b.n	2d0e <mem_manage_fault+0x52>
		PR_FAULT_INFO(
    2dfc:	f04f 0100 	mov.w	r1, #0
    2e00:	2301      	movs	r3, #1
    2e02:	f363 0102 	bfi	r1, r3, #0, #3
    2e06:	f36f 01c5 	bfc	r1, #3, #3
    2e0a:	4b05      	ldr	r3, [pc, #20]	; (2e20 <mem_manage_fault+0x164>)
    2e0c:	4a05      	ldr	r2, [pc, #20]	; (2e24 <mem_manage_fault+0x168>)
    2e0e:	1a9b      	subs	r3, r3, r2
    2e10:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2e14:	f363 118f 	bfi	r1, r3, #6, #10
    2e18:	480a      	ldr	r0, [pc, #40]	; (2e44 <mem_manage_fault+0x188>)
    2e1a:	f7fe ff41 	bl	1ca0 <log_0>
    2e1e:	e77b      	b.n	2d18 <mem_manage_fault+0x5c>
    2e20:	00010cb8 	.word	0x00010cb8
    2e24:	00010c18 	.word	0x00010c18
    2e28:	000119b8 	.word	0x000119b8
    2e2c:	e000ed00 	.word	0xe000ed00
    2e30:	000119d0 	.word	0x000119d0
    2e34:	00011a04 	.word	0x00011a04
    2e38:	00011a18 	.word	0x00011a18
    2e3c:	00011a30 	.word	0x00011a30
    2e40:	00011a48 	.word	0x00011a48
    2e44:	00011a68 	.word	0x00011a68

00002e48 <bus_fault>:
{
    2e48:	b570      	push	{r4, r5, r6, lr}
    2e4a:	4605      	mov	r5, r0
    2e4c:	460e      	mov	r6, r1
    2e4e:	4614      	mov	r4, r2
	PR_FAULT_INFO("***** BUS FAULT *****");
    2e50:	f04f 0100 	mov.w	r1, #0
    2e54:	2301      	movs	r3, #1
    2e56:	f363 0102 	bfi	r1, r3, #0, #3
    2e5a:	f36f 01c5 	bfc	r1, #3, #3
    2e5e:	4b5f      	ldr	r3, [pc, #380]	; (2fdc <bus_fault+0x194>)
    2e60:	4a5f      	ldr	r2, [pc, #380]	; (2fe0 <bus_fault+0x198>)
    2e62:	1a9b      	subs	r3, r3, r2
    2e64:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2e68:	f363 118f 	bfi	r1, r3, #6, #10
    2e6c:	485d      	ldr	r0, [pc, #372]	; (2fe4 <bus_fault+0x19c>)
    2e6e:	f7fe ff17 	bl	1ca0 <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    2e72:	4b5d      	ldr	r3, [pc, #372]	; (2fe8 <bus_fault+0x1a0>)
    2e74:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2e76:	f413 5f80 	tst.w	r3, #4096	; 0x1000
    2e7a:	d124      	bne.n	2ec6 <bus_fault+0x7e>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    2e7c:	4b5a      	ldr	r3, [pc, #360]	; (2fe8 <bus_fault+0x1a0>)
    2e7e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2e80:	f413 6f00 	tst.w	r3, #2048	; 0x800
    2e84:	d131      	bne.n	2eea <bus_fault+0xa2>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    2e86:	4b58      	ldr	r3, [pc, #352]	; (2fe8 <bus_fault+0x1a0>)
    2e88:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2e8a:	f413 7f00 	tst.w	r3, #512	; 0x200
    2e8e:	d13e      	bne.n	2f0e <bus_fault+0xc6>
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    2e90:	4b55      	ldr	r3, [pc, #340]	; (2fe8 <bus_fault+0x1a0>)
    2e92:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2e94:	f413 6f80 	tst.w	r3, #1024	; 0x400
    2e98:	d169      	bne.n	2f6e <bus_fault+0x126>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    2e9a:	4b53      	ldr	r3, [pc, #332]	; (2fe8 <bus_fault+0x1a0>)
    2e9c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2e9e:	f413 7f80 	tst.w	r3, #256	; 0x100
    2ea2:	d176      	bne.n	2f92 <bus_fault+0x14a>
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    2ea4:	4b50      	ldr	r3, [pc, #320]	; (2fe8 <bus_fault+0x1a0>)
    2ea6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2ea8:	f413 5f00 	tst.w	r3, #8192	; 0x2000
    2eac:	f040 8083 	bne.w	2fb6 <bus_fault+0x16e>
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    2eb0:	4a4d      	ldr	r2, [pc, #308]	; (2fe8 <bus_fault+0x1a0>)
    2eb2:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2eb4:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
    2eb8:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    2eba:	4628      	mov	r0, r5
    2ebc:	f00b f8af 	bl	e01e <memory_fault_recoverable>
    2ec0:	7020      	strb	r0, [r4, #0]
}
    2ec2:	2000      	movs	r0, #0
    2ec4:	bd70      	pop	{r4, r5, r6, pc}
		PR_FAULT_INFO("  Stacking error");
    2ec6:	f04f 0100 	mov.w	r1, #0
    2eca:	2301      	movs	r3, #1
    2ecc:	f363 0102 	bfi	r1, r3, #0, #3
    2ed0:	f36f 01c5 	bfc	r1, #3, #3
    2ed4:	4b41      	ldr	r3, [pc, #260]	; (2fdc <bus_fault+0x194>)
    2ed6:	4a42      	ldr	r2, [pc, #264]	; (2fe0 <bus_fault+0x198>)
    2ed8:	1a9b      	subs	r3, r3, r2
    2eda:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2ede:	f363 118f 	bfi	r1, r3, #6, #10
    2ee2:	4842      	ldr	r0, [pc, #264]	; (2fec <bus_fault+0x1a4>)
    2ee4:	f7fe fedc 	bl	1ca0 <log_0>
    2ee8:	e7c8      	b.n	2e7c <bus_fault+0x34>
		PR_FAULT_INFO("  Unstacking error");
    2eea:	f04f 0100 	mov.w	r1, #0
    2eee:	2301      	movs	r3, #1
    2ef0:	f363 0102 	bfi	r1, r3, #0, #3
    2ef4:	f36f 01c5 	bfc	r1, #3, #3
    2ef8:	4b38      	ldr	r3, [pc, #224]	; (2fdc <bus_fault+0x194>)
    2efa:	4a39      	ldr	r2, [pc, #228]	; (2fe0 <bus_fault+0x198>)
    2efc:	1a9b      	subs	r3, r3, r2
    2efe:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2f02:	f363 118f 	bfi	r1, r3, #6, #10
    2f06:	483a      	ldr	r0, [pc, #232]	; (2ff0 <bus_fault+0x1a8>)
    2f08:	f7fe feca 	bl	1ca0 <log_0>
    2f0c:	e7bb      	b.n	2e86 <bus_fault+0x3e>
		PR_FAULT_INFO("  Precise data bus error");
    2f0e:	f04f 0100 	mov.w	r1, #0
    2f12:	2301      	movs	r3, #1
    2f14:	f363 0102 	bfi	r1, r3, #0, #3
    2f18:	f36f 01c5 	bfc	r1, #3, #3
    2f1c:	4b2f      	ldr	r3, [pc, #188]	; (2fdc <bus_fault+0x194>)
    2f1e:	4a30      	ldr	r2, [pc, #192]	; (2fe0 <bus_fault+0x198>)
    2f20:	1a9b      	subs	r3, r3, r2
    2f22:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2f26:	f363 118f 	bfi	r1, r3, #6, #10
    2f2a:	4832      	ldr	r0, [pc, #200]	; (2ff4 <bus_fault+0x1ac>)
    2f2c:	f7fe feb8 	bl	1ca0 <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
    2f30:	4b2d      	ldr	r3, [pc, #180]	; (2fe8 <bus_fault+0x1a0>)
    2f32:	6b99      	ldr	r1, [r3, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    2f34:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2f36:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    2f3a:	d0a9      	beq.n	2e90 <bus_fault+0x48>
			PR_EXC("  BFAR Address: 0x%x", bfar);
    2f3c:	f04f 0200 	mov.w	r2, #0
    2f40:	2301      	movs	r3, #1
    2f42:	f363 0202 	bfi	r2, r3, #0, #3
    2f46:	f36f 02c5 	bfc	r2, #3, #3
    2f4a:	4b24      	ldr	r3, [pc, #144]	; (2fdc <bus_fault+0x194>)
    2f4c:	4824      	ldr	r0, [pc, #144]	; (2fe0 <bus_fault+0x198>)
    2f4e:	1a1b      	subs	r3, r3, r0
    2f50:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2f54:	f363 128f 	bfi	r2, r3, #6, #10
    2f58:	4827      	ldr	r0, [pc, #156]	; (2ff8 <bus_fault+0x1b0>)
    2f5a:	f7fe fd31 	bl	19c0 <log_1>
			if (from_hard_fault) {
    2f5e:	2e00      	cmp	r6, #0
    2f60:	d096      	beq.n	2e90 <bus_fault+0x48>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    2f62:	4a21      	ldr	r2, [pc, #132]	; (2fe8 <bus_fault+0x1a0>)
    2f64:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2f66:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    2f6a:	6293      	str	r3, [r2, #40]	; 0x28
    2f6c:	e790      	b.n	2e90 <bus_fault+0x48>
		PR_FAULT_INFO("  Imprecise data bus error");
    2f6e:	f04f 0100 	mov.w	r1, #0
    2f72:	2301      	movs	r3, #1
    2f74:	f363 0102 	bfi	r1, r3, #0, #3
    2f78:	f36f 01c5 	bfc	r1, #3, #3
    2f7c:	4b17      	ldr	r3, [pc, #92]	; (2fdc <bus_fault+0x194>)
    2f7e:	4a18      	ldr	r2, [pc, #96]	; (2fe0 <bus_fault+0x198>)
    2f80:	1a9b      	subs	r3, r3, r2
    2f82:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2f86:	f363 118f 	bfi	r1, r3, #6, #10
    2f8a:	481c      	ldr	r0, [pc, #112]	; (2ffc <bus_fault+0x1b4>)
    2f8c:	f7fe fe88 	bl	1ca0 <log_0>
    2f90:	e783      	b.n	2e9a <bus_fault+0x52>
		PR_FAULT_INFO("  Instruction bus error");
    2f92:	f04f 0100 	mov.w	r1, #0
    2f96:	2301      	movs	r3, #1
    2f98:	f363 0102 	bfi	r1, r3, #0, #3
    2f9c:	f36f 01c5 	bfc	r1, #3, #3
    2fa0:	4b0e      	ldr	r3, [pc, #56]	; (2fdc <bus_fault+0x194>)
    2fa2:	4a0f      	ldr	r2, [pc, #60]	; (2fe0 <bus_fault+0x198>)
    2fa4:	1a9b      	subs	r3, r3, r2
    2fa6:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2faa:	f363 118f 	bfi	r1, r3, #6, #10
    2fae:	4814      	ldr	r0, [pc, #80]	; (3000 <bus_fault+0x1b8>)
    2fb0:	f7fe fe76 	bl	1ca0 <log_0>
    2fb4:	e77c      	b.n	2eb0 <bus_fault+0x68>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    2fb6:	f04f 0100 	mov.w	r1, #0
    2fba:	2301      	movs	r3, #1
    2fbc:	f363 0102 	bfi	r1, r3, #0, #3
    2fc0:	f36f 01c5 	bfc	r1, #3, #3
    2fc4:	4b05      	ldr	r3, [pc, #20]	; (2fdc <bus_fault+0x194>)
    2fc6:	4a06      	ldr	r2, [pc, #24]	; (2fe0 <bus_fault+0x198>)
    2fc8:	1a9b      	subs	r3, r3, r2
    2fca:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    2fce:	f363 118f 	bfi	r1, r3, #6, #10
    2fd2:	480c      	ldr	r0, [pc, #48]	; (3004 <bus_fault+0x1bc>)
    2fd4:	f7fe fe64 	bl	1ca0 <log_0>
    2fd8:	e76a      	b.n	2eb0 <bus_fault+0x68>
    2fda:	bf00      	nop
    2fdc:	00010cb8 	.word	0x00010cb8
    2fe0:	00010c18 	.word	0x00010c18
    2fe4:	00011a98 	.word	0x00011a98
    2fe8:	e000ed00 	.word	0xe000ed00
    2fec:	00011ab0 	.word	0x00011ab0
    2ff0:	00011a04 	.word	0x00011a04
    2ff4:	00011ac4 	.word	0x00011ac4
    2ff8:	00011ae0 	.word	0x00011ae0
    2ffc:	00011af8 	.word	0x00011af8
    3000:	00011b14 	.word	0x00011b14
    3004:	00011a68 	.word	0x00011a68

00003008 <hard_fault>:
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t hard_fault(z_arch_esf_t *esf, bool *recoverable)
{
    3008:	b570      	push	{r4, r5, r6, lr}
    300a:	4605      	mov	r5, r0
    300c:	460c      	mov	r4, r1
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** HARD FAULT *****");
    300e:	f04f 0100 	mov.w	r1, #0
    3012:	2301      	movs	r3, #1
    3014:	f363 0102 	bfi	r1, r3, #0, #3
    3018:	f36f 01c5 	bfc	r1, #3, #3
    301c:	4b2b      	ldr	r3, [pc, #172]	; (30cc <hard_fault+0xc4>)
    301e:	4a2c      	ldr	r2, [pc, #176]	; (30d0 <hard_fault+0xc8>)
    3020:	1a9b      	subs	r3, r3, r2
    3022:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    3026:	f363 118f 	bfi	r1, r3, #6, #10
    302a:	482a      	ldr	r0, [pc, #168]	; (30d4 <hard_fault+0xcc>)
    302c:	f7fe fe38 	bl	1ca0 <log_0>
	}
#undef _SVC_OPCODE

	*recoverable = memory_fault_recoverable(esf);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	*recoverable = false;
    3030:	2300      	movs	r3, #0
    3032:	7023      	strb	r3, [r4, #0]

	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    3034:	4b28      	ldr	r3, [pc, #160]	; (30d8 <hard_fault+0xd0>)
    3036:	6ade      	ldr	r6, [r3, #44]	; 0x2c
    3038:	f016 0602 	ands.w	r6, r6, #2
    303c:	d105      	bne.n	304a <hard_fault+0x42>
		PR_EXC("  Bus fault on vector table read");
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    303e:	4b26      	ldr	r3, [pc, #152]	; (30d8 <hard_fault+0xd0>)
    3040:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    3042:	f010 4080 	ands.w	r0, r0, #1073741824	; 0x40000000
    3046:	d113      	bne.n	3070 <hard_fault+0x68>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	return reason;
}
    3048:	bd70      	pop	{r4, r5, r6, pc}
		PR_EXC("  Bus fault on vector table read");
    304a:	f04f 0100 	mov.w	r1, #0
    304e:	2301      	movs	r3, #1
    3050:	f363 0102 	bfi	r1, r3, #0, #3
    3054:	f36f 01c5 	bfc	r1, #3, #3
    3058:	4b1c      	ldr	r3, [pc, #112]	; (30cc <hard_fault+0xc4>)
    305a:	4a1d      	ldr	r2, [pc, #116]	; (30d0 <hard_fault+0xc8>)
    305c:	1a9b      	subs	r3, r3, r2
    305e:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    3062:	f363 118f 	bfi	r1, r3, #6, #10
    3066:	481d      	ldr	r0, [pc, #116]	; (30dc <hard_fault+0xd4>)
    3068:	f7fe fe1a 	bl	1ca0 <log_0>
	u32_t reason = K_ERR_CPU_EXCEPTION;
    306c:	2000      	movs	r0, #0
    306e:	e7eb      	b.n	3048 <hard_fault+0x40>
		PR_EXC("  Fault escalation (see below)");
    3070:	f04f 0100 	mov.w	r1, #0
    3074:	2301      	movs	r3, #1
    3076:	f363 0102 	bfi	r1, r3, #0, #3
    307a:	f36f 01c5 	bfc	r1, #3, #3
    307e:	4b13      	ldr	r3, [pc, #76]	; (30cc <hard_fault+0xc4>)
    3080:	4a13      	ldr	r2, [pc, #76]	; (30d0 <hard_fault+0xc8>)
    3082:	1a9b      	subs	r3, r3, r2
    3084:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    3088:	f363 118f 	bfi	r1, r3, #6, #10
    308c:	4814      	ldr	r0, [pc, #80]	; (30e0 <hard_fault+0xd8>)
    308e:	f7fe fe07 	bl	1ca0 <log_0>
		if (SCB_MMFSR != 0) {
    3092:	4b14      	ldr	r3, [pc, #80]	; (30e4 <hard_fault+0xdc>)
    3094:	781b      	ldrb	r3, [r3, #0]
    3096:	b943      	cbnz	r3, 30aa <hard_fault+0xa2>
		} else if (SCB_BFSR != 0) {
    3098:	4b13      	ldr	r3, [pc, #76]	; (30e8 <hard_fault+0xe0>)
    309a:	781b      	ldrb	r3, [r3, #0]
    309c:	b95b      	cbnz	r3, 30b6 <hard_fault+0xae>
		} else if (SCB_UFSR != 0) {
    309e:	4b13      	ldr	r3, [pc, #76]	; (30ec <hard_fault+0xe4>)
    30a0:	881b      	ldrh	r3, [r3, #0]
    30a2:	b29b      	uxth	r3, r3
    30a4:	b96b      	cbnz	r3, 30c2 <hard_fault+0xba>
	u32_t reason = K_ERR_CPU_EXCEPTION;
    30a6:	4630      	mov	r0, r6
	return reason;
    30a8:	e7ce      	b.n	3048 <hard_fault+0x40>
			reason = mem_manage_fault(esf, 1, recoverable);
    30aa:	4622      	mov	r2, r4
    30ac:	2101      	movs	r1, #1
    30ae:	4628      	mov	r0, r5
    30b0:	f7ff fe04 	bl	2cbc <mem_manage_fault>
    30b4:	e7c8      	b.n	3048 <hard_fault+0x40>
			reason = bus_fault(esf, 1, recoverable);
    30b6:	4622      	mov	r2, r4
    30b8:	2101      	movs	r1, #1
    30ba:	4628      	mov	r0, r5
    30bc:	f7ff fec4 	bl	2e48 <bus_fault>
    30c0:	e7c2      	b.n	3048 <hard_fault+0x40>
			reason = usage_fault(esf);
    30c2:	4628      	mov	r0, r5
    30c4:	f7ff fd26 	bl	2b14 <usage_fault>
    30c8:	e7be      	b.n	3048 <hard_fault+0x40>
    30ca:	bf00      	nop
    30cc:	00010cb8 	.word	0x00010cb8
    30d0:	00010c18 	.word	0x00010c18
    30d4:	00011b2c 	.word	0x00011b2c
    30d8:	e000ed00 	.word	0xe000ed00
    30dc:	00011b44 	.word	0x00011b44
    30e0:	00011b68 	.word	0x00011b68
    30e4:	e000ed28 	.word	0xe000ed28
    30e8:	e000ed29 	.word	0xe000ed29
    30ec:	e000ed2a 	.word	0xe000ed2a

000030f0 <reserved_exception>:
 * See z_arm_fault_dump() for example.
 *
 * @return N/A
 */
static void reserved_exception(const z_arch_esf_t *esf, int fault)
{
    30f0:	b508      	push	{r3, lr}
    30f2:	460a      	mov	r2, r1
	ARG_UNUSED(esf);

	PR_FAULT_INFO("***** %s %d) *****",
    30f4:	f04f 0300 	mov.w	r3, #0
    30f8:	2101      	movs	r1, #1
    30fa:	f361 0302 	bfi	r3, r1, #0, #3
    30fe:	f36f 03c5 	bfc	r3, #3, #3
    3102:	4808      	ldr	r0, [pc, #32]	; (3124 <reserved_exception+0x34>)
    3104:	4908      	ldr	r1, [pc, #32]	; (3128 <reserved_exception+0x38>)
    3106:	1a40      	subs	r0, r0, r1
    3108:	f3c0 00c9 	ubfx	r0, r0, #3, #10
    310c:	f360 138f 	bfi	r3, r0, #6, #10
    3110:	2a0f      	cmp	r2, #15
    3112:	dc05      	bgt.n	3120 <reserved_exception+0x30>
    3114:	4905      	ldr	r1, [pc, #20]	; (312c <reserved_exception+0x3c>)
    3116:	3a10      	subs	r2, #16
    3118:	4805      	ldr	r0, [pc, #20]	; (3130 <reserved_exception+0x40>)
    311a:	f7fe fcd1 	bl	1ac0 <log_2>
	       fault < 16 ? "Reserved Exception (" : "Spurious interrupt (IRQ ",
	       fault - 16);
}
    311e:	bd08      	pop	{r3, pc}
	PR_FAULT_INFO("***** %s %d) *****",
    3120:	4904      	ldr	r1, [pc, #16]	; (3134 <reserved_exception+0x44>)
    3122:	e7f8      	b.n	3116 <reserved_exception+0x26>
    3124:	00010cb8 	.word	0x00010cb8
    3128:	00010c18 	.word	0x00010c18
    312c:	00011b88 	.word	0x00011b88
    3130:	00011bbc 	.word	0x00011bbc
    3134:	00011ba0 	.word	0x00011ba0

00003138 <z_arm_fault>:
 * @param psp PSP value immediately after the exception occurred
 * @param exc_return EXC_RETURN value present in LR after exception entry.
 *
 */
void z_arm_fault(u32_t msp, u32_t psp, u32_t exc_return)
{
    3138:	b5f0      	push	{r4, r5, r6, r7, lr}
    313a:	b08b      	sub	sp, #44	; 0x2c
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    313c:	4b2e      	ldr	r3, [pc, #184]	; (31f8 <z_arm_fault+0xc0>)
    313e:	685d      	ldr	r5, [r3, #4]
    3140:	f3c5 0508 	ubfx	r5, r5, #0, #9
    3144:	2300      	movs	r3, #0
    3146:	f383 8811 	msr	BASEPRI, r3
    314a:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    314e:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
    3152:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
    3156:	d12b      	bne.n	31b0 <z_arm_fault+0x78>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    3158:	f002 030c 	and.w	r3, r2, #12
    315c:	2b08      	cmp	r3, #8
    315e:	d010      	beq.n	3182 <z_arm_fault+0x4a>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    3160:	f012 0f08 	tst.w	r2, #8
    3164:	d021      	beq.n	31aa <z_arm_fault+0x72>
			ptr_esf =  (z_arch_esf_t *)psp;
    3166:	460c      	mov	r4, r1
	*nested_exc = false;
    3168:	2700      	movs	r7, #0
	 */
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
		"ESF could not be retrieved successfully. Shall never occur.");

	reason = fault_handle(esf, fault, &recoverable);
    316a:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    316e:	4629      	mov	r1, r5
    3170:	4620      	mov	r0, r4
    3172:	f00a ff56 	bl	e022 <fault_handle>
    3176:	4606      	mov	r6, r0
	if (recoverable) {
    3178:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    317c:	b1db      	cbz	r3, 31b6 <z_arm_fault+0x7e>
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
	}

	z_arm_fatal_error(reason, &esf_copy);
}
    317e:	b00b      	add	sp, #44	; 0x2c
    3180:	bdf0      	pop	{r4, r5, r6, r7, pc}
		PR_EXC("SPSEL in thread mode does not indicate PSP");
    3182:	f04f 0100 	mov.w	r1, #0
    3186:	2301      	movs	r3, #1
    3188:	f363 0102 	bfi	r1, r3, #0, #3
    318c:	f36f 01c5 	bfc	r1, #3, #3
    3190:	4b1a      	ldr	r3, [pc, #104]	; (31fc <z_arm_fault+0xc4>)
    3192:	4a1b      	ldr	r2, [pc, #108]	; (3200 <z_arm_fault+0xc8>)
    3194:	1a9b      	subs	r3, r3, r2
    3196:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    319a:	f363 118f 	bfi	r1, r3, #6, #10
    319e:	4819      	ldr	r0, [pc, #100]	; (3204 <z_arm_fault+0xcc>)
    31a0:	f7fe fd7e 	bl	1ca0 <log_0>
	*nested_exc = false;
    31a4:	2700      	movs	r7, #0
		return NULL;
    31a6:	463c      	mov	r4, r7
    31a8:	e7df      	b.n	316a <z_arm_fault+0x32>
			ptr_esf = (z_arch_esf_t *)msp;
    31aa:	4604      	mov	r4, r0
			*nested_exc = true;
    31ac:	2701      	movs	r7, #1
    31ae:	e7dc      	b.n	316a <z_arm_fault+0x32>
	*nested_exc = false;
    31b0:	2700      	movs	r7, #0
		return NULL;
    31b2:	463c      	mov	r4, r7
    31b4:	e7d9      	b.n	316a <z_arm_fault+0x32>
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    31b6:	ad01      	add	r5, sp, #4
    31b8:	6820      	ldr	r0, [r4, #0]
    31ba:	6861      	ldr	r1, [r4, #4]
    31bc:	68a2      	ldr	r2, [r4, #8]
    31be:	68e3      	ldr	r3, [r4, #12]
    31c0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    31c2:	6920      	ldr	r0, [r4, #16]
    31c4:	6961      	ldr	r1, [r4, #20]
    31c6:	69a2      	ldr	r2, [r4, #24]
    31c8:	69e3      	ldr	r3, [r4, #28]
    31ca:	c50f      	stmia	r5!, {r0, r1, r2, r3}
	if (nested_exc) {
    31cc:	b14f      	cbz	r7, 31e2 <z_arm_fault+0xaa>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    31ce:	9b08      	ldr	r3, [sp, #32]
    31d0:	f3c3 0208 	ubfx	r2, r3, #0, #9
    31d4:	b95a      	cbnz	r2, 31ee <z_arm_fault+0xb6>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    31d6:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    31da:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    31de:	9308      	str	r3, [sp, #32]
    31e0:	e005      	b.n	31ee <z_arm_fault+0xb6>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    31e2:	9b08      	ldr	r3, [sp, #32]
    31e4:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    31e8:	f023 0301 	bic.w	r3, r3, #1
    31ec:	9308      	str	r3, [sp, #32]
	z_arm_fatal_error(reason, &esf_copy);
    31ee:	a901      	add	r1, sp, #4
    31f0:	4630      	mov	r0, r6
    31f2:	f00a fefc 	bl	dfee <z_arm_fatal_error>
    31f6:	e7c2      	b.n	317e <z_arm_fault+0x46>
    31f8:	e000ed00 	.word	0xe000ed00
    31fc:	00010cb8 	.word	0x00010cb8
    3200:	00010c18 	.word	0x00010c18
    3204:	00011bd0 	.word	0x00011bd0

00003208 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    3208:	4a02      	ldr	r2, [pc, #8]	; (3214 <z_arm_fault_init+0xc>)
    320a:	6953      	ldr	r3, [r2, #20]
    320c:	f043 0310 	orr.w	r3, r3, #16
    3210:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    3212:	4770      	bx	lr
    3214:	e000ed00 	.word	0xe000ed00

00003218 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
    3218:	4b04      	ldr	r3, [pc, #16]	; (322c <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
    321a:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
    321c:	6a58      	ldr	r0, [r3, #36]	; 0x24
	cmp r0, r1
    321e:	4288      	cmp	r0, r1
	beq _EXIT_EXC
    3220:	d003      	beq.n	322a <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
    3222:	4903      	ldr	r1, [pc, #12]	; (3230 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
    3224:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
    3228:	600a      	str	r2, [r1, #0]

0000322a <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
    322a:	4770      	bx	lr
	ldr r3, =_kernel
    322c:	20005874 	.word	0x20005874
	ldr r1, =_SCS_ICSR
    3230:	e000ed04 	.word	0xe000ed04

00003234 <z_arm_interrupt_init>:
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
    3234:	2200      	movs	r2, #0

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    3236:	e006      	b.n	3246 <z_arm_interrupt_init+0x12>
    3238:	f002 010f 	and.w	r1, r2, #15
    323c:	4b09      	ldr	r3, [pc, #36]	; (3264 <z_arm_interrupt_init+0x30>)
    323e:	440b      	add	r3, r1
    3240:	2120      	movs	r1, #32
    3242:	7619      	strb	r1, [r3, #24]
    3244:	3201      	adds	r2, #1
    3246:	2a2f      	cmp	r2, #47	; 0x2f
    3248:	dc0a      	bgt.n	3260 <z_arm_interrupt_init+0x2c>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
    324a:	b253      	sxtb	r3, r2
  if ((int32_t)(IRQn) >= 0)
    324c:	2b00      	cmp	r3, #0
    324e:	dbf3      	blt.n	3238 <z_arm_interrupt_init+0x4>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    3250:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    3254:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    3258:	2120      	movs	r1, #32
    325a:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
    325e:	e7f1      	b.n	3244 <z_arm_interrupt_init+0x10>
	}
}
    3260:	4770      	bx	lr
    3262:	bf00      	nop
    3264:	e000ecfc 	.word	0xe000ecfc

00003268 <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
    3268:	b538      	push	{r3, r4, r5, lr}
    326a:	4604      	mov	r4, r0
	__asm__ volatile(
    326c:	f04f 0320 	mov.w	r3, #32
    3270:	f3ef 8511 	mrs	r5, BASEPRI
    3274:	f383 8811 	msr	BASEPRI, r3
    3278:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
		 "essential thread aborted");

	z_thread_single_abort(thread);
    327c:	f007 fe72 	bl	af64 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
    3280:	4b0a      	ldr	r3, [pc, #40]	; (32ac <z_impl_k_thread_abort+0x44>)
    3282:	689b      	ldr	r3, [r3, #8]
    3284:	42a3      	cmp	r3, r4
    3286:	d003      	beq.n	3290 <z_impl_k_thread_abort+0x28>
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
    3288:	4628      	mov	r0, r5
    328a:	f00c fed6 	bl	1003a <z_reschedule_irqlock>
}
    328e:	bd38      	pop	{r3, r4, r5, pc}
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
    3290:	4b07      	ldr	r3, [pc, #28]	; (32b0 <z_impl_k_thread_abort+0x48>)
    3292:	685b      	ldr	r3, [r3, #4]
    3294:	f3c3 0308 	ubfx	r3, r3, #0, #9
    3298:	b12b      	cbz	r3, 32a6 <z_impl_k_thread_abort+0x3e>
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    329a:	4a05      	ldr	r2, [pc, #20]	; (32b0 <z_impl_k_thread_abort+0x48>)
    329c:	6853      	ldr	r3, [r2, #4]
    329e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    32a2:	6053      	str	r3, [r2, #4]
    32a4:	e7f0      	b.n	3288 <z_impl_k_thread_abort+0x20>
	int ret;
	z_check_stack_sentinel();
#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = arch_swap(key);
    32a6:	4628      	mov	r0, r5
    32a8:	f7ff fa8a 	bl	27c0 <arch_swap>
			CODE_UNREACHABLE;
    32ac:	20005874 	.word	0x20005874
    32b0:	e000ed00 	.word	0xe000ed00

000032b4 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    32b4:	b500      	push	{lr}
    32b6:	b085      	sub	sp, #20
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
		{
		.start = (u32_t)&_ramfunc_ram_start,
    32b8:	4b08      	ldr	r3, [pc, #32]	; (32dc <z_arm_configure_static_mpu_regions+0x28>)
		const struct k_mem_partition ramfunc_region =
    32ba:	9301      	str	r3, [sp, #4]
		.size = (u32_t)&_ramfunc_ram_size,
    32bc:	4b08      	ldr	r3, [pc, #32]	; (32e0 <z_arm_configure_static_mpu_regions+0x2c>)
		const struct k_mem_partition ramfunc_region =
    32be:	9302      	str	r3, [sp, #8]
    32c0:	4b08      	ldr	r3, [pc, #32]	; (32e4 <z_arm_configure_static_mpu_regions+0x30>)
    32c2:	9303      	str	r3, [sp, #12]

	/* Define a constant array of k_mem_partition objects
	 * to hold the configuration of the respective static
	 * MPU regions.
	 */
	const struct k_mem_partition *static_regions[] = {
    32c4:	ab01      	add	r3, sp, #4
    32c6:	9300      	str	r3, [sp, #0]
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    32c8:	4b07      	ldr	r3, [pc, #28]	; (32e8 <z_arm_configure_static_mpu_regions+0x34>)
    32ca:	4a08      	ldr	r2, [pc, #32]	; (32ec <z_arm_configure_static_mpu_regions+0x38>)
    32cc:	2101      	movs	r1, #1
    32ce:	4668      	mov	r0, sp
    32d0:	f00a fefb 	bl	e0ca <arm_core_mpu_configure_static_mpu_regions>
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    32d4:	b005      	add	sp, #20
    32d6:	f85d fb04 	ldr.w	pc, [sp], #4
    32da:	bf00      	nop
    32dc:	20000000 	.word	0x20000000
    32e0:	00000000 	.word	0x00000000
    32e4:	060b0000 	.word	0x060b0000
    32e8:	20020000 	.word	0x20020000
    32ec:	20000000 	.word	0x20000000

000032f0 <region_init>:
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Select the region you want to access */
	MPU->RNR = index;
    32f0:	4a06      	ldr	r2, [pc, #24]	; (330c <region_init+0x1c>)
    32f2:	6090      	str	r0, [r2, #8]
	/* Configure the region */
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    32f4:	680b      	ldr	r3, [r1, #0]
    32f6:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
    32fa:	4303      	orrs	r3, r0
    32fc:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    3300:	60d3      	str	r3, [r2, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    3302:	688b      	ldr	r3, [r1, #8]
    3304:	f043 0301 	orr.w	r3, r3, #1
    3308:	6113      	str	r3, [r2, #16]
	LOG_DBG("[%d] 0x%08x 0x%08x",
		index, region_conf->base, region_conf->attr.rasr);
}
    330a:	4770      	bx	lr
    330c:	e000ed90 	.word	0xe000ed90

00003310 <region_allocate_and_init>:
#error "Unsupported ARM CPU"
#endif

static int region_allocate_and_init(const u8_t index,
	const struct arm_mpu_region *region_conf)
{
    3310:	b510      	push	{r4, lr}
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1)) {
    3312:	2807      	cmp	r0, #7
    3314:	d804      	bhi.n	3320 <region_allocate_and_init+0x10>
    3316:	4604      	mov	r4, r0
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
    3318:	f7ff ffea 	bl	32f0 <region_init>

	return index;
}
    331c:	4620      	mov	r0, r4
    331e:	bd10      	pop	{r4, pc}
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    3320:	f04f 0200 	mov.w	r2, #0
    3324:	2301      	movs	r3, #1
    3326:	f363 0202 	bfi	r2, r3, #0, #3
    332a:	f36f 02c5 	bfc	r2, #3, #3
    332e:	4b07      	ldr	r3, [pc, #28]	; (334c <region_allocate_and_init+0x3c>)
    3330:	4907      	ldr	r1, [pc, #28]	; (3350 <region_allocate_and_init+0x40>)
    3332:	1a5b      	subs	r3, r3, r1
    3334:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    3338:	f363 128f 	bfi	r2, r3, #6, #10
    333c:	4601      	mov	r1, r0
    333e:	4805      	ldr	r0, [pc, #20]	; (3354 <region_allocate_and_init+0x44>)
    3340:	f7fe fb3e 	bl	19c0 <log_1>
		return -EINVAL;
    3344:	f06f 0415 	mvn.w	r4, #21
    3348:	e7e8      	b.n	331c <region_allocate_and_init+0xc>
    334a:	bf00      	nop
    334c:	00010ca8 	.word	0x00010ca8
    3350:	00010c18 	.word	0x00010c18
    3354:	00011c00 	.word	0x00011c00

00003358 <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct k_mem_partition
	*regions[], u8_t regions_num, u8_t start_reg_index,
	bool do_sanity_check)
{
    3358:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    335c:	4680      	mov	r8, r0
    335e:	460f      	mov	r7, r1
    3360:	4699      	mov	r9, r3
	int i;
	int reg_index = start_reg_index;
    3362:	4615      	mov	r5, r2

	for (i = 0; i < regions_num; i++) {
    3364:	2400      	movs	r4, #0
    3366:	e009      	b.n	337c <mpu_configure_regions+0x24>
				(!mpu_partition_is_valid(regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
			return -EINVAL;
		}

		reg_index = mpu_configure_region(reg_index, regions[i]);
    3368:	4631      	mov	r1, r6
    336a:	b2e8      	uxtb	r0, r5
    336c:	f00a fe8e 	bl	e08c <mpu_configure_region>
    3370:	4605      	mov	r5, r0

		if (reg_index == -EINVAL) {
    3372:	f110 0f16 	cmn.w	r0, #22
    3376:	d024      	beq.n	33c2 <mpu_configure_regions+0x6a>
			return reg_index;
		}

		/* Increment number of programmed MPU indices. */
		reg_index++;
    3378:	3501      	adds	r5, #1
	for (i = 0; i < regions_num; i++) {
    337a:	3401      	adds	r4, #1
    337c:	42bc      	cmp	r4, r7
    337e:	da20      	bge.n	33c2 <mpu_configure_regions+0x6a>
		if (regions[i]->size == 0U) {
    3380:	f858 6024 	ldr.w	r6, [r8, r4, lsl #2]
    3384:	6872      	ldr	r2, [r6, #4]
    3386:	2a00      	cmp	r2, #0
    3388:	d0f7      	beq.n	337a <mpu_configure_regions+0x22>
		if (do_sanity_check &&
    338a:	f1b9 0f00 	cmp.w	r9, #0
    338e:	d0eb      	beq.n	3368 <mpu_configure_regions+0x10>
				(!mpu_partition_is_valid(regions[i]))) {
    3390:	4630      	mov	r0, r6
    3392:	f00a fe6a 	bl	e06a <mpu_partition_is_valid>
		if (do_sanity_check &&
    3396:	2800      	cmp	r0, #0
    3398:	d1e6      	bne.n	3368 <mpu_configure_regions+0x10>
			LOG_ERR("Partition %u: sanity check failed.", i);
    339a:	f04f 0200 	mov.w	r2, #0
    339e:	2301      	movs	r3, #1
    33a0:	f363 0202 	bfi	r2, r3, #0, #3
    33a4:	f36f 02c5 	bfc	r2, #3, #3
    33a8:	4b07      	ldr	r3, [pc, #28]	; (33c8 <mpu_configure_regions+0x70>)
    33aa:	4908      	ldr	r1, [pc, #32]	; (33cc <mpu_configure_regions+0x74>)
    33ac:	1a5b      	subs	r3, r3, r1
    33ae:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    33b2:	f363 128f 	bfi	r2, r3, #6, #10
    33b6:	4621      	mov	r1, r4
    33b8:	4805      	ldr	r0, [pc, #20]	; (33d0 <mpu_configure_regions+0x78>)
    33ba:	f7fe fb01 	bl	19c0 <log_1>
			return -EINVAL;
    33be:	f06f 0515 	mvn.w	r5, #21
	}

	return reg_index;
}
    33c2:	4628      	mov	r0, r5
    33c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    33c8:	00010ca8 	.word	0x00010ca8
    33cc:	00010c18 	.word	0x00010c18
    33d0:	00011c28 	.word	0x00011c28

000033d4 <mpu_configure_static_mpu_regions>:
 */
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
    33d4:	b510      	push	{r4, lr}
	int mpu_reg_index = static_regions_num;
    33d6:	4c03      	ldr	r4, [pc, #12]	; (33e4 <mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
    33d8:	2301      	movs	r3, #1
    33da:	7822      	ldrb	r2, [r4, #0]
    33dc:	f7ff ffbc 	bl	3358 <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    33e0:	7020      	strb	r0, [r4, #0]

	return mpu_reg_index;
}
    33e2:	bd10      	pop	{r4, pc}
    33e4:	2000594f 	.word	0x2000594f

000033e8 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    33e8:	4b03      	ldr	r3, [pc, #12]	; (33f8 <arm_core_mpu_enable+0x10>)
    33ea:	2205      	movs	r2, #5
    33ec:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    33ee:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    33f2:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    33f6:	4770      	bx	lr
    33f8:	e000ed90 	.word	0xe000ed90

000033fc <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    33fc:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    3400:	4b01      	ldr	r3, [pc, #4]	; (3408 <arm_core_mpu_disable+0xc>)
    3402:	2200      	movs	r2, #0
    3404:	605a      	str	r2, [r3, #4]
}
    3406:	4770      	bx	lr
    3408:	e000ed90 	.word	0xe000ed90

0000340c <arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
static int arm_mpu_init(struct device *arg)
{
    340c:	b538      	push	{r3, r4, r5, lr}
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    340e:	4b0e      	ldr	r3, [pc, #56]	; (3448 <arm_mpu_init+0x3c>)
    3410:	681d      	ldr	r5, [r3, #0]
    3412:	2d08      	cmp	r5, #8
    3414:	d815      	bhi.n	3442 <arm_mpu_init+0x36>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    3416:	f7ff fff1 	bl	33fc <arm_core_mpu_disable>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    341a:	2400      	movs	r4, #0
    341c:	42a5      	cmp	r5, r4
    341e:	d90a      	bls.n	3436 <arm_mpu_init+0x2a>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
    3420:	4b09      	ldr	r3, [pc, #36]	; (3448 <arm_mpu_init+0x3c>)
    3422:	6859      	ldr	r1, [r3, #4]
    3424:	eb04 0244 	add.w	r2, r4, r4, lsl #1
    3428:	0093      	lsls	r3, r2, #2
    342a:	4419      	add	r1, r3
    342c:	4620      	mov	r0, r4
    342e:	f7ff ff5f 	bl	32f0 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    3432:	3401      	adds	r4, #1
    3434:	e7f2      	b.n	341c <arm_mpu_init+0x10>
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    3436:	4b05      	ldr	r3, [pc, #20]	; (344c <arm_mpu_init+0x40>)
    3438:	701d      	strb	r5, [r3, #0]


	arm_core_mpu_enable();
    343a:	f7ff ffd5 	bl	33e8 <arm_core_mpu_enable>
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
    343e:	2000      	movs	r0, #0
}
    3440:	bd38      	pop	{r3, r4, r5, pc}
		return -1;
    3442:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    3446:	e7fb      	b.n	3440 <arm_mpu_init+0x34>
    3448:	00011c64 	.word	0x00011c64
    344c:	2000594f 	.word	0x2000594f

00003450 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    3450:	4b01      	ldr	r3, [pc, #4]	; (3458 <__stdout_hook_install+0x8>)
    3452:	6018      	str	r0, [r3, #0]
}
    3454:	4770      	bx	lr
    3456:	bf00      	nop
    3458:	20000104 	.word	0x20000104

0000345c <z_impl_zephyr_read_stdin>:
{
	_stdin_hook = hook;
}

int z_impl_zephyr_read_stdin(char *buf, int nbytes)
{
    345c:	b570      	push	{r4, r5, r6, lr}
    345e:	4606      	mov	r6, r0
    3460:	460d      	mov	r5, r1
	int i = 0;

	for (i = 0; i < nbytes; i++) {
    3462:	2400      	movs	r4, #0
    3464:	e000      	b.n	3468 <z_impl_zephyr_read_stdin+0xc>
    3466:	3401      	adds	r4, #1
    3468:	42ac      	cmp	r4, r5
    346a:	da08      	bge.n	347e <z_impl_zephyr_read_stdin+0x22>
		*(buf + i) = _stdin_hook();
    346c:	4b05      	ldr	r3, [pc, #20]	; (3484 <z_impl_zephyr_read_stdin+0x28>)
    346e:	681b      	ldr	r3, [r3, #0]
    3470:	4798      	blx	r3
    3472:	5530      	strb	r0, [r6, r4]
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
    3474:	280a      	cmp	r0, #10
    3476:	d001      	beq.n	347c <z_impl_zephyr_read_stdin+0x20>
    3478:	280d      	cmp	r0, #13
    347a:	d1f4      	bne.n	3466 <z_impl_zephyr_read_stdin+0xa>
			i++;
    347c:	3401      	adds	r4, #1
			break;
		}
	}
	return i;
}
    347e:	4620      	mov	r0, r4
    3480:	bd70      	pop	{r4, r5, r6, pc}
    3482:	bf00      	nop
    3484:	20000100 	.word	0x20000100

00003488 <z_impl_zephyr_write_stdout>:
}
#include <syscalls/z_zephyr_read_stdin_mrsh.c>
#endif

int z_impl_zephyr_write_stdout(const void *buffer, int nbytes)
{
    3488:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    348a:	4605      	mov	r5, r0
    348c:	460f      	mov	r7, r1
	const char *buf = buffer;
	int i;

	for (i = 0; i < nbytes; i++) {
    348e:	2400      	movs	r4, #0
    3490:	e004      	b.n	349c <z_impl_zephyr_write_stdout+0x14>
		if (*(buf + i) == '\n') {
			_stdout_hook('\r');
		}
		_stdout_hook(*(buf + i));
    3492:	4b09      	ldr	r3, [pc, #36]	; (34b8 <z_impl_zephyr_write_stdout+0x30>)
    3494:	681b      	ldr	r3, [r3, #0]
    3496:	7830      	ldrb	r0, [r6, #0]
    3498:	4798      	blx	r3
	for (i = 0; i < nbytes; i++) {
    349a:	3401      	adds	r4, #1
    349c:	42bc      	cmp	r4, r7
    349e:	da08      	bge.n	34b2 <z_impl_zephyr_write_stdout+0x2a>
		if (*(buf + i) == '\n') {
    34a0:	192e      	adds	r6, r5, r4
    34a2:	5d2b      	ldrb	r3, [r5, r4]
    34a4:	2b0a      	cmp	r3, #10
    34a6:	d1f4      	bne.n	3492 <z_impl_zephyr_write_stdout+0xa>
			_stdout_hook('\r');
    34a8:	4b03      	ldr	r3, [pc, #12]	; (34b8 <z_impl_zephyr_write_stdout+0x30>)
    34aa:	681b      	ldr	r3, [r3, #0]
    34ac:	200d      	movs	r0, #13
    34ae:	4798      	blx	r3
    34b0:	e7ef      	b.n	3492 <z_impl_zephyr_write_stdout+0xa>
	}
	return nbytes;
}
    34b2:	4638      	mov	r0, r7
    34b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    34b6:	bf00      	nop
    34b8:	20000104 	.word	0x20000104

000034bc <_exit>:
	return 0;
}
__weak FUNC_ALIAS(_fstat, fstat, int);

__weak void _exit(int status)
{
    34bc:	b508      	push	{r3, lr}
	_write(1, "exit\n", 5);
    34be:	2205      	movs	r2, #5
    34c0:	4902      	ldr	r1, [pc, #8]	; (34cc <_exit+0x10>)
    34c2:	2001      	movs	r0, #1
    34c4:	f00a fe10 	bl	e0e8 <_write>
	while (1) {
    34c8:	e7fe      	b.n	34c8 <_exit+0xc>
    34ca:	bf00      	nop
    34cc:	00011c4c 	.word	0x00011c4c

000034d0 <_sbrk>:
}

static LIBC_DATA SYS_SEM_DEFINE(heap_sem, 1, 1);

void *_sbrk(int count)
{
    34d0:	b538      	push	{r3, r4, r5, lr}
    34d2:	4604      	mov	r4, r0
	void *ret, *ptr;

	sys_sem_take(&heap_sem, K_FOREVER);
    34d4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    34d8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    34dc:	480b      	ldr	r0, [pc, #44]	; (350c <_sbrk+0x3c>)
    34de:	f009 fdc7 	bl	d070 <sys_sem_take>

#if CONFIG_NEWLIB_LIBC_ALIGNED_HEAP_SIZE
	ptr = heap_base + heap_sz;
#else
	ptr = ((char *)HEAP_BASE) + heap_sz;
    34e2:	4b0b      	ldr	r3, [pc, #44]	; (3510 <_sbrk+0x40>)
    34e4:	6818      	ldr	r0, [r3, #0]
    34e6:	4b0b      	ldr	r3, [pc, #44]	; (3514 <_sbrk+0x44>)
    34e8:	18c5      	adds	r5, r0, r3
#endif

	if ((heap_sz + count) < MAX_HEAP_SIZE) {
    34ea:	4420      	add	r0, r4
    34ec:	f1c3 5300 	rsb	r3, r3, #536870912	; 0x20000000
    34f0:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
    34f4:	4298      	cmp	r0, r3
    34f6:	d206      	bcs.n	3506 <_sbrk+0x36>
		heap_sz += count;
    34f8:	4b05      	ldr	r3, [pc, #20]	; (3510 <_sbrk+0x40>)
    34fa:	6018      	str	r0, [r3, #0]
		ret = ptr;
	} else {
		ret = (void *)-1;
	}

	sys_sem_give(&heap_sem);
    34fc:	4803      	ldr	r0, [pc, #12]	; (350c <_sbrk+0x3c>)
    34fe:	f009 fdb2 	bl	d066 <sys_sem_give>

	return ret;
}
    3502:	4628      	mov	r0, r5
    3504:	bd38      	pop	{r3, r4, r5, pc}
		ret = (void *)-1;
    3506:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    350a:	e7f7      	b.n	34fc <_sbrk+0x2c>
    350c:	20000480 	.word	0x20000480
    3510:	20003d94 	.word	0x20003d94
    3514:	20008794 	.word	0x20008794

00003518 <nordicsemi_nrf52_init>:
    3518:	f04f 0320 	mov.w	r3, #32
    351c:	f3ef 8211 	mrs	r2, BASEPRI
    3520:	f383 8811 	msr	BASEPRI, r3
    3524:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    3528:	2301      	movs	r3, #1
    352a:	4906      	ldr	r1, [pc, #24]	; (3544 <nordicsemi_nrf52_init+0x2c>)
    352c:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
#endif

#if NRF_POWER_HAS_DCDCEN
NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable)
{
    p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
    3530:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    3534:	f8c1 3578 	str.w	r3, [r1, #1400]	; 0x578
	__asm__ volatile(
    3538:	f382 8811 	msr	BASEPRI, r2
    353c:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    3540:	2000      	movs	r0, #0
    3542:	4770      	bx	lr
    3544:	4001e000 	.word	0x4001e000

00003548 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    3548:	b130      	cbz	r0, 3558 <arch_busy_wait+0x10>

void arch_busy_wait(u32_t time_us)
{
    354a:	b508      	push	{r3, lr}
    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
    354c:	0180      	lsls	r0, r0, #6
    354e:	4b03      	ldr	r3, [pc, #12]	; (355c <arch_busy_wait+0x14>)
    3550:	f043 0301 	orr.w	r3, r3, #1
    3554:	4798      	blx	r3
	nrfx_coredep_delay_us(time_us);
}
    3556:	bd08      	pop	{r3, pc}
    3558:	4770      	bx	lr
    355a:	bf00      	nop
    355c:	00010d50 	.word	0x00010d50

00003560 <bt_hex_real>:
	static const char hex[] = "0123456789abcdef";
	static char str[129];
	const u8_t *b = buf;
	size_t i;

	len = MIN(len, (sizeof(str) - 1) / 2);
    3560:	2940      	cmp	r1, #64	; 0x40
    3562:	bf28      	it	cs
    3564:	2140      	movcs	r1, #64	; 0x40

	for (i = 0; i < len; i++) {
    3566:	2300      	movs	r3, #0
    3568:	428b      	cmp	r3, r1
    356a:	d217      	bcs.n	359c <bt_hex_real+0x3c>
{
    356c:	b470      	push	{r4, r5, r6}
		str[i * 2]     = hex[b[i] >> 4];
    356e:	5cc4      	ldrb	r4, [r0, r3]
    3570:	0924      	lsrs	r4, r4, #4
    3572:	005a      	lsls	r2, r3, #1
    3574:	4e0c      	ldr	r6, [pc, #48]	; (35a8 <bt_hex_real+0x48>)
    3576:	5d34      	ldrb	r4, [r6, r4]
    3578:	4d0c      	ldr	r5, [pc, #48]	; (35ac <bt_hex_real+0x4c>)
    357a:	f805 4013 	strb.w	r4, [r5, r3, lsl #1]
		str[i * 2 + 1] = hex[b[i] & 0xf];
    357e:	5cc4      	ldrb	r4, [r0, r3]
    3580:	f004 040f 	and.w	r4, r4, #15
    3584:	3201      	adds	r2, #1
    3586:	5d34      	ldrb	r4, [r6, r4]
    3588:	54ac      	strb	r4, [r5, r2]
	for (i = 0; i < len; i++) {
    358a:	3301      	adds	r3, #1
    358c:	428b      	cmp	r3, r1
    358e:	d3ee      	bcc.n	356e <bt_hex_real+0xe>
	}

	str[i * 2] = '\0';
    3590:	4806      	ldr	r0, [pc, #24]	; (35ac <bt_hex_real+0x4c>)
    3592:	2200      	movs	r2, #0
    3594:	f800 2013 	strb.w	r2, [r0, r3, lsl #1]

	return str;
}
    3598:	bc70      	pop	{r4, r5, r6}
    359a:	4770      	bx	lr
	str[i * 2] = '\0';
    359c:	4803      	ldr	r0, [pc, #12]	; (35ac <bt_hex_real+0x4c>)
    359e:	2200      	movs	r2, #0
    35a0:	f800 2013 	strb.w	r2, [r0, r3, lsl #1]
}
    35a4:	4770      	bx	lr
    35a6:	bf00      	nop
    35a8:	00011cdc 	.word	0x00011cdc
    35ac:	20003d98 	.word	0x20003d98

000035b0 <bt_addr_le_str_real>:

	return str;
}

const char *bt_addr_le_str_real(const bt_addr_le_t *addr)
{
    35b0:	b5f0      	push	{r4, r5, r6, r7, lr}
    35b2:	b08b      	sub	sp, #44	; 0x2c
    35b4:	4604      	mov	r4, r0
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
				    size_t len)
{
	char type[10];

	switch (addr->type) {
    35b6:	7803      	ldrb	r3, [r0, #0]
    35b8:	2b03      	cmp	r3, #3
    35ba:	d838      	bhi.n	362e <bt_addr_le_str_real+0x7e>
    35bc:	e8df f003 	tbb	[pc, r3]
    35c0:	312b2102 	.word	0x312b2102
	case BT_ADDR_LE_PUBLIC:
		strcpy(type, "public");
    35c4:	4b1d      	ldr	r3, [pc, #116]	; (363c <bt_addr_le_str_real+0x8c>)
    35c6:	e893 0003 	ldmia.w	r3, {r0, r1}
    35ca:	9007      	str	r0, [sp, #28]
    35cc:	f8ad 1020 	strh.w	r1, [sp, #32]
    35d0:	0c09      	lsrs	r1, r1, #16
    35d2:	f88d 1022 	strb.w	r1, [sp, #34]	; 0x22
		snprintk(type, sizeof(type), "0x%02x", addr->type);
		break;
	}

	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
			addr->a.val[5], addr->a.val[4], addr->a.val[3],
    35d6:	7963      	ldrb	r3, [r4, #5]
    35d8:	7922      	ldrb	r2, [r4, #4]
			addr->a.val[2], addr->a.val[1], addr->a.val[0], type);
    35da:	78e1      	ldrb	r1, [r4, #3]
    35dc:	78a0      	ldrb	r0, [r4, #2]
    35de:	7866      	ldrb	r6, [r4, #1]
	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
    35e0:	4d17      	ldr	r5, [pc, #92]	; (3640 <bt_addr_le_str_real+0x90>)
    35e2:	af07      	add	r7, sp, #28
    35e4:	9705      	str	r7, [sp, #20]
    35e6:	9604      	str	r6, [sp, #16]
    35e8:	9003      	str	r0, [sp, #12]
    35ea:	9102      	str	r1, [sp, #8]
    35ec:	9201      	str	r2, [sp, #4]
    35ee:	9300      	str	r3, [sp, #0]
    35f0:	79a3      	ldrb	r3, [r4, #6]
    35f2:	4a14      	ldr	r2, [pc, #80]	; (3644 <bt_addr_le_str_real+0x94>)
    35f4:	211e      	movs	r1, #30
    35f6:	4628      	mov	r0, r5
    35f8:	f009 fd27 	bl	d04a <snprintk>
	static char str[BT_ADDR_LE_STR_LEN];

	bt_addr_le_to_str(addr, str, sizeof(str));

	return str;
}
    35fc:	4628      	mov	r0, r5
    35fe:	b00b      	add	sp, #44	; 0x2c
    3600:	bdf0      	pop	{r4, r5, r6, r7, pc}
		strcpy(type, "random");
    3602:	4b11      	ldr	r3, [pc, #68]	; (3648 <bt_addr_le_str_real+0x98>)
    3604:	e893 0003 	ldmia.w	r3, {r0, r1}
    3608:	9007      	str	r0, [sp, #28]
    360a:	f8ad 1020 	strh.w	r1, [sp, #32]
    360e:	0c09      	lsrs	r1, r1, #16
    3610:	f88d 1022 	strb.w	r1, [sp, #34]	; 0x22
		break;
    3614:	e7df      	b.n	35d6 <bt_addr_le_str_real+0x26>
		strcpy(type, "public-id");
    3616:	4a0d      	ldr	r2, [pc, #52]	; (364c <bt_addr_le_str_real+0x9c>)
    3618:	ab07      	add	r3, sp, #28
    361a:	ca07      	ldmia	r2, {r0, r1, r2}
    361c:	c303      	stmia	r3!, {r0, r1}
    361e:	801a      	strh	r2, [r3, #0]
		break;
    3620:	e7d9      	b.n	35d6 <bt_addr_le_str_real+0x26>
		strcpy(type, "random-id");
    3622:	4a0b      	ldr	r2, [pc, #44]	; (3650 <bt_addr_le_str_real+0xa0>)
    3624:	ab07      	add	r3, sp, #28
    3626:	ca07      	ldmia	r2, {r0, r1, r2}
    3628:	c303      	stmia	r3!, {r0, r1}
    362a:	801a      	strh	r2, [r3, #0]
		break;
    362c:	e7d3      	b.n	35d6 <bt_addr_le_str_real+0x26>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
    362e:	4a09      	ldr	r2, [pc, #36]	; (3654 <bt_addr_le_str_real+0xa4>)
    3630:	210a      	movs	r1, #10
    3632:	a807      	add	r0, sp, #28
    3634:	f009 fd09 	bl	d04a <snprintk>
		break;
    3638:	e7cd      	b.n	35d6 <bt_addr_le_str_real+0x26>
    363a:	bf00      	nop
    363c:	00011c88 	.word	0x00011c88
    3640:	20003e1c 	.word	0x20003e1c
    3644:	00011ca0 	.word	0x00011ca0
    3648:	00011c90 	.word	0x00011c90
    364c:	00011cc4 	.word	0x00011cc4
    3650:	00011cd0 	.word	0x00011cd0
    3654:	00011c98 	.word	0x00011c98

00003658 <read_local_ver_complete>:
}


static void read_local_ver_complete(struct net_buf *buf)
{
	struct bt_hci_rp_read_local_version_info *rp = (void *)buf->data;
    3658:	6882      	ldr	r2, [r0, #8]

	BT_DBG("status 0x%02x", rp->status);

	bt_dev.hci_version = rp->hci_version;
    365a:	7851      	ldrb	r1, [r2, #1]
    365c:	4b07      	ldr	r3, [pc, #28]	; (367c <read_local_ver_complete+0x24>)
    365e:	f883 1038 	strb.w	r1, [r3, #56]	; 0x38
	bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
    3662:	8851      	ldrh	r1, [r2, #2]
    3664:	8759      	strh	r1, [r3, #58]	; 0x3a
	bt_dev.lmp_version = rp->lmp_version;
    3666:	7911      	ldrb	r1, [r2, #4]
    3668:	f883 1039 	strb.w	r1, [r3, #57]	; 0x39
	bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
    366c:	f8b2 1007 	ldrh.w	r1, [r2, #7]
    3670:	8799      	strh	r1, [r3, #60]	; 0x3c
	bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
    3672:	f8b2 2005 	ldrh.w	r2, [r2, #5]
    3676:	87da      	strh	r2, [r3, #62]	; 0x3e
}
    3678:	4770      	bx	lr
    367a:	bf00      	nop
    367c:	20000000 	.word	0x20000000

00003680 <read_le_features_complete>:
{
	struct bt_hci_rp_le_read_local_features *rp = (void *)buf->data;

	BT_DBG("status 0x%02x", rp->status);

	memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
    3680:	4b03      	ldr	r3, [pc, #12]	; (3690 <read_le_features_complete+0x10>)
    3682:	6882      	ldr	r2, [r0, #8]
    3684:	f852 0f01 	ldr.w	r0, [r2, #1]!
    3688:	6851      	ldr	r1, [r2, #4]
    368a:	c303      	stmia	r3!, {r0, r1}
}
    368c:	4770      	bx	lr
    368e:	bf00      	nop
    3690:	200000a0 	.word	0x200000a0

00003694 <read_supported_commands_complete>:
	k_sem_init(&bt_dev.le.pkts, rp->le_max_num, rp->le_max_num);
}
#endif

static void read_supported_commands_complete(struct net_buf *buf)
{
    3694:	b4f0      	push	{r4, r5, r6, r7}
	struct bt_hci_rp_read_supported_commands *rp = (void *)buf->data;
    3696:	6886      	ldr	r6, [r0, #8]

	BT_DBG("status 0x%02x", rp->status);

	memcpy(bt_dev.supported_commands, rp->commands,
    3698:	1c74      	adds	r4, r6, #1
    369a:	4f07      	ldr	r7, [pc, #28]	; (36b8 <read_supported_commands_complete+0x24>)
    369c:	3641      	adds	r6, #65	; 0x41
    369e:	463d      	mov	r5, r7
    36a0:	6820      	ldr	r0, [r4, #0]
    36a2:	6861      	ldr	r1, [r4, #4]
    36a4:	68a2      	ldr	r2, [r4, #8]
    36a6:	68e3      	ldr	r3, [r4, #12]
    36a8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    36aa:	3410      	adds	r4, #16
    36ac:	462f      	mov	r7, r5
    36ae:	42b4      	cmp	r4, r6
    36b0:	d1f5      	bne.n	369e <read_supported_commands_complete+0xa>
	 */
	if (IS_ENABLED(CONFIG_BT_TINYCRYPT_ECC)) {
		bt_dev.supported_commands[34] |= 0x02;
		bt_dev.supported_commands[34] |= 0x04;
	}
}
    36b2:	bcf0      	pop	{r4, r5, r6, r7}
    36b4:	4770      	bx	lr
    36b6:	bf00      	nop
    36b8:	20000048 	.word	0x20000048

000036bc <read_local_features_complete>:
{
	struct bt_hci_rp_read_local_features *rp = (void *)buf->data;

	BT_DBG("status 0x%02x", rp->status);

	memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
    36bc:	4b03      	ldr	r3, [pc, #12]	; (36cc <read_local_features_complete+0x10>)
    36be:	6882      	ldr	r2, [r0, #8]
    36c0:	f852 0f01 	ldr.w	r0, [r2, #1]!
    36c4:	6851      	ldr	r1, [r2, #4]
    36c6:	c303      	stmia	r3!, {r0, r1}
}
    36c8:	4770      	bx	lr
    36ca:	bf00      	nop
    36cc:	20000040 	.word	0x20000040

000036d0 <le_read_supp_states_complete>:

static void le_read_supp_states_complete(struct net_buf *buf)
{
	struct bt_hci_rp_le_read_supp_states *rp = (void *)buf->data;
    36d0:	6883      	ldr	r3, [r0, #8]
 *
 *  @return 16-bit integer in host endianness.
 */
static inline u16_t sys_get_le16(const u8_t src[2])
{
	return ((u16_t)src[1] << 8) | src[0];
    36d2:	7a19      	ldrb	r1, [r3, #8]
    36d4:	79da      	ldrb	r2, [r3, #7]
    36d6:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
    36da:	7998      	ldrb	r0, [r3, #6]
    36dc:	795a      	ldrb	r2, [r3, #5]
    36de:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 *
 *  @return 32-bit integer in host endianness.
 */
static inline u32_t sys_get_le32(const u8_t src[4])
{
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
    36e2:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
	return ((u16_t)src[1] << 8) | src[0];
    36e6:	7918      	ldrb	r0, [r3, #4]
    36e8:	78d9      	ldrb	r1, [r3, #3]
    36ea:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
    36ee:	7898      	ldrb	r0, [r3, #2]
    36f0:	785b      	ldrb	r3, [r3, #1]
    36f2:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
    36f6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16

	BT_DBG("status 0x%02x", rp->status);

	bt_dev.le.states = sys_get_le64(rp->le_states);
    36fa:	4903      	ldr	r1, [pc, #12]	; (3708 <le_read_supp_states_complete+0x38>)
    36fc:	f8c1 30a8 	str.w	r3, [r1, #168]	; 0xa8
    3700:	f8c1 20ac 	str.w	r2, [r1, #172]	; 0xac
}
    3704:	4770      	bx	lr
    3706:	bf00      	nop
    3708:	20000000 	.word	0x20000000

0000370c <ver_str>:
	return 1U;
}

#if defined(CONFIG_BT_DEBUG)
static const char *ver_str(u8_t ver)
{
    370c:	b470      	push	{r4, r5, r6}
    370e:	b08d      	sub	sp, #52	; 0x34
    3710:	4606      	mov	r6, r0
	const char * const str[] = {
    3712:	466c      	mov	r4, sp
    3714:	4d0a      	ldr	r5, [pc, #40]	; (3740 <ver_str+0x34>)
    3716:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3718:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    371a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    371c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    371e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    3722:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
		"1.0b", "1.1", "1.2", "2.0", "2.1", "3.0", "4.0", "4.1", "4.2",
		"5.0", "5.1", "5.2"
	};

	if (ver < ARRAY_SIZE(str)) {
    3726:	2e0b      	cmp	r6, #11
    3728:	d903      	bls.n	3732 <ver_str+0x26>
		return str[ver];
	}

	return "unknown";
    372a:	4806      	ldr	r0, [pc, #24]	; (3744 <ver_str+0x38>)
}
    372c:	b00d      	add	sp, #52	; 0x34
    372e:	bc70      	pop	{r4, r5, r6}
    3730:	4770      	bx	lr
		return str[ver];
    3732:	ab0c      	add	r3, sp, #48	; 0x30
    3734:	eb03 0686 	add.w	r6, r3, r6, lsl #2
    3738:	f856 0c30 	ldr.w	r0, [r6, #-48]
    373c:	e7f6      	b.n	372c <ver_str+0x20>
    373e:	bf00      	nop
    3740:	00010d00 	.word	0x00010d00
    3744:	00011df0 	.word	0x00011df0

00003748 <vs_hw_platform>:
{
	static const char * const plat_str[] = {
		"reserved", "Intel Corporation", "Nordic Semiconductor",
		"NXP Semiconductors" };

	if (platform < ARRAY_SIZE(plat_str)) {
    3748:	2803      	cmp	r0, #3
    374a:	d901      	bls.n	3750 <vs_hw_platform+0x8>
		return plat_str[platform];
	}

	return "unknown";
    374c:	4802      	ldr	r0, [pc, #8]	; (3758 <vs_hw_platform+0x10>)
}
    374e:	4770      	bx	lr
		return plat_str[platform];
    3750:	4b02      	ldr	r3, [pc, #8]	; (375c <vs_hw_platform+0x14>)
    3752:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
    3756:	4770      	bx	lr
    3758:	00011df0 	.word	0x00011df0
    375c:	000123f0 	.word	0x000123f0

00003760 <vs_hw_variant>:
{
	static const char * const nordic_str[] = {
		"reserved", "nRF51x", "nRF52x", "nRF53x"
	};

	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
    3760:	2802      	cmp	r0, #2
    3762:	d107      	bne.n	3774 <vs_hw_variant+0x14>
		return "unknown";
	}

	if (variant < ARRAY_SIZE(nordic_str)) {
    3764:	2903      	cmp	r1, #3
    3766:	d901      	bls.n	376c <vs_hw_variant+0xc>
		return nordic_str[variant];
	}

	return "unknown";
    3768:	4803      	ldr	r0, [pc, #12]	; (3778 <vs_hw_variant+0x18>)
}
    376a:	4770      	bx	lr
		return nordic_str[variant];
    376c:	4b03      	ldr	r3, [pc, #12]	; (377c <vs_hw_variant+0x1c>)
    376e:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
    3772:	4770      	bx	lr
		return "unknown";
    3774:	4800      	ldr	r0, [pc, #0]	; (3778 <vs_hw_variant+0x18>)
    3776:	4770      	bx	lr
    3778:	00011df0 	.word	0x00011df0
    377c:	000123d0 	.word	0x000123d0

00003780 <vs_fw_variant>:
		"Vendor specific controller",
		"Firmware loader",
		"Rescue image",
	};

	if (variant < ARRAY_SIZE(var_str)) {
    3780:	2803      	cmp	r0, #3
    3782:	d901      	bls.n	3788 <vs_fw_variant+0x8>
		return var_str[variant];
	}

	return "unknown";
    3784:	4802      	ldr	r0, [pc, #8]	; (3790 <vs_fw_variant+0x10>)
}
    3786:	4770      	bx	lr
		return var_str[variant];
    3788:	4b02      	ldr	r3, [pc, #8]	; (3794 <vs_fw_variant+0x14>)
    378a:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
    378e:	4770      	bx	lr
    3790:	00011df0 	.word	0x00011df0
    3794:	00012410 	.word	0x00012410

00003798 <hci_reset_complete>:
	u8_t status = buf->data[0];
    3798:	6883      	ldr	r3, [r0, #8]
    379a:	781b      	ldrb	r3, [r3, #0]
	if (status) {
    379c:	b9ab      	cbnz	r3, 37ca <hci_reset_complete+0x32>
	scan_dev_found_cb = NULL;
    379e:	4b0b      	ldr	r3, [pc, #44]	; (37cc <hci_reset_complete+0x34>)
    37a0:	2200      	movs	r2, #0
    37a2:	601a      	str	r2, [r3, #0]
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    37a4:	f3bf 8f5b 	dmb	ish
    37a8:	4b09      	ldr	r3, [pc, #36]	; (37d0 <hci_reset_complete+0x38>)
    37aa:	f853 2f98 	ldr.w	r2, [r3, #152]!
    37ae:	f3bf 8f5b 	dmb	ish
	flags = (atomic_get(bt_dev.flags) & BT_DEV_PERSISTENT_FLAGS);
    37b2:	f002 0205 	and.w	r2, r2, #5
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    37b6:	f3bf 8f5b 	dmb	ish
    37ba:	e853 1f00 	ldrex	r1, [r3]
    37be:	e843 2000 	strex	r0, r2, [r3]
    37c2:	2800      	cmp	r0, #0
    37c4:	d1f9      	bne.n	37ba <hci_reset_complete+0x22>
    37c6:	f3bf 8f5b 	dmb	ish
}
    37ca:	4770      	bx	lr
    37cc:	20003e60 	.word	0x20003e60
    37d0:	20000000 	.word	0x20000000

000037d4 <id_find>:
	memcpy(addrs, bt_dev.id_addr, to_copy * sizeof(bt_addr_le_t));
	*count = to_copy;
}

static int id_find(const bt_addr_le_t *addr)
{
    37d4:	b570      	push	{r4, r5, r6, lr}
    37d6:	4605      	mov	r5, r0
	u8_t id;

	for (id = 0U; id < bt_dev.id_count; id++) {
    37d8:	2400      	movs	r4, #0
    37da:	4b0a      	ldr	r3, [pc, #40]	; (3804 <id_find+0x30>)
    37dc:	79db      	ldrb	r3, [r3, #7]
    37de:	42a3      	cmp	r3, r4
    37e0:	d90c      	bls.n	37fc <id_find+0x28>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
    37e2:	4626      	mov	r6, r4
    37e4:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
	return memcmp(a, b, sizeof(*a));
}

static inline int bt_addr_le_cmp(const bt_addr_le_t *a, const bt_addr_le_t *b)
{
	return memcmp(a, b, sizeof(*a));
    37e8:	2207      	movs	r2, #7
    37ea:	4b06      	ldr	r3, [pc, #24]	; (3804 <id_find+0x30>)
    37ec:	4419      	add	r1, r3
    37ee:	4628      	mov	r0, r5
    37f0:	f00c fec9 	bl	10586 <memcmp>
    37f4:	b120      	cbz	r0, 3800 <id_find+0x2c>
	for (id = 0U; id < bt_dev.id_count; id++) {
    37f6:	3401      	adds	r4, #1
    37f8:	b2e4      	uxtb	r4, r4
    37fa:	e7ee      	b.n	37da <id_find+0x6>
			return id;
		}
	}

	return -ENOENT;
    37fc:	f06f 0601 	mvn.w	r6, #1
}
    3800:	4630      	mov	r0, r6
    3802:	bd70      	pop	{r4, r5, r6, pc}
    3804:	20000000 	.word	0x20000000

00003808 <hci_vendor_event>:
{
    3808:	b510      	push	{r4, lr}
		BT_WARN("Unhandled vendor-specific event: %s",
    380a:	f04f 0400 	mov.w	r4, #0
    380e:	2302      	movs	r3, #2
    3810:	f363 0402 	bfi	r4, r3, #0, #3
    3814:	f36f 04c5 	bfc	r4, #3, #3
    3818:	4b09      	ldr	r3, [pc, #36]	; (3840 <hci_vendor_event+0x38>)
    381a:	4a0a      	ldr	r2, [pc, #40]	; (3844 <hci_vendor_event+0x3c>)
    381c:	1a9b      	subs	r3, r3, r2
    381e:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    3822:	f363 148f 	bfi	r4, r3, #6, #10
    3826:	8981      	ldrh	r1, [r0, #12]
    3828:	6880      	ldr	r0, [r0, #8]
    382a:	f7ff fe99 	bl	3560 <bt_hex_real>
    382e:	f7fd fef7 	bl	1620 <log_strdup>
    3832:	4601      	mov	r1, r0
    3834:	4622      	mov	r2, r4
    3836:	4804      	ldr	r0, [pc, #16]	; (3848 <hci_vendor_event+0x40>)
    3838:	f7fe f8c2 	bl	19c0 <log_1>
}
    383c:	bd10      	pop	{r4, pc}
    383e:	bf00      	nop
    3840:	00010c90 	.word	0x00010c90
    3844:	00010c18 	.word	0x00010c18
    3848:	00011df8 	.word	0x00011df8

0000384c <hci_cmd_done>:
{
    384c:	b5f0      	push	{r4, r5, r6, r7, lr}
    384e:	b085      	sub	sp, #20
    3850:	4605      	mov	r5, r0
    3852:	460e      	mov	r6, r1
    3854:	4614      	mov	r4, r2
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    3856:	7990      	ldrb	r0, [r2, #6]
    3858:	f005 fb58 	bl	8f0c <net_buf_pool_get>
    385c:	4b51      	ldr	r3, [pc, #324]	; (39a4 <hci_cmd_done+0x158>)
    385e:	4283      	cmp	r3, r0
    3860:	d01d      	beq.n	389e <hci_cmd_done+0x52>
		BT_WARN("opcode 0x%04x pool id %u pool %p != &hci_cmd_pool %p",
    3862:	f04f 0600 	mov.w	r6, #0
    3866:	2302      	movs	r3, #2
    3868:	f363 0602 	bfi	r6, r3, #0, #3
    386c:	f36f 06c5 	bfc	r6, #3, #3
    3870:	4b4d      	ldr	r3, [pc, #308]	; (39a8 <hci_cmd_done+0x15c>)
    3872:	4a4e      	ldr	r2, [pc, #312]	; (39ac <hci_cmd_done+0x160>)
    3874:	1a9b      	subs	r3, r3, r2
    3876:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    387a:	f363 168f 	bfi	r6, r3, #6, #10
    387e:	9500      	str	r5, [sp, #0]
    3880:	79a0      	ldrb	r0, [r4, #6]
    3882:	9001      	str	r0, [sp, #4]
    3884:	f005 fb42 	bl	8f0c <net_buf_pool_get>
    3888:	9002      	str	r0, [sp, #8]
    388a:	4b46      	ldr	r3, [pc, #280]	; (39a4 <hci_cmd_done+0x158>)
    388c:	9303      	str	r3, [sp, #12]
    388e:	4633      	mov	r3, r6
    3890:	2204      	movs	r2, #4
    3892:	4669      	mov	r1, sp
    3894:	4846      	ldr	r0, [pc, #280]	; (39b0 <hci_cmd_done+0x164>)
    3896:	f7fe f997 	bl	1bc8 <log_n>
}
    389a:	b005      	add	sp, #20
    389c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (cmd(buf)->opcode != opcode) {
    389e:	4620      	mov	r0, r4
    38a0:	f005 fb3c 	bl	8f1c <net_buf_id>
    38a4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    38a8:	4b42      	ldr	r3, [pc, #264]	; (39b4 <hci_cmd_done+0x168>)
    38aa:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    38ae:	8843      	ldrh	r3, [r0, #2]
    38b0:	42ab      	cmp	r3, r5
    38b2:	d129      	bne.n	3908 <hci_cmd_done+0xbc>
	if (cmd(buf)->state && !status) {
    38b4:	4620      	mov	r0, r4
    38b6:	f005 fb31 	bl	8f1c <net_buf_id>
    38ba:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    38be:	4b3d      	ldr	r3, [pc, #244]	; (39b4 <hci_cmd_done+0x168>)
    38c0:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    38c4:	6843      	ldr	r3, [r0, #4]
    38c6:	b10b      	cbz	r3, 38cc <hci_cmd_done+0x80>
    38c8:	2e00      	cmp	r6, #0
    38ca:	d03a      	beq.n	3942 <hci_cmd_done+0xf6>
	if (cmd(buf)->sync) {
    38cc:	4620      	mov	r0, r4
    38ce:	f005 fb25 	bl	8f1c <net_buf_id>
    38d2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    38d6:	4b37      	ldr	r3, [pc, #220]	; (39b4 <hci_cmd_done+0x168>)
    38d8:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    38dc:	6883      	ldr	r3, [r0, #8]
    38de:	2b00      	cmp	r3, #0
    38e0:	d0db      	beq.n	389a <hci_cmd_done+0x4e>
		cmd(buf)->status = status;
    38e2:	4620      	mov	r0, r4
    38e4:	f005 fb1a 	bl	8f1c <net_buf_id>
    38e8:	4d32      	ldr	r5, [pc, #200]	; (39b4 <hci_cmd_done+0x168>)
    38ea:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    38ee:	f805 6020 	strb.w	r6, [r5, r0, lsl #2]
		k_sem_give(cmd(buf)->sync);
    38f2:	4620      	mov	r0, r4
    38f4:	f005 fb12 	bl	8f1c <net_buf_id>
    38f8:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    38fc:	eb05 0580 	add.w	r5, r5, r0, lsl #2
    3900:	68a8      	ldr	r0, [r5, #8]
	z_impl_k_sem_give(sem);
    3902:	f007 fcfb 	bl	b2fc <z_impl_k_sem_give>
}
    3906:	e7c8      	b.n	389a <hci_cmd_done+0x4e>
		BT_WARN("OpCode 0x%04x completed instead of expected 0x%04x",
    3908:	f04f 0700 	mov.w	r7, #0
    390c:	2302      	movs	r3, #2
    390e:	f363 0702 	bfi	r7, r3, #0, #3
    3912:	f36f 07c5 	bfc	r7, #3, #3
    3916:	4b24      	ldr	r3, [pc, #144]	; (39a8 <hci_cmd_done+0x15c>)
    3918:	4a24      	ldr	r2, [pc, #144]	; (39ac <hci_cmd_done+0x160>)
    391a:	1a9b      	subs	r3, r3, r2
    391c:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    3920:	f363 178f 	bfi	r7, r3, #6, #10
    3924:	4620      	mov	r0, r4
    3926:	f005 faf9 	bl	8f1c <net_buf_id>
    392a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    392e:	4b21      	ldr	r3, [pc, #132]	; (39b4 <hci_cmd_done+0x168>)
    3930:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    3934:	463b      	mov	r3, r7
    3936:	8842      	ldrh	r2, [r0, #2]
    3938:	4629      	mov	r1, r5
    393a:	481f      	ldr	r0, [pc, #124]	; (39b8 <hci_cmd_done+0x16c>)
    393c:	f7fe f8c0 	bl	1ac0 <log_2>
    3940:	e7b8      	b.n	38b4 <hci_cmd_done+0x68>
		struct cmd_state_set *update = cmd(buf)->state;
    3942:	4620      	mov	r0, r4
    3944:	f005 faea 	bl	8f1c <net_buf_id>
    3948:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    394c:	4b19      	ldr	r3, [pc, #100]	; (39b4 <hci_cmd_done+0x168>)
    394e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    3952:	6842      	ldr	r2, [r0, #4]
		atomic_set_bit_to(update->target, update->bit, update->val);
    3954:	6813      	ldr	r3, [r2, #0]
    3956:	6851      	ldr	r1, [r2, #4]
    3958:	7a10      	ldrb	r0, [r2, #8]
 *
 * @return N/A
 */
static inline void atomic_set_bit_to(atomic_t *target, int bit, bool val)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    395a:	f001 051f 	and.w	r5, r1, #31
    395e:	2201      	movs	r2, #1
    3960:	40aa      	lsls	r2, r5

	if (val) {
    3962:	b170      	cbz	r0, 3982 <hci_cmd_done+0x136>
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    3964:	0949      	lsrs	r1, r1, #5
    3966:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    396a:	f3bf 8f5b 	dmb	ish
    396e:	e853 1f00 	ldrex	r1, [r3]
    3972:	4311      	orrs	r1, r2
    3974:	e843 1000 	strex	r0, r1, [r3]
    3978:	2800      	cmp	r0, #0
    397a:	d1f8      	bne.n	396e <hci_cmd_done+0x122>
    397c:	f3bf 8f5b 	dmb	ish
    3980:	e7a4      	b.n	38cc <hci_cmd_done+0x80>
	} else {
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    3982:	0949      	lsrs	r1, r1, #5
    3984:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    3988:	43d2      	mvns	r2, r2
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    398a:	f3bf 8f5b 	dmb	ish
    398e:	e853 1f00 	ldrex	r1, [r3]
    3992:	4011      	ands	r1, r2
    3994:	e843 1000 	strex	r0, r1, [r3]
    3998:	2800      	cmp	r0, #0
    399a:	d1f8      	bne.n	398e <hci_cmd_done+0x142>
    399c:	f3bf 8f5b 	dmb	ish
	}
}
    39a0:	e794      	b.n	38cc <hci_cmd_done+0x80>
    39a2:	bf00      	nop
    39a4:	20000528 	.word	0x20000528
    39a8:	00010c90 	.word	0x00010c90
    39ac:	00010c18 	.word	0x00010c18
    39b0:	00011e1c 	.word	0x00011e1c
    39b4:	20003e3c 	.word	0x20003e3c
    39b8:	00011e54 	.word	0x00011e54

000039bc <hci_cmd_status>:
{
    39bc:	b538      	push	{r3, r4, r5, lr}
    39be:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    39c0:	2104      	movs	r1, #4
    39c2:	3008      	adds	r0, #8
    39c4:	f00b fe83 	bl	f6ce <net_buf_simple_pull_mem>
	ncmd = evt->ncmd;
    39c8:	7845      	ldrb	r5, [r0, #1]
	hci_cmd_done(opcode, evt->status, buf);
    39ca:	4622      	mov	r2, r4
    39cc:	7801      	ldrb	r1, [r0, #0]
    39ce:	8840      	ldrh	r0, [r0, #2]
    39d0:	f7ff ff3c 	bl	384c <hci_cmd_done>
	if (ncmd) {
    39d4:	b905      	cbnz	r5, 39d8 <hci_cmd_status+0x1c>
}
    39d6:	bd38      	pop	{r3, r4, r5, pc}
	z_impl_k_sem_give(sem);
    39d8:	4801      	ldr	r0, [pc, #4]	; (39e0 <hci_cmd_status+0x24>)
    39da:	f007 fc8f 	bl	b2fc <z_impl_k_sem_give>
    39de:	e7fa      	b.n	39d6 <hci_cmd_status+0x1a>
    39e0:	200000b0 	.word	0x200000b0

000039e4 <hci_cmd_complete>:
{
    39e4:	b538      	push	{r3, r4, r5, lr}
    39e6:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    39e8:	2103      	movs	r1, #3
    39ea:	3008      	adds	r0, #8
    39ec:	f00b fe6f 	bl	f6ce <net_buf_simple_pull_mem>
	ncmd = evt->ncmd;
    39f0:	7805      	ldrb	r5, [r0, #0]
	status = buf->data[0];
    39f2:	68a3      	ldr	r3, [r4, #8]
	hci_cmd_done(opcode, status, buf);
    39f4:	4622      	mov	r2, r4
    39f6:	7819      	ldrb	r1, [r3, #0]
    39f8:	f8b0 0001 	ldrh.w	r0, [r0, #1]
    39fc:	f7ff ff26 	bl	384c <hci_cmd_done>
	if (ncmd) {
    3a00:	b905      	cbnz	r5, 3a04 <hci_cmd_complete+0x20>
}
    3a02:	bd38      	pop	{r3, r4, r5, pc}
    3a04:	4801      	ldr	r0, [pc, #4]	; (3a0c <hci_cmd_complete+0x28>)
    3a06:	f007 fc79 	bl	b2fc <z_impl_k_sem_give>
    3a0a:	e7fa      	b.n	3a02 <hci_cmd_complete+0x1e>
    3a0c:	200000b0 	.word	0x200000b0

00003a10 <bt_dev_show_info>:
{
    3a10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3a14:	b086      	sub	sp, #24
	BT_INFO("Identity%s: %s", bt_dev.id_count > 1 ? "[0]" : "",
    3a16:	f04f 0400 	mov.w	r4, #0
    3a1a:	2303      	movs	r3, #3
    3a1c:	f363 0402 	bfi	r4, r3, #0, #3
    3a20:	f36f 04c5 	bfc	r4, #3, #3
    3a24:	4b39      	ldr	r3, [pc, #228]	; (3b0c <bt_dev_show_info+0xfc>)
    3a26:	4a3a      	ldr	r2, [pc, #232]	; (3b10 <bt_dev_show_info+0x100>)
    3a28:	1a9b      	subs	r3, r3, r2
    3a2a:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    3a2e:	f363 148f 	bfi	r4, r3, #6, #10
    3a32:	4b38      	ldr	r3, [pc, #224]	; (3b14 <bt_dev_show_info+0x104>)
    3a34:	79db      	ldrb	r3, [r3, #7]
    3a36:	2b01      	cmp	r3, #1
    3a38:	d92c      	bls.n	3a94 <bt_dev_show_info+0x84>
    3a3a:	4e37      	ldr	r6, [pc, #220]	; (3b18 <bt_dev_show_info+0x108>)
    3a3c:	4835      	ldr	r0, [pc, #212]	; (3b14 <bt_dev_show_info+0x104>)
    3a3e:	f7ff fdb7 	bl	35b0 <bt_addr_le_str_real>
    3a42:	f7fd fded 	bl	1620 <log_strdup>
    3a46:	4602      	mov	r2, r0
    3a48:	4623      	mov	r3, r4
    3a4a:	4631      	mov	r1, r6
    3a4c:	4833      	ldr	r0, [pc, #204]	; (3b1c <bt_dev_show_info+0x10c>)
    3a4e:	f7fe f837 	bl	1ac0 <log_2>
	for (i = 1; i < bt_dev.id_count; i++) {
    3a52:	2401      	movs	r4, #1
    3a54:	4b2f      	ldr	r3, [pc, #188]	; (3b14 <bt_dev_show_info+0x104>)
    3a56:	79db      	ldrb	r3, [r3, #7]
    3a58:	42a3      	cmp	r3, r4
    3a5a:	dd1d      	ble.n	3a98 <bt_dev_show_info+0x88>
		BT_INFO("Identity[%d]: %s",
    3a5c:	2303      	movs	r3, #3
    3a5e:	f363 0502 	bfi	r5, r3, #0, #3
    3a62:	f36f 05c5 	bfc	r5, #3, #3
    3a66:	4b29      	ldr	r3, [pc, #164]	; (3b0c <bt_dev_show_info+0xfc>)
    3a68:	4a29      	ldr	r2, [pc, #164]	; (3b10 <bt_dev_show_info+0x100>)
    3a6a:	1a9b      	subs	r3, r3, r2
    3a6c:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    3a70:	f363 158f 	bfi	r5, r3, #6, #10
    3a74:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
    3a78:	4826      	ldr	r0, [pc, #152]	; (3b14 <bt_dev_show_info+0x104>)
    3a7a:	4418      	add	r0, r3
    3a7c:	f7ff fd98 	bl	35b0 <bt_addr_le_str_real>
    3a80:	f7fd fdce 	bl	1620 <log_strdup>
    3a84:	4602      	mov	r2, r0
    3a86:	462b      	mov	r3, r5
    3a88:	4621      	mov	r1, r4
    3a8a:	4825      	ldr	r0, [pc, #148]	; (3b20 <bt_dev_show_info+0x110>)
    3a8c:	f7fe f818 	bl	1ac0 <log_2>
	for (i = 1; i < bt_dev.id_count; i++) {
    3a90:	3401      	adds	r4, #1
    3a92:	e7df      	b.n	3a54 <bt_dev_show_info+0x44>
	BT_INFO("Identity%s: %s", bt_dev.id_count > 1 ? "[0]" : "",
    3a94:	4e23      	ldr	r6, [pc, #140]	; (3b24 <bt_dev_show_info+0x114>)
    3a96:	e7d1      	b.n	3a3c <bt_dev_show_info+0x2c>
	BT_INFO("HCI: version %s (0x%02x) revision 0x%04x, manufacturer 0x%04x",
    3a98:	2703      	movs	r7, #3
    3a9a:	f04f 0500 	mov.w	r5, #0
    3a9e:	f367 0502 	bfi	r5, r7, #0, #3
    3aa2:	f36f 05c5 	bfc	r5, #3, #3
    3aa6:	4c19      	ldr	r4, [pc, #100]	; (3b0c <bt_dev_show_info+0xfc>)
    3aa8:	4b19      	ldr	r3, [pc, #100]	; (3b10 <bt_dev_show_info+0x100>)
    3aaa:	1ae4      	subs	r4, r4, r3
    3aac:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    3ab0:	f364 158f 	bfi	r5, r4, #6, #10
    3ab4:	4e17      	ldr	r6, [pc, #92]	; (3b14 <bt_dev_show_info+0x104>)
    3ab6:	f896 8038 	ldrb.w	r8, [r6, #56]	; 0x38
    3aba:	4640      	mov	r0, r8
    3abc:	f7ff fe26 	bl	370c <ver_str>
    3ac0:	9002      	str	r0, [sp, #8]
    3ac2:	f8cd 800c 	str.w	r8, [sp, #12]
    3ac6:	8f73      	ldrh	r3, [r6, #58]	; 0x3a
    3ac8:	9304      	str	r3, [sp, #16]
    3aca:	8ff3      	ldrh	r3, [r6, #62]	; 0x3e
    3acc:	9305      	str	r3, [sp, #20]
    3ace:	462b      	mov	r3, r5
    3ad0:	2204      	movs	r2, #4
    3ad2:	a902      	add	r1, sp, #8
    3ad4:	4814      	ldr	r0, [pc, #80]	; (3b28 <bt_dev_show_info+0x118>)
    3ad6:	f7fe f877 	bl	1bc8 <log_n>
	BT_INFO("LMP: version %s (0x%02x) subver 0x%04x",
    3ada:	f04f 0500 	mov.w	r5, #0
    3ade:	f367 0502 	bfi	r5, r7, #0, #3
    3ae2:	f36f 05c5 	bfc	r5, #3, #3
    3ae6:	f364 158f 	bfi	r5, r4, #6, #10
    3aea:	f896 4039 	ldrb.w	r4, [r6, #57]	; 0x39
    3aee:	4620      	mov	r0, r4
    3af0:	f7ff fe0c 	bl	370c <ver_str>
    3af4:	4601      	mov	r1, r0
    3af6:	f8ad 5000 	strh.w	r5, [sp]
    3afa:	8fb3      	ldrh	r3, [r6, #60]	; 0x3c
    3afc:	4622      	mov	r2, r4
    3afe:	480b      	ldr	r0, [pc, #44]	; (3b2c <bt_dev_show_info+0x11c>)
    3b00:	f7fd fe92 	bl	1828 <log_3>
}
    3b04:	b006      	add	sp, #24
    3b06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3b0a:	bf00      	nop
    3b0c:	00010c90 	.word	0x00010c90
    3b10:	00010c18 	.word	0x00010c18
    3b14:	20000000 	.word	0x20000000
    3b18:	00011e88 	.word	0x00011e88
    3b1c:	00011e8c 	.word	0x00011e8c
    3b20:	00011e9c 	.word	0x00011e9c
    3b24:	00011320 	.word	0x00011320
    3b28:	00011eb0 	.word	0x00011eb0
    3b2c:	00011ef0 	.word	0x00011ef0

00003b30 <hci_le_meta_event>:
{
    3b30:	b5f0      	push	{r4, r5, r6, r7, lr}
    3b32:	b083      	sub	sp, #12
    3b34:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    3b36:	2101      	movs	r1, #1
    3b38:	3008      	adds	r0, #8
    3b3a:	f00b fdc8 	bl	f6ce <net_buf_simple_pull_mem>
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    3b3e:	7805      	ldrb	r5, [r0, #0]
	for (i = 0; i < num_handlers; i++) {
    3b40:	2300      	movs	r3, #0
    3b42:	bb23      	cbnz	r3, 3b8e <hci_le_meta_event+0x5e>
		const struct event_handler *handler = &handlers[i];
    3b44:	4a21      	ldr	r2, [pc, #132]	; (3bcc <hci_le_meta_event+0x9c>)
    3b46:	eb02 00c3 	add.w	r0, r2, r3, lsl #3
		if (handler->event != event) {
    3b4a:	f812 2033 	ldrb.w	r2, [r2, r3, lsl #3]
    3b4e:	4295      	cmp	r5, r2
    3b50:	d108      	bne.n	3b64 <hci_le_meta_event+0x34>
		if (buf->len < handler->min_len) {
    3b52:	89a1      	ldrh	r1, [r4, #12]
    3b54:	7843      	ldrb	r3, [r0, #1]
    3b56:	4299      	cmp	r1, r3
    3b58:	d306      	bcc.n	3b68 <hci_le_meta_event+0x38>
		handler->handler(buf);
    3b5a:	6843      	ldr	r3, [r0, #4]
    3b5c:	4620      	mov	r0, r4
    3b5e:	4798      	blx	r3
}
    3b60:	b003      	add	sp, #12
    3b62:	bdf0      	pop	{r4, r5, r6, r7, pc}
	for (i = 0; i < num_handlers; i++) {
    3b64:	3301      	adds	r3, #1
    3b66:	e7ec      	b.n	3b42 <hci_le_meta_event+0x12>
			BT_ERR("Too small (%u bytes) event 0x%02x",
    3b68:	f04f 0300 	mov.w	r3, #0
    3b6c:	2201      	movs	r2, #1
    3b6e:	f362 0302 	bfi	r3, r2, #0, #3
    3b72:	f36f 03c5 	bfc	r3, #3, #3
    3b76:	4a16      	ldr	r2, [pc, #88]	; (3bd0 <hci_le_meta_event+0xa0>)
    3b78:	4816      	ldr	r0, [pc, #88]	; (3bd4 <hci_le_meta_event+0xa4>)
    3b7a:	1a12      	subs	r2, r2, r0
    3b7c:	f3c2 02c9 	ubfx	r2, r2, #3, #10
    3b80:	f362 138f 	bfi	r3, r2, #6, #10
    3b84:	462a      	mov	r2, r5
    3b86:	4814      	ldr	r0, [pc, #80]	; (3bd8 <hci_le_meta_event+0xa8>)
    3b88:	f7fd ff9a 	bl	1ac0 <log_2>
			return;
    3b8c:	e7e8      	b.n	3b60 <hci_le_meta_event+0x30>
	BT_WARN("Unhandled event 0x%02x len %u: %s", event,
    3b8e:	f04f 0600 	mov.w	r6, #0
    3b92:	2302      	movs	r3, #2
    3b94:	f363 0602 	bfi	r6, r3, #0, #3
    3b98:	f36f 06c5 	bfc	r6, #3, #3
    3b9c:	4b0c      	ldr	r3, [pc, #48]	; (3bd0 <hci_le_meta_event+0xa0>)
    3b9e:	4a0d      	ldr	r2, [pc, #52]	; (3bd4 <hci_le_meta_event+0xa4>)
    3ba0:	1a9b      	subs	r3, r3, r2
    3ba2:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    3ba6:	f363 168f 	bfi	r6, r3, #6, #10
    3baa:	89a7      	ldrh	r7, [r4, #12]
    3bac:	4639      	mov	r1, r7
    3bae:	68a0      	ldr	r0, [r4, #8]
    3bb0:	f7ff fcd6 	bl	3560 <bt_hex_real>
    3bb4:	f7fd fd34 	bl	1620 <log_strdup>
    3bb8:	4603      	mov	r3, r0
    3bba:	f8ad 6000 	strh.w	r6, [sp]
    3bbe:	463a      	mov	r2, r7
    3bc0:	4629      	mov	r1, r5
    3bc2:	4806      	ldr	r0, [pc, #24]	; (3bdc <hci_le_meta_event+0xac>)
    3bc4:	f7fd fe30 	bl	1828 <log_3>
}
    3bc8:	e7ca      	b.n	3b60 <hci_le_meta_event+0x30>
    3bca:	bf00      	nop
    3bcc:	00012398 	.word	0x00012398
    3bd0:	00010c90 	.word	0x00010c90
    3bd4:	00010c18 	.word	0x00010c18
    3bd8:	00011f18 	.word	0x00011f18
    3bdc:	00011f3c 	.word	0x00011f3c

00003be0 <hci_event>:
{
    3be0:	b5f0      	push	{r4, r5, r6, r7, lr}
    3be2:	b083      	sub	sp, #12
    3be4:	4604      	mov	r4, r0
	BT_ASSERT(buf->len >= sizeof(*hdr));
    3be6:	8983      	ldrh	r3, [r0, #12]
    3be8:	2b01      	cmp	r3, #1
    3bea:	d920      	bls.n	3c2e <hci_event+0x4e>
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    3bec:	2102      	movs	r1, #2
    3bee:	f104 0008 	add.w	r0, r4, #8
    3bf2:	f00b fd6c 	bl	f6ce <net_buf_simple_pull_mem>
    3bf6:	4605      	mov	r5, r0
	BT_ASSERT(!bt_hci_evt_is_prio(hdr->evt));
    3bf8:	7803      	ldrb	r3, [r0, #0]
 * @return true if the event can be processed in the RX thread, false
 *         if it cannot.
 */
static inline bool bt_hci_evt_is_prio(u8_t evt)
{
	switch (evt) {
    3bfa:	3b0e      	subs	r3, #14
    3bfc:	2b01      	cmp	r3, #1
    3bfe:	d924      	bls.n	3c4a <hci_event+0x6a>
	handle_event(hdr->evt, buf, normal_events, ARRAY_SIZE(normal_events));
    3c00:	782d      	ldrb	r5, [r5, #0]
	for (i = 0; i < num_handlers; i++) {
    3c02:	2300      	movs	r3, #0
    3c04:	2b01      	cmp	r3, #1
    3c06:	d843      	bhi.n	3c90 <hci_event+0xb0>
		const struct event_handler *handler = &handlers[i];
    3c08:	4a30      	ldr	r2, [pc, #192]	; (3ccc <hci_event+0xec>)
    3c0a:	eb02 00c3 	add.w	r0, r2, r3, lsl #3
		if (handler->event != event) {
    3c0e:	f812 2033 	ldrb.w	r2, [r2, r3, lsl #3]
    3c12:	4295      	cmp	r5, r2
    3c14:	d127      	bne.n	3c66 <hci_event+0x86>
		if (buf->len < handler->min_len) {
    3c16:	89a1      	ldrh	r1, [r4, #12]
    3c18:	7843      	ldrb	r3, [r0, #1]
    3c1a:	4299      	cmp	r1, r3
    3c1c:	d325      	bcc.n	3c6a <hci_event+0x8a>
		handler->handler(buf);
    3c1e:	6843      	ldr	r3, [r0, #4]
    3c20:	4620      	mov	r0, r4
    3c22:	4798      	blx	r3
	net_buf_unref(buf);
    3c24:	4620      	mov	r0, r4
    3c26:	f00b fd0f 	bl	f648 <net_buf_unref>
}
    3c2a:	b003      	add	sp, #12
    3c2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	BT_ASSERT(buf->len >= sizeof(*hdr));
    3c2e:	f241 4372 	movw	r3, #5234	; 0x1472
    3c32:	4a27      	ldr	r2, [pc, #156]	; (3cd0 <hci_event+0xf0>)
    3c34:	4927      	ldr	r1, [pc, #156]	; (3cd4 <hci_event+0xf4>)
    3c36:	4828      	ldr	r0, [pc, #160]	; (3cd8 <hci_event+0xf8>)
    3c38:	f009 f9f9 	bl	d02e <printk>
    3c3c:	4040      	eors	r0, r0
    3c3e:	f380 8811 	msr	BASEPRI, r0
    3c42:	f04f 0003 	mov.w	r0, #3
    3c46:	df02      	svc	2
    3c48:	e7d0      	b.n	3bec <hci_event+0xc>
	BT_ASSERT(!bt_hci_evt_is_prio(hdr->evt));
    3c4a:	f241 4376 	movw	r3, #5238	; 0x1476
    3c4e:	4a20      	ldr	r2, [pc, #128]	; (3cd0 <hci_event+0xf0>)
    3c50:	4922      	ldr	r1, [pc, #136]	; (3cdc <hci_event+0xfc>)
    3c52:	4821      	ldr	r0, [pc, #132]	; (3cd8 <hci_event+0xf8>)
    3c54:	f009 f9eb 	bl	d02e <printk>
    3c58:	4040      	eors	r0, r0
    3c5a:	f380 8811 	msr	BASEPRI, r0
    3c5e:	f04f 0003 	mov.w	r0, #3
    3c62:	df02      	svc	2
    3c64:	e7cc      	b.n	3c00 <hci_event+0x20>
	for (i = 0; i < num_handlers; i++) {
    3c66:	3301      	adds	r3, #1
    3c68:	e7cc      	b.n	3c04 <hci_event+0x24>
			BT_ERR("Too small (%u bytes) event 0x%02x",
    3c6a:	f04f 0300 	mov.w	r3, #0
    3c6e:	2201      	movs	r2, #1
    3c70:	f362 0302 	bfi	r3, r2, #0, #3
    3c74:	f36f 03c5 	bfc	r3, #3, #3
    3c78:	4a19      	ldr	r2, [pc, #100]	; (3ce0 <hci_event+0x100>)
    3c7a:	481a      	ldr	r0, [pc, #104]	; (3ce4 <hci_event+0x104>)
    3c7c:	1a12      	subs	r2, r2, r0
    3c7e:	f3c2 02c9 	ubfx	r2, r2, #3, #10
    3c82:	f362 138f 	bfi	r3, r2, #6, #10
    3c86:	462a      	mov	r2, r5
    3c88:	4817      	ldr	r0, [pc, #92]	; (3ce8 <hci_event+0x108>)
    3c8a:	f7fd ff19 	bl	1ac0 <log_2>
			return;
    3c8e:	e7c9      	b.n	3c24 <hci_event+0x44>
	BT_WARN("Unhandled event 0x%02x len %u: %s", event,
    3c90:	f04f 0600 	mov.w	r6, #0
    3c94:	2302      	movs	r3, #2
    3c96:	f363 0602 	bfi	r6, r3, #0, #3
    3c9a:	f36f 06c5 	bfc	r6, #3, #3
    3c9e:	4b10      	ldr	r3, [pc, #64]	; (3ce0 <hci_event+0x100>)
    3ca0:	4a10      	ldr	r2, [pc, #64]	; (3ce4 <hci_event+0x104>)
    3ca2:	1a9b      	subs	r3, r3, r2
    3ca4:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    3ca8:	f363 168f 	bfi	r6, r3, #6, #10
    3cac:	89a7      	ldrh	r7, [r4, #12]
    3cae:	4639      	mov	r1, r7
    3cb0:	68a0      	ldr	r0, [r4, #8]
    3cb2:	f7ff fc55 	bl	3560 <bt_hex_real>
    3cb6:	f7fd fcb3 	bl	1620 <log_strdup>
    3cba:	4603      	mov	r3, r0
    3cbc:	f8ad 6000 	strh.w	r6, [sp]
    3cc0:	463a      	mov	r2, r7
    3cc2:	4629      	mov	r1, r5
    3cc4:	4809      	ldr	r0, [pc, #36]	; (3cec <hci_event+0x10c>)
    3cc6:	f7fd fdaf 	bl	1828 <log_3>
    3cca:	e7ab      	b.n	3c24 <hci_event+0x44>
    3ccc:	000123e0 	.word	0x000123e0
    3cd0:	00011f60 	.word	0x00011f60
    3cd4:	00011fd0 	.word	0x00011fd0
    3cd8:	00011fec 	.word	0x00011fec
    3cdc:	0001200c 	.word	0x0001200c
    3ce0:	00010c90 	.word	0x00010c90
    3ce4:	00010c18 	.word	0x00010c18
    3ce8:	00011f18 	.word	0x00011f18
    3cec:	00011f3c 	.word	0x00011f3c

00003cf0 <bt_hci_cmd_create>:
{
    3cf0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    3cf4:	4682      	mov	sl, r0
    3cf6:	460e      	mov	r6, r1
	buf = net_buf_alloc(&hci_cmd_pool, K_FOREVER);
    3cf8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3cfc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3d00:	4817      	ldr	r0, [pc, #92]	; (3d60 <bt_hci_cmd_create+0x70>)
    3d02:	f00b fc6e 	bl	f5e2 <net_buf_alloc_fixed>
    3d06:	4604      	mov	r4, r0
	net_buf_reserve(buf, BT_BUF_RESERVE);
    3d08:	f100 0808 	add.w	r8, r0, #8
    3d0c:	2100      	movs	r1, #0
    3d0e:	4640      	mov	r0, r8
    3d10:	f00b fc89 	bl	f626 <net_buf_simple_reserve>
 *  @param buf   Bluetooth buffer
 *  @param type  The BT_* type to set the buffer to
 */
static inline void bt_buf_set_type(struct net_buf *buf, enum bt_buf_type type)
{
	*(u8_t *)net_buf_user_data(buf) = type;
    3d14:	2700      	movs	r7, #0
    3d16:	7527      	strb	r7, [r4, #20]
	cmd(buf)->opcode = opcode;
    3d18:	4620      	mov	r0, r4
    3d1a:	f005 f8ff 	bl	8f1c <net_buf_id>
    3d1e:	4d11      	ldr	r5, [pc, #68]	; (3d64 <bt_hci_cmd_create+0x74>)
    3d20:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    3d24:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    3d28:	f8a0 a002 	strh.w	sl, [r0, #2]
	cmd(buf)->sync = NULL;
    3d2c:	4620      	mov	r0, r4
    3d2e:	f005 f8f5 	bl	8f1c <net_buf_id>
    3d32:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    3d36:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    3d3a:	6087      	str	r7, [r0, #8]
	cmd(buf)->state = NULL;
    3d3c:	4620      	mov	r0, r4
    3d3e:	f005 f8ed 	bl	8f1c <net_buf_id>
    3d42:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    3d46:	eb05 0580 	add.w	r5, r5, r0, lsl #2
    3d4a:	606f      	str	r7, [r5, #4]
	hdr = net_buf_add(buf, sizeof(*hdr));
    3d4c:	2103      	movs	r1, #3
    3d4e:	4640      	mov	r0, r8
    3d50:	f00b fca4 	bl	f69c <net_buf_simple_add>
	hdr->opcode = sys_cpu_to_le16(opcode);
    3d54:	f8a0 a000 	strh.w	sl, [r0]
	hdr->param_len = param_len;
    3d58:	7086      	strb	r6, [r0, #2]
}
    3d5a:	4620      	mov	r0, r4
    3d5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    3d60:	20000528 	.word	0x20000528
    3d64:	20003e3c 	.word	0x20003e3c

00003d68 <bt_hci_cmd_send_sync>:
{
    3d68:	b5f0      	push	{r4, r5, r6, r7, lr}
    3d6a:	b087      	sub	sp, #28
    3d6c:	4606      	mov	r6, r0
    3d6e:	4615      	mov	r5, r2
	if (!buf) {
    3d70:	460c      	mov	r4, r1
    3d72:	b361      	cbz	r1, 3dce <bt_hci_cmd_send_sync+0x66>
	return z_impl_k_sem_init(sem, initial_count, limit);
    3d74:	2201      	movs	r2, #1
    3d76:	2100      	movs	r1, #0
    3d78:	4668      	mov	r0, sp
    3d7a:	f00c fa8a 	bl	10292 <z_impl_k_sem_init>
	cmd(buf)->sync = &sync_sem;
    3d7e:	4620      	mov	r0, r4
    3d80:	f005 f8cc 	bl	8f1c <net_buf_id>
    3d84:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    3d88:	4b2f      	ldr	r3, [pc, #188]	; (3e48 <bt_hci_cmd_send_sync+0xe0>)
    3d8a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    3d8e:	f8c0 d008 	str.w	sp, [r0, #8]
	net_buf_ref(buf);
    3d92:	4620      	mov	r0, r4
    3d94:	f00b fc7e 	bl	f694 <net_buf_ref>
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
    3d98:	4621      	mov	r1, r4
    3d9a:	482c      	ldr	r0, [pc, #176]	; (3e4c <bt_hci_cmd_send_sync+0xe4>)
    3d9c:	f00b fc47 	bl	f62e <net_buf_put>
	return z_impl_k_sem_take(sem, timeout);
    3da0:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
    3da4:	2300      	movs	r3, #0
    3da6:	4668      	mov	r0, sp
    3da8:	f007 fad0 	bl	b34c <z_impl_k_sem_take>
	BT_ASSERT_MSG(err == 0, "k_sem_take failed with err %d", err);
    3dac:	4607      	mov	r7, r0
    3dae:	b9b0      	cbnz	r0, 3dde <bt_hci_cmd_send_sync+0x76>
	status = cmd(buf)->status;
    3db0:	4620      	mov	r0, r4
    3db2:	f005 f8b3 	bl	8f1c <net_buf_id>
    3db6:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    3dba:	4b23      	ldr	r3, [pc, #140]	; (3e48 <bt_hci_cmd_send_sync+0xe0>)
    3dbc:	f813 7020 	ldrb.w	r7, [r3, r0, lsl #2]
	if (status) {
    3dc0:	b9ff      	cbnz	r7, 3e02 <bt_hci_cmd_send_sync+0x9a>
	if (rsp) {
    3dc2:	2d00      	cmp	r5, #0
    3dc4:	d03b      	beq.n	3e3e <bt_hci_cmd_send_sync+0xd6>
		*rsp = buf;
    3dc6:	602c      	str	r4, [r5, #0]
	return 0;
    3dc8:	2000      	movs	r0, #0
}
    3dca:	b007      	add	sp, #28
    3dcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		buf = bt_hci_cmd_create(opcode, 0);
    3dce:	f7ff ff8f 	bl	3cf0 <bt_hci_cmd_create>
		if (!buf) {
    3dd2:	4604      	mov	r4, r0
    3dd4:	2800      	cmp	r0, #0
    3dd6:	d1cd      	bne.n	3d74 <bt_hci_cmd_send_sync+0xc>
			return -ENOBUFS;
    3dd8:	f06f 0068 	mvn.w	r0, #104	; 0x68
    3ddc:	e7f5      	b.n	3dca <bt_hci_cmd_send_sync+0x62>
	BT_ASSERT_MSG(err == 0, "k_sem_take failed with err %d", err);
    3dde:	f44f 73b9 	mov.w	r3, #370	; 0x172
    3de2:	4a1b      	ldr	r2, [pc, #108]	; (3e50 <bt_hci_cmd_send_sync+0xe8>)
    3de4:	491b      	ldr	r1, [pc, #108]	; (3e54 <bt_hci_cmd_send_sync+0xec>)
    3de6:	481c      	ldr	r0, [pc, #112]	; (3e58 <bt_hci_cmd_send_sync+0xf0>)
    3de8:	f009 f921 	bl	d02e <printk>
    3dec:	4639      	mov	r1, r7
    3dee:	481b      	ldr	r0, [pc, #108]	; (3e5c <bt_hci_cmd_send_sync+0xf4>)
    3df0:	f009 f91d 	bl	d02e <printk>
    3df4:	4040      	eors	r0, r0
    3df6:	f380 8811 	msr	BASEPRI, r0
    3dfa:	f04f 0003 	mov.w	r0, #3
    3dfe:	df02      	svc	2
    3e00:	e7d6      	b.n	3db0 <bt_hci_cmd_send_sync+0x48>
		BT_WARN("opcode 0x%04x status 0x%02x", opcode, status);
    3e02:	f04f 0300 	mov.w	r3, #0
    3e06:	2202      	movs	r2, #2
    3e08:	f362 0302 	bfi	r3, r2, #0, #3
    3e0c:	f36f 03c5 	bfc	r3, #3, #3
    3e10:	4a13      	ldr	r2, [pc, #76]	; (3e60 <bt_hci_cmd_send_sync+0xf8>)
    3e12:	4914      	ldr	r1, [pc, #80]	; (3e64 <bt_hci_cmd_send_sync+0xfc>)
    3e14:	1a52      	subs	r2, r2, r1
    3e16:	f3c2 02c9 	ubfx	r2, r2, #3, #10
    3e1a:	f362 138f 	bfi	r3, r2, #6, #10
    3e1e:	463a      	mov	r2, r7
    3e20:	4631      	mov	r1, r6
    3e22:	4811      	ldr	r0, [pc, #68]	; (3e68 <bt_hci_cmd_send_sync+0x100>)
    3e24:	f7fd fe4c 	bl	1ac0 <log_2>
		net_buf_unref(buf);
    3e28:	4620      	mov	r0, r4
    3e2a:	f00b fc0d 	bl	f648 <net_buf_unref>
		switch (status) {
    3e2e:	2f09      	cmp	r7, #9
    3e30:	d002      	beq.n	3e38 <bt_hci_cmd_send_sync+0xd0>
			return -EIO;
    3e32:	f06f 0004 	mvn.w	r0, #4
    3e36:	e7c8      	b.n	3dca <bt_hci_cmd_send_sync+0x62>
			return -ECONNREFUSED;
    3e38:	f06f 006e 	mvn.w	r0, #110	; 0x6e
    3e3c:	e7c5      	b.n	3dca <bt_hci_cmd_send_sync+0x62>
		net_buf_unref(buf);
    3e3e:	4620      	mov	r0, r4
    3e40:	f00b fc02 	bl	f648 <net_buf_unref>
	return 0;
    3e44:	2000      	movs	r0, #0
    3e46:	e7c0      	b.n	3dca <bt_hci_cmd_send_sync+0x62>
    3e48:	20003e3c 	.word	0x20003e3c
    3e4c:	200000cc 	.word	0x200000cc
    3e50:	00011f60 	.word	0x00011f60
    3e54:	0001202c 	.word	0x0001202c
    3e58:	00011fec 	.word	0x00011fec
    3e5c:	00012038 	.word	0x00012038
    3e60:	00010c90 	.word	0x00010c90
    3e64:	00010c18 	.word	0x00010c18
    3e68:	00012058 	.word	0x00012058

00003e6c <common_init>:
{
    3e6c:	b510      	push	{r4, lr}
    3e6e:	b082      	sub	sp, #8
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
    3e70:	4b22      	ldr	r3, [pc, #136]	; (3efc <common_init+0x90>)
    3e72:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
    3e76:	689b      	ldr	r3, [r3, #8]
    3e78:	f013 0f01 	tst.w	r3, #1
    3e7c:	d10d      	bne.n	3e9a <common_init+0x2e>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
    3e7e:	aa01      	add	r2, sp, #4
    3e80:	2100      	movs	r1, #0
    3e82:	f640 4003 	movw	r0, #3075	; 0xc03
    3e86:	f7ff ff6f 	bl	3d68 <bt_hci_cmd_send_sync>
		if (err) {
    3e8a:	4604      	mov	r4, r0
    3e8c:	b968      	cbnz	r0, 3eaa <common_init+0x3e>
		hci_reset_complete(rsp);
    3e8e:	9801      	ldr	r0, [sp, #4]
    3e90:	f7ff fc82 	bl	3798 <hci_reset_complete>
		net_buf_unref(rsp);
    3e94:	9801      	ldr	r0, [sp, #4]
    3e96:	f00b fbd7 	bl	f648 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
    3e9a:	aa01      	add	r2, sp, #4
    3e9c:	2100      	movs	r1, #0
    3e9e:	f241 0003 	movw	r0, #4099	; 0x1003
    3ea2:	f7ff ff61 	bl	3d68 <bt_hci_cmd_send_sync>
	if (err) {
    3ea6:	4604      	mov	r4, r0
    3ea8:	b110      	cbz	r0, 3eb0 <common_init+0x44>
}
    3eaa:	4620      	mov	r0, r4
    3eac:	b002      	add	sp, #8
    3eae:	bd10      	pop	{r4, pc}
	read_local_features_complete(rsp);
    3eb0:	9801      	ldr	r0, [sp, #4]
    3eb2:	f7ff fc03 	bl	36bc <read_local_features_complete>
	net_buf_unref(rsp);
    3eb6:	9801      	ldr	r0, [sp, #4]
    3eb8:	f00b fbc6 	bl	f648 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
    3ebc:	aa01      	add	r2, sp, #4
    3ebe:	2100      	movs	r1, #0
    3ec0:	f241 0001 	movw	r0, #4097	; 0x1001
    3ec4:	f7ff ff50 	bl	3d68 <bt_hci_cmd_send_sync>
	if (err) {
    3ec8:	4604      	mov	r4, r0
    3eca:	2800      	cmp	r0, #0
    3ecc:	d1ed      	bne.n	3eaa <common_init+0x3e>
	read_local_ver_complete(rsp);
    3ece:	9801      	ldr	r0, [sp, #4]
    3ed0:	f7ff fbc2 	bl	3658 <read_local_ver_complete>
	net_buf_unref(rsp);
    3ed4:	9801      	ldr	r0, [sp, #4]
    3ed6:	f00b fbb7 	bl	f648 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
    3eda:	aa01      	add	r2, sp, #4
    3edc:	2100      	movs	r1, #0
    3ede:	f241 0002 	movw	r0, #4098	; 0x1002
    3ee2:	f7ff ff41 	bl	3d68 <bt_hci_cmd_send_sync>
	if (err) {
    3ee6:	4604      	mov	r4, r0
    3ee8:	2800      	cmp	r0, #0
    3eea:	d1de      	bne.n	3eaa <common_init+0x3e>
	read_supported_commands_complete(rsp);
    3eec:	9801      	ldr	r0, [sp, #4]
    3eee:	f7ff fbd1 	bl	3694 <read_supported_commands_complete>
	net_buf_unref(rsp);
    3ef2:	9801      	ldr	r0, [sp, #4]
    3ef4:	f00b fba8 	bl	f648 <net_buf_unref>
	return 0;
    3ef8:	e7d7      	b.n	3eaa <common_init+0x3e>
    3efa:	bf00      	nop
    3efc:	20000000 	.word	0x20000000

00003f00 <le_init>:
{
    3f00:	b510      	push	{r4, lr}
    3f02:	b082      	sub	sp, #8
	if (!BT_FEAT_LE(bt_dev.features)) {
    3f04:	4b32      	ldr	r3, [pc, #200]	; (3fd0 <le_init+0xd0>)
    3f06:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    3f0a:	f013 0f40 	tst.w	r3, #64	; 0x40
    3f0e:	d00a      	beq.n	3f26 <le_init+0x26>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
    3f10:	aa01      	add	r2, sp, #4
    3f12:	2100      	movs	r1, #0
    3f14:	f242 0003 	movw	r0, #8195	; 0x2003
    3f18:	f7ff ff26 	bl	3d68 <bt_hci_cmd_send_sync>
	if (err) {
    3f1c:	4603      	mov	r3, r0
    3f1e:	b1b0      	cbz	r0, 3f4e <le_init+0x4e>
}
    3f20:	4618      	mov	r0, r3
    3f22:	b002      	add	sp, #8
    3f24:	bd10      	pop	{r4, pc}
		BT_ERR("Non-LE capable controller detected!");
    3f26:	f04f 0100 	mov.w	r1, #0
    3f2a:	2301      	movs	r3, #1
    3f2c:	f363 0102 	bfi	r1, r3, #0, #3
    3f30:	f36f 01c5 	bfc	r1, #3, #3
    3f34:	4b27      	ldr	r3, [pc, #156]	; (3fd4 <le_init+0xd4>)
    3f36:	4a28      	ldr	r2, [pc, #160]	; (3fd8 <le_init+0xd8>)
    3f38:	1a9b      	subs	r3, r3, r2
    3f3a:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    3f3e:	f363 118f 	bfi	r1, r3, #6, #10
    3f42:	4826      	ldr	r0, [pc, #152]	; (3fdc <le_init+0xdc>)
    3f44:	f7fd feac 	bl	1ca0 <log_0>
		return -ENODEV;
    3f48:	f06f 0312 	mvn.w	r3, #18
    3f4c:	e7e8      	b.n	3f20 <le_init+0x20>
	read_le_features_complete(rsp);
    3f4e:	9801      	ldr	r0, [sp, #4]
    3f50:	f7ff fb96 	bl	3680 <read_le_features_complete>
	net_buf_unref(rsp);
    3f54:	9801      	ldr	r0, [sp, #4]
    3f56:	f00b fb77 	bl	f648 <net_buf_unref>
	if (BT_FEAT_BREDR(bt_dev.features)) {
    3f5a:	4b1d      	ldr	r3, [pc, #116]	; (3fd0 <le_init+0xd0>)
    3f5c:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    3f60:	f013 0f20 	tst.w	r3, #32
    3f64:	d018      	beq.n	3f98 <le_init+0x98>
	if (BT_CMD_LE_STATES(bt_dev.supported_commands)) {
    3f66:	4b1a      	ldr	r3, [pc, #104]	; (3fd0 <le_init+0xd0>)
    3f68:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
    3f6c:	f013 0f08 	tst.w	r3, #8
    3f70:	d00e      	beq.n	3f90 <le_init+0x90>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
    3f72:	aa01      	add	r2, sp, #4
    3f74:	2100      	movs	r1, #0
    3f76:	f242 001c 	movw	r0, #8220	; 0x201c
    3f7a:	f7ff fef5 	bl	3d68 <bt_hci_cmd_send_sync>
		if (err) {
    3f7e:	4603      	mov	r3, r0
    3f80:	2800      	cmp	r0, #0
    3f82:	d1cd      	bne.n	3f20 <le_init+0x20>
		le_read_supp_states_complete(rsp);
    3f84:	9801      	ldr	r0, [sp, #4]
    3f86:	f7ff fba3 	bl	36d0 <le_read_supp_states_complete>
		net_buf_unref(rsp);
    3f8a:	9801      	ldr	r0, [sp, #4]
    3f8c:	f00b fb5c 	bl	f648 <net_buf_unref>
	return  le_set_event_mask();
    3f90:	f00a f8fe 	bl	e190 <le_set_event_mask>
    3f94:	4603      	mov	r3, r0
    3f96:	e7c3      	b.n	3f20 <le_init+0x20>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP,
    3f98:	2102      	movs	r1, #2
    3f9a:	f640 406d 	movw	r0, #3181	; 0xc6d
    3f9e:	f7ff fea7 	bl	3cf0 <bt_hci_cmd_create>
		if (!buf) {
    3fa2:	4604      	mov	r4, r0
    3fa4:	b180      	cbz	r0, 3fc8 <le_init+0xc8>
		cp_le = net_buf_add(buf, sizeof(*cp_le));
    3fa6:	2102      	movs	r1, #2
    3fa8:	3008      	adds	r0, #8
    3faa:	f00b fb77 	bl	f69c <net_buf_simple_add>
		cp_le->le = 0x01;
    3fae:	2301      	movs	r3, #1
    3fb0:	7003      	strb	r3, [r0, #0]
		cp_le->simul = 0x00;
    3fb2:	2200      	movs	r2, #0
    3fb4:	7042      	strb	r2, [r0, #1]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
    3fb6:	4621      	mov	r1, r4
    3fb8:	f640 406d 	movw	r0, #3181	; 0xc6d
    3fbc:	f7ff fed4 	bl	3d68 <bt_hci_cmd_send_sync>
		if (err) {
    3fc0:	4603      	mov	r3, r0
    3fc2:	2800      	cmp	r0, #0
    3fc4:	d0cf      	beq.n	3f66 <le_init+0x66>
    3fc6:	e7ab      	b.n	3f20 <le_init+0x20>
			return -ENOBUFS;
    3fc8:	f06f 0368 	mvn.w	r3, #104	; 0x68
    3fcc:	e7a8      	b.n	3f20 <le_init+0x20>
    3fce:	bf00      	nop
    3fd0:	20000000 	.word	0x20000000
    3fd4:	00010c90 	.word	0x00010c90
    3fd8:	00010c18 	.word	0x00010c18
    3fdc:	00012074 	.word	0x00012074

00003fe0 <hci_vs_init>:
{
    3fe0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3fe4:	b086      	sub	sp, #24
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_VERSION_INFO, NULL, &rsp);
    3fe6:	aa05      	add	r2, sp, #20
    3fe8:	2100      	movs	r1, #0
    3fea:	f64f 4001 	movw	r0, #64513	; 0xfc01
    3fee:	f7ff febb 	bl	3d68 <bt_hci_cmd_send_sync>
	if (err) {
    3ff2:	2800      	cmp	r0, #0
    3ff4:	d173      	bne.n	40de <hci_vs_init+0xfe>
	rp.info = (void *)rsp->data;
    3ff6:	9b05      	ldr	r3, [sp, #20]
    3ff8:	689c      	ldr	r4, [r3, #8]
	BT_INFO("HW Platform: %s (0x%04x)",
    3ffa:	2703      	movs	r7, #3
    3ffc:	f04f 0600 	mov.w	r6, #0
    4000:	f367 0602 	bfi	r6, r7, #0, #3
    4004:	f36f 06c5 	bfc	r6, #3, #3
    4008:	4d51      	ldr	r5, [pc, #324]	; (4150 <hci_vs_init+0x170>)
    400a:	4b52      	ldr	r3, [pc, #328]	; (4154 <hci_vs_init+0x174>)
    400c:	1aed      	subs	r5, r5, r3
    400e:	f3c5 05c9 	ubfx	r5, r5, #3, #10
    4012:	f365 168f 	bfi	r6, r5, #6, #10
    4016:	f8b4 8001 	ldrh.w	r8, [r4, #1]
    401a:	4640      	mov	r0, r8
    401c:	f7ff fb94 	bl	3748 <vs_hw_platform>
    4020:	4601      	mov	r1, r0
    4022:	4633      	mov	r3, r6
    4024:	4642      	mov	r2, r8
    4026:	484c      	ldr	r0, [pc, #304]	; (4158 <hci_vs_init+0x178>)
    4028:	f7fd fd4a 	bl	1ac0 <log_2>
	BT_INFO("HW Variant: %s (0x%04x)",
    402c:	f04f 0600 	mov.w	r6, #0
    4030:	f367 0602 	bfi	r6, r7, #0, #3
    4034:	f36f 06c5 	bfc	r6, #3, #3
    4038:	f365 168f 	bfi	r6, r5, #6, #10
    403c:	f8b4 8003 	ldrh.w	r8, [r4, #3]
    4040:	4641      	mov	r1, r8
    4042:	f8b4 0001 	ldrh.w	r0, [r4, #1]
    4046:	f7ff fb8b 	bl	3760 <vs_hw_variant>
    404a:	4601      	mov	r1, r0
    404c:	4633      	mov	r3, r6
    404e:	4642      	mov	r2, r8
    4050:	4842      	ldr	r0, [pc, #264]	; (415c <hci_vs_init+0x17c>)
    4052:	f7fd fd35 	bl	1ac0 <log_2>
	BT_INFO("Firmware: %s (0x%02x) Version %u.%u Build %u",
    4056:	f04f 0600 	mov.w	r6, #0
    405a:	f367 0602 	bfi	r6, r7, #0, #3
    405e:	f36f 06c5 	bfc	r6, #3, #3
    4062:	f365 168f 	bfi	r6, r5, #6, #10
    4066:	7965      	ldrb	r5, [r4, #5]
    4068:	4628      	mov	r0, r5
    406a:	f7ff fb89 	bl	3780 <vs_fw_variant>
    406e:	9000      	str	r0, [sp, #0]
    4070:	9501      	str	r5, [sp, #4]
    4072:	79a3      	ldrb	r3, [r4, #6]
    4074:	9302      	str	r3, [sp, #8]
    4076:	f8b4 3007 	ldrh.w	r3, [r4, #7]
    407a:	9303      	str	r3, [sp, #12]
    407c:	f8d4 3009 	ldr.w	r3, [r4, #9]
    4080:	9304      	str	r3, [sp, #16]
    4082:	4633      	mov	r3, r6
    4084:	2205      	movs	r2, #5
    4086:	4669      	mov	r1, sp
    4088:	4835      	ldr	r0, [pc, #212]	; (4160 <hci_vs_init+0x180>)
    408a:	f7fd fd9d 	bl	1bc8 <log_n>
	net_buf_unref(rsp);
    408e:	9805      	ldr	r0, [sp, #20]
    4090:	f00b fada 	bl	f648 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_COMMANDS,
    4094:	aa05      	add	r2, sp, #20
    4096:	2100      	movs	r1, #0
    4098:	f64f 4002 	movw	r0, #64514	; 0xfc02
    409c:	f7ff fe64 	bl	3d68 <bt_hci_cmd_send_sync>
	if (err) {
    40a0:	bb88      	cbnz	r0, 4106 <hci_vs_init+0x126>
	rp.cmds = (void *)rsp->data;
    40a2:	9805      	ldr	r0, [sp, #20]
    40a4:	6883      	ldr	r3, [r0, #8]
	memcpy(bt_dev.vs_commands, rp.cmds->commands, BT_DEV_VS_CMDS_MAX);
    40a6:	f8b3 3001 	ldrh.w	r3, [r3, #1]
    40aa:	4c2e      	ldr	r4, [pc, #184]	; (4164 <hci_vs_init+0x184>)
    40ac:	f8a4 3089 	strh.w	r3, [r4, #137]	; 0x89
	net_buf_unref(rsp);
    40b0:	f00b faca 	bl	f648 <net_buf_unref>
	if (BT_VS_CMD_SUP_FEAT(bt_dev.vs_commands)) {
    40b4:	f894 3089 	ldrb.w	r3, [r4, #137]	; 0x89
    40b8:	f013 0f04 	tst.w	r3, #4
    40bc:	d020      	beq.n	4100 <hci_vs_init+0x120>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_FEATURES,
    40be:	aa05      	add	r2, sp, #20
    40c0:	2100      	movs	r1, #0
    40c2:	f64f 4003 	movw	r0, #64515	; 0xfc03
    40c6:	f7ff fe4f 	bl	3d68 <bt_hci_cmd_send_sync>
		if (err) {
    40ca:	bb70      	cbnz	r0, 412a <hci_vs_init+0x14a>
		rp.feat = (void *)rsp->data;
    40cc:	9805      	ldr	r0, [sp, #20]
    40ce:	6883      	ldr	r3, [r0, #8]
		memcpy(bt_dev.vs_features, rp.feat->features,
    40d0:	785a      	ldrb	r2, [r3, #1]
    40d2:	4b24      	ldr	r3, [pc, #144]	; (4164 <hci_vs_init+0x184>)
    40d4:	f883 2088 	strb.w	r2, [r3, #136]	; 0x88
		net_buf_unref(rsp);
    40d8:	f00b fab6 	bl	f648 <net_buf_unref>
    40dc:	e010      	b.n	4100 <hci_vs_init+0x120>
		BT_WARN("Vendor HCI extensions not available");
    40de:	f04f 0100 	mov.w	r1, #0
    40e2:	2302      	movs	r3, #2
    40e4:	f363 0102 	bfi	r1, r3, #0, #3
    40e8:	f36f 01c5 	bfc	r1, #3, #3
    40ec:	4b18      	ldr	r3, [pc, #96]	; (4150 <hci_vs_init+0x170>)
    40ee:	4a19      	ldr	r2, [pc, #100]	; (4154 <hci_vs_init+0x174>)
    40f0:	1a9b      	subs	r3, r3, r2
    40f2:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    40f6:	f363 118f 	bfi	r1, r3, #6, #10
    40fa:	481b      	ldr	r0, [pc, #108]	; (4168 <hci_vs_init+0x188>)
    40fc:	f7fd fdd0 	bl	1ca0 <log_0>
}
    4100:	b006      	add	sp, #24
    4102:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		BT_WARN("Failed to read supported vendor commands");
    4106:	f04f 0100 	mov.w	r1, #0
    410a:	2302      	movs	r3, #2
    410c:	f363 0102 	bfi	r1, r3, #0, #3
    4110:	f36f 01c5 	bfc	r1, #3, #3
    4114:	4b0e      	ldr	r3, [pc, #56]	; (4150 <hci_vs_init+0x170>)
    4116:	4a0f      	ldr	r2, [pc, #60]	; (4154 <hci_vs_init+0x174>)
    4118:	1a9b      	subs	r3, r3, r2
    411a:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    411e:	f363 118f 	bfi	r1, r3, #6, #10
    4122:	4812      	ldr	r0, [pc, #72]	; (416c <hci_vs_init+0x18c>)
    4124:	f7fd fdbc 	bl	1ca0 <log_0>
		return;
    4128:	e7ea      	b.n	4100 <hci_vs_init+0x120>
			BT_WARN("Failed to read supported vendor features");
    412a:	f04f 0100 	mov.w	r1, #0
    412e:	2302      	movs	r3, #2
    4130:	f363 0102 	bfi	r1, r3, #0, #3
    4134:	f36f 01c5 	bfc	r1, #3, #3
    4138:	4b05      	ldr	r3, [pc, #20]	; (4150 <hci_vs_init+0x170>)
    413a:	4a06      	ldr	r2, [pc, #24]	; (4154 <hci_vs_init+0x174>)
    413c:	1a9b      	subs	r3, r3, r2
    413e:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    4142:	f363 118f 	bfi	r1, r3, #6, #10
    4146:	480a      	ldr	r0, [pc, #40]	; (4170 <hci_vs_init+0x190>)
    4148:	f7fd fdaa 	bl	1ca0 <log_0>
			return;
    414c:	e7d8      	b.n	4100 <hci_vs_init+0x120>
    414e:	bf00      	nop
    4150:	00010c90 	.word	0x00010c90
    4154:	00010c18 	.word	0x00010c18
    4158:	000120bc 	.word	0x000120bc
    415c:	000120d8 	.word	0x000120d8
    4160:	000120f0 	.word	0x000120f0
    4164:	20000000 	.word	0x20000000
    4168:	00012098 	.word	0x00012098
    416c:	00012120 	.word	0x00012120
    4170:	0001214c 	.word	0x0001214c

00004174 <set_random_address>:
{
    4174:	b538      	push	{r3, r4, r5, lr}
    4176:	4604      	mov	r4, r0
	return memcmp(a, b, sizeof(*a));
    4178:	2206      	movs	r2, #6
    417a:	4913      	ldr	r1, [pc, #76]	; (41c8 <set_random_address+0x54>)
    417c:	f00c fa03 	bl	10586 <memcmp>
	if (!bt_addr_cmp(addr, &bt_dev.random_addr.a)) {
    4180:	b900      	cbnz	r0, 4184 <set_random_address+0x10>
}
    4182:	bd38      	pop	{r3, r4, r5, pc}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, sizeof(*addr));
    4184:	2106      	movs	r1, #6
    4186:	f242 0005 	movw	r0, #8197	; 0x2005
    418a:	f7ff fdb1 	bl	3cf0 <bt_hci_cmd_create>
	if (!buf) {
    418e:	4605      	mov	r5, r0
    4190:	b1b8      	cbz	r0, 41c2 <set_random_address+0x4e>
	net_buf_add_mem(buf, addr, sizeof(*addr));
    4192:	2206      	movs	r2, #6
    4194:	4621      	mov	r1, r4
    4196:	3008      	adds	r0, #8
    4198:	f00b fa86 	bl	f6a8 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
    419c:	2200      	movs	r2, #0
    419e:	4629      	mov	r1, r5
    41a0:	f242 0005 	movw	r0, #8197	; 0x2005
    41a4:	f7ff fde0 	bl	3d68 <bt_hci_cmd_send_sync>
	if (err) {
    41a8:	2800      	cmp	r0, #0
    41aa:	d1ea      	bne.n	4182 <set_random_address+0xe>
}

static inline void bt_addr_copy(bt_addr_t *dst, const bt_addr_t *src)
{
	memcpy(dst, src, sizeof(*dst));
    41ac:	4b07      	ldr	r3, [pc, #28]	; (41cc <set_random_address+0x58>)
    41ae:	6822      	ldr	r2, [r4, #0]
    41b0:	f8c3 2031 	str.w	r2, [r3, #49]	; 0x31
    41b4:	88a2      	ldrh	r2, [r4, #4]
    41b6:	f8a3 2035 	strh.w	r2, [r3, #53]	; 0x35
	bt_dev.random_addr.type = BT_ADDR_LE_RANDOM;
    41ba:	2201      	movs	r2, #1
    41bc:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
	return 0;
    41c0:	e7df      	b.n	4182 <set_random_address+0xe>
		return -ENOBUFS;
    41c2:	f06f 0068 	mvn.w	r0, #104	; 0x68
    41c6:	e7dc      	b.n	4182 <set_random_address+0xe>
    41c8:	20000031 	.word	0x20000031
    41cc:	20000000 	.word	0x20000000

000041d0 <set_le_scan_enable_legacy>:
{
    41d0:	b570      	push	{r4, r5, r6, lr}
    41d2:	b084      	sub	sp, #16
    41d4:	4604      	mov	r4, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_SCAN_ENABLE, sizeof(*cp));
    41d6:	2102      	movs	r1, #2
    41d8:	f242 000c 	movw	r0, #8204	; 0x200c
    41dc:	f7ff fd88 	bl	3cf0 <bt_hci_cmd_create>
	if (!buf) {
    41e0:	b378      	cbz	r0, 4242 <set_le_scan_enable_legacy+0x72>
    41e2:	4605      	mov	r5, r0
	cp = net_buf_add(buf, sizeof(*cp));
    41e4:	2102      	movs	r1, #2
    41e6:	3008      	adds	r0, #8
    41e8:	f00b fa58 	bl	f69c <net_buf_simple_add>
	if (enable == BT_HCI_LE_SCAN_ENABLE) {
    41ec:	2c01      	cmp	r4, #1
    41ee:	d01d      	beq.n	422c <set_le_scan_enable_legacy+0x5c>
		cp->filter_dup = BT_HCI_LE_SCAN_FILTER_DUP_DISABLE;
    41f0:	2300      	movs	r3, #0
    41f2:	7043      	strb	r3, [r0, #1]
	cp->enable = enable;
    41f4:	7004      	strb	r4, [r0, #0]
	cmd_state_set_init(&state, bt_dev.flags, BT_DEV_SCANNING,
    41f6:	ae01      	add	r6, sp, #4
    41f8:	2c01      	cmp	r4, #1
    41fa:	bf14      	ite	ne
    41fc:	2300      	movne	r3, #0
    41fe:	2301      	moveq	r3, #1
    4200:	2205      	movs	r2, #5
    4202:	4911      	ldr	r1, [pc, #68]	; (4248 <set_le_scan_enable_legacy+0x78>)
    4204:	4630      	mov	r0, r6
    4206:	f009 ffbf 	bl	e188 <cmd_state_set_init>
	cmd(buf)->state = &state;
    420a:	4628      	mov	r0, r5
    420c:	f004 fe86 	bl	8f1c <net_buf_id>
    4210:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    4214:	4b0d      	ldr	r3, [pc, #52]	; (424c <set_le_scan_enable_legacy+0x7c>)
    4216:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    421a:	6046      	str	r6, [r0, #4]
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_SCAN_ENABLE, buf, NULL);
    421c:	2200      	movs	r2, #0
    421e:	4629      	mov	r1, r5
    4220:	f242 000c 	movw	r0, #8204	; 0x200c
    4224:	f7ff fda0 	bl	3d68 <bt_hci_cmd_send_sync>
}
    4228:	b004      	add	sp, #16
    422a:	bd70      	pop	{r4, r5, r6, pc}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    422c:	f3bf 8f5b 	dmb	ish
    4230:	4b07      	ldr	r3, [pc, #28]	; (4250 <set_le_scan_enable_legacy+0x80>)
    4232:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    4236:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    423a:	f3c3 2300 	ubfx	r3, r3, #8, #1
		cp->filter_dup = atomic_test_bit(bt_dev.flags,
    423e:	7043      	strb	r3, [r0, #1]
    4240:	e7d8      	b.n	41f4 <set_le_scan_enable_legacy+0x24>
		return -ENOBUFS;
    4242:	f06f 0068 	mvn.w	r0, #104	; 0x68
    4246:	e7ef      	b.n	4228 <set_le_scan_enable_legacy+0x58>
    4248:	20000098 	.word	0x20000098
    424c:	20003e3c 	.word	0x20003e3c
    4250:	20000000 	.word	0x20000000

00004254 <bt_read_public_addr>:
{
    4254:	b530      	push	{r4, r5, lr}
    4256:	b087      	sub	sp, #28
    4258:	4605      	mov	r5, r0
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
    425a:	aa01      	add	r2, sp, #4
    425c:	2100      	movs	r1, #0
    425e:	f241 0009 	movw	r0, #4105	; 0x1009
    4262:	f7ff fd81 	bl	3d68 <bt_hci_cmd_send_sync>
	if (err) {
    4266:	b9f0      	cbnz	r0, 42a6 <bt_read_public_addr+0x52>
	rp = (void *)rsp->data;
    4268:	9b01      	ldr	r3, [sp, #4]
    426a:	689c      	ldr	r4, [r3, #8]
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    426c:	3401      	adds	r4, #1
    426e:	2300      	movs	r3, #0
    4270:	9302      	str	r3, [sp, #8]
    4272:	f8ad 300c 	strh.w	r3, [sp, #12]
	return memcmp(a, b, sizeof(*a));
    4276:	2206      	movs	r2, #6
    4278:	a902      	add	r1, sp, #8
    427a:	4620      	mov	r0, r4
    427c:	f00c f983 	bl	10586 <memcmp>
    4280:	b158      	cbz	r0, 429a <bt_read_public_addr+0x46>
	    !bt_addr_cmp(&rp->bdaddr, BT_ADDR_NONE)) {
    4282:	4b19      	ldr	r3, [pc, #100]	; (42e8 <bt_read_public_addr+0x94>)
    4284:	e893 0003 	ldmia.w	r3, {r0, r1}
    4288:	9004      	str	r0, [sp, #16]
    428a:	f8ad 1014 	strh.w	r1, [sp, #20]
    428e:	2206      	movs	r2, #6
    4290:	a904      	add	r1, sp, #16
    4292:	4620      	mov	r0, r4
    4294:	f00c f977 	bl	10586 <memcmp>
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    4298:	b9c0      	cbnz	r0, 42cc <bt_read_public_addr+0x78>
		net_buf_unref(rsp);
    429a:	9801      	ldr	r0, [sp, #4]
    429c:	f00b f9d4 	bl	f648 <net_buf_unref>
		return 0U;
    42a0:	2000      	movs	r0, #0
}
    42a2:	b007      	add	sp, #28
    42a4:	bd30      	pop	{r4, r5, pc}
		BT_WARN("Failed to read public address");
    42a6:	f04f 0100 	mov.w	r1, #0
    42aa:	2302      	movs	r3, #2
    42ac:	f363 0102 	bfi	r1, r3, #0, #3
    42b0:	f36f 01c5 	bfc	r1, #3, #3
    42b4:	4b0d      	ldr	r3, [pc, #52]	; (42ec <bt_read_public_addr+0x98>)
    42b6:	4a0e      	ldr	r2, [pc, #56]	; (42f0 <bt_read_public_addr+0x9c>)
    42b8:	1a9b      	subs	r3, r3, r2
    42ba:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    42be:	f363 118f 	bfi	r1, r3, #6, #10
    42c2:	480c      	ldr	r0, [pc, #48]	; (42f4 <bt_read_public_addr+0xa0>)
    42c4:	f7fd fcec 	bl	1ca0 <log_0>
		return 0U;
    42c8:	2000      	movs	r0, #0
    42ca:	e7ea      	b.n	42a2 <bt_read_public_addr+0x4e>
    42cc:	6823      	ldr	r3, [r4, #0]
    42ce:	f8c5 3001 	str.w	r3, [r5, #1]
    42d2:	88a3      	ldrh	r3, [r4, #4]
    42d4:	f8a5 3005 	strh.w	r3, [r5, #5]
	addr->type = BT_ADDR_LE_PUBLIC;
    42d8:	2300      	movs	r3, #0
    42da:	702b      	strb	r3, [r5, #0]
	net_buf_unref(rsp);
    42dc:	9801      	ldr	r0, [sp, #4]
    42de:	f00b f9b3 	bl	f648 <net_buf_unref>
	return 1U;
    42e2:	2001      	movs	r0, #1
    42e4:	e7dd      	b.n	42a2 <bt_read_public_addr+0x4e>
    42e6:	bf00      	nop
    42e8:	00010d30 	.word	0x00010d30
    42ec:	00010c90 	.word	0x00010c90
    42f0:	00010c18 	.word	0x00010c18
    42f4:	00012178 	.word	0x00012178

000042f8 <le_adv_recv>:
{
    42f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    42fc:	b083      	sub	sp, #12
    42fe:	4604      	mov	r4, r0
    4300:	4688      	mov	r8, r1
    4302:	4615      	mov	r5, r2
    4304:	4699      	mov	r9, r3
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    4306:	f3bf 8f5b 	dmb	ish
    430a:	4b39      	ldr	r3, [pc, #228]	; (43f0 <le_adv_recv+0xf8>)
    430c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    4310:	f3bf 8f5b 	dmb	ish
	if (!IS_ENABLED(CONFIG_BT_PRIVACY) &&
    4314:	f013 0f40 	tst.w	r3, #64	; 0x40
    4318:	d003      	beq.n	4322 <le_adv_recv+0x2a>
	    (info->adv_props & BT_HCI_LE_ADV_PROP_DIRECT)) {
    431a:	890b      	ldrh	r3, [r1, #8]
	    atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN) &&
    431c:	f013 0f04 	tst.w	r3, #4
    4320:	d162      	bne.n	43e8 <le_adv_recv+0xf0>
	if (addr->type == BT_ADDR_LE_PUBLIC_ID ||
    4322:	7822      	ldrb	r2, [r4, #0]
    4324:	1e93      	subs	r3, r2, #2
    4326:	b2db      	uxtb	r3, r3
    4328:	2b01      	cmp	r3, #1
    432a:	d92f      	bls.n	438c <le_adv_recv+0x94>
	} else if (addr->type == BT_HCI_PEER_ADDR_ANONYMOUS) {
    432c:	2aff      	cmp	r2, #255	; 0xff
    432e:	d03a      	beq.n	43a6 <le_adv_recv+0xae>
		bt_addr_le_copy(&id_addr,
    4330:	4621      	mov	r1, r4
    4332:	2000      	movs	r0, #0
    4334:	f009 ff84 	bl	e240 <bt_lookup_id_addr>
    4338:	4603      	mov	r3, r0
}

static inline void bt_addr_le_copy(bt_addr_le_t *dst, const bt_addr_le_t *src)
{
	memcpy(dst, src, sizeof(*dst));
    433a:	6800      	ldr	r0, [r0, #0]
    433c:	9000      	str	r0, [sp, #0]
    433e:	889a      	ldrh	r2, [r3, #4]
    4340:	799b      	ldrb	r3, [r3, #6]
    4342:	f8ad 2004 	strh.w	r2, [sp, #4]
    4346:	f88d 3006 	strb.w	r3, [sp, #6]
	info->addr = &id_addr;
    434a:	f8c8 d000 	str.w	sp, [r8]
	if (scan_dev_found_cb) {
    434e:	4b29      	ldr	r3, [pc, #164]	; (43f4 <le_adv_recv+0xfc>)
    4350:	681b      	ldr	r3, [r3, #0]
    4352:	b1b3      	cbz	r3, 4382 <le_adv_recv+0x8a>
		net_buf_simple_save(&buf->b, &state);
    4354:	f105 0608 	add.w	r6, r5, #8
 * @param state Storage for the state.
 */
static inline void net_buf_simple_save(struct net_buf_simple *buf,
				       struct net_buf_simple_state *state)
{
	state->offset = net_buf_simple_headroom(buf);
    4358:	4630      	mov	r0, r6
    435a:	f00b f9c8 	bl	f6ee <net_buf_simple_headroom>
    435e:	b284      	uxth	r4, r0
	state->len = buf->len;
    4360:	89af      	ldrh	r7, [r5, #12]
		buf->len = len;
    4362:	f8a5 900c 	strh.w	r9, [r5, #12]
		scan_dev_found_cb(&id_addr, info->rssi, info->adv_type,
    4366:	4b23      	ldr	r3, [pc, #140]	; (43f4 <le_adv_recv+0xfc>)
    4368:	f8d3 a000 	ldr.w	sl, [r3]
    436c:	4633      	mov	r3, r6
    436e:	f898 2007 	ldrb.w	r2, [r8, #7]
    4372:	f998 1005 	ldrsb.w	r1, [r8, #5]
    4376:	4668      	mov	r0, sp
    4378:	47d0      	blx	sl
 * @param state Stored state.
 */
static inline void net_buf_simple_restore(struct net_buf_simple *buf,
					  struct net_buf_simple_state *state)
{
	buf->data = buf->__buf + state->offset;
    437a:	692b      	ldr	r3, [r5, #16]
    437c:	4423      	add	r3, r4
    437e:	60ab      	str	r3, [r5, #8]
	buf->len = state->len;
    4380:	81af      	strh	r7, [r5, #12]
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
    4382:	4b1d      	ldr	r3, [pc, #116]	; (43f8 <le_adv_recv+0x100>)
    4384:	681c      	ldr	r4, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&scan_cbs, listener, node) {
    4386:	b1a4      	cbz	r4, 43b2 <le_adv_recv+0xba>
    4388:	3c08      	subs	r4, #8
    438a:	e012      	b.n	43b2 <le_adv_recv+0xba>
    438c:	6820      	ldr	r0, [r4, #0]
    438e:	9000      	str	r0, [sp, #0]
    4390:	88a2      	ldrh	r2, [r4, #4]
    4392:	79a3      	ldrb	r3, [r4, #6]
    4394:	f8ad 2004 	strh.w	r2, [sp, #4]
    4398:	f88d 3006 	strb.w	r3, [sp, #6]
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
    439c:	b2c3      	uxtb	r3, r0
    439e:	3b02      	subs	r3, #2
    43a0:	f88d 3000 	strb.w	r3, [sp]
    43a4:	e7d1      	b.n	434a <le_adv_recv+0x52>
    43a6:	2300      	movs	r3, #0
    43a8:	9300      	str	r3, [sp, #0]
    43aa:	f8cd 3003 	str.w	r3, [sp, #3]
    43ae:	e7cc      	b.n	434a <le_adv_recv+0x52>
	SYS_SLIST_FOR_EACH_CONTAINER(&scan_cbs, listener, node) {
    43b0:	4634      	mov	r4, r6
    43b2:	b1cc      	cbz	r4, 43e8 <le_adv_recv+0xf0>
		net_buf_simple_save(&buf->b, &state);
    43b4:	f105 0b08 	add.w	fp, r5, #8
	state->offset = net_buf_simple_headroom(buf);
    43b8:	4658      	mov	r0, fp
    43ba:	f00b f998 	bl	f6ee <net_buf_simple_headroom>
    43be:	fa1f fa80 	uxth.w	sl, r0
	state->len = buf->len;
    43c2:	89af      	ldrh	r7, [r5, #12]
		buf->len = len;
    43c4:	f8a5 900c 	strh.w	r9, [r5, #12]
		listener->recv(info, &buf->b);
    43c8:	4626      	mov	r6, r4
    43ca:	f856 3b08 	ldr.w	r3, [r6], #8
    43ce:	4659      	mov	r1, fp
    43d0:	4640      	mov	r0, r8
    43d2:	4798      	blx	r3
	buf->data = buf->__buf + state->offset;
    43d4:	692a      	ldr	r2, [r5, #16]
    43d6:	4452      	add	r2, sl
    43d8:	60aa      	str	r2, [r5, #8]
	buf->len = state->len;
    43da:	81af      	strh	r7, [r5, #12]
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT(slist, snode)
    43dc:	2e00      	cmp	r6, #0
    43de:	d0e7      	beq.n	43b0 <le_adv_recv+0xb8>
	return node->next;
    43e0:	68a4      	ldr	r4, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&scan_cbs, listener, node) {
    43e2:	b10c      	cbz	r4, 43e8 <le_adv_recv+0xf0>
    43e4:	3c08      	subs	r4, #8
    43e6:	e7e4      	b.n	43b2 <le_adv_recv+0xba>
}
    43e8:	b003      	add	sp, #12
    43ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    43ee:	bf00      	nop
    43f0:	20000000 	.word	0x20000000
    43f4:	20003e60 	.word	0x20003e60
    43f8:	20003e58 	.word	0x20003e58

000043fc <le_adv_report>:
{
    43fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    43fe:	b085      	sub	sp, #20
    4400:	4605      	mov	r5, r0
	u8_t num_reports = net_buf_pull_u8(buf);
    4402:	f100 0608 	add.w	r6, r0, #8
    4406:	4630      	mov	r0, r6
    4408:	f00b f969 	bl	f6de <net_buf_simple_pull_u8>
	while (num_reports--) {
    440c:	1e43      	subs	r3, r0, #1
    440e:	b2df      	uxtb	r7, r3
    4410:	2800      	cmp	r0, #0
    4412:	d03e      	beq.n	4492 <le_adv_report+0x96>
		if (buf->len < sizeof(*evt)) {
    4414:	89ab      	ldrh	r3, [r5, #12]
    4416:	2b08      	cmp	r3, #8
    4418:	d92a      	bls.n	4470 <le_adv_report+0x74>
		evt = net_buf_pull_mem(buf, sizeof(*evt));
    441a:	2109      	movs	r1, #9
    441c:	4630      	mov	r0, r6
    441e:	f00b f956 	bl	f6ce <net_buf_simple_pull_mem>
    4422:	4604      	mov	r4, r0
		adv_info.rssi = evt->data[evt->length];
    4424:	7a03      	ldrb	r3, [r0, #8]
    4426:	4403      	add	r3, r0
    4428:	f993 3009 	ldrsb.w	r3, [r3, #9]
    442c:	f88d 3009 	strb.w	r3, [sp, #9]
		adv_info.primary_phy = BT_GAP_LE_PHY_1M;
    4430:	2301      	movs	r3, #1
    4432:	f88d 300e 	strb.w	r3, [sp, #14]
		adv_info.secondary_phy = 0;
    4436:	2300      	movs	r3, #0
    4438:	f88d 300f 	strb.w	r3, [sp, #15]
		adv_info.tx_power = BT_GAP_TX_POWER_INVALID;
    443c:	237f      	movs	r3, #127	; 0x7f
    443e:	f88d 300a 	strb.w	r3, [sp, #10]
		adv_info.sid = BT_GAP_SID_INVALID;
    4442:	23ff      	movs	r3, #255	; 0xff
    4444:	f88d 3008 	strb.w	r3, [sp, #8]
		adv_info.adv_type = evt->evt_type;
    4448:	7800      	ldrb	r0, [r0, #0]
    444a:	f88d 000b 	strb.w	r0, [sp, #11]
		adv_info.adv_props = get_adv_props(evt->evt_type);
    444e:	f009 fe65 	bl	e11c <get_adv_props>
    4452:	f8ad 000c 	strh.w	r0, [sp, #12]
		le_adv_recv(&evt->addr, &adv_info, buf, evt->length);
    4456:	7a23      	ldrb	r3, [r4, #8]
    4458:	462a      	mov	r2, r5
    445a:	a901      	add	r1, sp, #4
    445c:	1c60      	adds	r0, r4, #1
    445e:	f7ff ff4b 	bl	42f8 <le_adv_recv>
		net_buf_pull(buf, evt->length + sizeof(adv_info.rssi));
    4462:	7a21      	ldrb	r1, [r4, #8]
    4464:	3101      	adds	r1, #1
    4466:	4630      	mov	r0, r6
    4468:	f00b f929 	bl	f6be <net_buf_simple_pull>
	while (num_reports--) {
    446c:	4638      	mov	r0, r7
    446e:	e7cd      	b.n	440c <le_adv_report+0x10>
			BT_ERR("Unexpected end of buffer");
    4470:	f04f 0100 	mov.w	r1, #0
    4474:	2301      	movs	r3, #1
    4476:	f363 0102 	bfi	r1, r3, #0, #3
    447a:	f36f 01c5 	bfc	r1, #3, #3
    447e:	4b06      	ldr	r3, [pc, #24]	; (4498 <le_adv_report+0x9c>)
    4480:	4a06      	ldr	r2, [pc, #24]	; (449c <le_adv_report+0xa0>)
    4482:	1a9b      	subs	r3, r3, r2
    4484:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    4488:	f363 118f 	bfi	r1, r3, #6, #10
    448c:	4804      	ldr	r0, [pc, #16]	; (44a0 <le_adv_report+0xa4>)
    448e:	f7fd fc07 	bl	1ca0 <log_0>
}
    4492:	b005      	add	sp, #20
    4494:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4496:	bf00      	nop
    4498:	00010c90 	.word	0x00010c90
    449c:	00010c18 	.word	0x00010c18
    44a0:	00012198 	.word	0x00012198

000044a4 <bt_adv_lookup_legacy>:
}
    44a4:	4800      	ldr	r0, [pc, #0]	; (44a8 <bt_adv_lookup_legacy+0x4>)
    44a6:	4770      	bx	lr
    44a8:	20000018 	.word	0x20000018

000044ac <le_scan_set_random_addr>:
{
    44ac:	b510      	push	{r4, lr}
    44ae:	460c      	mov	r4, r1
		struct bt_le_ext_adv *adv = bt_adv_lookup_legacy();
    44b0:	f7ff fff8 	bl	44a4 <bt_adv_lookup_legacy>
		*own_addr_type = bt_dev.id_addr[0].type;
    44b4:	4b0b      	ldr	r3, [pc, #44]	; (44e4 <le_scan_set_random_addr+0x38>)
    44b6:	781b      	ldrb	r3, [r3, #0]
    44b8:	7023      	strb	r3, [r4, #0]
		if (!IS_ENABLED(CONFIG_BT_SCAN_WITH_IDENTITY) &&
    44ba:	b180      	cbz	r0, 44de <le_scan_set_random_addr+0x32>
    44bc:	f3bf 8f5b 	dmb	ish
    44c0:	6943      	ldr	r3, [r0, #20]
    44c2:	f3bf 8f5b 	dmb	ish
		    adv && !atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
    44c6:	f013 0f40 	tst.w	r3, #64	; 0x40
    44ca:	d001      	beq.n	44d0 <le_scan_set_random_addr+0x24>
	return 0;
    44cc:	2000      	movs	r0, #0
    44ce:	e007      	b.n	44e0 <le_scan_set_random_addr+0x34>
			err = le_set_private_addr(BT_ID_DEFAULT);
    44d0:	2000      	movs	r0, #0
    44d2:	f009 fe9d 	bl	e210 <le_set_private_addr>
			if (err) {
    44d6:	b918      	cbnz	r0, 44e0 <le_scan_set_random_addr+0x34>
			*own_addr_type = BT_ADDR_LE_RANDOM;
    44d8:	2301      	movs	r3, #1
    44da:	7023      	strb	r3, [r4, #0]
    44dc:	e000      	b.n	44e0 <le_scan_set_random_addr+0x34>
	return 0;
    44de:	2000      	movs	r0, #0
}
    44e0:	bd10      	pop	{r4, pc}
    44e2:	bf00      	nop
    44e4:	20000000 	.word	0x20000000

000044e8 <start_le_scan_legacy>:
{
    44e8:	b530      	push	{r4, r5, lr}
    44ea:	b083      	sub	sp, #12
	(void)memset(&set_param, 0, sizeof(set_param));
    44ec:	2300      	movs	r3, #0
    44ee:	f8ad 3005 	strh.w	r3, [sp, #5]
	set_param.scan_type = scan_type;
    44f2:	f88d 0000 	strb.w	r0, [sp]
	set_param.interval = sys_cpu_to_le16(interval);
    44f6:	f8ad 1001 	strh.w	r1, [sp, #1]
	set_param.window = sys_cpu_to_le16(window);
    44fa:	f8ad 2003 	strh.w	r2, [sp, #3]
	active_scan = scan_type == BT_HCI_LE_SCAN_ACTIVE;
    44fe:	2801      	cmp	r0, #1
    4500:	bf14      	ite	ne
    4502:	2400      	movne	r4, #0
    4504:	2401      	moveq	r4, #1
	err = le_scan_set_random_addr(active_scan, &set_param.addr_type);
    4506:	f10d 0105 	add.w	r1, sp, #5
    450a:	4620      	mov	r0, r4
    450c:	f7ff ffce 	bl	44ac <le_scan_set_random_addr>
	if (err) {
    4510:	b108      	cbz	r0, 4516 <start_le_scan_legacy+0x2e>
}
    4512:	b003      	add	sp, #12
    4514:	bd30      	pop	{r4, r5, pc}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_SCAN_PARAM, sizeof(set_param));
    4516:	2107      	movs	r1, #7
    4518:	f242 000b 	movw	r0, #8203	; 0x200b
    451c:	f7ff fbe8 	bl	3cf0 <bt_hci_cmd_create>
	if (!buf) {
    4520:	4605      	mov	r5, r0
    4522:	b370      	cbz	r0, 4582 <start_le_scan_legacy+0x9a>
	net_buf_add_mem(buf, &set_param, sizeof(set_param));
    4524:	2207      	movs	r2, #7
    4526:	4669      	mov	r1, sp
    4528:	3008      	adds	r0, #8
    452a:	f00b f8bd 	bl	f6a8 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_SCAN_PARAM, buf, NULL);
    452e:	2200      	movs	r2, #0
    4530:	4629      	mov	r1, r5
    4532:	f242 000b 	movw	r0, #8203	; 0x200b
    4536:	f7ff fc17 	bl	3d68 <bt_hci_cmd_send_sync>
	if (err) {
    453a:	2800      	cmp	r0, #0
    453c:	d1e9      	bne.n	4512 <start_le_scan_legacy+0x2a>
	err = set_le_scan_enable(BT_HCI_LE_SCAN_ENABLE);
    453e:	2001      	movs	r0, #1
    4540:	f009 fe7a 	bl	e238 <set_le_scan_enable>
	if (err) {
    4544:	2800      	cmp	r0, #0
    4546:	d1e4      	bne.n	4512 <start_le_scan_legacy+0x2a>
	if (val) {
    4548:	b16c      	cbz	r4, 4566 <start_le_scan_legacy+0x7e>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    454a:	4b0f      	ldr	r3, [pc, #60]	; (4588 <start_le_scan_legacy+0xa0>)
    454c:	f3bf 8f5b 	dmb	ish
    4550:	e853 2f00 	ldrex	r2, [r3]
    4554:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    4558:	e843 2100 	strex	r1, r2, [r3]
    455c:	2900      	cmp	r1, #0
    455e:	d1f7      	bne.n	4550 <start_le_scan_legacy+0x68>
    4560:	f3bf 8f5b 	dmb	ish
    4564:	e7d5      	b.n	4512 <start_le_scan_legacy+0x2a>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    4566:	4b08      	ldr	r3, [pc, #32]	; (4588 <start_le_scan_legacy+0xa0>)
    4568:	f3bf 8f5b 	dmb	ish
    456c:	e853 2f00 	ldrex	r2, [r3]
    4570:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    4574:	e843 2100 	strex	r1, r2, [r3]
    4578:	2900      	cmp	r1, #0
    457a:	d1f7      	bne.n	456c <start_le_scan_legacy+0x84>
    457c:	f3bf 8f5b 	dmb	ish
}
    4580:	e7c7      	b.n	4512 <start_le_scan_legacy+0x2a>
		return -ENOBUFS;
    4582:	f06f 0068 	mvn.w	r0, #104	; 0x68
    4586:	e7c4      	b.n	4512 <start_le_scan_legacy+0x2a>
    4588:	20000098 	.word	0x20000098

0000458c <bt_le_scan_update>:
{
    458c:	b508      	push	{r3, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    458e:	f3bf 8f5b 	dmb	ish
    4592:	4b0d      	ldr	r3, [pc, #52]	; (45c8 <bt_le_scan_update+0x3c>)
    4594:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    4598:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
    459c:	f013 0f40 	tst.w	r3, #64	; 0x40
    45a0:	d001      	beq.n	45a6 <bt_le_scan_update+0x1a>
		return 0;
    45a2:	2000      	movs	r0, #0
}
    45a4:	bd08      	pop	{r3, pc}
    45a6:	f3bf 8f5b 	dmb	ish
    45aa:	4b07      	ldr	r3, [pc, #28]	; (45c8 <bt_le_scan_update+0x3c>)
    45ac:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    45b0:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    45b4:	f3c3 1040 	ubfx	r0, r3, #5, #1
	if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING)) {
    45b8:	f013 0f20 	tst.w	r3, #32
    45bc:	d0f2      	beq.n	45a4 <bt_le_scan_update+0x18>
		err = set_le_scan_enable(BT_HCI_LE_SCAN_DISABLE);
    45be:	2000      	movs	r0, #0
    45c0:	f009 fe3a 	bl	e238 <set_le_scan_enable>
		if (err) {
    45c4:	e7ee      	b.n	45a4 <bt_le_scan_update+0x18>
    45c6:	bf00      	nop
    45c8:	20000000 	.word	0x20000000

000045cc <id_create>:

static void id_create(u8_t id, bt_addr_le_t *addr, u8_t *irk)
{
    45cc:	b530      	push	{r4, r5, lr}
    45ce:	b085      	sub	sp, #20
    45d0:	4604      	mov	r4, r0
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    45d2:	460d      	mov	r5, r1
    45d4:	b149      	cbz	r1, 45ea <id_create+0x1e>
    45d6:	2300      	movs	r3, #0
    45d8:	9302      	str	r3, [sp, #8]
    45da:	f8cd 300b 	str.w	r3, [sp, #11]
	return memcmp(a, b, sizeof(*a));
    45de:	2207      	movs	r2, #7
    45e0:	a902      	add	r1, sp, #8
    45e2:	4628      	mov	r0, r5
    45e4:	f00b ffcf 	bl	10586 <memcmp>
    45e8:	b9e0      	cbnz	r0, 4624 <id_create+0x58>
		bt_addr_le_copy(&bt_dev.id_addr[id], addr);
	} else {
		bt_addr_le_t new_addr;

		do {
			bt_addr_le_create_static(&new_addr);
    45ea:	4668      	mov	r0, sp
    45ec:	f009 fe2c 	bl	e248 <bt_addr_le_create_static>
			/* Make sure we didn't generate a duplicate */
		} while (id_find(&new_addr) >= 0);
    45f0:	4668      	mov	r0, sp
    45f2:	f7ff f8ef 	bl	37d4 <id_find>
    45f6:	2800      	cmp	r0, #0
    45f8:	daf7      	bge.n	45ea <id_create+0x1e>

		bt_addr_le_copy(&bt_dev.id_addr[id], &new_addr);
    45fa:	4a10      	ldr	r2, [pc, #64]	; (463c <id_create+0x70>)
    45fc:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
    4600:	1913      	adds	r3, r2, r4
    4602:	9800      	ldr	r0, [sp, #0]
    4604:	5110      	str	r0, [r2, r4]
    4606:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    460a:	f89d 2006 	ldrb.w	r2, [sp, #6]
    460e:	8099      	strh	r1, [r3, #4]
    4610:	719a      	strb	r2, [r3, #6]

		if (addr) {
    4612:	b12d      	cbz	r5, 4620 <id_create+0x54>
    4614:	681a      	ldr	r2, [r3, #0]
    4616:	602a      	str	r2, [r5, #0]
    4618:	889a      	ldrh	r2, [r3, #4]
    461a:	799b      	ldrb	r3, [r3, #6]
    461c:	80aa      	strh	r2, [r5, #4]
    461e:	71ab      	strb	r3, [r5, #6]
	 */
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
	    atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
		bt_settings_save_id();
	}
}
    4620:	b005      	add	sp, #20
    4622:	bd30      	pop	{r4, r5, pc}
		bt_addr_le_copy(&bt_dev.id_addr[id], addr);
    4624:	4a05      	ldr	r2, [pc, #20]	; (463c <id_create+0x70>)
    4626:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
    462a:	1913      	adds	r3, r2, r4
    462c:	6829      	ldr	r1, [r5, #0]
    462e:	5111      	str	r1, [r2, r4]
    4630:	88a9      	ldrh	r1, [r5, #4]
    4632:	79aa      	ldrb	r2, [r5, #6]
    4634:	8099      	strh	r1, [r3, #4]
    4636:	719a      	strb	r2, [r3, #6]
}
    4638:	e7f2      	b.n	4620 <id_create+0x54>
    463a:	bf00      	nop
    463c:	20000000 	.word	0x20000000

00004640 <bt_send>:
{
    4640:	b508      	push	{r3, lr}
	return bt_dev.drv->send(buf);
    4642:	4b03      	ldr	r3, [pc, #12]	; (4650 <bt_send+0x10>)
    4644:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
    4648:	691b      	ldr	r3, [r3, #16]
    464a:	4798      	blx	r3
}
    464c:	bd08      	pop	{r3, pc}
    464e:	bf00      	nop
    4650:	20000000 	.word	0x20000000

00004654 <send_cmd>:
{
    4654:	b538      	push	{r3, r4, r5, lr}
	buf = net_buf_get(&bt_dev.cmd_tx_queue, K_NO_WAIT);
    4656:	2200      	movs	r2, #0
    4658:	2300      	movs	r3, #0
    465a:	4838      	ldr	r0, [pc, #224]	; (473c <send_cmd+0xe8>)
    465c:	f00a ffc8 	bl	f5f0 <net_buf_get>
	BT_ASSERT(buf);
    4660:	4604      	mov	r4, r0
    4662:	b378      	cbz	r0, 46c4 <send_cmd+0x70>
    4664:	4d36      	ldr	r5, [pc, #216]	; (4740 <send_cmd+0xec>)
    4666:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    466a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    466e:	f105 00b0 	add.w	r0, r5, #176	; 0xb0
    4672:	f006 fe6b 	bl	b34c <z_impl_k_sem_take>
	if (bt_dev.sent_cmd) {
    4676:	f8d5 30c8 	ldr.w	r3, [r5, #200]	; 0xc8
    467a:	b1bb      	cbz	r3, 46ac <send_cmd+0x58>
		BT_ERR("Uncleared pending sent_cmd");
    467c:	f04f 0100 	mov.w	r1, #0
    4680:	2301      	movs	r3, #1
    4682:	f363 0102 	bfi	r1, r3, #0, #3
    4686:	f36f 01c5 	bfc	r1, #3, #3
    468a:	4b2e      	ldr	r3, [pc, #184]	; (4744 <send_cmd+0xf0>)
    468c:	4a2e      	ldr	r2, [pc, #184]	; (4748 <send_cmd+0xf4>)
    468e:	1a9b      	subs	r3, r3, r2
    4690:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    4694:	f363 118f 	bfi	r1, r3, #6, #10
    4698:	482c      	ldr	r0, [pc, #176]	; (474c <send_cmd+0xf8>)
    469a:	f7fd fb01 	bl	1ca0 <log_0>
		net_buf_unref(bt_dev.sent_cmd);
    469e:	f8d5 00c8 	ldr.w	r0, [r5, #200]	; 0xc8
    46a2:	f00a ffd1 	bl	f648 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    46a6:	2300      	movs	r3, #0
    46a8:	f8c5 30c8 	str.w	r3, [r5, #200]	; 0xc8
	bt_dev.sent_cmd = net_buf_ref(buf);
    46ac:	4620      	mov	r0, r4
    46ae:	f00a fff1 	bl	f694 <net_buf_ref>
    46b2:	4b23      	ldr	r3, [pc, #140]	; (4740 <send_cmd+0xec>)
    46b4:	f8c3 00c8 	str.w	r0, [r3, #200]	; 0xc8
	err = bt_send(buf);
    46b8:	4620      	mov	r0, r4
    46ba:	f7ff ffc1 	bl	4640 <bt_send>
	if (err) {
    46be:	4601      	mov	r1, r0
    46c0:	b970      	cbnz	r0, 46e0 <send_cmd+0x8c>
}
    46c2:	bd38      	pop	{r3, r4, r5, pc}
	BT_ASSERT(buf);
    46c4:	f241 4385 	movw	r3, #5253	; 0x1485
    46c8:	4a21      	ldr	r2, [pc, #132]	; (4750 <send_cmd+0xfc>)
    46ca:	4922      	ldr	r1, [pc, #136]	; (4754 <send_cmd+0x100>)
    46cc:	4822      	ldr	r0, [pc, #136]	; (4758 <send_cmd+0x104>)
    46ce:	f008 fcae 	bl	d02e <printk>
    46d2:	4040      	eors	r0, r0
    46d4:	f380 8811 	msr	BASEPRI, r0
    46d8:	f04f 0003 	mov.w	r0, #3
    46dc:	df02      	svc	2
    46de:	e7c1      	b.n	4664 <send_cmd+0x10>
		BT_ERR("Unable to send to driver (err %d)", err);
    46e0:	f04f 0200 	mov.w	r2, #0
    46e4:	2301      	movs	r3, #1
    46e6:	f363 0202 	bfi	r2, r3, #0, #3
    46ea:	f36f 02c5 	bfc	r2, #3, #3
    46ee:	4b15      	ldr	r3, [pc, #84]	; (4744 <send_cmd+0xf0>)
    46f0:	4815      	ldr	r0, [pc, #84]	; (4748 <send_cmd+0xf4>)
    46f2:	1a1b      	subs	r3, r3, r0
    46f4:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    46f8:	f363 128f 	bfi	r2, r3, #6, #10
    46fc:	4817      	ldr	r0, [pc, #92]	; (475c <send_cmd+0x108>)
    46fe:	f7fd f95f 	bl	19c0 <log_1>
	z_impl_k_sem_give(sem);
    4702:	4d0f      	ldr	r5, [pc, #60]	; (4740 <send_cmd+0xec>)
    4704:	f105 00b0 	add.w	r0, r5, #176	; 0xb0
    4708:	f006 fdf8 	bl	b2fc <z_impl_k_sem_give>
		hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED, buf);
    470c:	4620      	mov	r0, r4
    470e:	f004 fc05 	bl	8f1c <net_buf_id>
    4712:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    4716:	4b12      	ldr	r3, [pc, #72]	; (4760 <send_cmd+0x10c>)
    4718:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    471c:	4622      	mov	r2, r4
    471e:	211f      	movs	r1, #31
    4720:	8840      	ldrh	r0, [r0, #2]
    4722:	f7ff f893 	bl	384c <hci_cmd_done>
		net_buf_unref(bt_dev.sent_cmd);
    4726:	f8d5 00c8 	ldr.w	r0, [r5, #200]	; 0xc8
    472a:	f00a ff8d 	bl	f648 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    472e:	2300      	movs	r3, #0
    4730:	f8c5 30c8 	str.w	r3, [r5, #200]	; 0xc8
		net_buf_unref(buf);
    4734:	4620      	mov	r0, r4
    4736:	f00a ff87 	bl	f648 <net_buf_unref>
    473a:	e7c2      	b.n	46c2 <send_cmd+0x6e>
    473c:	200000cc 	.word	0x200000cc
    4740:	20000000 	.word	0x20000000
    4744:	00010c90 	.word	0x00010c90
    4748:	00010c18 	.word	0x00010c18
    474c:	000121d8 	.word	0x000121d8
    4750:	00011f60 	.word	0x00011f60
    4754:	00012da8 	.word	0x00012da8
    4758:	00011fec 	.word	0x00011fec
    475c:	000121b4 	.word	0x000121b4
    4760:	20003e3c 	.word	0x20003e3c

00004764 <process_events>:
{
    4764:	b570      	push	{r4, r5, r6, lr}
    4766:	4604      	mov	r4, r0
    4768:	460d      	mov	r5, r1
	BT_DBG("count %d", count);
    476a:	e011      	b.n	4790 <process_events+0x2c>
			BT_WARN("Unexpected k_poll event state %u", ev->state);
    476c:	2302      	movs	r3, #2
    476e:	f363 0602 	bfi	r6, r3, #0, #3
    4772:	f36f 06c5 	bfc	r6, #3, #3
    4776:	4b0e      	ldr	r3, [pc, #56]	; (47b0 <process_events+0x4c>)
    4778:	4a0e      	ldr	r2, [pc, #56]	; (47b4 <process_events+0x50>)
    477a:	1a9b      	subs	r3, r3, r2
    477c:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    4780:	f363 168f 	bfi	r6, r3, #6, #10
    4784:	4632      	mov	r2, r6
    4786:	480c      	ldr	r0, [pc, #48]	; (47b8 <process_events+0x54>)
    4788:	f7fd f91a 	bl	19c0 <log_1>
	for (; count; ev++, count--) {
    478c:	3414      	adds	r4, #20
    478e:	3d01      	subs	r5, #1
    4790:	b165      	cbz	r5, 47ac <process_events+0x48>
		switch (ev->state) {
    4792:	68e1      	ldr	r1, [r4, #12]
    4794:	f3c1 3104 	ubfx	r1, r1, #12, #5
    4798:	2901      	cmp	r1, #1
    479a:	d9f7      	bls.n	478c <process_events+0x28>
    479c:	2904      	cmp	r1, #4
    479e:	d1e5      	bne.n	476c <process_events+0x8>
			if (ev->tag == BT_EVENT_CMD_TX) {
    47a0:	7b23      	ldrb	r3, [r4, #12]
    47a2:	2b00      	cmp	r3, #0
    47a4:	d1f2      	bne.n	478c <process_events+0x28>
				send_cmd();
    47a6:	f7ff ff55 	bl	4654 <send_cmd>
    47aa:	e7ef      	b.n	478c <process_events+0x28>
}
    47ac:	bd70      	pop	{r4, r5, r6, pc}
    47ae:	bf00      	nop
    47b0:	00010c90 	.word	0x00010c90
    47b4:	00010c18 	.word	0x00010c18
    47b8:	000121f4 	.word	0x000121f4

000047bc <hci_tx_thread>:
{
    47bc:	b508      	push	{r3, lr}
    47be:	e005      	b.n	47cc <hci_tx_thread+0x10>
		process_events(events, ev_count);
    47c0:	2101      	movs	r1, #1
    47c2:	4810      	ldr	r0, [pc, #64]	; (4804 <hci_tx_thread+0x48>)
    47c4:	f7ff ffce 	bl	4764 <process_events>
	z_impl_k_yield();
    47c8:	f006 fcd2 	bl	b170 <z_impl_k_yield>
		events[0].state = K_POLL_STATE_NOT_READY;
    47cc:	480d      	ldr	r0, [pc, #52]	; (4804 <hci_tx_thread+0x48>)
    47ce:	68c3      	ldr	r3, [r0, #12]
    47d0:	f36f 3310 	bfc	r3, #12, #5
    47d4:	60c3      	str	r3, [r0, #12]
		parm0.val = timeout;
		return (int) arch_syscall_invoke4(*(uintptr_t *)&events, *(uintptr_t *)&num_events, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
    47d6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    47da:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    47de:	2101      	movs	r1, #1
    47e0:	f007 f85a 	bl	b898 <z_impl_k_poll>
		BT_ASSERT(err == 0);
    47e4:	2800      	cmp	r0, #0
    47e6:	d0eb      	beq.n	47c0 <hci_tx_thread+0x4>
    47e8:	f241 43e3 	movw	r3, #5347	; 0x14e3
    47ec:	4a06      	ldr	r2, [pc, #24]	; (4808 <hci_tx_thread+0x4c>)
    47ee:	4907      	ldr	r1, [pc, #28]	; (480c <hci_tx_thread+0x50>)
    47f0:	4807      	ldr	r0, [pc, #28]	; (4810 <hci_tx_thread+0x54>)
    47f2:	f008 fc1c 	bl	d02e <printk>
    47f6:	4040      	eors	r0, r0
    47f8:	f380 8811 	msr	BASEPRI, r0
    47fc:	f04f 0003 	mov.w	r0, #3
    4800:	df02      	svc	2
    4802:	e7dd      	b.n	47c0 <hci_tx_thread+0x4>
    4804:	20000108 	.word	0x20000108
    4808:	00011f60 	.word	0x00011f60
    480c:	0001202c 	.word	0x0001202c
    4810:	00011fec 	.word	0x00011fec

00004814 <bt_recv>:
{
    4814:	b510      	push	{r4, lr}
    4816:	4604      	mov	r4, r0
	 * pointer to an enum causes issues on qemu_x86 because the true
	 * size is 8-bit, but the enum is 32-bit on qemu_x86. So we put in
	 * a temporary cast to 8-bit to ensure only 8 bits are read from
	 * the pointer.
	 */
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
    4818:	7d01      	ldrb	r1, [r0, #20]
	switch (bt_buf_get_type(buf)) {
    481a:	2901      	cmp	r1, #1
    481c:	d103      	bne.n	4826 <bt_recv+0x12>
		hci_event(buf);
    481e:	f7ff f9df 	bl	3be0 <hci_event>
		return 0;
    4822:	2000      	movs	r0, #0
}
    4824:	bd10      	pop	{r4, pc}
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
    4826:	f04f 0200 	mov.w	r2, #0
    482a:	2301      	movs	r3, #1
    482c:	f363 0202 	bfi	r2, r3, #0, #3
    4830:	f36f 02c5 	bfc	r2, #3, #3
    4834:	4b07      	ldr	r3, [pc, #28]	; (4854 <bt_recv+0x40>)
    4836:	4808      	ldr	r0, [pc, #32]	; (4858 <bt_recv+0x44>)
    4838:	1a1b      	subs	r3, r3, r0
    483a:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    483e:	f363 128f 	bfi	r2, r3, #6, #10
    4842:	4806      	ldr	r0, [pc, #24]	; (485c <bt_recv+0x48>)
    4844:	f7fd f8bc 	bl	19c0 <log_1>
		net_buf_unref(buf);
    4848:	4620      	mov	r0, r4
    484a:	f00a fefd 	bl	f648 <net_buf_unref>
		return -EINVAL;
    484e:	f06f 0015 	mvn.w	r0, #21
    4852:	e7e7      	b.n	4824 <bt_recv+0x10>
    4854:	00010c90 	.word	0x00010c90
    4858:	00010c18 	.word	0x00010c18
    485c:	00012218 	.word	0x00012218

00004860 <bt_recv_prio>:
{
    4860:	b5f0      	push	{r4, r5, r6, r7, lr}
    4862:	b083      	sub	sp, #12
    4864:	4604      	mov	r4, r0
    4866:	7d03      	ldrb	r3, [r0, #20]
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
    4868:	2b01      	cmp	r3, #1
    486a:	d131      	bne.n	48d0 <bt_recv_prio+0x70>
	BT_ASSERT(buf->len >= sizeof(*hdr));
    486c:	89a3      	ldrh	r3, [r4, #12]
    486e:	2b01      	cmp	r3, #1
    4870:	d93c      	bls.n	48ec <bt_recv_prio+0x8c>
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    4872:	2102      	movs	r1, #2
    4874:	f104 0008 	add.w	r0, r4, #8
    4878:	f00a ff29 	bl	f6ce <net_buf_simple_pull_mem>
    487c:	4605      	mov	r5, r0
	BT_ASSERT(bt_hci_evt_is_prio(hdr->evt));
    487e:	7803      	ldrb	r3, [r0, #0]
    4880:	3b0e      	subs	r3, #14
    4882:	2b01      	cmp	r3, #1
    4884:	d90c      	bls.n	48a0 <bt_recv_prio+0x40>
    4886:	f641 03fb 	movw	r3, #6395	; 0x18fb
    488a:	4a39      	ldr	r2, [pc, #228]	; (4970 <bt_recv_prio+0x110>)
    488c:	4939      	ldr	r1, [pc, #228]	; (4974 <bt_recv_prio+0x114>)
    488e:	483a      	ldr	r0, [pc, #232]	; (4978 <bt_recv_prio+0x118>)
    4890:	f008 fbcd 	bl	d02e <printk>
    4894:	4040      	eors	r0, r0
    4896:	f380 8811 	msr	BASEPRI, r0
    489a:	f04f 0003 	mov.w	r0, #3
    489e:	df02      	svc	2
	handle_event(hdr->evt, buf, prio_events, ARRAY_SIZE(prio_events));
    48a0:	782d      	ldrb	r5, [r5, #0]
	for (i = 0; i < num_handlers; i++) {
    48a2:	2300      	movs	r3, #0
    48a4:	2b01      	cmp	r3, #1
    48a6:	d844      	bhi.n	4932 <bt_recv_prio+0xd2>
		const struct event_handler *handler = &handlers[i];
    48a8:	4a34      	ldr	r2, [pc, #208]	; (497c <bt_recv_prio+0x11c>)
    48aa:	eb02 00c3 	add.w	r0, r2, r3, lsl #3
		if (handler->event != event) {
    48ae:	f812 2033 	ldrb.w	r2, [r2, r3, lsl #3]
    48b2:	4295      	cmp	r5, r2
    48b4:	d128      	bne.n	4908 <bt_recv_prio+0xa8>
		if (buf->len < handler->min_len) {
    48b6:	89a1      	ldrh	r1, [r4, #12]
    48b8:	7843      	ldrb	r3, [r0, #1]
    48ba:	4299      	cmp	r1, r3
    48bc:	d326      	bcc.n	490c <bt_recv_prio+0xac>
		handler->handler(buf);
    48be:	6843      	ldr	r3, [r0, #4]
    48c0:	4620      	mov	r0, r4
    48c2:	4798      	blx	r3
	net_buf_unref(buf);
    48c4:	4620      	mov	r0, r4
    48c6:	f00a febf 	bl	f648 <net_buf_unref>
}
    48ca:	2000      	movs	r0, #0
    48cc:	b003      	add	sp, #12
    48ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
    48d0:	f641 03f7 	movw	r3, #6391	; 0x18f7
    48d4:	4a26      	ldr	r2, [pc, #152]	; (4970 <bt_recv_prio+0x110>)
    48d6:	492a      	ldr	r1, [pc, #168]	; (4980 <bt_recv_prio+0x120>)
    48d8:	4827      	ldr	r0, [pc, #156]	; (4978 <bt_recv_prio+0x118>)
    48da:	f008 fba8 	bl	d02e <printk>
    48de:	4040      	eors	r0, r0
    48e0:	f380 8811 	msr	BASEPRI, r0
    48e4:	f04f 0003 	mov.w	r0, #3
    48e8:	df02      	svc	2
    48ea:	e7bf      	b.n	486c <bt_recv_prio+0xc>
	BT_ASSERT(buf->len >= sizeof(*hdr));
    48ec:	f641 03f8 	movw	r3, #6392	; 0x18f8
    48f0:	4a1f      	ldr	r2, [pc, #124]	; (4970 <bt_recv_prio+0x110>)
    48f2:	4924      	ldr	r1, [pc, #144]	; (4984 <bt_recv_prio+0x124>)
    48f4:	4820      	ldr	r0, [pc, #128]	; (4978 <bt_recv_prio+0x118>)
    48f6:	f008 fb9a 	bl	d02e <printk>
    48fa:	4040      	eors	r0, r0
    48fc:	f380 8811 	msr	BASEPRI, r0
    4900:	f04f 0003 	mov.w	r0, #3
    4904:	df02      	svc	2
    4906:	e7b4      	b.n	4872 <bt_recv_prio+0x12>
	for (i = 0; i < num_handlers; i++) {
    4908:	3301      	adds	r3, #1
    490a:	e7cb      	b.n	48a4 <bt_recv_prio+0x44>
			BT_ERR("Too small (%u bytes) event 0x%02x",
    490c:	f04f 0300 	mov.w	r3, #0
    4910:	2201      	movs	r2, #1
    4912:	f362 0302 	bfi	r3, r2, #0, #3
    4916:	f36f 03c5 	bfc	r3, #3, #3
    491a:	4a1b      	ldr	r2, [pc, #108]	; (4988 <bt_recv_prio+0x128>)
    491c:	481b      	ldr	r0, [pc, #108]	; (498c <bt_recv_prio+0x12c>)
    491e:	1a12      	subs	r2, r2, r0
    4920:	f3c2 02c9 	ubfx	r2, r2, #3, #10
    4924:	f362 138f 	bfi	r3, r2, #6, #10
    4928:	462a      	mov	r2, r5
    492a:	4819      	ldr	r0, [pc, #100]	; (4990 <bt_recv_prio+0x130>)
    492c:	f7fd f8c8 	bl	1ac0 <log_2>
			return;
    4930:	e7c8      	b.n	48c4 <bt_recv_prio+0x64>
	BT_WARN("Unhandled event 0x%02x len %u: %s", event,
    4932:	f04f 0600 	mov.w	r6, #0
    4936:	2302      	movs	r3, #2
    4938:	f363 0602 	bfi	r6, r3, #0, #3
    493c:	f36f 06c5 	bfc	r6, #3, #3
    4940:	4b11      	ldr	r3, [pc, #68]	; (4988 <bt_recv_prio+0x128>)
    4942:	4a12      	ldr	r2, [pc, #72]	; (498c <bt_recv_prio+0x12c>)
    4944:	1a9b      	subs	r3, r3, r2
    4946:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    494a:	f363 168f 	bfi	r6, r3, #6, #10
    494e:	89a7      	ldrh	r7, [r4, #12]
    4950:	4639      	mov	r1, r7
    4952:	68a0      	ldr	r0, [r4, #8]
    4954:	f7fe fe04 	bl	3560 <bt_hex_real>
    4958:	f7fc fe62 	bl	1620 <log_strdup>
    495c:	4603      	mov	r3, r0
    495e:	f8ad 6000 	strh.w	r6, [sp]
    4962:	463a      	mov	r2, r7
    4964:	4629      	mov	r1, r5
    4966:	480b      	ldr	r0, [pc, #44]	; (4994 <bt_recv_prio+0x134>)
    4968:	f7fc ff5e 	bl	1828 <log_3>
    496c:	e7aa      	b.n	48c4 <bt_recv_prio+0x64>
    496e:	bf00      	nop
    4970:	00011f60 	.word	0x00011f60
    4974:	00012250 	.word	0x00012250
    4978:	00011fec 	.word	0x00011fec
    497c:	00012400 	.word	0x00012400
    4980:	0001222c 	.word	0x0001222c
    4984:	00011fd0 	.word	0x00011fd0
    4988:	00010c90 	.word	0x00010c90
    498c:	00010c18 	.word	0x00010c18
    4990:	00011f18 	.word	0x00011f18
    4994:	00011f3c 	.word	0x00011f3c

00004998 <bt_hci_driver_register>:
	if (bt_dev.drv) {
    4998:	4b0a      	ldr	r3, [pc, #40]	; (49c4 <bt_hci_driver_register+0x2c>)
    499a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
    499e:	b943      	cbnz	r3, 49b2 <bt_hci_driver_register+0x1a>
	if (!drv->open || !drv->send) {
    49a0:	68c3      	ldr	r3, [r0, #12]
    49a2:	b14b      	cbz	r3, 49b8 <bt_hci_driver_register+0x20>
    49a4:	6903      	ldr	r3, [r0, #16]
    49a6:	b153      	cbz	r3, 49be <bt_hci_driver_register+0x26>
	bt_dev.drv = drv;
    49a8:	4b06      	ldr	r3, [pc, #24]	; (49c4 <bt_hci_driver_register+0x2c>)
    49aa:	f8c3 00e4 	str.w	r0, [r3, #228]	; 0xe4
	return 0;
    49ae:	2000      	movs	r0, #0
    49b0:	4770      	bx	lr
		return -EALREADY;
    49b2:	f06f 0077 	mvn.w	r0, #119	; 0x77
    49b6:	4770      	bx	lr
		return -EINVAL;
    49b8:	f06f 0015 	mvn.w	r0, #21
    49bc:	4770      	bx	lr
    49be:	f06f 0015 	mvn.w	r0, #21
}
    49c2:	4770      	bx	lr
    49c4:	20000000 	.word	0x20000000

000049c8 <bt_finalize_init>:
{
    49c8:	b508      	push	{r3, lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    49ca:	4b09      	ldr	r3, [pc, #36]	; (49f0 <bt_finalize_init+0x28>)
    49cc:	f3bf 8f5b 	dmb	ish
    49d0:	e853 2f00 	ldrex	r2, [r3]
    49d4:	f042 0202 	orr.w	r2, r2, #2
    49d8:	e843 2100 	strex	r1, r2, [r3]
    49dc:	2900      	cmp	r1, #0
    49de:	d1f7      	bne.n	49d0 <bt_finalize_init+0x8>
    49e0:	f3bf 8f5b 	dmb	ish
		bt_le_scan_update(false);
    49e4:	2000      	movs	r0, #0
    49e6:	f7ff fdd1 	bl	458c <bt_le_scan_update>
	bt_dev_show_info();
    49ea:	f7ff f811 	bl	3a10 <bt_dev_show_info>
}
    49ee:	bd08      	pop	{r3, pc}
    49f0:	20000098 	.word	0x20000098

000049f4 <bt_id_create>:

int bt_id_create(bt_addr_le_t *addr, u8_t *irk)
{
    49f4:	b570      	push	{r4, r5, r6, lr}
    49f6:	b082      	sub	sp, #8
    49f8:	460c      	mov	r4, r1
	int new_id;

	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    49fa:	4605      	mov	r5, r0
    49fc:	b348      	cbz	r0, 4a52 <bt_id_create+0x5e>
    49fe:	2300      	movs	r3, #0
    4a00:	9300      	str	r3, [sp, #0]
    4a02:	f8cd 3003 	str.w	r3, [sp, #3]
	return memcmp(a, b, sizeof(*a));
    4a06:	2207      	movs	r2, #7
    4a08:	4669      	mov	r1, sp
    4a0a:	f00b fdbc 	bl	10586 <memcmp>
    4a0e:	b300      	cbz	r0, 4a52 <bt_id_create+0x5e>
		if (addr->type != BT_ADDR_LE_RANDOM ||
    4a10:	782b      	ldrb	r3, [r5, #0]
    4a12:	2b01      	cmp	r3, #1
    4a14:	d104      	bne.n	4a20 <bt_id_create+0x2c>
		    !BT_ADDR_IS_STATIC(&addr->a)) {
    4a16:	79ab      	ldrb	r3, [r5, #6]
		if (addr->type != BT_ADDR_LE_RANDOM ||
    4a18:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    4a1c:	2bc0      	cmp	r3, #192	; 0xc0
    4a1e:	d013      	beq.n	4a48 <bt_id_create+0x54>
			BT_ERR("Only static random identity address supported");
    4a20:	f04f 0100 	mov.w	r1, #0
    4a24:	2301      	movs	r3, #1
    4a26:	f363 0102 	bfi	r1, r3, #0, #3
    4a2a:	f36f 01c5 	bfc	r1, #3, #3
    4a2e:	4b15      	ldr	r3, [pc, #84]	; (4a84 <bt_id_create+0x90>)
    4a30:	4a15      	ldr	r2, [pc, #84]	; (4a88 <bt_id_create+0x94>)
    4a32:	1a9b      	subs	r3, r3, r2
    4a34:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    4a38:	f363 118f 	bfi	r1, r3, #6, #10
    4a3c:	4813      	ldr	r0, [pc, #76]	; (4a8c <bt_id_create+0x98>)
    4a3e:	f7fd f92f 	bl	1ca0 <log_0>
			return -EINVAL;
    4a42:	f06f 0615 	mvn.w	r6, #21
    4a46:	e010      	b.n	4a6a <bt_id_create+0x76>
		}

		if (id_find(addr) >= 0) {
    4a48:	4628      	mov	r0, r5
    4a4a:	f7fe fec3 	bl	37d4 <id_find>
    4a4e:	2800      	cmp	r0, #0
    4a50:	da0e      	bge.n	4a70 <bt_id_create+0x7c>
			return -EALREADY;
		}
	}

	if (!IS_ENABLED(CONFIG_BT_PRIVACY) && irk) {
    4a52:	b984      	cbnz	r4, 4a76 <bt_id_create+0x82>
		return -EINVAL;
	}

	if (bt_dev.id_count == ARRAY_SIZE(bt_dev.id_addr)) {
    4a54:	4b0e      	ldr	r3, [pc, #56]	; (4a90 <bt_id_create+0x9c>)
    4a56:	79d8      	ldrb	r0, [r3, #7]
    4a58:	2801      	cmp	r0, #1
    4a5a:	d00f      	beq.n	4a7c <bt_id_create+0x88>
		return -ENOMEM;
	}

	new_id = bt_dev.id_count++;
    4a5c:	1c42      	adds	r2, r0, #1
    4a5e:	71da      	strb	r2, [r3, #7]
    4a60:	4606      	mov	r6, r0
	id_create(new_id, addr, irk);
    4a62:	4622      	mov	r2, r4
    4a64:	4629      	mov	r1, r5
    4a66:	f7ff fdb1 	bl	45cc <id_create>

	return new_id;
}
    4a6a:	4630      	mov	r0, r6
    4a6c:	b002      	add	sp, #8
    4a6e:	bd70      	pop	{r4, r5, r6, pc}
			return -EALREADY;
    4a70:	f06f 0677 	mvn.w	r6, #119	; 0x77
    4a74:	e7f9      	b.n	4a6a <bt_id_create+0x76>
		return -EINVAL;
    4a76:	f06f 0615 	mvn.w	r6, #21
    4a7a:	e7f6      	b.n	4a6a <bt_id_create+0x76>
		return -ENOMEM;
    4a7c:	f06f 060b 	mvn.w	r6, #11
    4a80:	e7f3      	b.n	4a6a <bt_id_create+0x76>
    4a82:	bf00      	nop
    4a84:	00010c90 	.word	0x00010c90
    4a88:	00010c18 	.word	0x00010c18
    4a8c:	00012270 	.word	0x00012270
    4a90:	20000000 	.word	0x20000000

00004a94 <bt_setup_public_id_addr>:
#endif /* defined(CONFIG_BT_HCI_VS_EXT) */
}
#endif /* defined(CONFIG_BT_PRIVACY) */

void bt_setup_public_id_addr(void)
{
    4a94:	b500      	push	{lr}
    4a96:	b083      	sub	sp, #12
	bt_addr_le_t addr;
	u8_t *irk = NULL;

	bt_dev.id_count = bt_read_public_addr(&addr);
    4a98:	4668      	mov	r0, sp
    4a9a:	f7ff fbdb 	bl	4254 <bt_read_public_addr>
    4a9e:	4b06      	ldr	r3, [pc, #24]	; (4ab8 <bt_setup_public_id_addr+0x24>)
    4aa0:	71d8      	strb	r0, [r3, #7]

	if (!bt_dev.id_count) {
    4aa2:	b910      	cbnz	r0, 4aaa <bt_setup_public_id_addr+0x16>
		atomic_set_bit(bt_dev.flags, BT_DEV_STORE_ID);
	}
#endif /* defined(CONFIG_BT_PRIVACY) */

	id_create(BT_ID_DEFAULT, &addr, irk);
}
    4aa4:	b003      	add	sp, #12
    4aa6:	f85d fb04 	ldr.w	pc, [sp], #4
	id_create(BT_ID_DEFAULT, &addr, irk);
    4aaa:	2200      	movs	r2, #0
    4aac:	4669      	mov	r1, sp
    4aae:	4610      	mov	r0, r2
    4ab0:	f7ff fd8c 	bl	45cc <id_create>
    4ab4:	e7f6      	b.n	4aa4 <bt_setup_public_id_addr+0x10>
    4ab6:	bf00      	nop
    4ab8:	20000000 	.word	0x20000000

00004abc <bt_read_static_addr>:

#if defined(CONFIG_BT_HCI_VS_EXT)
u8_t bt_read_static_addr(struct bt_hci_vs_static_addr addrs[], u8_t size)
{
    4abc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4ac0:	b082      	sub	sp, #8
	struct bt_hci_rp_vs_read_static_addrs *rp;
	struct net_buf *rsp;
	int err, i;
	u8_t cnt;

	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
    4ac2:	4b38      	ldr	r3, [pc, #224]	; (4ba4 <bt_read_static_addr+0xe8>)
    4ac4:	f893 608a 	ldrb.w	r6, [r3, #138]	; 0x8a
    4ac8:	f016 0601 	ands.w	r6, r6, #1
    4acc:	d012      	beq.n	4af4 <bt_read_static_addr+0x38>
    4ace:	4607      	mov	r7, r0
    4ad0:	460d      	mov	r5, r1
		BT_WARN("Read Static Addresses command not available");
		return 0;
	}

	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_STATIC_ADDRS, NULL, &rsp);
    4ad2:	aa01      	add	r2, sp, #4
    4ad4:	2100      	movs	r1, #0
    4ad6:	f64f 4009 	movw	r0, #64521	; 0xfc09
    4ada:	f7ff f945 	bl	3d68 <bt_hci_cmd_send_sync>
	if (err) {
    4ade:	4604      	mov	r4, r0
    4ae0:	b9d0      	cbnz	r0, 4b18 <bt_read_static_addr+0x5c>
		BT_WARN("Invalid Vendor HCI extensions");
		net_buf_unref(rsp);
		return 0;
	}

	rp = (void *)rsp->data;
    4ae2:	9b01      	ldr	r3, [sp, #4]
    4ae4:	f8d3 8008 	ldr.w	r8, [r3, #8]
	cnt = MIN(rp->num_addrs, size);
    4ae8:	f898 6001 	ldrb.w	r6, [r8, #1]
    4aec:	42ae      	cmp	r6, r5
    4aee:	bf28      	it	cs
    4af0:	462e      	movcs	r6, r5
		BT_WARN("Invalid Vendor HCI extensions");
		net_buf_unref(rsp);
		return 0;
	}

	for (i = 0; i < cnt; i++) {
    4af2:	e03b      	b.n	4b6c <bt_read_static_addr+0xb0>
		BT_WARN("Read Static Addresses command not available");
    4af4:	f04f 0100 	mov.w	r1, #0
    4af8:	2302      	movs	r3, #2
    4afa:	f363 0102 	bfi	r1, r3, #0, #3
    4afe:	f36f 01c5 	bfc	r1, #3, #3
    4b02:	4b29      	ldr	r3, [pc, #164]	; (4ba8 <bt_read_static_addr+0xec>)
    4b04:	4a29      	ldr	r2, [pc, #164]	; (4bac <bt_read_static_addr+0xf0>)
    4b06:	1a9b      	subs	r3, r3, r2
    4b08:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    4b0c:	f363 118f 	bfi	r1, r3, #6, #10
    4b10:	4827      	ldr	r0, [pc, #156]	; (4bb0 <bt_read_static_addr+0xf4>)
    4b12:	f7fd f8c5 	bl	1ca0 <log_0>
		return 0;
    4b16:	e02f      	b.n	4b78 <bt_read_static_addr+0xbc>
		BT_WARN("Failed to read static addresses");
    4b18:	f04f 0100 	mov.w	r1, #0
    4b1c:	2302      	movs	r3, #2
    4b1e:	f363 0102 	bfi	r1, r3, #0, #3
    4b22:	f36f 01c5 	bfc	r1, #3, #3
    4b26:	4b20      	ldr	r3, [pc, #128]	; (4ba8 <bt_read_static_addr+0xec>)
    4b28:	4a20      	ldr	r2, [pc, #128]	; (4bac <bt_read_static_addr+0xf0>)
    4b2a:	1a9b      	subs	r3, r3, r2
    4b2c:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    4b30:	f363 118f 	bfi	r1, r3, #6, #10
    4b34:	481f      	ldr	r0, [pc, #124]	; (4bb4 <bt_read_static_addr+0xf8>)
    4b36:	f7fd f8b3 	bl	1ca0 <log_0>
		return 0;
    4b3a:	2600      	movs	r6, #0
    4b3c:	e01c      	b.n	4b78 <bt_read_static_addr+0xbc>
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
    4b3e:	2116      	movs	r1, #22
    4b40:	fb01 f104 	mul.w	r1, r1, r4
    4b44:	187a      	adds	r2, r7, r1
    4b46:	4643      	mov	r3, r8
    4b48:	f853 5f02 	ldr.w	r5, [r3, #2]!
    4b4c:	f8d3 e004 	ldr.w	lr, [r3, #4]
    4b50:	f8d3 c008 	ldr.w	ip, [r3, #8]
    4b54:	68d8      	ldr	r0, [r3, #12]
    4b56:	507d      	str	r5, [r7, r1]
    4b58:	f8c2 e004 	str.w	lr, [r2, #4]
    4b5c:	f8c2 c008 	str.w	ip, [r2, #8]
    4b60:	60d0      	str	r0, [r2, #12]
    4b62:	691d      	ldr	r5, [r3, #16]
    4b64:	6115      	str	r5, [r2, #16]
    4b66:	8a9b      	ldrh	r3, [r3, #20]
    4b68:	8293      	strh	r3, [r2, #20]
	for (i = 0; i < cnt; i++) {
    4b6a:	3401      	adds	r4, #1
    4b6c:	42a6      	cmp	r6, r4
    4b6e:	dce6      	bgt.n	4b3e <bt_read_static_addr+0x82>
	}

	net_buf_unref(rsp);
    4b70:	9801      	ldr	r0, [sp, #4]
    4b72:	f00a fd69 	bl	f648 <net_buf_unref>
	if (!cnt) {
    4b76:	b11e      	cbz	r6, 4b80 <bt_read_static_addr+0xc4>
		BT_WARN("No static addresses stored in controller");
	}

	return cnt;
}
    4b78:	4630      	mov	r0, r6
    4b7a:	b002      	add	sp, #8
    4b7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		BT_WARN("No static addresses stored in controller");
    4b80:	f04f 0100 	mov.w	r1, #0
    4b84:	2302      	movs	r3, #2
    4b86:	f363 0102 	bfi	r1, r3, #0, #3
    4b8a:	f36f 01c5 	bfc	r1, #3, #3
    4b8e:	4b06      	ldr	r3, [pc, #24]	; (4ba8 <bt_read_static_addr+0xec>)
    4b90:	4a06      	ldr	r2, [pc, #24]	; (4bac <bt_read_static_addr+0xf0>)
    4b92:	1a9b      	subs	r3, r3, r2
    4b94:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    4b98:	f363 118f 	bfi	r1, r3, #6, #10
    4b9c:	4806      	ldr	r0, [pc, #24]	; (4bb8 <bt_read_static_addr+0xfc>)
    4b9e:	f7fd f87f 	bl	1ca0 <log_0>
    4ba2:	e7e9      	b.n	4b78 <bt_read_static_addr+0xbc>
    4ba4:	20000000 	.word	0x20000000
    4ba8:	00010c90 	.word	0x00010c90
    4bac:	00010c18 	.word	0x00010c18
    4bb0:	000122a0 	.word	0x000122a0
    4bb4:	000122cc 	.word	0x000122cc
    4bb8:	000122ec 	.word	0x000122ec

00004bbc <bt_setup_random_id_addr>:
#endif /* CONFIG_BT_HCI_VS_EXT */

int bt_setup_random_id_addr(void)
{
    4bbc:	b510      	push	{r4, lr}
    4bbe:	b088      	sub	sp, #32
#if defined(CONFIG_BT_HCI_VS_EXT) || defined(CONFIG_BT_CTLR)
	/* Only read the addresses if the user has not already configured one or
	 * more identities (!bt_dev.id_count).
	 */
	if (!bt_dev.id_count) {
    4bc0:	4b14      	ldr	r3, [pc, #80]	; (4c14 <bt_setup_random_id_addr+0x58>)
    4bc2:	79dc      	ldrb	r4, [r3, #7]
    4bc4:	b934      	cbnz	r4, 4bd4 <bt_setup_random_id_addr+0x18>
		struct bt_hci_vs_static_addr addrs[CONFIG_BT_ID_MAX];

		bt_dev.id_count = bt_read_static_addr(addrs, CONFIG_BT_ID_MAX);
    4bc6:	2101      	movs	r1, #1
    4bc8:	a802      	add	r0, sp, #8
    4bca:	f7ff ff77 	bl	4abc <bt_read_static_addr>
    4bce:	4b11      	ldr	r3, [pc, #68]	; (4c14 <bt_setup_random_id_addr+0x58>)
    4bd0:	71d8      	strb	r0, [r3, #7]

		if (bt_dev.id_count) {
    4bd2:	b9c8      	cbnz	r0, 4c08 <bt_setup_random_id_addr+0x4c>

	if (IS_ENABLED(CONFIG_BT_PRIVACY) && IS_ENABLED(CONFIG_BT_SETTINGS)) {
		atomic_set_bit(bt_dev.flags, BT_DEV_STORE_ID);
	}

	return bt_id_create(NULL, NULL);
    4bd4:	2100      	movs	r1, #0
    4bd6:	4608      	mov	r0, r1
    4bd8:	f7ff ff0c 	bl	49f4 <bt_id_create>
}
    4bdc:	b008      	add	sp, #32
    4bde:	bd10      	pop	{r4, pc}
				bt_addr_copy(&addr.a, &addrs[i].bdaddr);
    4be0:	2316      	movs	r3, #22
    4be2:	aa02      	add	r2, sp, #8
    4be4:	fb03 2304 	mla	r3, r3, r4, r2
	memcpy(dst, src, sizeof(*dst));
    4be8:	681a      	ldr	r2, [r3, #0]
    4bea:	f8cd 2001 	str.w	r2, [sp, #1]
    4bee:	889b      	ldrh	r3, [r3, #4]
    4bf0:	f8ad 3005 	strh.w	r3, [sp, #5]
				addr.type = BT_ADDR_LE_RANDOM;
    4bf4:	2301      	movs	r3, #1
    4bf6:	f88d 3000 	strb.w	r3, [sp]
				id_create(i, &addr, irk);
    4bfa:	2200      	movs	r2, #0
    4bfc:	4669      	mov	r1, sp
    4bfe:	4620      	mov	r0, r4
    4c00:	f7ff fce4 	bl	45cc <id_create>
			for (u8_t i = 0; i < bt_dev.id_count; i++) {
    4c04:	3401      	adds	r4, #1
    4c06:	b2e4      	uxtb	r4, r4
    4c08:	4b02      	ldr	r3, [pc, #8]	; (4c14 <bt_setup_random_id_addr+0x58>)
    4c0a:	79db      	ldrb	r3, [r3, #7]
    4c0c:	42a3      	cmp	r3, r4
    4c0e:	d8e7      	bhi.n	4be0 <bt_setup_random_id_addr+0x24>
			return 0;
    4c10:	2000      	movs	r0, #0
    4c12:	e7e3      	b.n	4bdc <bt_setup_random_id_addr+0x20>
    4c14:	20000000 	.word	0x20000000

00004c18 <hci_init>:
{
    4c18:	b510      	push	{r4, lr}
	err = common_init();
    4c1a:	f7ff f927 	bl	3e6c <common_init>
	if (err) {
    4c1e:	4604      	mov	r4, r0
    4c20:	b108      	cbz	r0, 4c26 <hci_init+0xe>
}
    4c22:	4620      	mov	r0, r4
    4c24:	bd10      	pop	{r4, pc}
	err = le_init();
    4c26:	f7ff f96b 	bl	3f00 <le_init>
	if (err) {
    4c2a:	4604      	mov	r4, r0
    4c2c:	2800      	cmp	r0, #0
    4c2e:	d1f8      	bne.n	4c22 <hci_init+0xa>
	if (BT_FEAT_BREDR(bt_dev.features)) {
    4c30:	4b24      	ldr	r3, [pc, #144]	; (4cc4 <hci_init+0xac>)
    4c32:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    4c36:	f013 0f20 	tst.w	r3, #32
    4c3a:	d104      	bne.n	4c46 <hci_init+0x2e>
		err = br_init();
    4c3c:	f009 fa7f 	bl	e13e <br_init>
		if (err) {
    4c40:	4604      	mov	r4, r0
    4c42:	2800      	cmp	r0, #0
    4c44:	d1ed      	bne.n	4c22 <hci_init+0xa>
	err = set_event_mask();
    4c46:	f009 fac2 	bl	e1ce <set_event_mask>
	if (err) {
    4c4a:	4604      	mov	r4, r0
    4c4c:	2800      	cmp	r0, #0
    4c4e:	d1e8      	bne.n	4c22 <hci_init+0xa>
	hci_vs_init();
    4c50:	f7ff f9c6 	bl	3fe0 <hci_vs_init>
	if (!IS_ENABLED(CONFIG_BT_SETTINGS) && !bt_dev.id_count) {
    4c54:	4b1b      	ldr	r3, [pc, #108]	; (4cc4 <hci_init+0xac>)
    4c56:	79db      	ldrb	r3, [r3, #7]
    4c58:	b1fb      	cbz	r3, 4c9a <hci_init+0x82>
	if (!IS_ENABLED(CONFIG_BT_SETTINGS) && !bt_dev.id_count) {
    4c5a:	4b1a      	ldr	r3, [pc, #104]	; (4cc4 <hci_init+0xac>)
    4c5c:	79db      	ldrb	r3, [r3, #7]
    4c5e:	2b00      	cmp	r3, #0
    4c60:	d1df      	bne.n	4c22 <hci_init+0xa>
		err = bt_setup_random_id_addr();
    4c62:	f7ff ffab 	bl	4bbc <bt_setup_random_id_addr>
		if (err) {
    4c66:	4604      	mov	r4, r0
    4c68:	b9d0      	cbnz	r0, 4ca0 <hci_init+0x88>
		err = set_random_address(&bt_dev.id_addr[0].a);
    4c6a:	4817      	ldr	r0, [pc, #92]	; (4cc8 <hci_init+0xb0>)
    4c6c:	f7ff fa82 	bl	4174 <set_random_address>
		if (err) {
    4c70:	4604      	mov	r4, r0
    4c72:	2800      	cmp	r0, #0
    4c74:	d0d5      	beq.n	4c22 <hci_init+0xa>
			BT_ERR("Unable to set random address");
    4c76:	f04f 0100 	mov.w	r1, #0
    4c7a:	2301      	movs	r3, #1
    4c7c:	f363 0102 	bfi	r1, r3, #0, #3
    4c80:	f36f 01c5 	bfc	r1, #3, #3
    4c84:	4b11      	ldr	r3, [pc, #68]	; (4ccc <hci_init+0xb4>)
    4c86:	4a12      	ldr	r2, [pc, #72]	; (4cd0 <hci_init+0xb8>)
    4c88:	1a9b      	subs	r3, r3, r2
    4c8a:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    4c8e:	f363 118f 	bfi	r1, r3, #6, #10
    4c92:	4810      	ldr	r0, [pc, #64]	; (4cd4 <hci_init+0xbc>)
    4c94:	f7fd f804 	bl	1ca0 <log_0>
			return err;
    4c98:	e7c3      	b.n	4c22 <hci_init+0xa>
		bt_setup_public_id_addr();
    4c9a:	f7ff fefb 	bl	4a94 <bt_setup_public_id_addr>
    4c9e:	e7dc      	b.n	4c5a <hci_init+0x42>
			BT_ERR("Unable to set identity address");
    4ca0:	f04f 0100 	mov.w	r1, #0
    4ca4:	2301      	movs	r3, #1
    4ca6:	f363 0102 	bfi	r1, r3, #0, #3
    4caa:	f36f 01c5 	bfc	r1, #3, #3
    4cae:	4b07      	ldr	r3, [pc, #28]	; (4ccc <hci_init+0xb4>)
    4cb0:	4a07      	ldr	r2, [pc, #28]	; (4cd0 <hci_init+0xb8>)
    4cb2:	1a9b      	subs	r3, r3, r2
    4cb4:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    4cb8:	f363 118f 	bfi	r1, r3, #6, #10
    4cbc:	4806      	ldr	r0, [pc, #24]	; (4cd8 <hci_init+0xc0>)
    4cbe:	f7fc ffef 	bl	1ca0 <log_0>
			return err;
    4cc2:	e7ae      	b.n	4c22 <hci_init+0xa>
    4cc4:	20000000 	.word	0x20000000
    4cc8:	20000001 	.word	0x20000001
    4ccc:	00010c90 	.word	0x00010c90
    4cd0:	00010c18 	.word	0x00010c18
    4cd4:	00012338 	.word	0x00012338
    4cd8:	00012318 	.word	0x00012318

00004cdc <init_work>:
{
    4cdc:	b508      	push	{r3, lr}
	err = bt_init();
    4cde:	f009 fac1 	bl	e264 <bt_init>
	if (ready_cb) {
    4ce2:	4b02      	ldr	r3, [pc, #8]	; (4cec <init_work+0x10>)
    4ce4:	681b      	ldr	r3, [r3, #0]
    4ce6:	b103      	cbz	r3, 4cea <init_work+0xe>
		ready_cb(err);
    4ce8:	4798      	blx	r3
}
    4cea:	bd08      	pop	{r3, pc}
    4cec:	20003e54 	.word	0x20003e54

00004cf0 <bt_enable>:
{
    4cf0:	b530      	push	{r4, r5, lr}
    4cf2:	b089      	sub	sp, #36	; 0x24
	if (!bt_dev.drv) {
    4cf4:	4b3f      	ldr	r3, [pc, #252]	; (4df4 <bt_enable+0x104>)
    4cf6:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
    4cfa:	2b00      	cmp	r3, #0
    4cfc:	d046      	beq.n	4d8c <bt_enable+0x9c>
    4cfe:	4604      	mov	r4, r0
    4d00:	4b3d      	ldr	r3, [pc, #244]	; (4df8 <bt_enable+0x108>)
    4d02:	f3bf 8f5b 	dmb	ish
    4d06:	e853 2f00 	ldrex	r2, [r3]
    4d0a:	f042 0101 	orr.w	r1, r2, #1
    4d0e:	e843 1000 	strex	r0, r1, [r3]
    4d12:	2800      	cmp	r0, #0
    4d14:	d1f7      	bne.n	4d06 <bt_enable+0x16>
    4d16:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_ENABLE)) {
    4d1a:	f012 0f01 	tst.w	r2, #1
    4d1e:	d166      	bne.n	4dee <bt_enable+0xfe>
	ready_cb = cb;
    4d20:	4b36      	ldr	r3, [pc, #216]	; (4dfc <bt_enable+0x10c>)
    4d22:	601c      	str	r4, [r3, #0]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    4d24:	4d36      	ldr	r5, [pc, #216]	; (4e00 <bt_enable+0x110>)
    4d26:	2200      	movs	r2, #0
    4d28:	2300      	movs	r3, #0
    4d2a:	e9cd 2306 	strd	r2, r3, [sp, #24]
    4d2e:	2300      	movs	r3, #0
    4d30:	9304      	str	r3, [sp, #16]
    4d32:	f06f 0208 	mvn.w	r2, #8
    4d36:	9203      	str	r2, [sp, #12]
    4d38:	9302      	str	r3, [sp, #8]
    4d3a:	9301      	str	r3, [sp, #4]
    4d3c:	9300      	str	r3, [sp, #0]
    4d3e:	4b31      	ldr	r3, [pc, #196]	; (4e04 <bt_enable+0x114>)
    4d40:	f44f 7220 	mov.w	r2, #640	; 0x280
    4d44:	4930      	ldr	r1, [pc, #192]	; (4e08 <bt_enable+0x118>)
    4d46:	4628      	mov	r0, r5
    4d48:	f00b fad1 	bl	102ee <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    4d4c:	492f      	ldr	r1, [pc, #188]	; (4e0c <bt_enable+0x11c>)
    4d4e:	4628      	mov	r0, r5
    4d50:	f00b fabc 	bl	102cc <z_impl_k_thread_name_set>
	err = bt_dev.drv->open();
    4d54:	4b27      	ldr	r3, [pc, #156]	; (4df4 <bt_enable+0x104>)
    4d56:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
    4d5a:	68db      	ldr	r3, [r3, #12]
    4d5c:	4798      	blx	r3
	if (err) {
    4d5e:	4605      	mov	r5, r0
    4d60:	bb40      	cbnz	r0, 4db4 <bt_enable+0xc4>
	if (!cb) {
    4d62:	2c00      	cmp	r4, #0
    4d64:	d039      	beq.n	4dda <bt_enable+0xea>
    4d66:	4b2a      	ldr	r3, [pc, #168]	; (4e10 <bt_enable+0x120>)
    4d68:	f3bf 8f5b 	dmb	ish
    4d6c:	e853 2f00 	ldrex	r2, [r3]
    4d70:	f042 0101 	orr.w	r1, r2, #1
    4d74:	e843 1000 	strex	r0, r1, [r3]
    4d78:	2800      	cmp	r0, #0
    4d7a:	d1f7      	bne.n	4d6c <bt_enable+0x7c>
    4d7c:	f3bf 8f5b 	dmb	ish
 * @return N/A
 */
static inline void k_work_submit_to_queue(struct k_work_q *work_q,
					  struct k_work *work)
{
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    4d80:	f012 0f01 	tst.w	r2, #1
    4d84:	d02d      	beq.n	4de2 <bt_enable+0xf2>
}
    4d86:	4628      	mov	r0, r5
    4d88:	b009      	add	sp, #36	; 0x24
    4d8a:	bd30      	pop	{r4, r5, pc}
		BT_ERR("No HCI driver registered");
    4d8c:	f04f 0100 	mov.w	r1, #0
    4d90:	2301      	movs	r3, #1
    4d92:	f363 0102 	bfi	r1, r3, #0, #3
    4d96:	f36f 01c5 	bfc	r1, #3, #3
    4d9a:	4b1e      	ldr	r3, [pc, #120]	; (4e14 <bt_enable+0x124>)
    4d9c:	4a1e      	ldr	r2, [pc, #120]	; (4e18 <bt_enable+0x128>)
    4d9e:	1a9b      	subs	r3, r3, r2
    4da0:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    4da4:	f363 118f 	bfi	r1, r3, #6, #10
    4da8:	481c      	ldr	r0, [pc, #112]	; (4e1c <bt_enable+0x12c>)
    4daa:	f7fc ff79 	bl	1ca0 <log_0>
		return -ENODEV;
    4dae:	f06f 0512 	mvn.w	r5, #18
    4db2:	e7e8      	b.n	4d86 <bt_enable+0x96>
		BT_ERR("HCI driver open failed (%d)", err);
    4db4:	f04f 0200 	mov.w	r2, #0
    4db8:	2301      	movs	r3, #1
    4dba:	f363 0202 	bfi	r2, r3, #0, #3
    4dbe:	f36f 02c5 	bfc	r2, #3, #3
    4dc2:	4b14      	ldr	r3, [pc, #80]	; (4e14 <bt_enable+0x124>)
    4dc4:	4914      	ldr	r1, [pc, #80]	; (4e18 <bt_enable+0x128>)
    4dc6:	1a5b      	subs	r3, r3, r1
    4dc8:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    4dcc:	f363 128f 	bfi	r2, r3, #6, #10
    4dd0:	4601      	mov	r1, r0
    4dd2:	4813      	ldr	r0, [pc, #76]	; (4e20 <bt_enable+0x130>)
    4dd4:	f7fc fdf4 	bl	19c0 <log_1>
		return err;
    4dd8:	e7d5      	b.n	4d86 <bt_enable+0x96>
		return bt_init();
    4dda:	f009 fa43 	bl	e264 <bt_init>
    4dde:	4605      	mov	r5, r0
    4de0:	e7d1      	b.n	4d86 <bt_enable+0x96>
		k_queue_append(&work_q->queue, work);
    4de2:	f1a3 0108 	sub.w	r1, r3, #8
    4de6:	480f      	ldr	r0, [pc, #60]	; (4e24 <bt_enable+0x134>)
    4de8:	f00b f888 	bl	fefc <k_queue_append>
	}
}
    4dec:	e7cb      	b.n	4d86 <bt_enable+0x96>
		return -EALREADY;
    4dee:	f06f 0577 	mvn.w	r5, #119	; 0x77
    4df2:	e7c8      	b.n	4d86 <bt_enable+0x96>
    4df4:	20000000 	.word	0x20000000
    4df8:	20000098 	.word	0x20000098
    4dfc:	20003e54 	.word	0x20003e54
    4e00:	20003e64 	.word	0x20003e64
    4e04:	000047bd 	.word	0x000047bd
    4e08:	20005c60 	.word	0x20005c60
    4e0c:	00012374 	.word	0x00012374
    4e10:	20000094 	.word	0x20000094
    4e14:	00010c90 	.word	0x00010c90
    4e18:	00010c18 	.word	0x00010c18
    4e1c:	00012358 	.word	0x00012358
    4e20:	0001237c 	.word	0x0001237c
    4e24:	200058b0 	.word	0x200058b0

00004e28 <bt_le_scan_start>:

	return true;
}

int bt_le_scan_start(const struct bt_le_scan_param *param, bt_le_scan_cb_t cb)
{
    4e28:	b538      	push	{r3, r4, r5, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    4e2a:	f3bf 8f5b 	dmb	ish
    4e2e:	4b44      	ldr	r3, [pc, #272]	; (4f40 <bt_le_scan_start+0x118>)
    4e30:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    4e34:	f3bf 8f5b 	dmb	ish
	int err;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    4e38:	f013 0f02 	tst.w	r3, #2
    4e3c:	d070      	beq.n	4f20 <bt_le_scan_start+0xf8>
    4e3e:	4604      	mov	r4, r0
    4e40:	460d      	mov	r5, r1
		return -EAGAIN;
	}

	/* Check that the parameters have valid values */
	if (!valid_le_scan_param(param)) {
    4e42:	f009 f97e 	bl	e142 <valid_le_scan_param>
    4e46:	2800      	cmp	r0, #0
    4e48:	d06d      	beq.n	4f26 <bt_le_scan_start+0xfe>
		return -EINVAL;
	}

	if (param->type && !bt_le_scan_random_addr_check()) {
    4e4a:	7823      	ldrb	r3, [r4, #0]
    4e4c:	b11b      	cbz	r3, 4e56 <bt_le_scan_start+0x2e>
    4e4e:	f009 f9f9 	bl	e244 <bt_le_scan_random_addr_check>
    4e52:	2800      	cmp	r0, #0
    4e54:	d06a      	beq.n	4f2c <bt_le_scan_start+0x104>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    4e56:	4b3b      	ldr	r3, [pc, #236]	; (4f44 <bt_le_scan_start+0x11c>)
    4e58:	f3bf 8f5b 	dmb	ish
    4e5c:	e853 2f00 	ldrex	r2, [r3]
    4e60:	f042 0140 	orr.w	r1, r2, #64	; 0x40
    4e64:	e843 1000 	strex	r0, r1, [r3]
    4e68:	2800      	cmp	r0, #0
    4e6a:	d1f7      	bne.n	4e5c <bt_le_scan_start+0x34>
    4e6c:	f3bf 8f5b 	dmb	ish
		return -EINVAL;
	}

	/* Return if active scan is already enabled */
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
    4e70:	f012 0f40 	tst.w	r2, #64	; 0x40
    4e74:	d15d      	bne.n	4f32 <bt_le_scan_start+0x10a>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    4e76:	f3bf 8f5b 	dmb	ish
    4e7a:	3b98      	subs	r3, #152	; 0x98
    4e7c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    4e80:	f3bf 8f5b 	dmb	ish
		return -EALREADY;
	}

	if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING)) {
    4e84:	f013 0f20 	tst.w	r3, #32
    4e88:	d003      	beq.n	4e92 <bt_le_scan_start+0x6a>
		err = set_le_scan_enable(BT_HCI_LE_SCAN_DISABLE);
    4e8a:	2000      	movs	r0, #0
    4e8c:	f009 f9d4 	bl	e238 <set_le_scan_enable>
		if (err) {
    4e90:	b9e0      	cbnz	r0, 4ecc <bt_le_scan_start+0xa4>
			return err;
		}
	}

	atomic_set_bit_to(bt_dev.flags, BT_DEV_SCAN_FILTER_DUP,
			  param->options & BT_LE_SCAN_OPT_FILTER_DUPLICATE);
    4e92:	6863      	ldr	r3, [r4, #4]
	if (val) {
    4e94:	f013 0f01 	tst.w	r3, #1
    4e98:	d026      	beq.n	4ee8 <bt_le_scan_start+0xc0>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    4e9a:	4b2a      	ldr	r3, [pc, #168]	; (4f44 <bt_le_scan_start+0x11c>)
    4e9c:	f3bf 8f5b 	dmb	ish
    4ea0:	e853 2f00 	ldrex	r2, [r3]
    4ea4:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    4ea8:	e843 2100 	strex	r1, r2, [r3]
    4eac:	2900      	cmp	r1, #0
    4eae:	d1f7      	bne.n	4ea0 <bt_le_scan_start+0x78>
    4eb0:	f3bf 8f5b 	dmb	ish
			phy_coded = &param_coded;
		}

		err = start_le_scan_ext(phy_1m, phy_coded, param->timeout);
	} else {
		if (param->timeout) {
    4eb4:	89a3      	ldrh	r3, [r4, #12]
    4eb6:	2b00      	cmp	r3, #0
    4eb8:	d13e      	bne.n	4f38 <bt_le_scan_start+0x110>
			return -ENOTSUP;
		}

		err = start_le_scan_legacy(param->type, param->interval,
    4eba:	8962      	ldrh	r2, [r4, #10]
    4ebc:	8921      	ldrh	r1, [r4, #8]
    4ebe:	7820      	ldrb	r0, [r4, #0]
    4ec0:	f7ff fb12 	bl	44e8 <start_le_scan_legacy>
					   param->window);
	}

	if (err) {
    4ec4:	b9f0      	cbnz	r0, 4f04 <bt_le_scan_start+0xdc>
		atomic_clear_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN);
		return err;
	}

	scan_dev_found_cb = cb;
    4ec6:	4b20      	ldr	r3, [pc, #128]	; (4f48 <bt_le_scan_start+0x120>)
    4ec8:	601d      	str	r5, [r3, #0]

	return 0;
}
    4eca:	bd38      	pop	{r3, r4, r5, pc}
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    4ecc:	4b1d      	ldr	r3, [pc, #116]	; (4f44 <bt_le_scan_start+0x11c>)
    4ece:	f3bf 8f5b 	dmb	ish
    4ed2:	e853 2f00 	ldrex	r2, [r3]
    4ed6:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    4eda:	e843 2100 	strex	r1, r2, [r3]
    4ede:	2900      	cmp	r1, #0
    4ee0:	d1f7      	bne.n	4ed2 <bt_le_scan_start+0xaa>
    4ee2:	f3bf 8f5b 	dmb	ish
			return err;
    4ee6:	e7f0      	b.n	4eca <bt_le_scan_start+0xa2>
    4ee8:	4b16      	ldr	r3, [pc, #88]	; (4f44 <bt_le_scan_start+0x11c>)
    4eea:	f3bf 8f5b 	dmb	ish
    4eee:	e853 2f00 	ldrex	r2, [r3]
    4ef2:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    4ef6:	e843 2100 	strex	r1, r2, [r3]
    4efa:	2900      	cmp	r1, #0
    4efc:	d1f7      	bne.n	4eee <bt_le_scan_start+0xc6>
    4efe:	f3bf 8f5b 	dmb	ish
    4f02:	e7d7      	b.n	4eb4 <bt_le_scan_start+0x8c>
    4f04:	4b0f      	ldr	r3, [pc, #60]	; (4f44 <bt_le_scan_start+0x11c>)
    4f06:	f3bf 8f5b 	dmb	ish
    4f0a:	e853 2f00 	ldrex	r2, [r3]
    4f0e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    4f12:	e843 2100 	strex	r1, r2, [r3]
    4f16:	2900      	cmp	r1, #0
    4f18:	d1f7      	bne.n	4f0a <bt_le_scan_start+0xe2>
    4f1a:	f3bf 8f5b 	dmb	ish
		return err;
    4f1e:	e7d4      	b.n	4eca <bt_le_scan_start+0xa2>
		return -EAGAIN;
    4f20:	f06f 000a 	mvn.w	r0, #10
    4f24:	e7d1      	b.n	4eca <bt_le_scan_start+0xa2>
		return -EINVAL;
    4f26:	f06f 0015 	mvn.w	r0, #21
    4f2a:	e7ce      	b.n	4eca <bt_le_scan_start+0xa2>
		return -EINVAL;
    4f2c:	f06f 0015 	mvn.w	r0, #21
    4f30:	e7cb      	b.n	4eca <bt_le_scan_start+0xa2>
		return -EALREADY;
    4f32:	f06f 0077 	mvn.w	r0, #119	; 0x77
    4f36:	e7c8      	b.n	4eca <bt_le_scan_start+0xa2>
			return -ENOTSUP;
    4f38:	f06f 0085 	mvn.w	r0, #133	; 0x85
    4f3c:	e7c5      	b.n	4eca <bt_le_scan_start+0xa2>
    4f3e:	bf00      	nop
    4f40:	20000000 	.word	0x20000000
    4f44:	20000098 	.word	0x20000098
    4f48:	20003e60 	.word	0x20003e60

00004f4c <bt_buf_get_rx>:
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_HOST_CHAN_CLASSIF,
				    buf, NULL);
}

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, k_timeout_t timeout)
{
    4f4c:	b538      	push	{r3, r4, r5, lr}
    4f4e:	4604      	mov	r4, r0
		buf = net_buf_alloc(&hci_rx_pool, timeout);
	} else {
		buf = net_buf_alloc(&acl_in_pool, timeout);
	}
#else
	buf = net_buf_alloc(&hci_rx_pool, timeout);
    4f50:	4805      	ldr	r0, [pc, #20]	; (4f68 <bt_buf_get_rx+0x1c>)
    4f52:	f00a fb46 	bl	f5e2 <net_buf_alloc_fixed>
#endif

	if (buf) {
    4f56:	4605      	mov	r5, r0
    4f58:	b120      	cbz	r0, 4f64 <bt_buf_get_rx+0x18>
		net_buf_reserve(buf, BT_BUF_RESERVE);
    4f5a:	2100      	movs	r1, #0
    4f5c:	3008      	adds	r0, #8
    4f5e:	f00a fb62 	bl	f626 <net_buf_simple_reserve>
	*(u8_t *)net_buf_user_data(buf) = type;
    4f62:	752c      	strb	r4, [r5, #20]
		bt_buf_set_type(buf, type);
	}

	return buf;
}
    4f64:	4628      	mov	r0, r5
    4f66:	bd38      	pop	{r3, r4, r5, pc}
    4f68:	20000550 	.word	0x20000550

00004f6c <bt_buf_get_cmd_complete>:

struct net_buf *bt_buf_get_cmd_complete(k_timeout_t timeout)
{
    4f6c:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
    4f6e:	f04f 0320 	mov.w	r3, #32
    4f72:	f3ef 8211 	mrs	r2, BASEPRI
    4f76:	f383 8811 	msr	BASEPRI, r3
    4f7a:	f3bf 8f6f 	isb	sy
	struct net_buf *buf;
	unsigned int key;

	key = irq_lock();
	buf = bt_dev.sent_cmd;
    4f7e:	4b0e      	ldr	r3, [pc, #56]	; (4fb8 <bt_buf_get_cmd_complete+0x4c>)
    4f80:	f8d3 40c8 	ldr.w	r4, [r3, #200]	; 0xc8
	bt_dev.sent_cmd = NULL;
    4f84:	2500      	movs	r5, #0
    4f86:	f8c3 50c8 	str.w	r5, [r3, #200]	; 0xc8
	__asm__ volatile(
    4f8a:	f382 8811 	msr	BASEPRI, r2
    4f8e:	f3bf 8f6f 	isb	sy
	irq_unlock(key);

	BT_DBG("sent_cmd %p", buf);

	if (buf) {
    4f92:	b14c      	cbz	r4, 4fa8 <bt_buf_get_cmd_complete+0x3c>
    4f94:	2301      	movs	r3, #1
    4f96:	7523      	strb	r3, [r4, #20]
		bt_buf_set_type(buf, BT_BUF_EVT);
		buf->len = 0U;
    4f98:	4629      	mov	r1, r5
    4f9a:	81a5      	strh	r5, [r4, #12]
		net_buf_reserve(buf, BT_BUF_RESERVE);
    4f9c:	f104 0008 	add.w	r0, r4, #8
    4fa0:	f00a fb41 	bl	f626 <net_buf_simple_reserve>

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
}
    4fa4:	4620      	mov	r0, r4
    4fa6:	bd38      	pop	{r3, r4, r5, pc}
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
    4fa8:	4602      	mov	r2, r0
    4faa:	460b      	mov	r3, r1
    4fac:	2001      	movs	r0, #1
    4fae:	f7ff ffcd 	bl	4f4c <bt_buf_get_rx>
    4fb2:	4604      	mov	r4, r0
    4fb4:	e7f6      	b.n	4fa4 <bt_buf_get_cmd_complete+0x38>
    4fb6:	bf00      	nop
    4fb8:	20000000 	.word	0x20000000

00004fbc <bt_buf_get_evt>:

struct net_buf *bt_buf_get_evt(u8_t evt, bool discardable, k_timeout_t timeout)
{
    4fbc:	b510      	push	{r4, lr}
	switch (evt) {
    4fbe:	f1a0 040e 	sub.w	r4, r0, #14
    4fc2:	2c01      	cmp	r4, #1
    4fc4:	d906      	bls.n	4fd4 <bt_buf_get_evt+0x18>
	case BT_HCI_EVT_CMD_COMPLETE:
	case BT_HCI_EVT_CMD_STATUS:
		return bt_buf_get_cmd_complete(timeout);
	default:
#if defined(CONFIG_BT_DISCARDABLE_BUF_COUNT)
		if (discardable) {
    4fc6:	b959      	cbnz	r1, 4fe0 <bt_buf_get_evt+0x24>

			return buf;
		}
#endif /* CONFIG_BT_DISCARDABLE_BUF_COUNT */

		return bt_buf_get_rx(BT_BUF_EVT, timeout);
    4fc8:	2001      	movs	r0, #1
    4fca:	f7ff ffbf 	bl	4f4c <bt_buf_get_rx>
    4fce:	4604      	mov	r4, r0
	}
}
    4fd0:	4620      	mov	r0, r4
    4fd2:	bd10      	pop	{r4, pc}
		return bt_buf_get_cmd_complete(timeout);
    4fd4:	4610      	mov	r0, r2
    4fd6:	4619      	mov	r1, r3
    4fd8:	f7ff ffc8 	bl	4f6c <bt_buf_get_cmd_complete>
    4fdc:	4604      	mov	r4, r0
    4fde:	e7f7      	b.n	4fd0 <bt_buf_get_evt+0x14>
			buf = net_buf_alloc(&discardable_pool, timeout);
    4fe0:	4806      	ldr	r0, [pc, #24]	; (4ffc <bt_buf_get_evt+0x40>)
    4fe2:	f00a fafe 	bl	f5e2 <net_buf_alloc_fixed>
			if (buf) {
    4fe6:	4604      	mov	r4, r0
    4fe8:	2800      	cmp	r0, #0
    4fea:	d0f1      	beq.n	4fd0 <bt_buf_get_evt+0x14>
				net_buf_reserve(buf, BT_BUF_RESERVE);
    4fec:	2100      	movs	r1, #0
    4fee:	3008      	adds	r0, #8
    4ff0:	f00a fb19 	bl	f626 <net_buf_simple_reserve>
    4ff4:	2301      	movs	r3, #1
    4ff6:	7523      	strb	r3, [r4, #20]
			return buf;
    4ff8:	e7ea      	b.n	4fd0 <bt_buf_get_evt+0x14>
    4ffa:	bf00      	nop
    4ffc:	20000500 	.word	0x20000500

00005000 <dequeue>:
	return 0;
}

static void dequeue(u8_t callee_id, u8_t caller_id, memq_link_t *link,
		    struct mayfly *m)
{
    5000:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5002:	4616      	mov	r6, r2
    5004:	461c      	mov	r4, r3
	u8_t req;

	req = m->_req;
    5006:	781b      	ldrb	r3, [r3, #0]
    5008:	b2df      	uxtb	r7, r3
	if (((req - m->_ack) & 0x03) != 1U) {
    500a:	7862      	ldrb	r2, [r4, #1]
    500c:	1a9b      	subs	r3, r3, r2
    500e:	f003 0303 	and.w	r3, r3, #3
    5012:	2b01      	cmp	r3, #1
    5014:	d100      	bne.n	5018 <dequeue+0x18>

			m->_ack = ack;
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
		}
	}
}
    5016:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5018:	4605      	mov	r5, r0
		memq_dequeue(mft[callee_id][caller_id].tail,
    501a:	f8df c048 	ldr.w	ip, [pc, #72]	; 5064 <dequeue+0x64>
    501e:	eb01 0341 	add.w	r3, r1, r1, lsl #1
    5022:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    5026:	0100      	lsls	r0, r0, #4
    5028:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    502c:	4603      	mov	r3, r0
    502e:	4463      	add	r3, ip
    5030:	2200      	movs	r2, #0
    5032:	4619      	mov	r1, r3
    5034:	6858      	ldr	r0, [r3, #4]
    5036:	f009 f98f 	bl	e358 <memq_dequeue>
		m->_link = link;
    503a:	6066      	str	r6, [r4, #4]
		ack = m->_ack;
    503c:	7862      	ldrb	r2, [r4, #1]
		m->_ack = req;
    503e:	7067      	strb	r7, [r4, #1]
		if (((m->_req - ack) & 0x03) == 1U) {
    5040:	7823      	ldrb	r3, [r4, #0]
    5042:	1a9b      	subs	r3, r3, r2
    5044:	f003 0303 	and.w	r3, r3, #3
    5048:	2b01      	cmp	r3, #1
    504a:	d1e4      	bne.n	5016 <dequeue+0x16>
			m->_ack = ack;
    504c:	7062      	strb	r2, [r4, #1]
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
    504e:	ebc5 1505 	rsb	r5, r5, r5, lsl #4
    5052:	4a04      	ldr	r2, [pc, #16]	; (5064 <dequeue+0x64>)
    5054:	eb02 0285 	add.w	r2, r2, r5, lsl #2
    5058:	3204      	adds	r2, #4
    505a:	4621      	mov	r1, r4
    505c:	4630      	mov	r0, r6
    505e:	f009 f96b 	bl	e338 <memq_enqueue>
}
    5062:	e7d8      	b.n	5016 <dequeue+0x16>
    5064:	20003f5c 	.word	0x20003f5c

00005068 <mayfly_init>:
{
    5068:	b538      	push	{r3, r4, r5, lr}
	callee_id = MAYFLY_CALLEE_COUNT;
    506a:	2504      	movs	r5, #4
	while (callee_id--) {
    506c:	e015      	b.n	509a <mayfly_init+0x32>
			memq_init(&mfl[callee_id][caller_id],
    506e:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    5072:	0099      	lsls	r1, r3, #2
    5074:	eb05 0245 	add.w	r2, r5, r5, lsl #1
    5078:	0113      	lsls	r3, r2, #4
    507a:	440b      	add	r3, r1
    507c:	490a      	ldr	r1, [pc, #40]	; (50a8 <mayfly_init+0x40>)
    507e:	4419      	add	r1, r3
    5080:	eb04 0085 	add.w	r0, r4, r5, lsl #2
    5084:	1d0a      	adds	r2, r1, #4
    5086:	4b09      	ldr	r3, [pc, #36]	; (50ac <mayfly_init+0x44>)
    5088:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    508c:	f009 f951 	bl	e332 <memq_init>
		while (caller_id--) {
    5090:	4623      	mov	r3, r4
    5092:	1e5c      	subs	r4, r3, #1
    5094:	b2e4      	uxtb	r4, r4
    5096:	2b00      	cmp	r3, #0
    5098:	d1e9      	bne.n	506e <mayfly_init+0x6>
	while (callee_id--) {
    509a:	462b      	mov	r3, r5
    509c:	3d01      	subs	r5, #1
    509e:	b2ed      	uxtb	r5, r5
    50a0:	b10b      	cbz	r3, 50a6 <mayfly_init+0x3e>
		caller_id = MAYFLY_CALLER_COUNT;
    50a2:	2304      	movs	r3, #4
    50a4:	e7f5      	b.n	5092 <mayfly_init+0x2a>
}
    50a6:	bd38      	pop	{r3, r4, r5, pc}
    50a8:	20003f5c 	.word	0x20003f5c
    50ac:	20003ed8 	.word	0x20003ed8

000050b0 <mayfly_enqueue>:
{
    50b0:	b570      	push	{r4, r5, r6, lr}
    50b2:	4606      	mov	r6, r0
    50b4:	460d      	mov	r5, r1
    50b6:	461c      	mov	r4, r3
		!mayfly_is_enabled(caller_id, callee_id) ||
    50b8:	b172      	cbz	r2, 50d8 <mayfly_enqueue+0x28>
    50ba:	2101      	movs	r1, #1
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
    50bc:	b2c9      	uxtb	r1, r1
	ack = m->_ack;
    50be:	7862      	ldrb	r2, [r4, #1]
	state = (m->_req - ack) & 0x03;
    50c0:	7823      	ldrb	r3, [r4, #0]
    50c2:	1a9b      	subs	r3, r3, r2
	if (state != 0U) {
    50c4:	f013 0303 	ands.w	r3, r3, #3
    50c8:	d02e      	beq.n	5128 <mayfly_enqueue+0x78>
		if (chain) {
    50ca:	b351      	cbz	r1, 5122 <mayfly_enqueue+0x72>
			if (state != 1U) {
    50cc:	2b01      	cmp	r3, #1
    50ce:	d04b      	beq.n	5168 <mayfly_enqueue+0xb8>
				m->_req = ack + 1;
    50d0:	3201      	adds	r2, #1
    50d2:	b2d2      	uxtb	r2, r2
    50d4:	7022      	strb	r2, [r4, #0]
				goto mayfly_enqueue_pend;
    50d6:	e03e      	b.n	5156 <mayfly_enqueue+0xa6>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
    50d8:	f00a f8c2 	bl	f260 <mayfly_prio_is_equal>
    50dc:	b908      	cbnz	r0, 50e2 <mayfly_enqueue+0x32>
		!mayfly_is_enabled(caller_id, callee_id) ||
    50de:	2101      	movs	r1, #1
    50e0:	e7ec      	b.n	50bc <mayfly_enqueue+0xc>
    50e2:	4629      	mov	r1, r5
    50e4:	4630      	mov	r0, r6
    50e6:	f003 fddd 	bl	8ca4 <mayfly_is_enabled>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
    50ea:	b1c0      	cbz	r0, 511e <mayfly_enqueue+0x6e>
		(mft[callee_id][caller_id].disable_req !=
    50ec:	491f      	ldr	r1, [pc, #124]	; (516c <mayfly_enqueue+0xbc>)
    50ee:	eb06 0346 	add.w	r3, r6, r6, lsl #1
    50f2:	eb05 0245 	add.w	r2, r5, r5, lsl #1
    50f6:	0112      	lsls	r2, r2, #4
    50f8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    50fc:	440b      	add	r3, r1
    50fe:	7a98      	ldrb	r0, [r3, #10]
		 mft[callee_id][caller_id].disable_ack);
    5100:	eb06 0346 	add.w	r3, r6, r6, lsl #1
    5104:	eb05 0245 	add.w	r2, r5, r5, lsl #1
    5108:	0112      	lsls	r2, r2, #4
    510a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    510e:	440b      	add	r3, r1
    5110:	7adb      	ldrb	r3, [r3, #11]
		!mayfly_is_enabled(caller_id, callee_id) ||
    5112:	4298      	cmp	r0, r3
    5114:	d001      	beq.n	511a <mayfly_enqueue+0x6a>
    5116:	2101      	movs	r1, #1
    5118:	e7d0      	b.n	50bc <mayfly_enqueue+0xc>
    511a:	2100      	movs	r1, #0
    511c:	e7ce      	b.n	50bc <mayfly_enqueue+0xc>
    511e:	2101      	movs	r1, #1
    5120:	e7cc      	b.n	50bc <mayfly_enqueue+0xc>
		m->_req = ack + 2;
    5122:	1c93      	adds	r3, r2, #2
    5124:	b2db      	uxtb	r3, r3
    5126:	7023      	strb	r3, [r4, #0]
	if (!chain) {
    5128:	b921      	cbnz	r1, 5134 <mayfly_enqueue+0x84>
		m->fp(m->param);
    512a:	68e3      	ldr	r3, [r4, #12]
    512c:	68a0      	ldr	r0, [r4, #8]
    512e:	4798      	blx	r3
		return 0;
    5130:	2000      	movs	r0, #0
    5132:	e018      	b.n	5166 <mayfly_enqueue+0xb6>
	m->_req = ack + 1;
    5134:	3201      	adds	r2, #1
    5136:	b2d2      	uxtb	r2, r2
    5138:	7022      	strb	r2, [r4, #0]
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
    513a:	eb06 0246 	add.w	r2, r6, r6, lsl #1
    513e:	eb05 0345 	add.w	r3, r5, r5, lsl #1
    5142:	011b      	lsls	r3, r3, #4
    5144:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    5148:	4b08      	ldr	r3, [pc, #32]	; (516c <mayfly_enqueue+0xbc>)
    514a:	441a      	add	r2, r3
    514c:	3204      	adds	r2, #4
    514e:	4621      	mov	r1, r4
    5150:	6860      	ldr	r0, [r4, #4]
    5152:	f009 f8f1 	bl	e338 <memq_enqueue>
	mfp[callee_id] = 1U;
    5156:	4b06      	ldr	r3, [pc, #24]	; (5170 <mayfly_enqueue+0xc0>)
    5158:	2201      	movs	r2, #1
    515a:	555a      	strb	r2, [r3, r5]
	mayfly_pend(caller_id, callee_id);
    515c:	4629      	mov	r1, r5
    515e:	4630      	mov	r0, r6
    5160:	f003 fdc6 	bl	8cf0 <mayfly_pend>
	return 0;
    5164:	2000      	movs	r0, #0
}
    5166:	bd70      	pop	{r4, r5, r6, pc}
			return 1;
    5168:	2001      	movs	r0, #1
    516a:	e7fc      	b.n	5166 <mayfly_enqueue+0xb6>
    516c:	20003f5c 	.word	0x20003f5c
    5170:	20003f58 	.word	0x20003f58

00005174 <mayfly_run>:
{
	u8_t disable = 0U;
	u8_t enable = 0U;
	u8_t caller_id;

	if (!mfp[callee_id]) {
    5174:	4b4f      	ldr	r3, [pc, #316]	; (52b4 <mayfly_run+0x140>)
    5176:	5c1b      	ldrb	r3, [r3, r0]
    5178:	2b00      	cmp	r3, #0
    517a:	f000 8099 	beq.w	52b0 <mayfly_run+0x13c>
{
    517e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5182:	b083      	sub	sp, #12
    5184:	4680      	mov	r8, r0
    5186:	4605      	mov	r5, r0
		return;
	}
	mfp[callee_id] = 0U;
    5188:	f04f 0900 	mov.w	r9, #0
    518c:	4b49      	ldr	r3, [pc, #292]	; (52b4 <mayfly_run+0x140>)
    518e:	f803 9000 	strb.w	r9, [r3, r0]

	/* iterate through each caller queue to this callee_id */
	caller_id = MAYFLY_CALLER_COUNT;
    5192:	2304      	movs	r3, #4
	u8_t enable = 0U;
    5194:	46ca      	mov	sl, r9
	while (caller_id--) {
    5196:	1e5f      	subs	r7, r3, #1
    5198:	b2ff      	uxtb	r7, r7
    519a:	2b00      	cmp	r3, #0
    519c:	d07c      	beq.n	5298 <mayfly_run+0x124>
		memq_link_t *link;
		struct mayfly *m = 0;
    519e:	2300      	movs	r3, #0
    51a0:	9301      	str	r3, [sp, #4]

		/* fetch mayfly in callee queue, if any */
		link = memq_peek(mft[callee_id][caller_id].head,
    51a2:	463e      	mov	r6, r7
    51a4:	4844      	ldr	r0, [pc, #272]	; (52b8 <mayfly_run+0x144>)
    51a6:	eb07 0347 	add.w	r3, r7, r7, lsl #1
    51aa:	eb05 0245 	add.w	r2, r5, r5, lsl #1
    51ae:	0112      	lsls	r2, r2, #4
    51b0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    51b4:	18c1      	adds	r1, r0, r3
    51b6:	aa01      	add	r2, sp, #4
    51b8:	6849      	ldr	r1, [r1, #4]
    51ba:	58c0      	ldr	r0, [r0, r3]
    51bc:	f009 f8c4 	bl	e348 <memq_peek>
    51c0:	4683      	mov	fp, r0
				 mft[callee_id][caller_id].tail,
				 (void **)&m);
		while (link) {
    51c2:	f1bb 0f00 	cmp.w	fp, #0
    51c6:	d033      	beq.n	5230 <mayfly_run+0xbc>
#if defined(MAYFLY_UT)
			_state = 0U;
#endif /* MAYFLY_UT */

			/* execute work if ready */
			state = (m->_req - m->_ack) & 0x03;
    51c8:	9b01      	ldr	r3, [sp, #4]
    51ca:	781c      	ldrb	r4, [r3, #0]
    51cc:	785a      	ldrb	r2, [r3, #1]
    51ce:	1aa4      	subs	r4, r4, r2
    51d0:	f004 0403 	and.w	r4, r4, #3
			if (state == 1U) {
    51d4:	2c01      	cmp	r4, #1
    51d6:	d024      	beq.n	5222 <mayfly_run+0xae>
				/* call the mayfly function */
				m->fp(m->param);
			}

			/* dequeue if not re-pended */
			dequeue(callee_id, caller_id, link, m);
    51d8:	9b01      	ldr	r3, [sp, #4]
    51da:	465a      	mov	r2, fp
    51dc:	4639      	mov	r1, r7
    51de:	4640      	mov	r0, r8
    51e0:	f7ff ff0e 	bl	5000 <dequeue>

			/* fetch next mayfly in callee queue, if any */
			link = memq_peek(mft[callee_id][caller_id].head,
    51e4:	4834      	ldr	r0, [pc, #208]	; (52b8 <mayfly_run+0x144>)
    51e6:	eb06 0346 	add.w	r3, r6, r6, lsl #1
    51ea:	eb05 0245 	add.w	r2, r5, r5, lsl #1
    51ee:	0112      	lsls	r2, r2, #4
    51f0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    51f4:	18c1      	adds	r1, r0, r3
    51f6:	aa01      	add	r2, sp, #4
    51f8:	6849      	ldr	r1, [r1, #4]
    51fa:	58c0      	ldr	r0, [r0, r3]
    51fc:	f009 f8a4 	bl	e348 <memq_peek>
    5200:	4683      	mov	fp, r0
 */
#if defined(CONFIG_BT_MAYFLY_YIELD_AFTER_CALL)
			/* yield out of mayfly_run if a mayfly function was
			 * called.
			 */
			if (state == 1U) {
    5202:	2c01      	cmp	r4, #1
    5204:	d1dd      	bne.n	51c2 <mayfly_run+0x4e>
				/* pend callee (tailchain) if mayfly queue is
				 * not empty or all caller queues are not
				 * processed.
				 */
				if (caller_id || link) {
    5206:	b90f      	cbnz	r7, 520c <mayfly_run+0x98>
    5208:	2800      	cmp	r0, #0
    520a:	d0da      	beq.n	51c2 <mayfly_run+0x4e>
					/* set mayfly callee pending */
					mfp[callee_id] = 1U;
    520c:	4b29      	ldr	r3, [pc, #164]	; (52b4 <mayfly_run+0x140>)
    520e:	2201      	movs	r2, #1
    5210:	f803 2008 	strb.w	r2, [r3, r8]

					/* pend the callee for execution */
					mayfly_pend(callee_id, callee_id);
    5214:	4641      	mov	r1, r8
    5216:	4640      	mov	r0, r8
    5218:	f003 fd6a 	bl	8cf0 <mayfly_pend>
	}

	if (disable && !enable) {
		mayfly_enable_cb(callee_id, callee_id, 0);
	}
}
    521c:	b003      	add	sp, #12
    521e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				m->_ack--;
    5222:	3a01      	subs	r2, #1
    5224:	705a      	strb	r2, [r3, #1]
				m->fp(m->param);
    5226:	9b01      	ldr	r3, [sp, #4]
    5228:	68da      	ldr	r2, [r3, #12]
    522a:	6898      	ldr	r0, [r3, #8]
    522c:	4790      	blx	r2
    522e:	e7d3      	b.n	51d8 <mayfly_run+0x64>
		if (mft[callee_id][caller_id].disable_req !=
    5230:	eb07 0347 	add.w	r3, r7, r7, lsl #1
    5234:	eb05 0245 	add.w	r2, r5, r5, lsl #1
    5238:	0112      	lsls	r2, r2, #4
    523a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    523e:	4a1e      	ldr	r2, [pc, #120]	; (52b8 <mayfly_run+0x144>)
    5240:	4413      	add	r3, r2
    5242:	7a99      	ldrb	r1, [r3, #10]
		    mft[callee_id][caller_id].disable_ack) {
    5244:	7adb      	ldrb	r3, [r3, #11]
		if (mft[callee_id][caller_id].disable_req !=
    5246:	4299      	cmp	r1, r3
    5248:	d00b      	beq.n	5262 <mayfly_run+0xee>
			mft[callee_id][caller_id].disable_ack =
    524a:	eb07 0347 	add.w	r3, r7, r7, lsl #1
    524e:	eb05 0245 	add.w	r2, r5, r5, lsl #1
    5252:	0112      	lsls	r2, r2, #4
    5254:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    5258:	4a17      	ldr	r2, [pc, #92]	; (52b8 <mayfly_run+0x144>)
    525a:	4413      	add	r3, r2
    525c:	72d9      	strb	r1, [r3, #11]
			disable = 1U;
    525e:	f04f 0901 	mov.w	r9, #1
		if (mft[callee_id][caller_id].enable_req !=
    5262:	eb07 0347 	add.w	r3, r7, r7, lsl #1
    5266:	eb05 0245 	add.w	r2, r5, r5, lsl #1
    526a:	0112      	lsls	r2, r2, #4
    526c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    5270:	4a11      	ldr	r2, [pc, #68]	; (52b8 <mayfly_run+0x144>)
    5272:	4413      	add	r3, r2
    5274:	7a19      	ldrb	r1, [r3, #8]
		    mft[callee_id][caller_id].enable_ack) {
    5276:	7a5b      	ldrb	r3, [r3, #9]
		if (mft[callee_id][caller_id].enable_req !=
    5278:	4299      	cmp	r1, r3
    527a:	d00b      	beq.n	5294 <mayfly_run+0x120>
			mft[callee_id][caller_id].enable_ack =
    527c:	eb07 0347 	add.w	r3, r7, r7, lsl #1
    5280:	eb05 0245 	add.w	r2, r5, r5, lsl #1
    5284:	0112      	lsls	r2, r2, #4
    5286:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    528a:	4a0b      	ldr	r2, [pc, #44]	; (52b8 <mayfly_run+0x144>)
    528c:	4413      	add	r3, r2
    528e:	7259      	strb	r1, [r3, #9]
			enable = 1U;
    5290:	f04f 0a01 	mov.w	sl, #1
	while (caller_id--) {
    5294:	463b      	mov	r3, r7
    5296:	e77e      	b.n	5196 <mayfly_run+0x22>
	if (disable && !enable) {
    5298:	f1b9 0f00 	cmp.w	r9, #0
    529c:	d0be      	beq.n	521c <mayfly_run+0xa8>
    529e:	f1ba 0f00 	cmp.w	sl, #0
    52a2:	d1bb      	bne.n	521c <mayfly_run+0xa8>
		mayfly_enable_cb(callee_id, callee_id, 0);
    52a4:	2200      	movs	r2, #0
    52a6:	4641      	mov	r1, r8
    52a8:	4640      	mov	r0, r8
    52aa:	f003 fcdb 	bl	8c64 <mayfly_enable_cb>
    52ae:	e7b5      	b.n	521c <mayfly_run+0xa8>
    52b0:	4770      	bx	lr
    52b2:	bf00      	nop
    52b4:	20003f58 	.word	0x20003f58
    52b8:	20003f5c 	.word	0x20003f5c

000052bc <ticker_remainder_inc>:
 * @internal
 */
static u8_t ticker_remainder_inc(struct ticker_node *ticker)
{
#ifdef HAL_TICKER_REMAINDER_RANGE
	ticker->remainder_current += ticker->remainder_periodic;
    52bc:	6a03      	ldr	r3, [r0, #32]
    52be:	6a42      	ldr	r2, [r0, #36]	; 0x24
    52c0:	4413      	add	r3, r2
    52c2:	6243      	str	r3, [r0, #36]	; 0x24
	if ((ticker->remainder_current < BIT(31)) &&
    52c4:	4a05      	ldr	r2, [pc, #20]	; (52dc <ticker_remainder_inc+0x20>)
    52c6:	441a      	add	r2, r3
    52c8:	4905      	ldr	r1, [pc, #20]	; (52e0 <ticker_remainder_inc+0x24>)
    52ca:	428a      	cmp	r2, r1
    52cc:	d901      	bls.n	52d2 <ticker_remainder_inc+0x16>
	    (ticker->remainder_current > (HAL_TICKER_REMAINDER_RANGE >> 1))) {
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
		return 1;
	}
	return 0;
    52ce:	2000      	movs	r0, #0
#else
	return 0;
#endif
}
    52d0:	4770      	bx	lr
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    52d2:	4a04      	ldr	r2, [pc, #16]	; (52e4 <ticker_remainder_inc+0x28>)
    52d4:	441a      	add	r2, r3
    52d6:	6242      	str	r2, [r0, #36]	; 0x24
		return 1;
    52d8:	2001      	movs	r0, #1
    52da:	4770      	bx	lr
    52dc:	ff172b5a 	.word	0xff172b5a
    52e0:	7f172b59 	.word	0x7f172b59
    52e4:	fe2e56b6 	.word	0xfe2e56b6

000052e8 <ticker_remainder_dec>:
 *
 * @return Returns 1 to indicate decrement is due, otherwise 0
 * @internal
 */
static u8_t ticker_remainder_dec(struct ticker_node *ticker)
{
    52e8:	4603      	mov	r3, r0
#ifdef HAL_TICKER_REMAINDER_RANGE
	u8_t decrement = 0U;

	if ((ticker->remainder_current >= BIT(31)) ||
    52ea:	6a41      	ldr	r1, [r0, #36]	; 0x24
    52ec:	4a07      	ldr	r2, [pc, #28]	; (530c <ticker_remainder_dec+0x24>)
    52ee:	440a      	add	r2, r1
    52f0:	4807      	ldr	r0, [pc, #28]	; (5310 <ticker_remainder_dec+0x28>)
    52f2:	4282      	cmp	r2, r0
    52f4:	d908      	bls.n	5308 <ticker_remainder_dec+0x20>
	    (ticker->remainder_current <= (HAL_TICKER_REMAINDER_RANGE >> 1))) {
		decrement++;
		ticker->remainder_current += HAL_TICKER_REMAINDER_RANGE;
    52f6:	4a07      	ldr	r2, [pc, #28]	; (5314 <ticker_remainder_dec+0x2c>)
    52f8:	440a      	add	r2, r1
    52fa:	625a      	str	r2, [r3, #36]	; 0x24
		decrement++;
    52fc:	2001      	movs	r0, #1
	}
	ticker->remainder_current -= ticker->remainder_periodic;
    52fe:	6a19      	ldr	r1, [r3, #32]
    5300:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    5302:	1a52      	subs	r2, r2, r1
    5304:	625a      	str	r2, [r3, #36]	; 0x24
	return decrement;
#else
	return 0;
#endif
}
    5306:	4770      	bx	lr
	u8_t decrement = 0U;
    5308:	2000      	movs	r0, #0
    530a:	e7f8      	b.n	52fe <ticker_remainder_dec+0x16>
    530c:	ff172b5a 	.word	0xff172b5a
    5310:	7f172b59 	.word	0x7f172b59
    5314:	01d1a94a 	.word	0x01d1a94a

00005318 <ticker_init>:
u32_t ticker_init(u8_t instance_index, u8_t count_node, void *node,
		  u8_t count_user, void *user, u8_t count_op, void *user_op,
		  ticker_caller_id_get_cb_t caller_id_get_cb,
		  ticker_sched_cb_t sched_cb,
		  ticker_trigger_set_cb_t trigger_set_cb)
{
    5318:	b5f0      	push	{r4, r5, r6, r7, lr}
    531a:	9f05      	ldr	r7, [sp, #20]
    531c:	f89d 6018 	ldrb.w	r6, [sp, #24]
    5320:	9d07      	ldr	r5, [sp, #28]
	struct ticker_instance *instance = &_instance[instance_index];
	struct ticker_user_op *user_op_ = (void *)user_op;
	struct ticker_user *users;

	if (instance_index >= TICKER_INSTANCE_MAX) {
    5322:	2800      	cmp	r0, #0
    5324:	d149      	bne.n	53ba <ticker_init+0xa2>
    5326:	461c      	mov	r4, r3
    5328:	4684      	mov	ip, r0
		return TICKER_STATUS_FAILURE;
	}

	instance->count_node = count_node;
    532a:	4826      	ldr	r0, [pc, #152]	; (53c4 <ticker_init+0xac>)
    532c:	232c      	movs	r3, #44	; 0x2c
    532e:	fb03 f30c 	mul.w	r3, r3, ip
    5332:	eb00 0e03 	add.w	lr, r0, r3
    5336:	f88e 1008 	strb.w	r1, [lr, #8]
	instance->nodes = node;
    533a:	50c2      	str	r2, [r0, r3]

#if !defined(CONFIG_BT_TICKER_COMPATIBILITY_MODE)
	while (count_node--) {
    533c:	1e48      	subs	r0, r1, #1
    533e:	b2c0      	uxtb	r0, r0
    5340:	b141      	cbz	r1, 5354 <ticker_init+0x3c>
		instance->nodes[count_node].priority = 0;
    5342:	eb00 0140 	add.w	r1, r0, r0, lsl #1
    5346:	eb02 1101 	add.w	r1, r2, r1, lsl #4
    534a:	2300      	movs	r3, #0
    534c:	f881 302d 	strb.w	r3, [r1, #45]	; 0x2d
	while (count_node--) {
    5350:	4601      	mov	r1, r0
    5352:	e7f3      	b.n	533c <ticker_init+0x24>
	}
#endif /* !CONFIG_BT_TICKER_COMPATIBILITY_MODE */

	instance->count_user = count_user;
    5354:	4a1b      	ldr	r2, [pc, #108]	; (53c4 <ticker_init+0xac>)
    5356:	232c      	movs	r3, #44	; 0x2c
    5358:	fb03 230c 	mla	r3, r3, ip, r2
    535c:	725c      	strb	r4, [r3, #9]
	instance->users = user;
    535e:	605f      	str	r7, [r3, #4]

	/** @todo check if enough ticker_user_op supplied */

	users = &instance->users[0];
	while (count_user--) {
    5360:	e00a      	b.n	5378 <ticker_init+0x60>
		users[count_user].user_op = user_op_;
    5362:	eb07 03c2 	add.w	r3, r7, r2, lsl #3
    5366:	605d      	str	r5, [r3, #4]
		user_op_ += users[count_user].count_user_op;
    5368:	f817 3032 	ldrb.w	r3, [r7, r2, lsl #3]
    536c:	2134      	movs	r1, #52	; 0x34
    536e:	fb01 5503 	mla	r5, r1, r3, r5
		count_op -= users[count_user].count_user_op;
    5372:	1af3      	subs	r3, r6, r3
    5374:	b2de      	uxtb	r6, r3
	while (count_user--) {
    5376:	4614      	mov	r4, r2
    5378:	1e62      	subs	r2, r4, #1
    537a:	b2d2      	uxtb	r2, r2
    537c:	2c00      	cmp	r4, #0
    537e:	d1f0      	bne.n	5362 <ticker_init+0x4a>
	}

	if (count_op) {
    5380:	b9ee      	cbnz	r6, 53be <ticker_init+0xa6>
		return TICKER_STATUS_FAILURE;
	}

	instance->caller_id_get_cb = caller_id_get_cb;
    5382:	4b10      	ldr	r3, [pc, #64]	; (53c4 <ticker_init+0xac>)
    5384:	222c      	movs	r2, #44	; 0x2c
    5386:	fb02 3c0c 	mla	ip, r2, ip, r3
    538a:	9b08      	ldr	r3, [sp, #32]
    538c:	f8cc 3020 	str.w	r3, [ip, #32]
	instance->sched_cb = sched_cb;
    5390:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5392:	f8cc 3024 	str.w	r3, [ip, #36]	; 0x24
	instance->trigger_set_cb = trigger_set_cb;
    5396:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5398:	f8cc 3028 	str.w	r3, [ip, #40]	; 0x28

	instance->ticker_id_head = TICKER_NULL;
    539c:	23ff      	movs	r3, #255	; 0xff
    539e:	f88c 301d 	strb.w	r3, [ip, #29]
	instance->ticker_id_slot_previous = TICKER_NULL;
    53a2:	f88c 301c 	strb.w	r3, [ip, #28]
	instance->ticks_slot_previous = 0U;
    53a6:	2000      	movs	r0, #0
    53a8:	f8cc 0018 	str.w	r0, [ip, #24]
	instance->ticks_current = 0U;
    53ac:	f8cc 0014 	str.w	r0, [ip, #20]
	instance->ticks_elapsed_first = 0U;
    53b0:	f88c 000a 	strb.w	r0, [ip, #10]
	instance->ticks_elapsed_last = 0U;
    53b4:	f88c 000b 	strb.w	r0, [ip, #11]

	return TICKER_STATUS_SUCCESS;
}
    53b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return TICKER_STATUS_FAILURE;
    53ba:	2001      	movs	r0, #1
    53bc:	e7fc      	b.n	53b8 <ticker_init+0xa0>
		return TICKER_STATUS_FAILURE;
    53be:	2001      	movs	r0, #1
    53c0:	e7fa      	b.n	53b8 <ticker_init+0xa0>
    53c2:	bf00      	nop
    53c4:	2000401c 	.word	0x2000401c

000053c8 <ticker_trigger>:
 * corresponding mayfly.
 *
 * @param instance_index Index of ticker instance
 */
void ticker_trigger(u8_t instance_index)
{
    53c8:	b510      	push	{r4, lr}
	struct ticker_instance *instance;

	DEBUG_TICKER_ISR(1);

	instance = &_instance[instance_index];
    53ca:	4b05      	ldr	r3, [pc, #20]	; (53e0 <ticker_trigger+0x18>)
    53cc:	222c      	movs	r2, #44	; 0x2c
    53ce:	fb02 3300 	mla	r3, r2, r0, r3
	if (instance->sched_cb) {
    53d2:	6a5c      	ldr	r4, [r3, #36]	; 0x24
    53d4:	b11c      	cbz	r4, 53de <ticker_trigger+0x16>
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
    53d6:	2201      	movs	r2, #1
    53d8:	2103      	movs	r1, #3
    53da:	2002      	movs	r0, #2
    53dc:	47a0      	blx	r4
				   TICKER_CALL_ID_WORKER, 1, instance);
	}

	DEBUG_TICKER_ISR(0);
}
    53de:	bd10      	pop	{r4, pc}
    53e0:	2000401c 	.word	0x2000401c

000053e4 <ticker_start_ext>:
		   u32_t ticks_anchor, u32_t ticks_first, u32_t ticks_periodic,
		   u32_t remainder_periodic, u16_t lazy, u32_t ticks_slot,
		   ticker_timeout_func fp_timeout_func, void *context,
		   ticker_op_func fp_op_func, void *op_context)
#endif
{
    53e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    53e8:	4606      	mov	r6, r0
    53ea:	4608      	mov	r0, r1
	struct ticker_instance *instance = &_instance[instance_index];
    53ec:	4925      	ldr	r1, [pc, #148]	; (5484 <ticker_start_ext+0xa0>)
    53ee:	272c      	movs	r7, #44	; 0x2c
    53f0:	fb07 1706 	mla	r7, r7, r6, r1
	struct ticker_user_op *user_op;
	struct ticker_user *user;
	u8_t last;

	user = &instance->users[user_id];
    53f4:	687c      	ldr	r4, [r7, #4]
    53f6:	eb04 01c0 	add.w	r1, r4, r0, lsl #3

	last = user->last + 1;
    53fa:	f891 8003 	ldrb.w	r8, [r1, #3]
    53fe:	f991 5003 	ldrsb.w	r5, [r1, #3]
    5402:	3501      	adds	r5, #1
    5404:	b2ed      	uxtb	r5, r5
	if (last >= user->count_user_op) {
    5406:	f814 4030 	ldrb.w	r4, [r4, r0, lsl #3]
    540a:	42ac      	cmp	r4, r5
    540c:	d800      	bhi.n	5410 <ticker_start_ext+0x2c>
		last = 0U;
    540e:	2500      	movs	r5, #0
	}

	if (last == user->first) {
    5410:	784c      	ldrb	r4, [r1, #1]
    5412:	42ac      	cmp	r4, r5
    5414:	d033      	beq.n	547e <ticker_start_ext+0x9a>
		return TICKER_STATUS_FAILURE;
	}

	user_op = &user->user_op[user->last];
    5416:	f8d1 e004 	ldr.w	lr, [r1, #4]
    541a:	f04f 0c34 	mov.w	ip, #52	; 0x34
    541e:	fb0c fc08 	mul.w	ip, ip, r8
    5422:	eb0e 040c 	add.w	r4, lr, ip
	user_op->op = TICKER_USER_OP_TYPE_START;
    5426:	f04f 0804 	mov.w	r8, #4
    542a:	f80e 800c 	strb.w	r8, [lr, ip]
	user_op->id = ticker_id;
    542e:	7062      	strb	r2, [r4, #1]
	user_op->params.start.ticks_at_start = ticks_anchor;
    5430:	6063      	str	r3, [r4, #4]
	user_op->params.start.ticks_first = ticks_first;
    5432:	9b06      	ldr	r3, [sp, #24]
    5434:	60a3      	str	r3, [r4, #8]
	user_op->params.start.ticks_periodic = ticks_periodic;
    5436:	9b07      	ldr	r3, [sp, #28]
    5438:	60e3      	str	r3, [r4, #12]
	user_op->params.start.remainder_periodic = remainder_periodic;
    543a:	9b08      	ldr	r3, [sp, #32]
    543c:	6123      	str	r3, [r4, #16]
	user_op->params.start.ticks_slot = ticks_slot;
    543e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5440:	61a3      	str	r3, [r4, #24]
	user_op->params.start.lazy = lazy;
    5442:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    5446:	82a3      	strh	r3, [r4, #20]
#if defined(CONFIG_BT_TICKER_EXT)
	user_op->params.start.ext_data = ext_data;
    5448:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    544a:	6263      	str	r3, [r4, #36]	; 0x24
#endif
	user_op->params.start.fp_timeout_func = fp_timeout_func;
    544c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    544e:	61e3      	str	r3, [r4, #28]
	user_op->params.start.context = context;
    5450:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5452:	6223      	str	r3, [r4, #32]
	user_op->status = TICKER_STATUS_BUSY;
    5454:	2302      	movs	r3, #2
    5456:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->fp_op_func = fp_op_func;
    5458:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    545a:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
    545c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    545e:	6323      	str	r3, [r4, #48]	; 0x30

	user->last = last;
    5460:	70cd      	strb	r5, [r1, #3]

	instance->sched_cb(instance->caller_id_get_cb(user_id),
    5462:	4b08      	ldr	r3, [pc, #32]	; (5484 <ticker_start_ext+0xa0>)
    5464:	222c      	movs	r2, #44	; 0x2c
    5466:	fb02 3306 	mla	r3, r2, r6, r3
    546a:	6a5d      	ldr	r5, [r3, #36]	; 0x24
    546c:	6a1b      	ldr	r3, [r3, #32]
    546e:	4798      	blx	r3
    5470:	463b      	mov	r3, r7
    5472:	2200      	movs	r2, #0
    5474:	4641      	mov	r1, r8
    5476:	47a8      	blx	r5
			   TICKER_CALL_ID_JOB, 0, instance);

	return user_op->status;
    5478:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
    547a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
    547e:	2001      	movs	r0, #1
    5480:	e7fb      	b.n	547a <ticker_start_ext+0x96>
    5482:	bf00      	nop
    5484:	2000401c 	.word	0x2000401c

00005488 <ticker_stop>:
 * available, and TICKER_STATUS_SUCCESS is returned if ticker_job gets to run
 * before exiting ticker_stop
 */
u32_t ticker_stop(u8_t instance_index, u8_t user_id, u8_t ticker_id,
		  ticker_op_func fp_op_func, void *op_context)
{
    5488:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    548c:	4605      	mov	r5, r0
    548e:	4608      	mov	r0, r1
	struct ticker_instance *instance = &_instance[instance_index];
    5490:	491b      	ldr	r1, [pc, #108]	; (5500 <ticker_stop+0x78>)
    5492:	262c      	movs	r6, #44	; 0x2c
    5494:	fb06 1605 	mla	r6, r6, r5, r1
	struct ticker_user_op *user_op;
	struct ticker_user *user;
	u8_t last;

	user = &instance->users[user_id];
    5498:	6877      	ldr	r7, [r6, #4]
    549a:	eb07 01c0 	add.w	r1, r7, r0, lsl #3

	last = user->last + 1;
    549e:	f891 8003 	ldrb.w	r8, [r1, #3]
    54a2:	f991 4003 	ldrsb.w	r4, [r1, #3]
    54a6:	3401      	adds	r4, #1
    54a8:	b2e4      	uxtb	r4, r4
	if (last >= user->count_user_op) {
    54aa:	f817 7030 	ldrb.w	r7, [r7, r0, lsl #3]
    54ae:	42a7      	cmp	r7, r4
    54b0:	d800      	bhi.n	54b4 <ticker_stop+0x2c>
		last = 0U;
    54b2:	2400      	movs	r4, #0
	}

	if (last == user->first) {
    54b4:	784f      	ldrb	r7, [r1, #1]
    54b6:	42a7      	cmp	r7, r4
    54b8:	d020      	beq.n	54fc <ticker_stop+0x74>
		return TICKER_STATUS_FAILURE;
	}

	user_op = &user->user_op[user->last];
    54ba:	f8d1 e004 	ldr.w	lr, [r1, #4]
    54be:	f04f 0c34 	mov.w	ip, #52	; 0x34
    54c2:	fb0c fc08 	mul.w	ip, ip, r8
    54c6:	eb0e 070c 	add.w	r7, lr, ip
	user_op->op = TICKER_USER_OP_TYPE_STOP;
    54ca:	f04f 0806 	mov.w	r8, #6
    54ce:	f80e 800c 	strb.w	r8, [lr, ip]
	user_op->id = ticker_id;
    54d2:	707a      	strb	r2, [r7, #1]
	user_op->status = TICKER_STATUS_BUSY;
    54d4:	2202      	movs	r2, #2
    54d6:	62ba      	str	r2, [r7, #40]	; 0x28
	user_op->fp_op_func = fp_op_func;
    54d8:	62fb      	str	r3, [r7, #44]	; 0x2c
	user_op->op_context = op_context;
    54da:	9b06      	ldr	r3, [sp, #24]
    54dc:	633b      	str	r3, [r7, #48]	; 0x30

	user->last = last;
    54de:	70cc      	strb	r4, [r1, #3]

	instance->sched_cb(instance->caller_id_get_cb(user_id),
    54e0:	4b07      	ldr	r3, [pc, #28]	; (5500 <ticker_stop+0x78>)
    54e2:	222c      	movs	r2, #44	; 0x2c
    54e4:	fb02 3305 	mla	r3, r2, r5, r3
    54e8:	6a5c      	ldr	r4, [r3, #36]	; 0x24
    54ea:	6a1b      	ldr	r3, [r3, #32]
    54ec:	4798      	blx	r3
    54ee:	4633      	mov	r3, r6
    54f0:	2200      	movs	r2, #0
    54f2:	2104      	movs	r1, #4
    54f4:	47a0      	blx	r4
			   TICKER_CALL_ID_JOB, 0, instance);

	return user_op->status;
    54f6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
}
    54f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
    54fc:	2001      	movs	r0, #1
    54fe:	e7fb      	b.n	54f8 <ticker_stop+0x70>
    5500:	2000401c 	.word	0x2000401c

00005504 <ticker_job>:
{
    5504:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5508:	b08d      	sub	sp, #52	; 0x34
	if (instance->worker_trigger) {
    550a:	7fc3      	ldrb	r3, [r0, #31]
    550c:	9303      	str	r3, [sp, #12]
    550e:	2b00      	cmp	r3, #0
    5510:	f040 8345 	bne.w	5b9e <ticker_job+0x69a>
    5514:	4681      	mov	r9, r0
	instance->job_guard = 1U;
    5516:	2301      	movs	r3, #1
    5518:	7783      	strb	r3, [r0, #30]
	ticks_previous = instance->ticks_current;
    551a:	6943      	ldr	r3, [r0, #20]
    551c:	9309      	str	r3, [sp, #36]	; 0x24
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
    551e:	7a83      	ldrb	r3, [r0, #10]
    5520:	7ac2      	ldrb	r2, [r0, #11]
    5522:	4293      	cmp	r3, r2
    5524:	d026      	beq.n	5574 <ticker_job+0x70>
	u8_t idx = *ticks_elapsed_index + 1;
    5526:	b25b      	sxtb	r3, r3
    5528:	3301      	adds	r3, #1
    552a:	b2db      	uxtb	r3, r3
	if (idx == DOUBLE_BUFFER_SIZE) {
    552c:	2b02      	cmp	r3, #2
    552e:	d01f      	beq.n	5570 <ticker_job+0x6c>
	*ticks_elapsed_index = idx;
    5530:	f889 300a 	strb.w	r3, [r9, #10]
		ticks_elapsed =
    5534:	3302      	adds	r3, #2
    5536:	eb09 0383 	add.w	r3, r9, r3, lsl #2
    553a:	685b      	ldr	r3, [r3, #4]
    553c:	9302      	str	r3, [sp, #8]
		instance->ticks_current += ticks_elapsed;
    553e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    5540:	18d3      	adds	r3, r2, r3
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;
    5542:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    5546:	f8c9 3014 	str.w	r3, [r9, #20]
		flag_elapsed = 1U;
    554a:	2301      	movs	r3, #1
    554c:	9301      	str	r3, [sp, #4]
	ticker_id_old_head = instance->ticker_id_head;
    554e:	f899 301d 	ldrb.w	r3, [r9, #29]
    5552:	9308      	str	r3, [sp, #32]
	node = &instance->nodes[0];
    5554:	f8d9 b000 	ldr.w	fp, [r9]
	users = &instance->users[0];
    5558:	f8d9 3004 	ldr.w	r3, [r9, #4]
    555c:	930b      	str	r3, [sp, #44]	; 0x2c
	count_user = instance->count_user;
    555e:	f899 3009 	ldrb.w	r3, [r9, #9]
	pending = 0U;
    5562:	9a03      	ldr	r2, [sp, #12]
    5564:	9204      	str	r2, [sp, #16]
	insert_head = TICKER_NULL;
    5566:	22ff      	movs	r2, #255	; 0xff
    5568:	9200      	str	r2, [sp, #0]
    556a:	f8cd b018 	str.w	fp, [sp, #24]
	while (count_user--) {
    556e:	e101      	b.n	5774 <ticker_job+0x270>
		idx = 0U;
    5570:	9b03      	ldr	r3, [sp, #12]
    5572:	e7dd      	b.n	5530 <ticker_job+0x2c>
		flag_elapsed = 0U;
    5574:	9b03      	ldr	r3, [sp, #12]
    5576:	9301      	str	r3, [sp, #4]
		ticks_elapsed = 0U;
    5578:	2300      	movs	r3, #0
    557a:	9302      	str	r3, [sp, #8]
    557c:	e7e7      	b.n	554e <ticker_job+0x4a>
				middle = 0U;
    557e:	9b03      	ldr	r3, [sp, #12]
    5580:	e093      	b.n	56aa <ticker_job+0x1a6>
			     (user_op->params.update.ticks_drift_plus == 0U) &&
    5582:	686a      	ldr	r2, [r5, #4]
			    ((user_op->op == TICKER_USER_OP_TYPE_UPDATE) &&
    5584:	2a00      	cmp	r2, #0
    5586:	f040 80ab 	bne.w	56e0 <ticker_job+0x1dc>
			     (user_op->params.update.ticks_drift_minus == 0U) &&
    558a:	68aa      	ldr	r2, [r5, #8]
			     (user_op->params.update.ticks_drift_plus == 0U) &&
    558c:	2a00      	cmp	r2, #0
    558e:	f040 80a7 	bne.w	56e0 <ticker_job+0x1dc>
			     (user_op->params.update.ticks_slot_plus == 0U) &&
    5592:	68ea      	ldr	r2, [r5, #12]
			     (user_op->params.update.ticks_drift_minus == 0U) &&
    5594:	2a00      	cmp	r2, #0
    5596:	f040 80a3 	bne.w	56e0 <ticker_job+0x1dc>
			     (user_op->params.update.ticks_slot_minus == 0U) &&
    559a:	692a      	ldr	r2, [r5, #16]
			     (user_op->params.update.ticks_slot_plus == 0U) &&
    559c:	2a00      	cmp	r2, #0
    559e:	f040 809f 	bne.w	56e0 <ticker_job+0x1dc>
			     (user_op->params.update.lazy == 0U) &&
    55a2:	696a      	ldr	r2, [r5, #20]
    55a4:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
    55a8:	f040 809a 	bne.w	56e0 <ticker_job+0x1dc>
				ticker_job_op_cb(user_op,
    55ac:	2101      	movs	r1, #1
    55ae:	4628      	mov	r0, r5
    55b0:	f008 ffe2 	bl	e578 <ticker_job_op_cb>
				continue;
    55b4:	e066      	b.n	5684 <ticker_job+0x180>
		ticker_job_node_update(ticker, user_op, instance->ticks_current,
    55b6:	f8d9 8014 	ldr.w	r8, [r9, #20]
	u32_t ticks_to_expire = ticker->ticks_to_expire;
    55ba:	4606      	mov	r6, r0
	ticks_now = cntr_cnt_get();
    55bc:	f002 fe86 	bl	82cc <cntr_cnt_get>
    55c0:	9007      	str	r0, [sp, #28]
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
    55c2:	4641      	mov	r1, r8
    55c4:	f009 f8aa 	bl	e71c <ticker_ticks_diff_get>
    55c8:	9b02      	ldr	r3, [sp, #8]
    55ca:	4418      	add	r0, r3
	if (ticks_to_expire > ticks_elapsed) {
    55cc:	4286      	cmp	r6, r0
    55ce:	d907      	bls.n	55e0 <ticker_job+0xdc>
		ticks_to_expire -= ticks_elapsed;
    55d0:	1a36      	subs	r6, r6, r0
	if ((ticker->ticks_periodic != 0U) &&
    55d2:	6863      	ldr	r3, [r4, #4]
    55d4:	b343      	cbz	r3, 5628 <ticker_job+0x124>
	    (user_op->params.update.lazy != 0U)) {
    55d6:	8aab      	ldrh	r3, [r5, #20]
	if ((ticker->ticks_periodic != 0U) &&
    55d8:	b333      	cbz	r3, 5628 <ticker_job+0x124>
		user_op->params.update.lazy--;
    55da:	3b01      	subs	r3, #1
    55dc:	82ab      	strh	r3, [r5, #20]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
    55de:	e00d      	b.n	55fc <ticker_job+0xf8>
		ticker->ticks_to_expire_minus += ticks_elapsed -
    55e0:	1b86      	subs	r6, r0, r6
    55e2:	6960      	ldr	r0, [r4, #20]
    55e4:	4406      	add	r6, r0
    55e6:	6166      	str	r6, [r4, #20]
		ticks_to_expire = 0U;
    55e8:	2600      	movs	r6, #0
    55ea:	e7f2      	b.n	55d2 <ticker_job+0xce>
					   ticker_remainder_dec(ticker);
    55ec:	4620      	mov	r0, r4
    55ee:	f7ff fe7b 	bl	52e8 <ticker_remainder_dec>
			ticks_to_expire -= ticker->ticks_periodic +
    55f2:	4438      	add	r0, r7
    55f4:	1a36      	subs	r6, r6, r0
			ticker->lazy_current--;
    55f6:	8be3      	ldrh	r3, [r4, #30]
    55f8:	3b01      	subs	r3, #1
    55fa:	83e3      	strh	r3, [r4, #30]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
    55fc:	6867      	ldr	r7, [r4, #4]
    55fe:	42b7      	cmp	r7, r6
    5600:	d203      	bcs.n	560a <ticker_job+0x106>
		       (ticker->lazy_current > user_op->params.update.lazy)) {
    5602:	8be2      	ldrh	r2, [r4, #30]
    5604:	8aab      	ldrh	r3, [r5, #20]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
    5606:	429a      	cmp	r2, r3
    5608:	d8f0      	bhi.n	55ec <ticker_job+0xe8>
		while (ticker->lazy_current < user_op->params.update.lazy) {
    560a:	8be2      	ldrh	r2, [r4, #30]
    560c:	8aab      	ldrh	r3, [r5, #20]
    560e:	429a      	cmp	r2, r3
    5610:	d209      	bcs.n	5626 <ticker_job+0x122>
			ticks_to_expire += ticker->ticks_periodic +
    5612:	6867      	ldr	r7, [r4, #4]
					   ticker_remainder_inc(ticker);
    5614:	4620      	mov	r0, r4
    5616:	f7ff fe51 	bl	52bc <ticker_remainder_inc>
			ticks_to_expire += ticker->ticks_periodic +
    561a:	4407      	add	r7, r0
    561c:	443e      	add	r6, r7
			ticker->lazy_current++;
    561e:	8be3      	ldrh	r3, [r4, #30]
    5620:	3301      	adds	r3, #1
    5622:	83e3      	strh	r3, [r4, #30]
    5624:	e7f1      	b.n	560a <ticker_job+0x106>
		ticker->lazy_periodic = user_op->params.update.lazy;
    5626:	83a3      	strh	r3, [r4, #28]
				  user_op->params.update.ticks_drift_plus;
    5628:	6868      	ldr	r0, [r5, #4]
	ticker->ticks_to_expire = ticks_to_expire +
    562a:	4406      	add	r6, r0
    562c:	60a6      	str	r6, [r4, #8]
				user_op->params.update.ticks_drift_minus;
    562e:	68aa      	ldr	r2, [r5, #8]
	ticker->ticks_to_expire_minus +=
    5630:	6963      	ldr	r3, [r4, #20]
    5632:	4413      	add	r3, r2
    5634:	6163      	str	r3, [r4, #20]
	struct ticker_ext *ext_data = ticker->ext_data;
    5636:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	if (ext_data && ext_data->ticks_slot_window != 0U) {
    5638:	b12b      	cbz	r3, 5646 <ticker_job+0x142>
    563a:	681a      	ldr	r2, [r3, #0]
    563c:	b11a      	cbz	r2, 5646 <ticker_job+0x142>
			user_op->params.update.ticks_drift_plus -
    563e:	686a      	ldr	r2, [r5, #4]
			user_op->params.update.ticks_drift_minus;
    5640:	68a9      	ldr	r1, [r5, #8]
			user_op->params.update.ticks_drift_plus -
    5642:	1a52      	subs	r2, r2, r1
		ext_data->ticks_drift =
    5644:	605a      	str	r2, [r3, #4]
	ticks_to_expire_prep(ticker, ticks_current, ticks_now);
    5646:	9a07      	ldr	r2, [sp, #28]
    5648:	4641      	mov	r1, r8
    564a:	4620      	mov	r0, r4
    564c:	f009 f922 	bl	e894 <ticks_to_expire_prep>
	ticker->ticks_slot += user_op->params.update.ticks_slot_plus;
    5650:	68eb      	ldr	r3, [r5, #12]
    5652:	69a2      	ldr	r2, [r4, #24]
    5654:	4413      	add	r3, r2
    5656:	61a3      	str	r3, [r4, #24]
	if (ticker->ticks_slot > user_op->params.update.ticks_slot_minus) {
    5658:	692a      	ldr	r2, [r5, #16]
    565a:	4293      	cmp	r3, r2
    565c:	d96d      	bls.n	573a <ticker_job+0x236>
		ticker->ticks_slot -= user_op->params.update.ticks_slot_minus;
    565e:	1a9b      	subs	r3, r3, r2
    5660:	61a3      	str	r3, [r4, #24]
	if (user_op->params.update.force != 0U) {
    5662:	7dab      	ldrb	r3, [r5, #22]
    5664:	b103      	cbz	r3, 5668 <ticker_job+0x164>
		ticker->force = user_op->params.update.force;
    5666:	70e3      	strb	r3, [r4, #3]
	ticker->next = *insert_head;
    5668:	9b06      	ldr	r3, [sp, #24]
    566a:	4619      	mov	r1, r3
    566c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    566e:	9b00      	ldr	r3, [sp, #0]
    5670:	548b      	strb	r3, [r1, r2]
	*insert_head = user_op->id;
    5672:	786b      	ldrb	r3, [r5, #1]
    5674:	9300      	str	r3, [sp, #0]
		ticker->req++;
    5676:	7863      	ldrb	r3, [r4, #1]
    5678:	3301      	adds	r3, #1
    567a:	7063      	strb	r3, [r4, #1]
	ticker_job_op_cb(user_op, TICKER_STATUS_SUCCESS);
    567c:	2100      	movs	r1, #0
    567e:	4628      	mov	r0, r5
    5680:	f008 ff7a 	bl	e578 <ticker_job_op_cb>
		while (user->middle != user->last) {
    5684:	f89a 7002 	ldrb.w	r7, [sl, #2]
    5688:	f89a 3003 	ldrb.w	r3, [sl, #3]
    568c:	429f      	cmp	r7, r3
    568e:	d070      	beq.n	5772 <ticker_job+0x26e>
			user_op = &user_ops[user->middle];
    5690:	2634      	movs	r6, #52	; 0x34
    5692:	fb06 f607 	mul.w	r6, r6, r7
    5696:	eb0b 0506 	add.w	r5, fp, r6
			middle = user->middle + 1;
    569a:	b27b      	sxtb	r3, r7
    569c:	3301      	adds	r3, #1
    569e:	b2db      	uxtb	r3, r3
			if (middle == user->count_user_op) {
    56a0:	f89a 2000 	ldrb.w	r2, [sl]
    56a4:	4293      	cmp	r3, r2
    56a6:	f43f af6a 	beq.w	557e <ticker_job+0x7a>
			user->middle = middle;
    56aa:	f88a 3002 	strb.w	r3, [sl, #2]
			ticker = &node[user_op->id];
    56ae:	786c      	ldrb	r4, [r5, #1]
    56b0:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    56b4:	0123      	lsls	r3, r4, #4
    56b6:	930a      	str	r3, [sp, #40]	; 0x28
    56b8:	9b06      	ldr	r3, [sp, #24]
    56ba:	eb03 1404 	add.w	r4, r3, r4, lsl #4
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
    56be:	f81b 2006 	ldrb.w	r2, [fp, r6]
    56c2:	2a04      	cmp	r2, #4
    56c4:	d9de      	bls.n	5684 <ticker_job+0x180>
			state = (ticker->req - ticker->ack) & 0xff;
    56c6:	7863      	ldrb	r3, [r4, #1]
    56c8:	78a1      	ldrb	r1, [r4, #2]
    56ca:	1a5b      	subs	r3, r3, r1
    56cc:	b2db      	uxtb	r3, r3
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
    56ce:	2a07      	cmp	r2, #7
    56d0:	f63f af6c 	bhi.w	55ac <ticker_job+0xa8>
    56d4:	2b00      	cmp	r3, #0
    56d6:	f43f af69 	beq.w	55ac <ticker_job+0xa8>
			    (state == 0U) ||
    56da:	2a05      	cmp	r2, #5
    56dc:	f43f af51 	beq.w	5582 <ticker_job+0x7e>
			if (state == 1U) {
    56e0:	2b01      	cmp	r3, #1
    56e2:	d13b      	bne.n	575c <ticker_job+0x258>
	ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
    56e4:	7869      	ldrb	r1, [r5, #1]
    56e6:	4648      	mov	r0, r9
    56e8:	f008 feb1 	bl	e44e <ticker_dequeue>
    56ec:	60a0      	str	r0, [r4, #8]
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
    56ee:	f81b 3006 	ldrb.w	r3, [fp, r6]
    56f2:	2b05      	cmp	r3, #5
    56f4:	f43f af5f 	beq.w	55b6 <ticker_job+0xb2>
		ticker->req = ticker->ack;
    56f8:	78a3      	ldrb	r3, [r4, #2]
    56fa:	7063      	strb	r3, [r4, #1]
		if (instance->ticker_id_slot_previous == user_op->id) {
    56fc:	f899 201c 	ldrb.w	r2, [r9, #28]
    5700:	786b      	ldrb	r3, [r5, #1]
    5702:	429a      	cmp	r2, r3
    5704:	d1ba      	bne.n	567c <ticker_job+0x178>
			instance->ticker_id_slot_previous = TICKER_NULL;
    5706:	23ff      	movs	r3, #255	; 0xff
    5708:	f889 301c 	strb.w	r3, [r9, #28]
			if (user_op->op == TICKER_USER_OP_TYPE_STOP_ABS) {
    570c:	f81b 3006 	ldrb.w	r3, [fp, r6]
    5710:	2b07      	cmp	r3, #7
    5712:	d115      	bne.n	5740 <ticker_job+0x23c>
				ticks_at_stop =
    5714:	6868      	ldr	r0, [r5, #4]
			ticks_current = instance->ticks_current;
    5716:	f8d9 3014 	ldr.w	r3, [r9, #20]
			if (!((ticks_at_stop - ticks_current) &
    571a:	1ac2      	subs	r2, r0, r3
    571c:	f412 0f00 	tst.w	r2, #8388608	; 0x800000
    5720:	d111      	bne.n	5746 <ticker_job+0x242>
					ticker_ticks_diff_get(ticks_at_stop,
    5722:	4619      	mov	r1, r3
    5724:	f008 fffa 	bl	e71c <ticker_ticks_diff_get>
				ticks_used = ticks_elapsed +
    5728:	9b02      	ldr	r3, [sp, #8]
    572a:	4418      	add	r0, r3
			if (instance->ticks_slot_previous > ticks_used) {
    572c:	f8d9 3018 	ldr.w	r3, [r9, #24]
    5730:	4283      	cmp	r3, r0
    5732:	d9a3      	bls.n	567c <ticker_job+0x178>
				instance->ticks_slot_previous = ticks_used;
    5734:	f8c9 0018 	str.w	r0, [r9, #24]
    5738:	e7a0      	b.n	567c <ticker_job+0x178>
		ticker->ticks_slot = 0U;
    573a:	2300      	movs	r3, #0
    573c:	61a3      	str	r3, [r4, #24]
    573e:	e790      	b.n	5662 <ticker_job+0x15e>
				ticks_at_stop = cntr_cnt_get();
    5740:	f002 fdc4 	bl	82cc <cntr_cnt_get>
    5744:	e7e7      	b.n	5716 <ticker_job+0x212>
					ticker_ticks_diff_get(ticks_current,
    5746:	4601      	mov	r1, r0
    5748:	4618      	mov	r0, r3
    574a:	f008 ffe7 	bl	e71c <ticker_ticks_diff_get>
				if (ticks_elapsed > ticks_used) {
    574e:	9b02      	ldr	r3, [sp, #8]
    5750:	4283      	cmp	r3, r0
    5752:	d901      	bls.n	5758 <ticker_job+0x254>
					ticks_used = ticks_elapsed -
    5754:	1a18      	subs	r0, r3, r0
    5756:	e7e9      	b.n	572c <ticker_job+0x228>
					ticks_used = 0;
    5758:	2000      	movs	r0, #0
    575a:	e7e7      	b.n	572c <ticker_job+0x228>
				instance->sched_cb(TICKER_CALL_ID_JOB,
    575c:	f8d9 4024 	ldr.w	r4, [r9, #36]	; 0x24
    5760:	464b      	mov	r3, r9
    5762:	2201      	movs	r2, #1
    5764:	2104      	movs	r1, #4
    5766:	4608      	mov	r0, r1
    5768:	47a0      	blx	r4
				user->middle = prev;
    576a:	f88a 7002 	strb.w	r7, [sl, #2]
				pending = 1U;
    576e:	2301      	movs	r3, #1
    5770:	9304      	str	r3, [sp, #16]
	insert_head = TICKER_NULL;
    5772:	9b05      	ldr	r3, [sp, #20]
	while (count_user--) {
    5774:	1e5a      	subs	r2, r3, #1
    5776:	b2d2      	uxtb	r2, r2
    5778:	9205      	str	r2, [sp, #20]
    577a:	b133      	cbz	r3, 578a <ticker_job+0x286>
		user = &users[count_user];
    577c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    577e:	9a05      	ldr	r2, [sp, #20]
    5780:	eb03 0ac2 	add.w	sl, r3, r2, lsl #3
		user_ops = &user->user_op[0];
    5784:	f8da b004 	ldr.w	fp, [sl, #4]
		while (user->middle != user->last) {
    5788:	e77c      	b.n	5684 <ticker_job+0x180>
    578a:	9306      	str	r3, [sp, #24]
	if (instance->ticker_id_head != ticker_id_old_head) {
    578c:	f899 301d 	ldrb.w	r3, [r9, #29]
    5790:	9a08      	ldr	r2, [sp, #32]
    5792:	4293      	cmp	r3, r2
    5794:	d012      	beq.n	57bc <ticker_job+0x2b8>
		flag_compare_update = 1U;
    5796:	2301      	movs	r3, #1
    5798:	930a      	str	r3, [sp, #40]	; 0x28
	if (flag_elapsed) {
    579a:	9b01      	ldr	r3, [sp, #4]
    579c:	2b00      	cmp	r3, #0
    579e:	f000 8157 	beq.w	5a50 <ticker_job+0x54c>
	ticks_now = cntr_cnt_get();
    57a2:	f002 fd93 	bl	82cc <cntr_cnt_get>
	ticks_latency = ticker_ticks_diff_get(ticks_now, ticks_previous);
    57a6:	9909      	ldr	r1, [sp, #36]	; 0x24
    57a8:	f008 ffb8 	bl	e71c <ticker_ticks_diff_get>
    57ac:	9007      	str	r0, [sp, #28]
	node = &instance->nodes[0];
    57ae:	f8d9 b000 	ldr.w	fp, [r9]
	while (instance->ticker_id_head != TICKER_NULL) {
    57b2:	f8dd 8008 	ldr.w	r8, [sp, #8]
	ticks_expired = 0U;
    57b6:	2300      	movs	r3, #0
    57b8:	9303      	str	r3, [sp, #12]
	while (instance->ticker_id_head != TICKER_NULL) {
    57ba:	e06a      	b.n	5892 <ticker_job+0x38e>
	flag_compare_update = 0U;
    57bc:	9b06      	ldr	r3, [sp, #24]
    57be:	930a      	str	r3, [sp, #40]	; 0x28
    57c0:	e7eb      	b.n	579a <ticker_job+0x296>
			ticker->ticks_to_expire -= ticks_elapsed;
    57c2:	eba3 0308 	sub.w	r3, r3, r8
    57c6:	60a3      	str	r3, [r4, #8]
		if (instance->ticker_id_head != ticker_id_old_head) {
    57c8:	f899 301d 	ldrb.w	r3, [r9, #29]
    57cc:	9a08      	ldr	r2, [sp, #32]
    57ce:	4293      	cmp	r3, r2
    57d0:	d001      	beq.n	57d6 <ticker_job+0x2d2>
			flag_compare_update = 1U;
    57d2:	9b01      	ldr	r3, [sp, #4]
    57d4:	930a      	str	r3, [sp, #40]	; 0x28
	node = &instance->nodes[0];
    57d6:	f8d9 a000 	ldr.w	sl, [r9]
	users = &instance->users[0];
    57da:	f8d9 3004 	ldr.w	r3, [r9, #4]
    57de:	9305      	str	r3, [sp, #20]
	count_user = instance->count_user;
    57e0:	f899 b009 	ldrb.w	fp, [r9, #9]
	while (count_user--) {
    57e4:	9f00      	ldr	r7, [sp, #0]
    57e6:	f8cd 900c 	str.w	r9, [sp, #12]
    57ea:	e116      	b.n	5a1a <ticker_job+0x516>
		is_must_expire_skip = (ticker->must_expire &&
    57ec:	2100      	movs	r1, #0
    57ee:	b2c9      	uxtb	r1, r1
		if (instance->ticks_slot_previous > ticks_to_expire) {
    57f0:	f8d9 2018 	ldr.w	r2, [r9, #24]
    57f4:	4293      	cmp	r3, r2
    57f6:	d21d      	bcs.n	5834 <ticker_job+0x330>
			instance->ticks_slot_previous -= ticks_to_expire;
    57f8:	1ad3      	subs	r3, r2, r3
    57fa:	f8c9 3018 	str.w	r3, [r9, #24]
		if ((ticker->ticks_slot != 0U) &&
    57fe:	69a3      	ldr	r3, [r4, #24]
    5800:	b12b      	cbz	r3, 580e <ticker_job+0x30a>
		    (((ticker->req - ticker->ack) & 0xff) == 2U) &&
    5802:	7863      	ldrb	r3, [r4, #1]
    5804:	78a2      	ldrb	r2, [r4, #2]
    5806:	1a9b      	subs	r3, r3, r2
    5808:	b2db      	uxtb	r3, r3
		if ((ticker->ticks_slot != 0U) &&
    580a:	2b02      	cmp	r3, #2
    580c:	d019      	beq.n	5842 <ticker_job+0x33e>
		ticker->ticks_to_expire = 0U;
    580e:	2300      	movs	r3, #0
    5810:	60a3      	str	r3, [r4, #8]
		instance->ticker_id_head = ticker->next;
    5812:	9b05      	ldr	r3, [sp, #20]
    5814:	f81b 3003 	ldrb.w	r3, [fp, r3]
    5818:	f889 301d 	strb.w	r3, [r9, #29]
		if ((ticker->ticks_periodic != 0U) ||
    581c:	6863      	ldr	r3, [r4, #4]
    581e:	b9eb      	cbnz	r3, 585c <ticker_job+0x358>
		    TICKER_RESCHEDULE_PENDING(ticker)) {
    5820:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		if ((ticker->ticks_periodic != 0U) ||
    5822:	b113      	cbz	r3, 582a <ticker_job+0x326>
		    TICKER_RESCHEDULE_PENDING(ticker)) {
    5824:	7a1b      	ldrb	r3, [r3, #8]
    5826:	2b01      	cmp	r3, #1
    5828:	d018      	beq.n	585c <ticker_job+0x358>
			ticker->req = ticker->ack;
    582a:	78a3      	ldrb	r3, [r4, #2]
    582c:	7063      	strb	r3, [r4, #1]
    582e:	e030      	b.n	5892 <ticker_job+0x38e>
		is_must_expire_skip = (ticker->must_expire &&
    5830:	2101      	movs	r1, #1
    5832:	e7dc      	b.n	57ee <ticker_job+0x2ea>
			instance->ticker_id_slot_previous = TICKER_NULL;
    5834:	23ff      	movs	r3, #255	; 0xff
    5836:	f889 301c 	strb.w	r3, [r9, #28]
			instance->ticks_slot_previous = 0U;
    583a:	2300      	movs	r3, #0
    583c:	f8c9 3018 	str.w	r3, [r9, #24]
    5840:	e7dd      	b.n	57fe <ticker_job+0x2fa>
		    (((ticker->req - ticker->ack) & 0xff) == 2U) &&
    5842:	2900      	cmp	r1, #0
    5844:	d1e3      	bne.n	580e <ticker_job+0x30a>
		    !TICKER_RESCHEDULE_PENDING(ticker)) {
    5846:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		    !is_must_expire_skip &&
    5848:	b113      	cbz	r3, 5850 <ticker_job+0x34c>
		    !TICKER_RESCHEDULE_PENDING(ticker)) {
    584a:	7a1b      	ldrb	r3, [r3, #8]
    584c:	2b01      	cmp	r3, #1
    584e:	d0de      	beq.n	580e <ticker_job+0x30a>
			instance->ticker_id_slot_previous = id_expired;
    5850:	f889 701c 	strb.w	r7, [r9, #28]
			instance->ticks_slot_previous = ticker->ticks_slot;
    5854:	69a3      	ldr	r3, [r4, #24]
    5856:	f8c9 3018 	str.w	r3, [r9, #24]
    585a:	e7d8      	b.n	580e <ticker_job+0x30a>
			if (TICKER_RESCHEDULE_PENDING(ticker)) {
    585c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    585e:	2b00      	cmp	r3, #0
    5860:	d035      	beq.n	58ce <ticker_job+0x3ca>
    5862:	7a1b      	ldrb	r3, [r3, #8]
    5864:	2b01      	cmp	r3, #1
    5866:	d132      	bne.n	58ce <ticker_job+0x3ca>
				ticker->ticks_to_expire = ticks_elapsed;
    5868:	f8c4 8008 	str.w	r8, [r4, #8]
				ticker->req = ticker->ack;
    586c:	78a3      	ldrb	r3, [r4, #2]
    586e:	7063      	strb	r3, [r4, #1]
			ticks_to_expire_prep(ticker, instance->ticks_current,
    5870:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5872:	9a03      	ldr	r2, [sp, #12]
    5874:	189a      	adds	r2, r3, r2
    5876:	f8d9 1014 	ldr.w	r1, [r9, #20]
    587a:	4620      	mov	r0, r4
    587c:	f009 f80a 	bl	e894 <ticks_to_expire_prep>
			ticker->next = *insert_head;
    5880:	9b05      	ldr	r3, [sp, #20]
    5882:	461a      	mov	r2, r3
    5884:	9b00      	ldr	r3, [sp, #0]
    5886:	f80b 3002 	strb.w	r3, [fp, r2]
			ticker->req++;
    588a:	7863      	ldrb	r3, [r4, #1]
    588c:	3301      	adds	r3, #1
    588e:	7063      	strb	r3, [r4, #1]
			*insert_head = id_expired;
    5890:	9700      	str	r7, [sp, #0]
	while (instance->ticker_id_head != TICKER_NULL) {
    5892:	f899 701d 	ldrb.w	r7, [r9, #29]
    5896:	2fff      	cmp	r7, #255	; 0xff
    5898:	d096      	beq.n	57c8 <ticker_job+0x2c4>
		ticker = &node[id_expired];
    589a:	eb07 0447 	add.w	r4, r7, r7, lsl #1
    589e:	0123      	lsls	r3, r4, #4
    58a0:	9305      	str	r3, [sp, #20]
    58a2:	eb0b 1404 	add.w	r4, fp, r4, lsl #4
		ticks_to_expire = ticker->ticks_to_expire;
    58a6:	68a3      	ldr	r3, [r4, #8]
		if (ticks_elapsed < ticks_to_expire) {
    58a8:	4543      	cmp	r3, r8
    58aa:	d88a      	bhi.n	57c2 <ticker_job+0x2be>
		ticks_elapsed -= ticks_to_expire;
    58ac:	eba8 0803 	sub.w	r8, r8, r3
		ticks_expired += ticks_to_expire;
    58b0:	9a03      	ldr	r2, [sp, #12]
    58b2:	441a      	add	r2, r3
    58b4:	9203      	str	r2, [sp, #12]
		ticks_latency -= ticks_to_expire;
    58b6:	9a07      	ldr	r2, [sp, #28]
    58b8:	1ad2      	subs	r2, r2, r3
    58ba:	9207      	str	r2, [sp, #28]
		is_must_expire_skip = (ticker->must_expire &&
    58bc:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    58c0:	2a00      	cmp	r2, #0
    58c2:	d093      	beq.n	57ec <ticker_job+0x2e8>
				       (ticker->lazy_current != 0U));
    58c4:	8be2      	ldrh	r2, [r4, #30]
		is_must_expire_skip = (ticker->must_expire &&
    58c6:	2a00      	cmp	r2, #0
    58c8:	d1b2      	bne.n	5830 <ticker_job+0x32c>
    58ca:	2100      	movs	r1, #0
    58cc:	e78f      	b.n	57ee <ticker_job+0x2ea>
				if (!ticker->lazy_current) {
    58ce:	8be3      	ldrh	r3, [r4, #30]
    58d0:	b96b      	cbnz	r3, 58ee <ticker_job+0x3ea>
					lazy_periodic = ticker->lazy_periodic;
    58d2:	8ba6      	ldrh	r6, [r4, #28]
				count = 1 + lazy_periodic;
    58d4:	1c73      	adds	r3, r6, #1
				ticks_to_expire = 0U;
    58d6:	2500      	movs	r5, #0
				while (count--) {
    58d8:	f103 3aff 	add.w	sl, r3, #4294967295	; 0xffffffff
    58dc:	b15b      	cbz	r3, 58f6 <ticker_job+0x3f2>
						ticker->ticks_periodic;
    58de:	6860      	ldr	r0, [r4, #4]
					ticks_to_expire +=
    58e0:	4405      	add	r5, r0
						ticker_remainder_inc(ticker);
    58e2:	4620      	mov	r0, r4
    58e4:	f7ff fcea 	bl	52bc <ticker_remainder_inc>
					ticks_to_expire +=
    58e8:	4405      	add	r5, r0
				while (count--) {
    58ea:	4653      	mov	r3, sl
    58ec:	e7f4      	b.n	58d8 <ticker_job+0x3d4>
					ticker->req = ticker->ack;
    58ee:	78a3      	ldrb	r3, [r4, #2]
    58f0:	7063      	strb	r3, [r4, #1]
					lazy_periodic = 0U;
    58f2:	2600      	movs	r6, #0
    58f4:	e7ee      	b.n	58d4 <ticker_job+0x3d0>
				if (!ticker->must_expire) {
    58f6:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    58fa:	b14b      	cbz	r3, 5910 <ticker_job+0x40c>
				lazy = 0U;
    58fc:	f04f 0a00 	mov.w	sl, #0
				ticker->ticks_to_expire = ticks_to_expire;
    5900:	60a5      	str	r5, [r4, #8]
				ticker->lazy_current += (lazy_periodic + lazy);
    5902:	4456      	add	r6, sl
    5904:	f8b4 a01e 	ldrh.w	sl, [r4, #30]
    5908:	fa0a f686 	sxtah	r6, sl, r6
    590c:	83e6      	strh	r6, [r4, #30]
    590e:	e7af      	b.n	5870 <ticker_job+0x36c>
				lazy = 0U;
    5910:	f04f 0a00 	mov.w	sl, #0
    5914:	960b      	str	r6, [sp, #44]	; 0x2c
    5916:	9e07      	ldr	r6, [sp, #28]
					while (ticks_to_expire <
    5918:	42ae      	cmp	r6, r5
    591a:	d90a      	bls.n	5932 <ticker_job+0x42e>
							ticker->ticks_periodic;
    591c:	6860      	ldr	r0, [r4, #4]
						ticks_to_expire +=
    591e:	4405      	add	r5, r0
						  ticker_remainder_inc(ticker);
    5920:	4620      	mov	r0, r4
    5922:	f7ff fccb 	bl	52bc <ticker_remainder_inc>
						ticks_to_expire +=
    5926:	4405      	add	r5, r0
						lazy++;
    5928:	f10a 0a01 	add.w	sl, sl, #1
    592c:	fa1f fa8a 	uxth.w	sl, sl
    5930:	e7f2      	b.n	5918 <ticker_job+0x414>
    5932:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    5934:	e7e4      	b.n	5900 <ticker_job+0x3fc>
				user_op = &user_ops[user_ops_first];
    5936:	2334      	movs	r3, #52	; 0x34
    5938:	fb03 f306 	mul.w	r3, r3, r6
    593c:	9a00      	ldr	r2, [sp, #0]
    593e:	18d5      	adds	r5, r2, r3
				first = user_ops_first + 1;
    5940:	3601      	adds	r6, #1
    5942:	b2f6      	uxtb	r6, r6
				if (first == user->count_user_op) {
    5944:	f898 2000 	ldrb.w	r2, [r8]
    5948:	4296      	cmp	r6, r2
    594a:	d039      	beq.n	59c0 <ticker_job+0x4bc>
				id_insert = user_op->id;
    594c:	f895 9001 	ldrb.w	r9, [r5, #1]
				ticker = &node[id_insert];
    5950:	eb09 0449 	add.w	r4, r9, r9, lsl #1
    5954:	eb0a 1404 	add.w	r4, sl, r4, lsl #4
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
    5958:	9a00      	ldr	r2, [sp, #0]
    595a:	5cd3      	ldrb	r3, [r2, r3]
    595c:	2b04      	cmp	r3, #4
    595e:	d13e      	bne.n	59de <ticker_job+0x4da>
				if (((ticker->req -
    5960:	7863      	ldrb	r3, [r4, #1]
				      ticker->ack) & 0xff) != 0U) {
    5962:	78a2      	ldrb	r2, [r4, #2]
				if (((ticker->req -
    5964:	1a9b      	subs	r3, r3, r2
    5966:	f013 0fff 	tst.w	r3, #255	; 0xff
    596a:	d12b      	bne.n	59c4 <ticker_job+0x4c0>
				ticker_job_op_start(ticker, user_op,
    596c:	9b03      	ldr	r3, [sp, #12]
    596e:	6959      	ldr	r1, [r3, #20]
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
    5970:	8aaa      	ldrh	r2, [r5, #20]
    5972:	f64f 73ff 	movw	r3, #65535	; 0xffff
    5976:	429a      	cmp	r2, r3
    5978:	d029      	beq.n	59ce <ticker_job+0x4ca>
    597a:	9b06      	ldr	r3, [sp, #24]
    597c:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
	ticker->ext_data = start->ext_data;
    5980:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    5982:	62a3      	str	r3, [r4, #40]	; 0x28
	ticker->ticks_periodic = start->ticks_periodic;
    5984:	68eb      	ldr	r3, [r5, #12]
    5986:	6063      	str	r3, [r4, #4]
	ticker->remainder_periodic = start->remainder_periodic;
    5988:	692b      	ldr	r3, [r5, #16]
    598a:	6223      	str	r3, [r4, #32]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
    598c:	8aab      	ldrh	r3, [r5, #20]
    598e:	f64f 72ff 	movw	r2, #65535	; 0xffff
    5992:	4293      	cmp	r3, r2
    5994:	d01d      	beq.n	59d2 <ticker_job+0x4ce>
    5996:	83a3      	strh	r3, [r4, #28]
	ticker->ticks_slot = start->ticks_slot;
    5998:	69ab      	ldr	r3, [r5, #24]
    599a:	61a3      	str	r3, [r4, #24]
	ticker->timeout_func = start->fp_timeout_func;
    599c:	69eb      	ldr	r3, [r5, #28]
    599e:	60e3      	str	r3, [r4, #12]
	ticker->context = start->context;
    59a0:	6a2b      	ldr	r3, [r5, #32]
    59a2:	6123      	str	r3, [r4, #16]
	ticker->ticks_to_expire = start->ticks_first;
    59a4:	68ab      	ldr	r3, [r5, #8]
    59a6:	60a3      	str	r3, [r4, #8]
	ticker->ticks_to_expire_minus = 0U;
    59a8:	2300      	movs	r3, #0
    59aa:	6163      	str	r3, [r4, #20]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
    59ac:	686a      	ldr	r2, [r5, #4]
    59ae:	4620      	mov	r0, r4
    59b0:	f008 ff70 	bl	e894 <ticks_to_expire_prep>
	ticker->remainder_current = 0U;
    59b4:	2300      	movs	r3, #0
    59b6:	6263      	str	r3, [r4, #36]	; 0x24
	ticker->lazy_current = 0U;
    59b8:	83e3      	strh	r3, [r4, #30]
	ticker->force = 1U;
    59ba:	2301      	movs	r3, #1
    59bc:	70e3      	strb	r3, [r4, #3]
}
    59be:	e01b      	b.n	59f8 <ticker_job+0x4f4>
					first = 0U;
    59c0:	9e06      	ldr	r6, [sp, #24]
    59c2:	e7c3      	b.n	594c <ticker_job+0x448>
					ticker_job_op_cb(user_op,
    59c4:	2101      	movs	r1, #1
    59c6:	4628      	mov	r0, r5
    59c8:	f008 fdd6 	bl	e578 <ticker_job_op_cb>
					continue;
    59cc:	e007      	b.n	59de <ticker_job+0x4da>
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
    59ce:	9b01      	ldr	r3, [sp, #4]
    59d0:	e7d4      	b.n	597c <ticker_job+0x478>
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
    59d2:	2300      	movs	r3, #0
    59d4:	e7df      	b.n	5996 <ticker_job+0x492>
				ticker_job_op_cb(user_op, status);
    59d6:	2100      	movs	r1, #0
    59d8:	4628      	mov	r0, r5
    59da:	f008 fdcd 	bl	e578 <ticker_job_op_cb>
		while ((insert_head != TICKER_NULL) ||
    59de:	2fff      	cmp	r7, #255	; 0xff
    59e0:	d017      	beq.n	5a12 <ticker_job+0x50e>
			if (insert_head != TICKER_NULL) {
    59e2:	2fff      	cmp	r7, #255	; 0xff
    59e4:	d0a7      	beq.n	5936 <ticker_job+0x432>
				ticker = &node[id_insert];
    59e6:	eb07 0447 	add.w	r4, r7, r7, lsl #1
    59ea:	0123      	lsls	r3, r4, #4
    59ec:	eb0a 1404 	add.w	r4, sl, r4, lsl #4
				id_insert = insert_head;
    59f0:	46b9      	mov	r9, r7
				insert_head = ticker->next;
    59f2:	f81a 7003 	ldrb.w	r7, [sl, r3]
				user_op = NULL;
    59f6:	2500      	movs	r5, #0
	ticker->next = TICKER_NULL;
    59f8:	23ff      	movs	r3, #255	; 0xff
    59fa:	7023      	strb	r3, [r4, #0]
	(void)ticker_enqueue(instance, id_insert);
    59fc:	4649      	mov	r1, r9
    59fe:	9803      	ldr	r0, [sp, #12]
    5a00:	f008 fce4 	bl	e3cc <ticker_enqueue>
	ticker->req = ticker->ack + 1;
    5a04:	f994 3002 	ldrsb.w	r3, [r4, #2]
    5a08:	3301      	adds	r3, #1
    5a0a:	7063      	strb	r3, [r4, #1]
			if (user_op) {
    5a0c:	2d00      	cmp	r5, #0
    5a0e:	d1e2      	bne.n	59d6 <ticker_job+0x4d2>
    5a10:	e7e5      	b.n	59de <ticker_job+0x4da>
		       (user_ops_first != user->middle)) {
    5a12:	f898 3002 	ldrb.w	r3, [r8, #2]
		while ((insert_head != TICKER_NULL) ||
    5a16:	429e      	cmp	r6, r3
    5a18:	d1e3      	bne.n	59e2 <ticker_job+0x4de>
	while (count_user--) {
    5a1a:	465b      	mov	r3, fp
    5a1c:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
    5a20:	fa5f fb8b 	uxtb.w	fp, fp
    5a24:	b143      	cbz	r3, 5a38 <ticker_job+0x534>
		user = &users[count_user];
    5a26:	9b05      	ldr	r3, [sp, #20]
    5a28:	eb03 08cb 	add.w	r8, r3, fp, lsl #3
		user_ops = (void *)&user->user_op[0];
    5a2c:	f8d8 3004 	ldr.w	r3, [r8, #4]
    5a30:	9300      	str	r3, [sp, #0]
		user_ops_first = user->first;
    5a32:	f898 6001 	ldrb.w	r6, [r8, #1]
		while ((insert_head != TICKER_NULL) ||
    5a36:	e7d2      	b.n	59de <ticker_job+0x4da>
    5a38:	f8dd 900c 	ldr.w	r9, [sp, #12]
		if (ticker_job_reschedule_in_window(instance, ticks_elapsed)) {
    5a3c:	9902      	ldr	r1, [sp, #8]
    5a3e:	4648      	mov	r0, r9
    5a40:	f008 fda5 	bl	e58e <ticker_job_reschedule_in_window>
    5a44:	2800      	cmp	r0, #0
    5a46:	f000 8091 	beq.w	5b6c <ticker_job+0x668>
			flag_compare_update = 1U;
    5a4a:	9b01      	ldr	r3, [sp, #4]
    5a4c:	930a      	str	r3, [sp, #40]	; 0x28
    5a4e:	e08d      	b.n	5b6c <ticker_job+0x668>
	node = &instance->nodes[0];
    5a50:	f8d9 a000 	ldr.w	sl, [r9]
	users = &instance->users[0];
    5a54:	f8d9 3004 	ldr.w	r3, [r9, #4]
    5a58:	9303      	str	r3, [sp, #12]
	count_user = instance->count_user;
    5a5a:	f899 b009 	ldrb.w	fp, [r9, #9]
	while (count_user--) {
    5a5e:	9f00      	ldr	r7, [sp, #0]
    5a60:	f8cd 9008 	str.w	r9, [sp, #8]
    5a64:	e071      	b.n	5b4a <ticker_job+0x646>
				user_op = &user_ops[user_ops_first];
    5a66:	2334      	movs	r3, #52	; 0x34
    5a68:	fb03 f306 	mul.w	r3, r3, r6
    5a6c:	9a00      	ldr	r2, [sp, #0]
    5a6e:	18d5      	adds	r5, r2, r3
				first = user_ops_first + 1;
    5a70:	3601      	adds	r6, #1
    5a72:	b2f6      	uxtb	r6, r6
				if (first == user->count_user_op) {
    5a74:	f898 2000 	ldrb.w	r2, [r8]
    5a78:	4296      	cmp	r6, r2
    5a7a:	d039      	beq.n	5af0 <ticker_job+0x5ec>
				id_insert = user_op->id;
    5a7c:	f895 9001 	ldrb.w	r9, [r5, #1]
				ticker = &node[id_insert];
    5a80:	eb09 0449 	add.w	r4, r9, r9, lsl #1
    5a84:	eb0a 1404 	add.w	r4, sl, r4, lsl #4
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
    5a88:	9a00      	ldr	r2, [sp, #0]
    5a8a:	5cd3      	ldrb	r3, [r2, r3]
    5a8c:	2b04      	cmp	r3, #4
    5a8e:	d13e      	bne.n	5b0e <ticker_job+0x60a>
				if (((ticker->req -
    5a90:	7863      	ldrb	r3, [r4, #1]
				      ticker->ack) & 0xff) != 0U) {
    5a92:	78a2      	ldrb	r2, [r4, #2]
				if (((ticker->req -
    5a94:	1a9b      	subs	r3, r3, r2
    5a96:	f013 0fff 	tst.w	r3, #255	; 0xff
    5a9a:	d12b      	bne.n	5af4 <ticker_job+0x5f0>
				ticker_job_op_start(ticker, user_op,
    5a9c:	9b02      	ldr	r3, [sp, #8]
    5a9e:	6959      	ldr	r1, [r3, #20]
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
    5aa0:	8aaa      	ldrh	r2, [r5, #20]
    5aa2:	f64f 73ff 	movw	r3, #65535	; 0xffff
    5aa6:	429a      	cmp	r2, r3
    5aa8:	d029      	beq.n	5afe <ticker_job+0x5fa>
    5aaa:	9b01      	ldr	r3, [sp, #4]
    5aac:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
	ticker->ext_data = start->ext_data;
    5ab0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    5ab2:	62a3      	str	r3, [r4, #40]	; 0x28
	ticker->ticks_periodic = start->ticks_periodic;
    5ab4:	68eb      	ldr	r3, [r5, #12]
    5ab6:	6063      	str	r3, [r4, #4]
	ticker->remainder_periodic = start->remainder_periodic;
    5ab8:	692b      	ldr	r3, [r5, #16]
    5aba:	6223      	str	r3, [r4, #32]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
    5abc:	8aab      	ldrh	r3, [r5, #20]
    5abe:	f64f 72ff 	movw	r2, #65535	; 0xffff
    5ac2:	4293      	cmp	r3, r2
    5ac4:	d01d      	beq.n	5b02 <ticker_job+0x5fe>
    5ac6:	83a3      	strh	r3, [r4, #28]
	ticker->ticks_slot = start->ticks_slot;
    5ac8:	69ab      	ldr	r3, [r5, #24]
    5aca:	61a3      	str	r3, [r4, #24]
	ticker->timeout_func = start->fp_timeout_func;
    5acc:	69eb      	ldr	r3, [r5, #28]
    5ace:	60e3      	str	r3, [r4, #12]
	ticker->context = start->context;
    5ad0:	6a2b      	ldr	r3, [r5, #32]
    5ad2:	6123      	str	r3, [r4, #16]
	ticker->ticks_to_expire = start->ticks_first;
    5ad4:	68ab      	ldr	r3, [r5, #8]
    5ad6:	60a3      	str	r3, [r4, #8]
	ticker->ticks_to_expire_minus = 0U;
    5ad8:	2300      	movs	r3, #0
    5ada:	6163      	str	r3, [r4, #20]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
    5adc:	686a      	ldr	r2, [r5, #4]
    5ade:	4620      	mov	r0, r4
    5ae0:	f008 fed8 	bl	e894 <ticks_to_expire_prep>
	ticker->remainder_current = 0U;
    5ae4:	2300      	movs	r3, #0
    5ae6:	6263      	str	r3, [r4, #36]	; 0x24
	ticker->lazy_current = 0U;
    5ae8:	83e3      	strh	r3, [r4, #30]
	ticker->force = 1U;
    5aea:	2301      	movs	r3, #1
    5aec:	70e3      	strb	r3, [r4, #3]
}
    5aee:	e01b      	b.n	5b28 <ticker_job+0x624>
					first = 0U;
    5af0:	9e01      	ldr	r6, [sp, #4]
    5af2:	e7c3      	b.n	5a7c <ticker_job+0x578>
					ticker_job_op_cb(user_op,
    5af4:	2101      	movs	r1, #1
    5af6:	4628      	mov	r0, r5
    5af8:	f008 fd3e 	bl	e578 <ticker_job_op_cb>
					continue;
    5afc:	e007      	b.n	5b0e <ticker_job+0x60a>
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
    5afe:	2301      	movs	r3, #1
    5b00:	e7d4      	b.n	5aac <ticker_job+0x5a8>
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
    5b02:	2300      	movs	r3, #0
    5b04:	e7df      	b.n	5ac6 <ticker_job+0x5c2>
				ticker_job_op_cb(user_op, status);
    5b06:	2100      	movs	r1, #0
    5b08:	4628      	mov	r0, r5
    5b0a:	f008 fd35 	bl	e578 <ticker_job_op_cb>
		while ((insert_head != TICKER_NULL) ||
    5b0e:	2fff      	cmp	r7, #255	; 0xff
    5b10:	d017      	beq.n	5b42 <ticker_job+0x63e>
			if (insert_head != TICKER_NULL) {
    5b12:	2fff      	cmp	r7, #255	; 0xff
    5b14:	d0a7      	beq.n	5a66 <ticker_job+0x562>
				ticker = &node[id_insert];
    5b16:	eb07 0447 	add.w	r4, r7, r7, lsl #1
    5b1a:	0123      	lsls	r3, r4, #4
    5b1c:	eb0a 1404 	add.w	r4, sl, r4, lsl #4
				id_insert = insert_head;
    5b20:	46b9      	mov	r9, r7
				insert_head = ticker->next;
    5b22:	f81a 7003 	ldrb.w	r7, [sl, r3]
				user_op = NULL;
    5b26:	2500      	movs	r5, #0
	ticker->next = TICKER_NULL;
    5b28:	23ff      	movs	r3, #255	; 0xff
    5b2a:	7023      	strb	r3, [r4, #0]
	(void)ticker_enqueue(instance, id_insert);
    5b2c:	4649      	mov	r1, r9
    5b2e:	9802      	ldr	r0, [sp, #8]
    5b30:	f008 fc4c 	bl	e3cc <ticker_enqueue>
	ticker->req = ticker->ack + 1;
    5b34:	f994 3002 	ldrsb.w	r3, [r4, #2]
    5b38:	3301      	adds	r3, #1
    5b3a:	7063      	strb	r3, [r4, #1]
			if (user_op) {
    5b3c:	2d00      	cmp	r5, #0
    5b3e:	d1e2      	bne.n	5b06 <ticker_job+0x602>
    5b40:	e7e5      	b.n	5b0e <ticker_job+0x60a>
		       (user_ops_first != user->middle)) {
    5b42:	f898 3002 	ldrb.w	r3, [r8, #2]
		while ((insert_head != TICKER_NULL) ||
    5b46:	429e      	cmp	r6, r3
    5b48:	d1e3      	bne.n	5b12 <ticker_job+0x60e>
	while (count_user--) {
    5b4a:	465b      	mov	r3, fp
    5b4c:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
    5b50:	fa5f fb8b 	uxtb.w	fp, fp
    5b54:	b143      	cbz	r3, 5b68 <ticker_job+0x664>
		user = &users[count_user];
    5b56:	9b03      	ldr	r3, [sp, #12]
    5b58:	eb03 08cb 	add.w	r8, r3, fp, lsl #3
		user_ops = (void *)&user->user_op[0];
    5b5c:	f8d8 3004 	ldr.w	r3, [r8, #4]
    5b60:	9300      	str	r3, [sp, #0]
		user_ops_first = user->first;
    5b62:	f898 6001 	ldrb.w	r6, [r8, #1]
		while ((insert_head != TICKER_NULL) ||
    5b66:	e7d2      	b.n	5b0e <ticker_job+0x60a>
    5b68:	f8dd 9008 	ldr.w	r9, [sp, #8]
	if (instance->ticker_id_head != ticker_id_old_head) {
    5b6c:	f899 301d 	ldrb.w	r3, [r9, #29]
    5b70:	9a08      	ldr	r2, [sp, #32]
    5b72:	4293      	cmp	r3, r2
    5b74:	d001      	beq.n	5b7a <ticker_job+0x676>
		flag_compare_update = 1U;
    5b76:	2301      	movs	r3, #1
    5b78:	930a      	str	r3, [sp, #40]	; 0x28
	if (!pending) {
    5b7a:	9b04      	ldr	r3, [sp, #16]
    5b7c:	b193      	cbz	r3, 5ba4 <ticker_job+0x6a0>
	instance->job_guard = 0U;
    5b7e:	2300      	movs	r3, #0
    5b80:	f889 301e 	strb.w	r3, [r9, #30]
	if (flag_compare_update) {
    5b84:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5b86:	2b00      	cmp	r3, #0
    5b88:	d156      	bne.n	5c38 <ticker_job+0x734>
	if (instance->worker_trigger) {
    5b8a:	f899 301f 	ldrb.w	r3, [r9, #31]
    5b8e:	b133      	cbz	r3, 5b9e <ticker_job+0x69a>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
    5b90:	f8d9 4024 	ldr.w	r4, [r9, #36]	; 0x24
    5b94:	464b      	mov	r3, r9
    5b96:	2201      	movs	r2, #1
    5b98:	2103      	movs	r1, #3
    5b9a:	2004      	movs	r0, #4
    5b9c:	47a0      	blx	r4
}
    5b9e:	b00d      	add	sp, #52	; 0x34
    5ba0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	users = &instance->users[0];
    5ba4:	f8d9 8004 	ldr.w	r8, [r9, #4]
	count_user = instance->count_user;
    5ba8:	f899 6009 	ldrb.w	r6, [r9, #9]
	while (count_user--) {
    5bac:	4633      	mov	r3, r6
    5bae:	3e01      	subs	r6, #1
    5bb0:	b2f6      	uxtb	r6, r6
    5bb2:	2b00      	cmp	r3, #0
    5bb4:	d0e3      	beq.n	5b7e <ticker_job+0x67a>
		user = &users[count_user];
    5bb6:	eb08 05c6 	add.w	r5, r8, r6, lsl #3
		user_op = &user->user_op[0];
    5bba:	686f      	ldr	r7, [r5, #4]
		while (user->first != user->last) {
    5bbc:	e024      	b.n	5c08 <ticker_job+0x704>
		ticker_by_next_slot_get(instance,
    5bbe:	68e3      	ldr	r3, [r4, #12]
    5bc0:	68a2      	ldr	r2, [r4, #8]
    5bc2:	6861      	ldr	r1, [r4, #4]
    5bc4:	4648      	mov	r0, r9
    5bc6:	f008 fbd1 	bl	e36c <ticker_by_next_slot_get>
		uop->status = TICKER_STATUS_SUCCESS;
    5bca:	2300      	movs	r3, #0
    5bcc:	62a3      	str	r3, [r4, #40]	; 0x28
		fp_op_func = uop->fp_op_func;
    5bce:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	if (fp_op_func) {
    5bd0:	b34b      	cbz	r3, 5c26 <ticker_job+0x722>
		fp_op_func(uop->status, uop->op_context);
    5bd2:	6b21      	ldr	r1, [r4, #48]	; 0x30
    5bd4:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    5bd6:	4798      	blx	r3
    5bd8:	e025      	b.n	5c26 <ticker_job+0x722>
		if (uop->id < instance->count_node) {
    5bda:	7863      	ldrb	r3, [r4, #1]
    5bdc:	f899 2008 	ldrb.w	r2, [r9, #8]
    5be0:	4293      	cmp	r3, r2
    5be2:	d20d      	bcs.n	5c00 <ticker_job+0x6fc>
			struct ticker_node *node = instance->nodes;
    5be4:	f8d9 2000 	ldr.w	r2, [r9]
			node[uop->id].priority =
    5be8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    5bec:	eb02 1303 	add.w	r3, r2, r3, lsl #4
				uop->params.priority_set.priority;
    5bf0:	f994 2004 	ldrsb.w	r2, [r4, #4]
			node[uop->id].priority =
    5bf4:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
			uop->status = TICKER_STATUS_SUCCESS;
    5bf8:	2300      	movs	r3, #0
    5bfa:	62a3      	str	r3, [r4, #40]	; 0x28
		fp_op_func = uop->fp_op_func;
    5bfc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
		break;
    5bfe:	e7e7      	b.n	5bd0 <ticker_job+0x6cc>
			uop->status = TICKER_STATUS_FAILURE;
    5c00:	2301      	movs	r3, #1
    5c02:	62a3      	str	r3, [r4, #40]	; 0x28
    5c04:	e7fa      	b.n	5bfc <ticker_job+0x6f8>
			user->first = first;
    5c06:	706b      	strb	r3, [r5, #1]
		while (user->first != user->last) {
    5c08:	786a      	ldrb	r2, [r5, #1]
    5c0a:	78eb      	ldrb	r3, [r5, #3]
    5c0c:	429a      	cmp	r2, r3
    5c0e:	d0cd      	beq.n	5bac <ticker_job+0x6a8>
			ticker_job_op_inquire(instance, &user_op[user->first]);
    5c10:	2334      	movs	r3, #52	; 0x34
    5c12:	fb03 f302 	mul.w	r3, r3, r2
    5c16:	18fc      	adds	r4, r7, r3
	switch (uop->op) {
    5c18:	5cfb      	ldrb	r3, [r7, r3]
    5c1a:	2b02      	cmp	r3, #2
    5c1c:	d0cf      	beq.n	5bbe <ticker_job+0x6ba>
    5c1e:	2b03      	cmp	r3, #3
    5c20:	d0db      	beq.n	5bda <ticker_job+0x6d6>
    5c22:	2b01      	cmp	r3, #1
    5c24:	d0d1      	beq.n	5bca <ticker_job+0x6c6>
			first = user->first + 1;
    5c26:	f995 3001 	ldrsb.w	r3, [r5, #1]
    5c2a:	3301      	adds	r3, #1
    5c2c:	b2db      	uxtb	r3, r3
			if (first == user->count_user_op) {
    5c2e:	782a      	ldrb	r2, [r5, #0]
    5c30:	4293      	cmp	r3, r2
    5c32:	d1e8      	bne.n	5c06 <ticker_job+0x702>
				first = 0U;
    5c34:	9b04      	ldr	r3, [sp, #16]
    5c36:	e7e6      	b.n	5c06 <ticker_job+0x702>
	if (instance->ticker_id_head == TICKER_NULL) {
    5c38:	f899 301d 	ldrb.w	r3, [r9, #29]
    5c3c:	2bff      	cmp	r3, #255	; 0xff
    5c3e:	d00e      	beq.n	5c5e <ticker_job+0x75a>
	if (ticker_id_old_head == TICKER_NULL) {
    5c40:	9b08      	ldr	r3, [sp, #32]
    5c42:	2bff      	cmp	r3, #255	; 0xff
    5c44:	d017      	beq.n	5c76 <ticker_job+0x772>
	ticker = &instance->nodes[instance->ticker_id_head];
    5c46:	f8d9 2000 	ldr.w	r2, [r9]
    5c4a:	f899 301d 	ldrb.w	r3, [r9, #29]
    5c4e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    5c52:	eb02 1303 	add.w	r3, r2, r3, lsl #4
	ticks_to_expire = ticker->ticks_to_expire;
    5c56:	f8d3 8008 	ldr.w	r8, [r3, #8]
	i = 10U;
    5c5a:	270a      	movs	r7, #10
    5c5c:	e043      	b.n	5ce6 <ticker_job+0x7e2>
		if (cntr_stop() == 0) {
    5c5e:	f002 fb0d 	bl	827c <cntr_stop>
    5c62:	2800      	cmp	r0, #0
    5c64:	d191      	bne.n	5b8a <ticker_job+0x686>
			instance->ticks_slot_previous = 0U;
    5c66:	2300      	movs	r3, #0
    5c68:	f8c9 3018 	str.w	r3, [r9, #24]
			instance->ticks_current = cntr_cnt_get();
    5c6c:	f002 fb2e 	bl	82cc <cntr_cnt_get>
    5c70:	f8c9 0014 	str.w	r0, [r9, #20]
		return;
    5c74:	e789      	b.n	5b8a <ticker_job+0x686>
		ticks_current = cntr_cnt_get();
    5c76:	f002 fb29 	bl	82cc <cntr_cnt_get>
    5c7a:	4604      	mov	r4, r0
		if (cntr_start() == 0) {
    5c7c:	f002 faee 	bl	825c <cntr_start>
    5c80:	2800      	cmp	r0, #0
    5c82:	d1e0      	bne.n	5c46 <ticker_job+0x742>
			instance->ticks_current = ticks_current;
    5c84:	f8c9 4014 	str.w	r4, [r9, #20]
    5c88:	e7dd      	b.n	5c46 <ticker_job+0x742>
		LL_ASSERT(i);
    5c8a:	f640 0371 	movw	r3, #2161	; 0x871
    5c8e:	4a17      	ldr	r2, [pc, #92]	; (5cec <ticker_job+0x7e8>)
    5c90:	4917      	ldr	r1, [pc, #92]	; (5cf0 <ticker_job+0x7ec>)
    5c92:	4818      	ldr	r0, [pc, #96]	; (5cf4 <ticker_job+0x7f0>)
    5c94:	f007 f9cb 	bl	d02e <printk>
    5c98:	4040      	eors	r0, r0
    5c9a:	f380 8811 	msr	BASEPRI, r0
    5c9e:	f04f 0003 	mov.w	r0, #3
    5ca2:	df02      	svc	2
		i--;
    5ca4:	3f01      	subs	r7, #1
		ctr = cntr_cnt_get();
    5ca6:	f002 fb11 	bl	82cc <cntr_cnt_get>
    5caa:	4605      	mov	r5, r0
		cc = instance->ticks_current;
    5cac:	f8d9 4014 	ldr.w	r4, [r9, #20]
		ticks_elapsed = ticker_ticks_diff_get(ctr, cc) +
    5cb0:	4621      	mov	r1, r4
    5cb2:	f008 fd33 	bl	e71c <ticker_ticks_diff_get>
    5cb6:	3003      	adds	r0, #3
		cc += MAX(ticks_elapsed, ticks_to_expire);
    5cb8:	4580      	cmp	r8, r0
    5cba:	bf2c      	ite	cs
    5cbc:	4444      	addcs	r4, r8
    5cbe:	1824      	addcc	r4, r4, r0
		cc &= HAL_TICKER_CNTR_MASK;
    5cc0:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
		instance->trigger_set_cb(cc);
    5cc4:	f8d9 3028 	ldr.w	r3, [r9, #40]	; 0x28
    5cc8:	4620      	mov	r0, r4
    5cca:	4798      	blx	r3
		ctr_post = cntr_cnt_get();
    5ccc:	f002 fafe 	bl	82cc <cntr_cnt_get>
	} while ((ticker_ticks_diff_get(ctr_post, ctr) +
    5cd0:	4629      	mov	r1, r5
    5cd2:	f008 fd23 	bl	e71c <ticker_ticks_diff_get>
    5cd6:	1cc6      	adds	r6, r0, #3
		  ticker_ticks_diff_get(cc, ctr));
    5cd8:	4629      	mov	r1, r5
    5cda:	4620      	mov	r0, r4
    5cdc:	f008 fd1e 	bl	e71c <ticker_ticks_diff_get>
    5ce0:	4286      	cmp	r6, r0
    5ce2:	f67f af52 	bls.w	5b8a <ticker_job+0x686>
		LL_ASSERT(i);
    5ce6:	2f00      	cmp	r7, #0
    5ce8:	d1dc      	bne.n	5ca4 <ticker_job+0x7a0>
    5cea:	e7ce      	b.n	5c8a <ticker_job+0x786>
    5cec:	00012420 	.word	0x00012420
    5cf0:	00012574 	.word	0x00012574
    5cf4:	00011fec 	.word	0x00011fec

00005cf8 <ll_addr_get>:
static u8_t pub_addr[BDADDR_SIZE];
static u8_t rnd_addr[BDADDR_SIZE];

u8_t *ll_addr_get(u8_t addr_type, u8_t *bdaddr)
{
	if (addr_type > 1) {
    5cf8:	2801      	cmp	r0, #1
    5cfa:	d810      	bhi.n	5d1e <ll_addr_get+0x26>
		return NULL;
	}

	if (addr_type) {
    5cfc:	b938      	cbnz	r0, 5d0e <ll_addr_get+0x16>
		}

		return rnd_addr;
	}

	if (bdaddr) {
    5cfe:	b181      	cbz	r1, 5d22 <ll_addr_get+0x2a>
    5d00:	4b09      	ldr	r3, [pc, #36]	; (5d28 <ll_addr_get+0x30>)
    5d02:	6818      	ldr	r0, [r3, #0]
    5d04:	6008      	str	r0, [r1, #0]
    5d06:	889a      	ldrh	r2, [r3, #4]
    5d08:	808a      	strh	r2, [r1, #4]
		memcpy(bdaddr, pub_addr, BDADDR_SIZE);
	}

	return pub_addr;
    5d0a:	4618      	mov	r0, r3
    5d0c:	4770      	bx	lr
		if (bdaddr) {
    5d0e:	b121      	cbz	r1, 5d1a <ll_addr_get+0x22>
    5d10:	4b06      	ldr	r3, [pc, #24]	; (5d2c <ll_addr_get+0x34>)
    5d12:	6818      	ldr	r0, [r3, #0]
    5d14:	6008      	str	r0, [r1, #0]
    5d16:	889b      	ldrh	r3, [r3, #4]
    5d18:	808b      	strh	r3, [r1, #4]
		return rnd_addr;
    5d1a:	4804      	ldr	r0, [pc, #16]	; (5d2c <ll_addr_get+0x34>)
    5d1c:	4770      	bx	lr
		return NULL;
    5d1e:	2000      	movs	r0, #0
    5d20:	4770      	bx	lr
	return pub_addr;
    5d22:	4801      	ldr	r0, [pc, #4]	; (5d28 <ll_addr_get+0x30>)
}
    5d24:	4770      	bx	lr
    5d26:	bf00      	nop
    5d28:	20004048 	.word	0x20004048
    5d2c:	20004050 	.word	0x20004050

00005d30 <ll_addr_set>:

u32_t ll_addr_set(u8_t addr_type, u8_t const *const bdaddr)
{
    5d30:	b538      	push	{r3, r4, r5, lr}
    5d32:	4605      	mov	r5, r0
    5d34:	460c      	mov	r4, r1
	    ull_adv_is_enabled(0)) {
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
	    (ull_scan_is_enabled(0) & (BIT(1) | BIT(2)))) {
    5d36:	2000      	movs	r0, #0
    5d38:	f009 f926 	bl	ef88 <ull_scan_is_enabled>
	if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
    5d3c:	f010 0306 	ands.w	r3, r0, #6
    5d40:	d10d      	bne.n	5d5e <ll_addr_set+0x2e>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	if (addr_type) {
    5d42:	b135      	cbz	r5, 5d52 <ll_addr_set+0x22>
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
    5d44:	4a07      	ldr	r2, [pc, #28]	; (5d64 <ll_addr_set+0x34>)
    5d46:	6820      	ldr	r0, [r4, #0]
    5d48:	6010      	str	r0, [r2, #0]
    5d4a:	88a1      	ldrh	r1, [r4, #4]
    5d4c:	8091      	strh	r1, [r2, #4]
	} else {
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
	}

	return 0;
}
    5d4e:	4618      	mov	r0, r3
    5d50:	bd38      	pop	{r3, r4, r5, pc}
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
    5d52:	4a05      	ldr	r2, [pc, #20]	; (5d68 <ll_addr_set+0x38>)
    5d54:	6820      	ldr	r0, [r4, #0]
    5d56:	6010      	str	r0, [r2, #0]
    5d58:	88a1      	ldrh	r1, [r4, #4]
    5d5a:	8091      	strh	r1, [r2, #4]
    5d5c:	e7f7      	b.n	5d4e <ll_addr_set+0x1e>
		return BT_HCI_ERR_CMD_DISALLOWED;
    5d5e:	230c      	movs	r3, #12
    5d60:	e7f5      	b.n	5d4e <ll_addr_set+0x1e>
    5d62:	bf00      	nop
    5d64:	20004050 	.word	0x20004050
    5d68:	20004048 	.word	0x20004048

00005d6c <hci_driver_init>:
	.open	= hci_driver_open,
	.send	= hci_driver_send,
};

static int hci_driver_init(struct device *unused)
{
    5d6c:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	bt_hci_driver_register(&drv);
    5d6e:	4802      	ldr	r0, [pc, #8]	; (5d78 <hci_driver_init+0xc>)
    5d70:	f7fe fe12 	bl	4998 <bt_hci_driver_register>

	return 0;
}
    5d74:	2000      	movs	r0, #0
    5d76:	bd08      	pop	{r3, pc}
    5d78:	000125a0 	.word	0x000125a0

00005d7c <cmd_handle>:
{
    5d7c:	b510      	push	{r4, lr}
    5d7e:	b082      	sub	sp, #8
	struct node_rx_pdu *node_rx = NULL;
    5d80:	2300      	movs	r3, #0
    5d82:	9301      	str	r3, [sp, #4]
	evt = hci_cmd_handle(buf, (void **) &node_rx);
    5d84:	a901      	add	r1, sp, #4
    5d86:	f000 fb01 	bl	638c <hci_cmd_handle>
	if (evt) {
    5d8a:	b158      	cbz	r0, 5da4 <cmd_handle+0x28>
		bt_recv_prio(evt);
    5d8c:	f7fe fd68 	bl	4860 <bt_recv_prio>
		if (node_rx) {
    5d90:	9c01      	ldr	r4, [sp, #4]
    5d92:	b13c      	cbz	r4, 5da4 <cmd_handle+0x28>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
    5d94:	4620      	mov	r0, r4
    5d96:	f009 f854 	bl	ee42 <hci_get_class>
    5d9a:	7160      	strb	r0, [r4, #5]
			k_fifo_put(&recv_fifo, node_rx);
    5d9c:	9901      	ldr	r1, [sp, #4]
    5d9e:	4803      	ldr	r0, [pc, #12]	; (5dac <cmd_handle+0x30>)
    5da0:	f00a f8ac 	bl	fefc <k_queue_append>
}
    5da4:	2000      	movs	r0, #0
    5da6:	b002      	add	sp, #8
    5da8:	bd10      	pop	{r4, pc}
    5daa:	bf00      	nop
    5dac:	200004c0 	.word	0x200004c0

00005db0 <hci_driver_send>:
{
    5db0:	b538      	push	{r3, r4, r5, lr}
	if (!buf->len) {
    5db2:	8983      	ldrh	r3, [r0, #12]
    5db4:	b143      	cbz	r3, 5dc8 <hci_driver_send+0x18>
    5db6:	4604      	mov	r4, r0
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
    5db8:	7d01      	ldrb	r1, [r0, #20]
	switch (type) {
    5dba:	b9c9      	cbnz	r1, 5df0 <hci_driver_send+0x40>
		err = cmd_handle(buf);
    5dbc:	f7ff ffde 	bl	5d7c <cmd_handle>
	if (!err) {
    5dc0:	4605      	mov	r5, r0
    5dc2:	b348      	cbz	r0, 5e18 <hci_driver_send+0x68>
}
    5dc4:	4628      	mov	r0, r5
    5dc6:	bd38      	pop	{r3, r4, r5, pc}
		BT_ERR("Empty HCI packet");
    5dc8:	f04f 0100 	mov.w	r1, #0
    5dcc:	2301      	movs	r3, #1
    5dce:	f363 0102 	bfi	r1, r3, #0, #3
    5dd2:	f36f 01c5 	bfc	r1, #3, #3
    5dd6:	4b12      	ldr	r3, [pc, #72]	; (5e20 <hci_driver_send+0x70>)
    5dd8:	4a12      	ldr	r2, [pc, #72]	; (5e24 <hci_driver_send+0x74>)
    5dda:	1a9b      	subs	r3, r3, r2
    5ddc:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    5de0:	f363 118f 	bfi	r1, r3, #6, #10
    5de4:	4810      	ldr	r0, [pc, #64]	; (5e28 <hci_driver_send+0x78>)
    5de6:	f7fb ff5b 	bl	1ca0 <log_0>
		return -EINVAL;
    5dea:	f06f 0515 	mvn.w	r5, #21
    5dee:	e7e9      	b.n	5dc4 <hci_driver_send+0x14>
		BT_ERR("Unknown HCI type %u", type);
    5df0:	f04f 0200 	mov.w	r2, #0
    5df4:	2301      	movs	r3, #1
    5df6:	f363 0202 	bfi	r2, r3, #0, #3
    5dfa:	f36f 02c5 	bfc	r2, #3, #3
    5dfe:	4b08      	ldr	r3, [pc, #32]	; (5e20 <hci_driver_send+0x70>)
    5e00:	4808      	ldr	r0, [pc, #32]	; (5e24 <hci_driver_send+0x74>)
    5e02:	1a1b      	subs	r3, r3, r0
    5e04:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    5e08:	f363 128f 	bfi	r2, r3, #6, #10
    5e0c:	4807      	ldr	r0, [pc, #28]	; (5e2c <hci_driver_send+0x7c>)
    5e0e:	f7fb fdd7 	bl	19c0 <log_1>
		return -EINVAL;
    5e12:	f06f 0515 	mvn.w	r5, #21
    5e16:	e7d5      	b.n	5dc4 <hci_driver_send+0x14>
		net_buf_unref(buf);
    5e18:	4620      	mov	r0, r4
    5e1a:	f009 fc15 	bl	f648 <net_buf_unref>
    5e1e:	e7d1      	b.n	5dc4 <hci_driver_send+0x14>
    5e20:	00010c48 	.word	0x00010c48
    5e24:	00010c18 	.word	0x00010c18
    5e28:	000124a8 	.word	0x000124a8
    5e2c:	000124bc 	.word	0x000124bc

00005e30 <recv_thread>:
{
    5e30:	b510      	push	{r4, lr}
    5e32:	b082      	sub	sp, #8
    5e34:	e022      	b.n	5e7c <recv_thread+0x4c>
			buf = bt_buf_get_evt(BT_HCI_EVT_UNKNOWN, true,
    5e36:	2200      	movs	r2, #0
    5e38:	2300      	movs	r3, #0
    5e3a:	2101      	movs	r1, #1
    5e3c:	2000      	movs	r0, #0
    5e3e:	f7ff f8bd 	bl	4fbc <bt_buf_get_evt>
    5e42:	4604      	mov	r4, r0
    5e44:	e033      	b.n	5eae <recv_thread+0x7e>
		LL_ASSERT(0);
    5e46:	23b4      	movs	r3, #180	; 0xb4
    5e48:	4a1e      	ldr	r2, [pc, #120]	; (5ec4 <recv_thread+0x94>)
    5e4a:	491f      	ldr	r1, [pc, #124]	; (5ec8 <recv_thread+0x98>)
    5e4c:	481f      	ldr	r0, [pc, #124]	; (5ecc <recv_thread+0x9c>)
    5e4e:	f007 f8ee 	bl	d02e <printk>
    5e52:	4040      	eors	r0, r0
    5e54:	f380 8811 	msr	BASEPRI, r0
    5e58:	f04f 0003 	mov.w	r0, #3
    5e5c:	df02      	svc	2
	struct net_buf *buf = NULL;
    5e5e:	2400      	movs	r4, #0
	node_rx->hdr.next = NULL;
    5e60:	9b01      	ldr	r3, [sp, #4]
    5e62:	2200      	movs	r2, #0
    5e64:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
    5e66:	a801      	add	r0, sp, #4
    5e68:	f000 fdc6 	bl	69f8 <ll_rx_mem_release>
		if (buf) {
    5e6c:	b124      	cbz	r4, 5e78 <recv_thread+0x48>
			if (buf->len) {
    5e6e:	89a3      	ldrh	r3, [r4, #12]
    5e70:	b323      	cbz	r3, 5ebc <recv_thread+0x8c>
				bt_recv(buf);
    5e72:	4620      	mov	r0, r4
    5e74:	f7fe fcce 	bl	4814 <bt_recv>
	z_impl_k_yield();
    5e78:	f005 f97a 	bl	b170 <z_impl_k_yield>
	return z_impl_k_queue_get(queue, timeout);
    5e7c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    5e80:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5e84:	4812      	ldr	r0, [pc, #72]	; (5ed0 <recv_thread+0xa0>)
    5e86:	f004 fe2d 	bl	aae4 <z_impl_k_queue_get>
		if (node_rx && !buf) {
    5e8a:	2800      	cmp	r0, #0
    5e8c:	d0f4      	beq.n	5e78 <recv_thread+0x48>
	buf = encode_node(node_rx, class);
    5e8e:	f990 2005 	ldrsb.w	r2, [r0, #5]
    5e92:	9001      	str	r0, [sp, #4]
	switch (class) {
    5e94:	1e53      	subs	r3, r2, #1
    5e96:	2b03      	cmp	r3, #3
    5e98:	d8d5      	bhi.n	5e46 <recv_thread+0x16>
		if (class == HCI_CLASS_EVT_DISCARDABLE) {
    5e9a:	2a02      	cmp	r2, #2
    5e9c:	d0cb      	beq.n	5e36 <recv_thread+0x6>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    5e9e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    5ea2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5ea6:	2001      	movs	r0, #1
    5ea8:	f7ff f850 	bl	4f4c <bt_buf_get_rx>
    5eac:	4604      	mov	r4, r0
		if (buf) {
    5eae:	2c00      	cmp	r4, #0
    5eb0:	d0d6      	beq.n	5e60 <recv_thread+0x30>
			hci_evt_encode(node_rx, buf);
    5eb2:	4621      	mov	r1, r4
    5eb4:	9801      	ldr	r0, [sp, #4]
    5eb6:	f008 ffb3 	bl	ee20 <hci_evt_encode>
    5eba:	e7d1      	b.n	5e60 <recv_thread+0x30>
				net_buf_unref(buf);
    5ebc:	4620      	mov	r0, r4
    5ebe:	f009 fbc3 	bl	f648 <net_buf_unref>
    5ec2:	e7d9      	b.n	5e78 <recv_thread+0x48>
    5ec4:	000124d0 	.word	0x000124d0
    5ec8:	00010df0 	.word	0x00010df0
    5ecc:	00011fec 	.word	0x00011fec
    5ed0:	200004c0 	.word	0x200004c0

00005ed4 <prio_recv_thread>:
{
    5ed4:	b530      	push	{r4, r5, lr}
    5ed6:	b083      	sub	sp, #12
    5ed8:	e003      	b.n	5ee2 <prio_recv_thread+0xe>
				k_fifo_put(&recv_fifo, node_rx);
    5eda:	4621      	mov	r1, r4
    5edc:	4815      	ldr	r0, [pc, #84]	; (5f34 <prio_recv_thread+0x60>)
    5ede:	f00a f80d 	bl	fefc <k_queue_append>
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
    5ee2:	f10d 0102 	add.w	r1, sp, #2
    5ee6:	a801      	add	r0, sp, #4
    5ee8:	f000 fd22 	bl	6930 <ll_rx_get>
    5eec:	2800      	cmp	r0, #0
    5eee:	d1f8      	bne.n	5ee2 <prio_recv_thread+0xe>
		if (node_rx) {
    5ef0:	9b01      	ldr	r3, [sp, #4]
    5ef2:	b1b3      	cbz	r3, 5f22 <prio_recv_thread+0x4e>
			ll_rx_dequeue();
    5ef4:	f000 fd30 	bl	6958 <ll_rx_dequeue>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
    5ef8:	9c01      	ldr	r4, [sp, #4]
    5efa:	4620      	mov	r0, r4
    5efc:	f008 ffa1 	bl	ee42 <hci_get_class>
    5f00:	7160      	strb	r0, [r4, #5]
			buf = process_prio_evt(node_rx);
    5f02:	9c01      	ldr	r4, [sp, #4]
    5f04:	4620      	mov	r0, r4
    5f06:	f008 fcec 	bl	e8e2 <process_prio_evt>
			if (buf) {
    5f0a:	4605      	mov	r5, r0
    5f0c:	2800      	cmp	r0, #0
    5f0e:	d0e4      	beq.n	5eda <prio_recv_thread+0x6>
				node_rx->hdr.next = NULL;
    5f10:	2300      	movs	r3, #0
    5f12:	6023      	str	r3, [r4, #0]
				ll_rx_mem_release((void **)&node_rx);
    5f14:	a801      	add	r0, sp, #4
    5f16:	f000 fd6f 	bl	69f8 <ll_rx_mem_release>
				bt_recv_prio(buf);
    5f1a:	4628      	mov	r0, r5
    5f1c:	f7fe fca0 	bl	4860 <bt_recv_prio>
    5f20:	e7df      	b.n	5ee2 <prio_recv_thread+0xe>
	return z_impl_k_sem_take(sem, timeout);
    5f22:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    5f26:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5f2a:	4803      	ldr	r0, [pc, #12]	; (5f38 <prio_recv_thread+0x64>)
    5f2c:	f005 fa0e 	bl	b34c <z_impl_k_sem_take>
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
    5f30:	e7d7      	b.n	5ee2 <prio_recv_thread+0xe>
    5f32:	bf00      	nop
    5f34:	200004c0 	.word	0x200004c0
    5f38:	20000468 	.word	0x20000468

00005f3c <hci_driver_open>:
{
    5f3c:	b5f0      	push	{r4, r5, r6, r7, lr}
    5f3e:	b089      	sub	sp, #36	; 0x24
	err = ll_init(&sem_prio_recv);
    5f40:	4825      	ldr	r0, [pc, #148]	; (5fd8 <hci_driver_open+0x9c>)
    5f42:	f000 fad3 	bl	64ec <ll_init>
	if (err) {
    5f46:	2800      	cmp	r0, #0
    5f48:	d132      	bne.n	5fb0 <hci_driver_open+0x74>
	hci_init(NULL);
    5f4a:	2000      	movs	r0, #0
    5f4c:	f008 ff84 	bl	ee58 <hci_init>
	k_thread_create(&prio_recv_thread_data, prio_recv_thread_stack,
    5f50:	2600      	movs	r6, #0
    5f52:	2700      	movs	r7, #0
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    5f54:	4d21      	ldr	r5, [pc, #132]	; (5fdc <hci_driver_open+0xa0>)
    5f56:	e9cd 6706 	strd	r6, r7, [sp, #24]
    5f5a:	2400      	movs	r4, #0
    5f5c:	9404      	str	r4, [sp, #16]
    5f5e:	f06f 0309 	mvn.w	r3, #9
    5f62:	9303      	str	r3, [sp, #12]
    5f64:	9402      	str	r4, [sp, #8]
    5f66:	9401      	str	r4, [sp, #4]
    5f68:	9400      	str	r4, [sp, #0]
    5f6a:	4b1d      	ldr	r3, [pc, #116]	; (5fe0 <hci_driver_open+0xa4>)
    5f6c:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
    5f70:	491c      	ldr	r1, [pc, #112]	; (5fe4 <hci_driver_open+0xa8>)
    5f72:	4628      	mov	r0, r5
    5f74:	f00a f9bb 	bl	102ee <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    5f78:	491b      	ldr	r1, [pc, #108]	; (5fe8 <hci_driver_open+0xac>)
    5f7a:	4628      	mov	r0, r5
    5f7c:	f00a f9a6 	bl	102cc <z_impl_k_thread_name_set>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    5f80:	4d1a      	ldr	r5, [pc, #104]	; (5fec <hci_driver_open+0xb0>)
    5f82:	e9cd 6706 	strd	r6, r7, [sp, #24]
    5f86:	9404      	str	r4, [sp, #16]
    5f88:	f06f 0307 	mvn.w	r3, #7
    5f8c:	9303      	str	r3, [sp, #12]
    5f8e:	9402      	str	r4, [sp, #8]
    5f90:	9401      	str	r4, [sp, #4]
    5f92:	9400      	str	r4, [sp, #0]
    5f94:	4b16      	ldr	r3, [pc, #88]	; (5ff0 <hci_driver_open+0xb4>)
    5f96:	f44f 6280 	mov.w	r2, #1024	; 0x400
    5f9a:	4916      	ldr	r1, [pc, #88]	; (5ff4 <hci_driver_open+0xb8>)
    5f9c:	4628      	mov	r0, r5
    5f9e:	f00a f9a6 	bl	102ee <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    5fa2:	4915      	ldr	r1, [pc, #84]	; (5ff8 <hci_driver_open+0xbc>)
    5fa4:	4628      	mov	r0, r5
    5fa6:	f00a f991 	bl	102cc <z_impl_k_thread_name_set>
}
    5faa:	4620      	mov	r0, r4
    5fac:	b009      	add	sp, #36	; 0x24
    5fae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5fb0:	4604      	mov	r4, r0
		BT_ERR("LL initialization failed: %d", err);
    5fb2:	f04f 0200 	mov.w	r2, #0
    5fb6:	2301      	movs	r3, #1
    5fb8:	f363 0202 	bfi	r2, r3, #0, #3
    5fbc:	f36f 02c5 	bfc	r2, #3, #3
    5fc0:	4b0e      	ldr	r3, [pc, #56]	; (5ffc <hci_driver_open+0xc0>)
    5fc2:	490f      	ldr	r1, [pc, #60]	; (6000 <hci_driver_open+0xc4>)
    5fc4:	1a5b      	subs	r3, r3, r1
    5fc6:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    5fca:	f363 128f 	bfi	r2, r3, #6, #10
    5fce:	4601      	mov	r1, r0
    5fd0:	480c      	ldr	r0, [pc, #48]	; (6004 <hci_driver_open+0xc8>)
    5fd2:	f7fb fcf5 	bl	19c0 <log_1>
		return err;
    5fd6:	e7e8      	b.n	5faa <hci_driver_open+0x6e>
    5fd8:	20000468 	.word	0x20000468
    5fdc:	20004058 	.word	0x20004058
    5fe0:	00005ed5 	.word	0x00005ed5
    5fe4:	20005ee0 	.word	0x20005ee0
    5fe8:	0001256c 	.word	0x0001256c
    5fec:	200040cc 	.word	0x200040cc
    5ff0:	00005e31 	.word	0x00005e31
    5ff4:	200060a0 	.word	0x200060a0
    5ff8:	00012578 	.word	0x00012578
    5ffc:	00010c48 	.word	0x00010c48
    6000:	00010c18 	.word	0x00010c18
    6004:	0001254c 	.word	0x0001254c

00006008 <enquque_dfe_data_packet>:
 *
 * @param node_rx	radio RX node that stores IQ samples data
 *
 */
static void enquque_dfe_data_packet(struct node_rx_pdu *node_rx)
{
    6008:	b510      	push	{r4, lr}
    600a:	4604      	mov	r4, r0
	struct pdu_adv * pdu_adv= (void *)PDU_DATA(node_rx);
	if(memcmp(dfe_addr,pdu_adv->adv_ind.addr,6)) return;
    600c:	2206      	movs	r2, #6
    600e:	f100 01b6 	add.w	r1, r0, #182	; 0xb6
    6012:	4808      	ldr	r0, [pc, #32]	; (6034 <enquque_dfe_data_packet+0x2c>)
    6014:	f00a fab7 	bl	10586 <memcmp>
    6018:	b958      	cbnz	r0, 6032 <enquque_dfe_data_packet+0x2a>

#if IS_ENABLED(CONFIG_BT_CTLR_DFE_RX)
static inline struct dfe_packet *dfe_data(struct node_rx_pdu *node_rx)
{
#if IS_ENABLED(CONFIG_BT_LL_SW_SPLIT)
	return &node_rx->df_data_packet;
    601a:	3420      	adds	r4, #32
	return z_impl_k_msgq_put(msgq, data, timeout);
    601c:	2200      	movs	r2, #0
    601e:	2300      	movs	r3, #0
    6020:	4621      	mov	r1, r4
    6022:	4805      	ldr	r0, [pc, #20]	; (6038 <enquque_dfe_data_packet+0x30>)
    6024:	f004 fbd6 	bl	a7d4 <z_impl_k_msgq_put>
	struct dfe_packet *df_data_packet = dfe_data(node_rx);
	while (k_msgq_put(&df_packet_msgq, df_data_packet, K_NO_WAIT) != 0)
    6028:	b118      	cbz	r0, 6032 <enquque_dfe_data_packet+0x2a>
	z_impl_k_msgq_purge(msgq);
    602a:	4803      	ldr	r0, [pc, #12]	; (6038 <enquque_dfe_data_packet+0x30>)
    602c:	f009 fea4 	bl	fd78 <z_impl_k_msgq_purge>
}
    6030:	e7f4      	b.n	601c <enquque_dfe_data_packet+0x14>
	{
		k_msgq_purge(&df_packet_msgq);
	}
}
    6032:	bd10      	pop	{r4, pc}
    6034:	00012684 	.word	0x00012684
    6038:	200004d8 	.word	0x200004d8

0000603c <le_advertising_report>:
#endif /* CONFIG_BT_HCI_MESH_EXT */

static void le_advertising_report(struct pdu_data *pdu_data,
				  struct node_rx_pdu *node_rx,
				  struct net_buf *buf)
{
    603c:	b5f0      	push	{r4, r5, r6, r7, lr}
    603e:	b083      	sub	sp, #12
    6040:	4604      	mov	r4, r0
    6042:	460d      	mov	r5, r1
    6044:	4617      	mov	r7, r2
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
    6046:	4b59      	ldr	r3, [pc, #356]	; (61ac <le_advertising_report+0x170>)
    6048:	e893 0003 	ldmia.w	r3, {r0, r1}
    604c:	9000      	str	r0, [sp, #0]
    604e:	f8ad 1004 	strh.w	r1, [sp, #4]
    6052:	0c09      	lsrs	r1, r1, #16
    6054:	f88d 1006 	strb.w	r1, [sp, #6]
	u8_t direct;
#endif /* CONFIG_BT_CTLR_EXT_SCAN_FP */
	s8_t *prssi;

#if defined(CONFIG_BT_LL_SW_SPLIT)
	rssi = -(node_rx->hdr.rx_ftr.rssi);
    6058:	7f2b      	ldrb	r3, [r5, #28]
    605a:	425b      	negs	r3, r3
    605c:	b25e      	sxtb	r6, r3
		le_mesh_scan_report(adv, node_rx, buf, rssi);
		return;
	}
#endif /* CONFIG_BT_HCI_MESH_EXT */

	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    605e:	4b54      	ldr	r3, [pc, #336]	; (61b0 <le_advertising_report+0x174>)
    6060:	6859      	ldr	r1, [r3, #4]
    6062:	2200      	movs	r2, #0
    6064:	f001 5300 	and.w	r3, r1, #536870912	; 0x20000000
    6068:	4313      	orrs	r3, r2
    606a:	d006      	beq.n	607a <le_advertising_report+0x3e>
	    !(le_event_mask & BT_EVT_MASK_LE_ADVERTISING_REPORT)) {
    606c:	4b51      	ldr	r3, [pc, #324]	; (61b4 <le_advertising_report+0x178>)
    606e:	6819      	ldr	r1, [r3, #0]
    6070:	f001 0202 	and.w	r2, r1, #2
    6074:	2300      	movs	r3, #0
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    6076:	4313      	orrs	r3, r2
    6078:	d101      	bne.n	607e <le_advertising_report+0x42>
	adv_info->length = data_len;
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
	/* RSSI */
	prssi = &adv_info->data[0] + data_len;
	*prssi = rssi;
}
    607a:	b003      	add	sp, #12
    607c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (dup_count >= 0) {
    607e:	4b4e      	ldr	r3, [pc, #312]	; (61b8 <le_advertising_report+0x17c>)
    6080:	681b      	ldr	r3, [r3, #0]
    6082:	2b00      	cmp	r3, #0
    6084:	db01      	blt.n	608a <le_advertising_report+0x4e>
		for (i = 0; i < dup_count; i++) {
    6086:	2500      	movs	r5, #0
    6088:	e034      	b.n	60f4 <le_advertising_report+0xb8>
	return false;
    608a:	2300      	movs	r3, #0
	if (dup_found(adv)) {
    608c:	2b00      	cmp	r3, #0
    608e:	d1f4      	bne.n	607a <le_advertising_report+0x3e>
	if (adv->type != PDU_ADV_TYPE_DIRECT_IND) {
    6090:	7823      	ldrb	r3, [r4, #0]
    6092:	f003 030f 	and.w	r3, r3, #15
    6096:	2b01      	cmp	r3, #1
    6098:	f000 8085 	beq.w	61a6 <le_advertising_report+0x16a>
		data_len = (adv->len - BDADDR_SIZE);
    609c:	f994 5001 	ldrsb.w	r5, [r4, #1]
    60a0:	3d06      	subs	r5, #6
    60a2:	b2ed      	uxtb	r5, r5
	sep = meta_evt(buf, BT_HCI_EVT_LE_ADVERTISING_REPORT,
    60a4:	f105 020b 	add.w	r2, r5, #11
    60a8:	b2d2      	uxtb	r2, r2
    60aa:	2102      	movs	r1, #2
    60ac:	4638      	mov	r0, r7
    60ae:	f008 fc2a 	bl	e906 <meta_evt>
	sep->num_reports = 1U;
    60b2:	2301      	movs	r3, #1
    60b4:	7003      	strb	r3, [r0, #0]
	adv_info->evt_type = c_adv_type[adv->type];
    60b6:	7823      	ldrb	r3, [r4, #0]
    60b8:	f003 030f 	and.w	r3, r3, #15
    60bc:	aa02      	add	r2, sp, #8
    60be:	4413      	add	r3, r2
    60c0:	f813 3c08 	ldrb.w	r3, [r3, #-8]
    60c4:	7043      	strb	r3, [r0, #1]
		adv_info->addr.type = adv->tx_addr;
    60c6:	4621      	mov	r1, r4
    60c8:	f811 3b08 	ldrb.w	r3, [r1], #8
    60cc:	f3c3 1380 	ubfx	r3, r3, #6, #1
    60d0:	7083      	strb	r3, [r0, #2]
    60d2:	f854 3f02 	ldr.w	r3, [r4, #2]!
    60d6:	f8c0 3003 	str.w	r3, [r0, #3]
    60da:	88a3      	ldrh	r3, [r4, #4]
    60dc:	f8a0 3007 	strh.w	r3, [r0, #7]
	adv_info->length = data_len;
    60e0:	7245      	strb	r5, [r0, #9]
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
    60e2:	f100 040a 	add.w	r4, r0, #10
    60e6:	462a      	mov	r2, r5
    60e8:	4620      	mov	r0, r4
    60ea:	f00a fa5a 	bl	105a2 <memcpy>
	*prssi = rssi;
    60ee:	5566      	strb	r6, [r4, r5]
    60f0:	e7c3      	b.n	607a <le_advertising_report+0x3e>
		for (i = 0; i < dup_count; i++) {
    60f2:	3501      	adds	r5, #1
    60f4:	4b30      	ldr	r3, [pc, #192]	; (61b8 <le_advertising_report+0x17c>)
    60f6:	681b      	ldr	r3, [r3, #0]
    60f8:	429d      	cmp	r5, r3
    60fa:	da26      	bge.n	614a <le_advertising_report+0x10e>
				    &dup_filter[i].addr.a.val[0],
    60fc:	492f      	ldr	r1, [pc, #188]	; (61bc <le_advertising_report+0x180>)
    60fe:	eb01 01c5 	add.w	r1, r1, r5, lsl #3
			if (!memcmp(&adv->adv_ind.addr[0],
    6102:	2206      	movs	r2, #6
    6104:	3102      	adds	r1, #2
    6106:	1ca0      	adds	r0, r4, #2
    6108:	f00a fa3d 	bl	10586 <memcmp>
    610c:	2800      	cmp	r0, #0
    610e:	d1f0      	bne.n	60f2 <le_advertising_report+0xb6>
			    adv->tx_addr == dup_filter[i].addr.type) {
    6110:	7823      	ldrb	r3, [r4, #0]
    6112:	f3c3 1380 	ubfx	r3, r3, #6, #1
    6116:	4a29      	ldr	r2, [pc, #164]	; (61bc <le_advertising_report+0x180>)
    6118:	eb02 02c5 	add.w	r2, r2, r5, lsl #3
    611c:	7852      	ldrb	r2, [r2, #1]
				    sizeof(bt_addr_t)) &&
    611e:	4293      	cmp	r3, r2
    6120:	d1e7      	bne.n	60f2 <le_advertising_report+0xb6>
				if (dup_filter[i].mask & BIT(adv->type)) {
    6122:	4b26      	ldr	r3, [pc, #152]	; (61bc <le_advertising_report+0x180>)
    6124:	f813 2035 	ldrb.w	r2, [r3, r5, lsl #3]
    6128:	7823      	ldrb	r3, [r4, #0]
    612a:	f003 030f 	and.w	r3, r3, #15
    612e:	fa22 f103 	lsr.w	r1, r2, r3
    6132:	f011 0f01 	tst.w	r1, #1
    6136:	d134      	bne.n	61a2 <le_advertising_report+0x166>
				dup_filter[i].mask |= BIT(adv->type);
    6138:	2101      	movs	r1, #1
    613a:	fa01 f303 	lsl.w	r3, r1, r3
    613e:	431a      	orrs	r2, r3
    6140:	4b1e      	ldr	r3, [pc, #120]	; (61bc <le_advertising_report+0x180>)
    6142:	f803 2035 	strb.w	r2, [r3, r5, lsl #3]
				return false;
    6146:	2300      	movs	r3, #0
    6148:	e7a0      	b.n	608c <le_advertising_report+0x50>
		memcpy(&dup_filter[dup_curr].addr.a.val[0],
    614a:	4a1d      	ldr	r2, [pc, #116]	; (61c0 <le_advertising_report+0x184>)
    614c:	6812      	ldr	r2, [r2, #0]
    614e:	4d1b      	ldr	r5, [pc, #108]	; (61bc <le_advertising_report+0x180>)
    6150:	eb05 01c2 	add.w	r1, r5, r2, lsl #3
    6154:	4620      	mov	r0, r4
    6156:	f850 cf02 	ldr.w	ip, [r0, #2]!
    615a:	f8c1 c002 	str.w	ip, [r1, #2]
    615e:	8880      	ldrh	r0, [r0, #4]
    6160:	80c8      	strh	r0, [r1, #6]
		dup_filter[dup_curr].addr.type = adv->tx_addr;
    6162:	7820      	ldrb	r0, [r4, #0]
    6164:	f3c0 1080 	ubfx	r0, r0, #6, #1
    6168:	7048      	strb	r0, [r1, #1]
		dup_filter[dup_curr].mask = BIT(adv->type);
    616a:	7821      	ldrb	r1, [r4, #0]
    616c:	f001 000f 	and.w	r0, r1, #15
    6170:	2101      	movs	r1, #1
    6172:	4081      	lsls	r1, r0
    6174:	f805 1032 	strb.w	r1, [r5, r2, lsl #3]
		if (dup_count < CONFIG_BT_CTLR_DUP_FILTER_LEN) {
    6178:	2b0f      	cmp	r3, #15
    617a:	dc0a      	bgt.n	6192 <le_advertising_report+0x156>
			dup_count++;
    617c:	3301      	adds	r3, #1
    617e:	4a0e      	ldr	r2, [pc, #56]	; (61b8 <le_advertising_report+0x17c>)
    6180:	6013      	str	r3, [r2, #0]
			dup_curr = dup_count;
    6182:	4a0f      	ldr	r2, [pc, #60]	; (61c0 <le_advertising_report+0x184>)
    6184:	6013      	str	r3, [r2, #0]
		if (dup_curr == CONFIG_BT_CTLR_DUP_FILTER_LEN) {
    6186:	4b0e      	ldr	r3, [pc, #56]	; (61c0 <le_advertising_report+0x184>)
    6188:	681b      	ldr	r3, [r3, #0]
    618a:	2b10      	cmp	r3, #16
    618c:	d005      	beq.n	619a <le_advertising_report+0x15e>
	return false;
    618e:	2300      	movs	r3, #0
    6190:	e77c      	b.n	608c <le_advertising_report+0x50>
			dup_curr++;
    6192:	3201      	adds	r2, #1
    6194:	4b0a      	ldr	r3, [pc, #40]	; (61c0 <le_advertising_report+0x184>)
    6196:	601a      	str	r2, [r3, #0]
    6198:	e7f5      	b.n	6186 <le_advertising_report+0x14a>
			dup_curr = 0U;
    619a:	2300      	movs	r3, #0
    619c:	4a08      	ldr	r2, [pc, #32]	; (61c0 <le_advertising_report+0x184>)
    619e:	6013      	str	r3, [r2, #0]
    61a0:	e774      	b.n	608c <le_advertising_report+0x50>
					return true;
    61a2:	2301      	movs	r3, #1
    61a4:	e772      	b.n	608c <le_advertising_report+0x50>
		data_len = 0U;
    61a6:	2500      	movs	r5, #0
    61a8:	e77c      	b.n	60a4 <le_advertising_report+0x68>
    61aa:	bf00      	nop
    61ac:	00010d38 	.word	0x00010d38
    61b0:	200000e8 	.word	0x200000e8
    61b4:	200000f0 	.word	0x200000f0
    61b8:	20004140 	.word	0x20004140
    61bc:	20004148 	.word	0x20004148
    61c0:	20004144 	.word	0x20004144

000061c4 <encode_control>:
 * @param pdu_data[in]    PDU. Same as node_rx_pdu->pdu, but more convenient
 * @param net_buf[out]    Upwards-going HCI buffer to fill
 */
static void encode_control(struct node_rx_pdu *node_rx,
			   struct pdu_data *pdu_data, struct net_buf *buf)
{
    61c4:	b508      	push	{r3, lr}
    61c6:	4603      	mov	r3, r0
    61c8:	4608      	mov	r0, r1
	u16_t handle;

	handle = node_rx->hdr.handle;

	switch (node_rx->hdr.type) {
    61ca:	7919      	ldrb	r1, [r3, #4]
    61cc:	2904      	cmp	r1, #4
    61ce:	d00d      	beq.n	61ec <encode_control+0x28>
		hci_user_ext_encode_control(node_rx, pdu_data, buf);
		return;
#endif /* CONFIG_BT_CTLR_USER_EXT */

	default:
		LL_ASSERT(0);
    61d0:	f640 5375 	movw	r3, #3445	; 0xd75
    61d4:	4a07      	ldr	r2, [pc, #28]	; (61f4 <encode_control+0x30>)
    61d6:	4908      	ldr	r1, [pc, #32]	; (61f8 <encode_control+0x34>)
    61d8:	4808      	ldr	r0, [pc, #32]	; (61fc <encode_control+0x38>)
    61da:	f006 ff28 	bl	d02e <printk>
    61de:	4040      	eors	r0, r0
    61e0:	f380 8811 	msr	BASEPRI, r0
    61e4:	f04f 0003 	mov.w	r0, #3
    61e8:	df02      	svc	2
		return;
	}
}
    61ea:	bd08      	pop	{r3, pc}
		le_advertising_report(pdu_data, node_rx, buf);
    61ec:	4619      	mov	r1, r3
    61ee:	f7ff ff25 	bl	603c <le_advertising_report>
		break;
    61f2:	e7fa      	b.n	61ea <encode_control+0x26>
    61f4:	000125b4 	.word	0x000125b4
    61f8:	00010df0 	.word	0x00010df0
    61fc:	00011fec 	.word	0x00011fec

00006200 <cmd_status>:
{
    6200:	b508      	push	{r3, lr}
    6202:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
    6204:	4b02      	ldr	r3, [pc, #8]	; (6210 <cmd_status+0x10>)
    6206:	8818      	ldrh	r0, [r3, #0]
    6208:	f008 fbb4 	bl	e974 <bt_hci_cmd_status_create>
}
    620c:	bd08      	pop	{r3, pc}
    620e:	bf00      	nop
    6210:	20005948 	.word	0x20005948

00006214 <hci_cmd_complete>:
{
    6214:	b538      	push	{r3, r4, r5, lr}
    6216:	4605      	mov	r5, r0
    6218:	460c      	mov	r4, r1
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
    621a:	4b05      	ldr	r3, [pc, #20]	; (6230 <hci_cmd_complete+0x1c>)
    621c:	8818      	ldrh	r0, [r3, #0]
    621e:	f008 fb97 	bl	e950 <bt_hci_cmd_complete_create>
    6222:	6028      	str	r0, [r5, #0]
	return net_buf_add(*buf, plen);
    6224:	4621      	mov	r1, r4
    6226:	3008      	adds	r0, #8
    6228:	f009 fa38 	bl	f69c <net_buf_simple_add>
}
    622c:	bd38      	pop	{r3, r4, r5, pc}
    622e:	bf00      	nop
    6230:	20005948 	.word	0x20005948

00006234 <vs_read_build_info>:
{
    6234:	b570      	push	{r4, r5, r6, lr}
    6236:	b086      	sub	sp, #24
    6238:	460e      	mov	r6, r1
	const char build_info[] = HCI_VS_BUILD_INFO;
    623a:	466c      	mov	r4, sp
    623c:	4d0e      	ldr	r5, [pc, #56]	; (6278 <vs_read_build_info+0x44>)
    623e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    6240:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    6242:	e895 0003 	ldmia.w	r5, {r0, r1}
    6246:	f844 0b04 	str.w	r0, [r4], #4
    624a:	7021      	strb	r1, [r4, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(build_info));
    624c:	2116      	movs	r1, #22
    624e:	4630      	mov	r0, r6
    6250:	f7ff ffe0 	bl	6214 <hci_cmd_complete>
    6254:	4606      	mov	r6, r0
	rp->status = 0x00;
    6256:	4605      	mov	r5, r0
    6258:	2300      	movs	r3, #0
    625a:	f805 3b01 	strb.w	r3, [r5], #1
    625e:	466c      	mov	r4, sp
    6260:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    6262:	f8c6 0001 	str.w	r0, [r6, #1]
    6266:	6069      	str	r1, [r5, #4]
    6268:	60aa      	str	r2, [r5, #8]
    626a:	60eb      	str	r3, [r5, #12]
    626c:	6820      	ldr	r0, [r4, #0]
    626e:	6128      	str	r0, [r5, #16]
    6270:	7923      	ldrb	r3, [r4, #4]
    6272:	752b      	strb	r3, [r5, #20]
}
    6274:	b006      	add	sp, #24
    6276:	bd70      	pop	{r4, r5, r6, pc}
    6278:	00012628 	.word	0x00012628

0000627c <set_event_mask>:
{
    627c:	b510      	push	{r4, lr}
    627e:	4603      	mov	r3, r0
    6280:	4608      	mov	r0, r1
	struct bt_hci_cp_set_event_mask *cmd = (void *)buf->data;
    6282:	689b      	ldr	r3, [r3, #8]
	return ((u16_t)src[1] << 8) | src[0];
    6284:	79d9      	ldrb	r1, [r3, #7]
    6286:	799a      	ldrb	r2, [r3, #6]
    6288:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
    628c:	795c      	ldrb	r4, [r3, #5]
    628e:	791a      	ldrb	r2, [r3, #4]
    6290:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
    6294:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
	return ((u16_t)src[1] << 8) | src[0];
    6298:	78dc      	ldrb	r4, [r3, #3]
    629a:	7899      	ldrb	r1, [r3, #2]
    629c:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
    62a0:	785c      	ldrb	r4, [r3, #1]
    62a2:	781b      	ldrb	r3, [r3, #0]
    62a4:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
    62a8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
	event_mask = sys_get_le64(cmd->events);
    62ac:	4904      	ldr	r1, [pc, #16]	; (62c0 <set_event_mask+0x44>)
    62ae:	600b      	str	r3, [r1, #0]
    62b0:	604a      	str	r2, [r1, #4]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    62b2:	2101      	movs	r1, #1
    62b4:	f7ff ffae 	bl	6214 <hci_cmd_complete>
	ccst->status = 0x00;
    62b8:	2300      	movs	r3, #0
    62ba:	7003      	strb	r3, [r0, #0]
}
    62bc:	bd10      	pop	{r4, pc}
    62be:	bf00      	nop
    62c0:	200000e8 	.word	0x200000e8

000062c4 <reset>:
{
    62c4:	b5d0      	push	{r4, r6, r7, lr}
	dup_count = -1;
    62c6:	4b0d      	ldr	r3, [pc, #52]	; (62fc <reset+0x38>)
    62c8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    62cc:	601a      	str	r2, [r3, #0]
	event_mask = DEFAULT_EVENT_MASK;
    62ce:	4b0c      	ldr	r3, [pc, #48]	; (6300 <reset+0x3c>)
    62d0:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
    62d4:	f641 77ff 	movw	r7, #8191	; 0x1fff
    62d8:	e9c3 6700 	strd	r6, r7, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
    62dc:	4b09      	ldr	r3, [pc, #36]	; (6304 <reset+0x40>)
    62de:	261f      	movs	r6, #31
    62e0:	2700      	movs	r7, #0
    62e2:	e9c3 6700 	strd	r6, r7, [r3]
	if (buf) {
    62e6:	b140      	cbz	r0, 62fa <reset+0x36>
    62e8:	460c      	mov	r4, r1
		ll_reset();
    62ea:	f000 fa17 	bl	671c <ll_reset>
		ccst = hci_cmd_complete(evt, sizeof(*ccst));
    62ee:	2101      	movs	r1, #1
    62f0:	4620      	mov	r0, r4
    62f2:	f7ff ff8f 	bl	6214 <hci_cmd_complete>
		ccst->status = 0x00;
    62f6:	2300      	movs	r3, #0
    62f8:	7003      	strb	r3, [r0, #0]
}
    62fa:	bdd0      	pop	{r4, r6, r7, pc}
    62fc:	20004140 	.word	0x20004140
    6300:	200000e8 	.word	0x200000e8
    6304:	200000f0 	.word	0x200000f0

00006308 <le_set_event_mask>:
{
    6308:	b510      	push	{r4, lr}
    630a:	4603      	mov	r3, r0
    630c:	4608      	mov	r0, r1
	struct bt_hci_cp_set_event_mask *cmd = (void *)buf->data;
    630e:	689b      	ldr	r3, [r3, #8]
	return ((u16_t)src[1] << 8) | src[0];
    6310:	79d9      	ldrb	r1, [r3, #7]
    6312:	799a      	ldrb	r2, [r3, #6]
    6314:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
    6318:	795c      	ldrb	r4, [r3, #5]
    631a:	791a      	ldrb	r2, [r3, #4]
    631c:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
    6320:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
	return ((u16_t)src[1] << 8) | src[0];
    6324:	78dc      	ldrb	r4, [r3, #3]
    6326:	7899      	ldrb	r1, [r3, #2]
    6328:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
    632c:	785c      	ldrb	r4, [r3, #1]
    632e:	781b      	ldrb	r3, [r3, #0]
    6330:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
    6334:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
	le_event_mask = sys_get_le64(cmd->events);
    6338:	4904      	ldr	r1, [pc, #16]	; (634c <le_set_event_mask+0x44>)
    633a:	600b      	str	r3, [r1, #0]
    633c:	604a      	str	r2, [r1, #4]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    633e:	2101      	movs	r1, #1
    6340:	f7ff ff68 	bl	6214 <hci_cmd_complete>
	ccst->status = 0x00;
    6344:	2300      	movs	r3, #0
    6346:	7003      	strb	r3, [r0, #0]
}
    6348:	bd10      	pop	{r4, pc}
    634a:	bf00      	nop
    634c:	200000f0 	.word	0x200000f0

00006350 <le_set_scan_enable>:
{
    6350:	b538      	push	{r3, r4, r5, lr}
    6352:	460d      	mov	r5, r1
	struct bt_hci_cp_le_set_scan_enable *cmd = (void *)buf->data;
    6354:	6883      	ldr	r3, [r0, #8]
	if (cmd->enable && cmd->filter_dup) {
    6356:	7818      	ldrb	r0, [r3, #0]
    6358:	b138      	cbz	r0, 636a <le_set_scan_enable+0x1a>
    635a:	785b      	ldrb	r3, [r3, #1]
    635c:	b12b      	cbz	r3, 636a <le_set_scan_enable+0x1a>
		dup_count = 0;
    635e:	2300      	movs	r3, #0
    6360:	4a08      	ldr	r2, [pc, #32]	; (6384 <le_set_scan_enable+0x34>)
    6362:	6013      	str	r3, [r2, #0]
		dup_curr = 0U;
    6364:	4a08      	ldr	r2, [pc, #32]	; (6388 <le_set_scan_enable+0x38>)
    6366:	6013      	str	r3, [r2, #0]
    6368:	e003      	b.n	6372 <le_set_scan_enable+0x22>
		dup_count = -1;
    636a:	4b06      	ldr	r3, [pc, #24]	; (6384 <le_set_scan_enable+0x34>)
    636c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    6370:	601a      	str	r2, [r3, #0]
	status = ll_scan_enable(cmd->enable);
    6372:	f008 fdea 	bl	ef4a <ll_scan_enable>
    6376:	4604      	mov	r4, r0
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    6378:	2101      	movs	r1, #1
    637a:	4628      	mov	r0, r5
    637c:	f7ff ff4a 	bl	6214 <hci_cmd_complete>
	ccst->status = status;
    6380:	7004      	strb	r4, [r0, #0]
}
    6382:	bd38      	pop	{r3, r4, r5, pc}
    6384:	20004140 	.word	0x20004140
    6388:	20004144 	.word	0x20004144

0000638c <hci_cmd_handle>:
{
    638c:	b530      	push	{r4, r5, lr}
    638e:	b083      	sub	sp, #12
	struct net_buf *evt = NULL;
    6390:	2300      	movs	r3, #0
    6392:	9301      	str	r3, [sp, #4]
	if (cmd->len < sizeof(*chdr)) {
    6394:	8983      	ldrh	r3, [r0, #12]
    6396:	2b02      	cmp	r3, #2
    6398:	d91e      	bls.n	63d8 <hci_cmd_handle+0x4c>
    639a:	4604      	mov	r4, r0
    639c:	460d      	mov	r5, r1
	chdr = net_buf_pull_mem(cmd, sizeof(*chdr));
    639e:	2103      	movs	r1, #3
    63a0:	3008      	adds	r0, #8
    63a2:	f009 f994 	bl	f6ce <net_buf_simple_pull_mem>
	if (cmd->len < chdr->param_len) {
    63a6:	89a2      	ldrh	r2, [r4, #12]
    63a8:	7883      	ldrb	r3, [r0, #2]
    63aa:	429a      	cmp	r2, r3
    63ac:	d327      	bcc.n	63fe <hci_cmd_handle+0x72>
	_opcode = sys_le16_to_cpu(chdr->opcode);
    63ae:	8802      	ldrh	r2, [r0, #0]
    63b0:	4b32      	ldr	r3, [pc, #200]	; (647c <hci_cmd_handle+0xf0>)
    63b2:	801a      	strh	r2, [r3, #0]
	ocf = BT_OCF(_opcode);
    63b4:	f3c2 0009 	ubfx	r0, r2, #0, #10
	switch (BT_OGF(_opcode)) {
    63b8:	0a93      	lsrs	r3, r2, #10
    63ba:	f5b2 5f10 	cmp.w	r2, #9216	; 0x2400
    63be:	d231      	bcs.n	6424 <hci_cmd_handle+0x98>
    63c0:	b21a      	sxth	r2, r3
    63c2:	2a00      	cmp	r2, #0
    63c4:	d054      	beq.n	6470 <hci_cmd_handle+0xe4>
    63c6:	3b01      	subs	r3, #1
    63c8:	2b07      	cmp	r3, #7
    63ca:	d851      	bhi.n	6470 <hci_cmd_handle+0xe4>
    63cc:	e8df f003 	tbb	[pc, r3]
    63d0:	403b5031 	.word	0x403b5031
    63d4:	4a505045 	.word	0x4a505045
		BT_ERR("No HCI Command header");
    63d8:	f04f 0100 	mov.w	r1, #0
    63dc:	2301      	movs	r3, #1
    63de:	f363 0102 	bfi	r1, r3, #0, #3
    63e2:	f36f 01c5 	bfc	r1, #3, #3
    63e6:	4b26      	ldr	r3, [pc, #152]	; (6480 <hci_cmd_handle+0xf4>)
    63e8:	4a26      	ldr	r2, [pc, #152]	; (6484 <hci_cmd_handle+0xf8>)
    63ea:	1a9b      	subs	r3, r3, r2
    63ec:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    63f0:	f363 118f 	bfi	r1, r3, #6, #10
    63f4:	4824      	ldr	r0, [pc, #144]	; (6488 <hci_cmd_handle+0xfc>)
    63f6:	f7fb fc53 	bl	1ca0 <log_0>
		return NULL;
    63fa:	2000      	movs	r0, #0
    63fc:	e021      	b.n	6442 <hci_cmd_handle+0xb6>
		BT_ERR("Invalid HCI CMD packet length");
    63fe:	f04f 0100 	mov.w	r1, #0
    6402:	2301      	movs	r3, #1
    6404:	f363 0102 	bfi	r1, r3, #0, #3
    6408:	f36f 01c5 	bfc	r1, #3, #3
    640c:	4b1c      	ldr	r3, [pc, #112]	; (6480 <hci_cmd_handle+0xf4>)
    640e:	4a1d      	ldr	r2, [pc, #116]	; (6484 <hci_cmd_handle+0xf8>)
    6410:	1a9b      	subs	r3, r3, r2
    6412:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    6416:	f363 118f 	bfi	r1, r3, #6, #10
    641a:	481c      	ldr	r0, [pc, #112]	; (648c <hci_cmd_handle+0x100>)
    641c:	f7fb fc40 	bl	1ca0 <log_0>
		return NULL;
    6420:	2000      	movs	r0, #0
    6422:	e00e      	b.n	6442 <hci_cmd_handle+0xb6>
	switch (BT_OGF(_opcode)) {
    6424:	2b3f      	cmp	r3, #63	; 0x3f
    6426:	d123      	bne.n	6470 <hci_cmd_handle+0xe4>

/* Map vendor command handler directly to common implementation */
inline int hci_vendor_cmd_handle(u16_t ocf, struct net_buf *cmd,
				 struct net_buf **evt)
{
	return hci_vendor_cmd_handle_common(ocf, cmd, evt);
    6428:	aa01      	add	r2, sp, #4
    642a:	4621      	mov	r1, r4
    642c:	f008 fccb 	bl	edc6 <hci_vendor_cmd_handle_common>
		break;
    6430:	e003      	b.n	643a <hci_cmd_handle+0xae>
		err = link_control_cmd_handle(ocf, cmd, &evt);
    6432:	aa01      	add	r2, sp, #4
    6434:	4621      	mov	r1, r4
    6436:	f008 fa56 	bl	e8e6 <link_control_cmd_handle>
	if (err == -EINVAL) {
    643a:	f110 0f16 	cmn.w	r0, #22
    643e:	d017      	beq.n	6470 <hci_cmd_handle+0xe4>
	return evt;
    6440:	9801      	ldr	r0, [sp, #4]
}
    6442:	b003      	add	sp, #12
    6444:	bd30      	pop	{r4, r5, pc}
		err = ctrl_bb_cmd_handle(ocf, cmd, &evt);
    6446:	aa01      	add	r2, sp, #4
    6448:	4621      	mov	r1, r4
    644a:	f008 faef 	bl	ea2c <ctrl_bb_cmd_handle>
		break;
    644e:	e7f4      	b.n	643a <hci_cmd_handle+0xae>
		err = info_cmd_handle(ocf, cmd, &evt);
    6450:	aa01      	add	r2, sp, #4
    6452:	4621      	mov	r1, r4
    6454:	f008 fb59 	bl	eb0a <info_cmd_handle>
		break;
    6458:	e7ef      	b.n	643a <hci_cmd_handle+0xae>
		err = status_cmd_handle(ocf, cmd, &evt);
    645a:	aa01      	add	r2, sp, #4
    645c:	4621      	mov	r1, r4
    645e:	f008 fa45 	bl	e8ec <status_cmd_handle>
		break;
    6462:	e7ea      	b.n	643a <hci_cmd_handle+0xae>
		err = controller_cmd_handle(ocf, cmd, &evt, node_rx);
    6464:	462b      	mov	r3, r5
    6466:	aa01      	add	r2, sp, #4
    6468:	4621      	mov	r1, r4
    646a:	f008 fc27 	bl	ecbc <controller_cmd_handle>
		break;
    646e:	e7e4      	b.n	643a <hci_cmd_handle+0xae>
		evt = cmd_status(BT_HCI_ERR_UNKNOWN_CMD);
    6470:	2001      	movs	r0, #1
    6472:	f7ff fec5 	bl	6200 <cmd_status>
    6476:	9001      	str	r0, [sp, #4]
    6478:	e7e2      	b.n	6440 <hci_cmd_handle+0xb4>
    647a:	bf00      	nop
    647c:	20005948 	.word	0x20005948
    6480:	00010c40 	.word	0x00010c40
    6484:	00010c18 	.word	0x00010c18
    6488:	00012640 	.word	0x00012640
    648c:	00012658 	.word	0x00012658

00006490 <perform_lll_reset>:

	return 0;
}

static void perform_lll_reset(void *param)
{
    6490:	b510      	push	{r4, lr}
    6492:	4604      	mov	r4, r0
	int err;

	/* Reset LLL */
	err = lll_reset();
    6494:	f008 fe17 	bl	f0c6 <lll_reset>
	LL_ASSERT(!err);
    6498:	b930      	cbnz	r0, 64a8 <perform_lll_reset+0x18>
	LL_ASSERT(!err);
#endif /* CONFIG_BT_BROADCASTER */

#if defined(CONFIG_BT_OBSERVER)
	/* Reset scan state */
	err = lll_scan_reset();
    649a:	f008 feaf 	bl	f1fc <lll_scan_reset>
	LL_ASSERT(!err);
    649e:	b988      	cbnz	r0, 64c4 <perform_lll_reset+0x34>
	z_impl_k_sem_give(sem);
    64a0:	4620      	mov	r0, r4
    64a2:	f004 ff2b 	bl	b2fc <z_impl_k_sem_give>
#endif /* CONFIG_BT_CONN */

#if !defined(CONFIG_BT_CTLR_ZLI)
	k_sem_give(param);
#endif /* !CONFIG_BT_CTLR_ZLI */
}
    64a6:	bd10      	pop	{r4, pc}
	LL_ASSERT(!err);
    64a8:	f240 43cf 	movw	r3, #1231	; 0x4cf
    64ac:	4a0c      	ldr	r2, [pc, #48]	; (64e0 <perform_lll_reset+0x50>)
    64ae:	490d      	ldr	r1, [pc, #52]	; (64e4 <perform_lll_reset+0x54>)
    64b0:	480d      	ldr	r0, [pc, #52]	; (64e8 <perform_lll_reset+0x58>)
    64b2:	f006 fdbc 	bl	d02e <printk>
    64b6:	4040      	eors	r0, r0
    64b8:	f380 8811 	msr	BASEPRI, r0
    64bc:	f04f 0003 	mov.w	r0, #3
    64c0:	df02      	svc	2
    64c2:	e7ea      	b.n	649a <perform_lll_reset+0xa>
	LL_ASSERT(!err);
    64c4:	f240 43da 	movw	r3, #1242	; 0x4da
    64c8:	4a05      	ldr	r2, [pc, #20]	; (64e0 <perform_lll_reset+0x50>)
    64ca:	4906      	ldr	r1, [pc, #24]	; (64e4 <perform_lll_reset+0x54>)
    64cc:	4806      	ldr	r0, [pc, #24]	; (64e8 <perform_lll_reset+0x58>)
    64ce:	f006 fdae 	bl	d02e <printk>
    64d2:	4040      	eors	r0, r0
    64d4:	f380 8811 	msr	BASEPRI, r0
    64d8:	f04f 0003 	mov.w	r0, #3
    64dc:	df02      	svc	2
    64de:	e7df      	b.n	64a0 <perform_lll_reset+0x10>
    64e0:	0001269c 	.word	0x0001269c
    64e4:	00012710 	.word	0x00012710
    64e8:	00011fec 	.word	0x00011fec

000064ec <ll_init>:
{
    64ec:	b570      	push	{r4, r5, r6, lr}
    64ee:	b086      	sub	sp, #24
	sem_recv = sem_rx;
    64f0:	4b75      	ldr	r3, [pc, #468]	; (66c8 <ll_init+0x1dc>)
    64f2:	6018      	str	r0, [r3, #0]
	cntr_init();
    64f4:	f001 fea4 	bl	8240 <cntr_init>
	mayfly_init();
    64f8:	f7fe fdb6 	bl	5068 <mayfly_init>
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
    64fc:	4a73      	ldr	r2, [pc, #460]	; (66cc <ll_init+0x1e0>)
    64fe:	2103      	movs	r1, #3
    6500:	7011      	strb	r1, [r2, #0]
	ticker_users[MAYFLY_CALL_ID_1][0] = TICKER_USER_ULL_HIGH_OPS;
    6502:	2304      	movs	r3, #4
    6504:	7213      	strb	r3, [r2, #8]
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
    6506:	2002      	movs	r0, #2
    6508:	7410      	strb	r0, [r2, #16]
	ticker_users[MAYFLY_CALL_ID_PROGRAM][0] = TICKER_USER_APP_OPS;
    650a:	7610      	strb	r0, [r2, #24]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
    650c:	4870      	ldr	r0, [pc, #448]	; (66d0 <ll_init+0x1e4>)
    650e:	9005      	str	r0, [sp, #20]
    6510:	4870      	ldr	r0, [pc, #448]	; (66d4 <ll_init+0x1e8>)
    6512:	9004      	str	r0, [sp, #16]
    6514:	4870      	ldr	r0, [pc, #448]	; (66d8 <ll_init+0x1ec>)
    6516:	9003      	str	r0, [sp, #12]
    6518:	4870      	ldr	r0, [pc, #448]	; (66dc <ll_init+0x1f0>)
    651a:	9002      	str	r0, [sp, #8]
    651c:	200b      	movs	r0, #11
    651e:	9001      	str	r0, [sp, #4]
    6520:	9200      	str	r2, [sp, #0]
    6522:	4a6f      	ldr	r2, [pc, #444]	; (66e0 <ll_init+0x1f4>)
    6524:	2000      	movs	r0, #0
    6526:	f7fe fef7 	bl	5318 <ticker_init>
	LL_ASSERT(!err);
    652a:	b958      	cbnz	r0, 6544 <ll_init+0x58>
	return z_impl_k_sem_init(sem, initial_count, limit);
    652c:	2201      	movs	r2, #1
    652e:	2100      	movs	r1, #0
    6530:	486c      	ldr	r0, [pc, #432]	; (66e4 <ll_init+0x1f8>)
    6532:	f009 feae 	bl	10292 <z_impl_k_sem_init>
	err = lll_init();
    6536:	f001 f939 	bl	77ac <lll_init>
	if (err) {
    653a:	4604      	mov	r4, r0
    653c:	b180      	cbz	r0, 6560 <ll_init+0x74>
}
    653e:	4620      	mov	r0, r4
    6540:	b006      	add	sp, #24
    6542:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(!err);
    6544:	f240 1317 	movw	r3, #279	; 0x117
    6548:	4a67      	ldr	r2, [pc, #412]	; (66e8 <ll_init+0x1fc>)
    654a:	4968      	ldr	r1, [pc, #416]	; (66ec <ll_init+0x200>)
    654c:	4868      	ldr	r0, [pc, #416]	; (66f0 <ll_init+0x204>)
    654e:	f006 fd6e 	bl	d02e <printk>
    6552:	4040      	eors	r0, r0
    6554:	f380 8811 	msr	BASEPRI, r0
    6558:	f04f 0003 	mov.w	r0, #3
    655c:	df02      	svc	2
    655e:	e7e5      	b.n	652c <ll_init+0x40>
	mem_init(mem_done.pool, sizeof(struct node_rx_event_done),
    6560:	4b64      	ldr	r3, [pc, #400]	; (66f4 <ll_init+0x208>)
    6562:	2203      	movs	r2, #3
    6564:	2138      	movs	r1, #56	; 0x38
    6566:	1d18      	adds	r0, r3, #4
    6568:	f007 fe86 	bl	e278 <mem_init>
	mem_init(mem_link_done.pool, sizeof(memq_link_t), EVENT_DONE_MAX,
    656c:	4b62      	ldr	r3, [pc, #392]	; (66f8 <ll_init+0x20c>)
    656e:	2203      	movs	r2, #3
    6570:	2108      	movs	r1, #8
    6572:	1d18      	adds	r0, r3, #4
    6574:	f007 fe80 	bl	e278 <mem_init>
static inline void done_alloc(void)
{
	u8_t idx;

	/* mfifo_done is a queue of pointers */
	while (MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
    6578:	e042      	b.n	6600 <ll_init+0x114>
			break;
		}

		rx = mem_acquire(&mem_done.free);
		if (!rx) {
			mem_release(link, &mem_link_done.free);
    657a:	495f      	ldr	r1, [pc, #380]	; (66f8 <ll_init+0x20c>)
    657c:	4628      	mov	r0, r5
    657e:	f007 fead 	bl	e2dc <mem_release>
	mem_init(mem_pdu_rx.pool, (PDU_RX_NODE_POOL_ELEMENT_SIZE),
    6582:	4b5e      	ldr	r3, [pc, #376]	; (66fc <ll_init+0x210>)
    6584:	2206      	movs	r2, #6
    6586:	21dc      	movs	r1, #220	; 0xdc
    6588:	1d18      	adds	r0, r3, #4
    658a:	f007 fe75 	bl	e278 <mem_init>
	mem_init(mem_link_rx.pool, sizeof(memq_link_t),
    658e:	485c      	ldr	r0, [pc, #368]	; (6700 <ll_init+0x214>)
    6590:	1d04      	adds	r4, r0, #4
    6592:	4623      	mov	r3, r4
    6594:	2208      	movs	r2, #8
    6596:	4611      	mov	r1, r2
    6598:	4410      	add	r0, r2
    659a:	f007 fe6d 	bl	e278 <mem_init>
	link = mem_acquire(&mem_link_rx.free);
    659e:	4620      	mov	r0, r4
    65a0:	f007 fe86 	bl	e2b0 <mem_acquire>
	LL_ASSERT(link);
    65a4:	4604      	mov	r4, r0
    65a6:	2800      	cmp	r0, #0
    65a8:	d034      	beq.n	6614 <ll_init+0x128>
	MEMQ_INIT(ull_rx, link);
    65aa:	4956      	ldr	r1, [pc, #344]	; (6704 <ll_init+0x218>)
    65ac:	1d0a      	adds	r2, r1, #4
    65ae:	4620      	mov	r0, r4
    65b0:	f007 febf 	bl	e332 <memq_init>
	link = mem_acquire(&mem_link_rx.free);
    65b4:	4854      	ldr	r0, [pc, #336]	; (6708 <ll_init+0x21c>)
    65b6:	f007 fe7b 	bl	e2b0 <mem_acquire>
	LL_ASSERT(link);
    65ba:	4604      	mov	r4, r0
    65bc:	2800      	cmp	r0, #0
    65be:	d037      	beq.n	6630 <ll_init+0x144>
	MEMQ_INIT(ll_rx, link);
    65c0:	4952      	ldr	r1, [pc, #328]	; (670c <ll_init+0x220>)
    65c2:	1d0a      	adds	r2, r1, #4
    65c4:	4620      	mov	r0, r4
    65c6:	f007 feb4 	bl	e332 <memq_init>
	mem_link_rx.quota_pdu = RX_CNT;
    65ca:	2306      	movs	r3, #6
    65cc:	4a4c      	ldr	r2, [pc, #304]	; (6700 <ll_init+0x214>)
    65ce:	7013      	strb	r3, [r2, #0]

		ll_rx_link_inc_quota(-1);
	}
#endif /* CONFIG_BT_CONN */

	if (max > mem_link_rx.quota_pdu) {
    65d0:	e06c      	b.n	66ac <ll_init+0x1c0>
	 * We want to maintain the invariant of emptiness defined by
	 * first == last, but we just advanced a copy of the write-index before
	 * and may have wrapped. So if first == last the queue is full and we
	 * can not continue
	 */
	if (last == first) {
    65d2:	4294      	cmp	r4, r2
    65d4:	d0d5      	beq.n	6582 <ll_init+0x96>
		link = mem_acquire(&mem_link_done.free);
    65d6:	4848      	ldr	r0, [pc, #288]	; (66f8 <ll_init+0x20c>)
    65d8:	f007 fe6a 	bl	e2b0 <mem_acquire>
		if (!link) {
    65dc:	4605      	mov	r5, r0
    65de:	2800      	cmp	r0, #0
    65e0:	d0cf      	beq.n	6582 <ll_init+0x96>
		rx = mem_acquire(&mem_done.free);
    65e2:	4844      	ldr	r0, [pc, #272]	; (66f4 <ll_init+0x208>)
    65e4:	f007 fe64 	bl	e2b0 <mem_acquire>
		if (!rx) {
    65e8:	4601      	mov	r1, r0
    65ea:	2800      	cmp	r0, #0
    65ec:	d0c5      	beq.n	657a <ll_init+0x8e>
		rx->link = link;
    65ee:	6005      	str	r5, [r0, #0]
		MFIFO_BY_IDX_ENQUEUE(done, idx, rx);
    65f0:	4b47      	ldr	r3, [pc, #284]	; (6710 <ll_init+0x224>)
    65f2:	7818      	ldrb	r0, [r3, #0]
 */
static inline void mfifo_by_idx_enqueue(u8_t *fifo, u8_t size, u8_t idx,
					void *mem, u8_t *last)
{
	/* API 2: fifo is array of void-ptrs */
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    65f4:	78da      	ldrb	r2, [r3, #3]
    65f6:	fb02 f200 	mul.w	r2, r2, r0
    65fa:	1d18      	adds	r0, r3, #4
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    65fc:	5081      	str	r1, [r0, r2]

	*last = idx; /* Commit: Update write index */
    65fe:	70dc      	strb	r4, [r3, #3]
	while (MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
    6600:	4b43      	ldr	r3, [pc, #268]	; (6710 <ll_init+0x224>)
    6602:	7859      	ldrb	r1, [r3, #1]
    6604:	789a      	ldrb	r2, [r3, #2]
    6606:	78dc      	ldrb	r4, [r3, #3]
	last = last + 1;
    6608:	3401      	adds	r4, #1
    660a:	b2e4      	uxtb	r4, r4
	if (last == count) {
    660c:	42a1      	cmp	r1, r4
    660e:	d1e0      	bne.n	65d2 <ll_init+0xe6>
		last = 0U;
    6610:	2400      	movs	r4, #0
    6612:	e7de      	b.n	65d2 <ll_init+0xe6>
	LL_ASSERT(link);
    6614:	f240 43b6 	movw	r3, #1206	; 0x4b6
    6618:	4a33      	ldr	r2, [pc, #204]	; (66e8 <ll_init+0x1fc>)
    661a:	493e      	ldr	r1, [pc, #248]	; (6714 <ll_init+0x228>)
    661c:	4834      	ldr	r0, [pc, #208]	; (66f0 <ll_init+0x204>)
    661e:	f006 fd06 	bl	d02e <printk>
    6622:	4040      	eors	r0, r0
    6624:	f380 8811 	msr	BASEPRI, r0
    6628:	f04f 0003 	mov.w	r0, #3
    662c:	df02      	svc	2
    662e:	e7bc      	b.n	65aa <ll_init+0xbe>
	LL_ASSERT(link);
    6630:	f240 43bd 	movw	r3, #1213	; 0x4bd
    6634:	4a2c      	ldr	r2, [pc, #176]	; (66e8 <ll_init+0x1fc>)
    6636:	4937      	ldr	r1, [pc, #220]	; (6714 <ll_init+0x228>)
    6638:	482d      	ldr	r0, [pc, #180]	; (66f0 <ll_init+0x204>)
    663a:	f006 fcf8 	bl	d02e <printk>
    663e:	4040      	eors	r0, r0
    6640:	f380 8811 	msr	BASEPRI, r0
    6644:	f04f 0003 	mov.w	r0, #3
    6648:	df02      	svc	2
    664a:	e7b9      	b.n	65c0 <ll_init+0xd4>
			break;
		}

		rx = mem_acquire(&mem_pdu_rx.free);
		if (!rx) {
			mem_release(link, &mem_link_rx.free);
    664c:	492e      	ldr	r1, [pc, #184]	; (6708 <ll_init+0x21c>)
    664e:	4630      	mov	r0, r6
    6650:	f007 fe44 	bl	e2dc <mem_release>
	err = lll_scan_init();
    6654:	f008 fdce 	bl	f1f4 <lll_scan_init>
	if (err) {
    6658:	4604      	mov	r4, r0
    665a:	2800      	cmp	r0, #0
    665c:	f47f af6f 	bne.w	653e <ll_init+0x52>
	err = ull_scan_init();
    6660:	f008 fc0a 	bl	ee78 <ull_scan_init>
	if (err) {
    6664:	4604      	mov	r4, r0
    6666:	2800      	cmp	r0, #0
    6668:	f47f af69 	bne.w	653e <ll_init+0x52>
		ull_filter_reset(true);
    666c:	2001      	movs	r0, #1
    666e:	f000 fedd 	bl	742c <ull_filter_reset>
	return  0;
    6672:	e764      	b.n	653e <ll_init+0x52>
	if (last == first) {
    6674:	4295      	cmp	r5, r2
    6676:	d0ed      	beq.n	6654 <ll_init+0x168>
		link = mem_acquire(&mem_link_rx.free);
    6678:	4823      	ldr	r0, [pc, #140]	; (6708 <ll_init+0x21c>)
    667a:	f007 fe19 	bl	e2b0 <mem_acquire>
		if (!link) {
    667e:	4606      	mov	r6, r0
    6680:	2800      	cmp	r0, #0
    6682:	d0e7      	beq.n	6654 <ll_init+0x168>
		rx = mem_acquire(&mem_pdu_rx.free);
    6684:	481d      	ldr	r0, [pc, #116]	; (66fc <ll_init+0x210>)
    6686:	f007 fe13 	bl	e2b0 <mem_acquire>
		if (!rx) {
    668a:	4601      	mov	r1, r0
    668c:	2800      	cmp	r0, #0
    668e:	d0dd      	beq.n	664c <ll_init+0x160>
			break;
		}

		rx->link = link;
    6690:	6006      	str	r6, [r0, #0]

		MFIFO_BY_IDX_ENQUEUE(pdu_rx_free, idx, rx);
    6692:	4b21      	ldr	r3, [pc, #132]	; (6718 <ll_init+0x22c>)
    6694:	7818      	ldrb	r0, [r3, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    6696:	78da      	ldrb	r2, [r3, #3]
    6698:	fb02 f200 	mul.w	r2, r2, r0
    669c:	1d18      	adds	r0, r3, #4
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    669e:	5081      	str	r1, [r0, r2]
	*last = idx; /* Commit: Update write index */
    66a0:	70dd      	strb	r5, [r3, #3]
	mem_link_rx.quota_pdu += delta;
    66a2:	4a17      	ldr	r2, [pc, #92]	; (6700 <ll_init+0x214>)
    66a4:	7813      	ldrb	r3, [r2, #0]
    66a6:	3b01      	subs	r3, #1
    66a8:	7013      	strb	r3, [r2, #0]
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
    66aa:	4623      	mov	r3, r4
    66ac:	1e5c      	subs	r4, r3, #1
    66ae:	b2e4      	uxtb	r4, r4
    66b0:	2b00      	cmp	r3, #0
    66b2:	d0cf      	beq.n	6654 <ll_init+0x168>
    66b4:	4b18      	ldr	r3, [pc, #96]	; (6718 <ll_init+0x22c>)
    66b6:	7859      	ldrb	r1, [r3, #1]
    66b8:	789a      	ldrb	r2, [r3, #2]
    66ba:	78db      	ldrb	r3, [r3, #3]
	last = last + 1;
    66bc:	3301      	adds	r3, #1
    66be:	b2dd      	uxtb	r5, r3
	if (last == count) {
    66c0:	42a9      	cmp	r1, r5
    66c2:	d1d7      	bne.n	6674 <ll_init+0x188>
		last = 0U;
    66c4:	2500      	movs	r5, #0
    66c6:	e7d5      	b.n	6674 <ll_init+0x188>
    66c8:	20004838 	.word	0x20004838
    66cc:	20004b20 	.word	0x20004b20
    66d0:	0000f2b5 	.word	0x0000f2b5
    66d4:	00008da9 	.word	0x00008da9
    66d8:	00008d4d 	.word	0x00008d4d
    66dc:	200048e4 	.word	0x200048e4
    66e0:	20004854 	.word	0x20004854
    66e4:	2000483c 	.word	0x2000483c
    66e8:	0001269c 	.word	0x0001269c
    66ec:	00012710 	.word	0x00012710
    66f0:	00011fec 	.word	0x00011fec
    66f4:	200041ec 	.word	0x200041ec
    66f8:	20004298 	.word	0x20004298
    66fc:	200042fc 	.word	0x200042fc
    6700:	200042b4 	.word	0x200042b4
    6704:	20004830 	.word	0x20004830
    6708:	200042b8 	.word	0x200042b8
    670c:	20004828 	.word	0x20004828
    6710:	2000011c 	.word	0x2000011c
    6714:	00012718 	.word	0x00012718
    6718:	20000130 	.word	0x20000130

0000671c <ll_reset>:
{
    671c:	b570      	push	{r4, r5, r6, lr}
    671e:	b086      	sub	sp, #24
	err = ull_scan_reset();
    6720:	f008 fbd7 	bl	eed2 <ull_scan_reset>
	LL_ASSERT(!err);
    6724:	bb70      	cbnz	r0, 6784 <ll_reset+0x68>
		ull_filter_reset(false);
    6726:	2000      	movs	r0, #0
    6728:	f000 fe80 	bl	742c <ull_filter_reset>
	MFIFO_INIT(prep);
    672c:	4b70      	ldr	r3, [pc, #448]	; (68f0 <ll_reset+0x1d4>)
    672e:	2400      	movs	r4, #0
    6730:	70dc      	strb	r4, [r3, #3]
    6732:	709c      	strb	r4, [r3, #2]
	MFIFO_INIT(done);
    6734:	4b6f      	ldr	r3, [pc, #444]	; (68f4 <ll_reset+0x1d8>)
    6736:	70dc      	strb	r4, [r3, #3]
    6738:	709c      	strb	r4, [r3, #2]
	MFIFO_INIT(pdu_rx_free);
    673a:	4b6f      	ldr	r3, [pc, #444]	; (68f8 <ll_reset+0x1dc>)
    673c:	70dc      	strb	r4, [r3, #3]
    673e:	709c      	strb	r4, [r3, #2]
    6740:	2201      	movs	r2, #1
    6742:	4621      	mov	r1, r4
    6744:	4668      	mov	r0, sp
    6746:	f009 fda4 	bl	10292 <z_impl_k_sem_init>
		mfy.param = &sem;
    674a:	4b6c      	ldr	r3, [pc, #432]	; (68fc <ll_reset+0x1e0>)
    674c:	f8c3 d008 	str.w	sp, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
    6750:	4622      	mov	r2, r4
    6752:	4621      	mov	r1, r4
    6754:	2003      	movs	r0, #3
    6756:	f7fe fcab 	bl	50b0 <mayfly_enqueue>
		LL_ASSERT(!retval);
    675a:	bb08      	cbnz	r0, 67a0 <ll_reset+0x84>
	return z_impl_k_sem_take(sem, timeout);
    675c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    6760:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    6764:	4668      	mov	r0, sp
    6766:	f004 fdf1 	bl	b34c <z_impl_k_sem_take>
	mem_init(mem_done.pool, sizeof(struct node_rx_event_done),
    676a:	4b65      	ldr	r3, [pc, #404]	; (6900 <ll_reset+0x1e4>)
    676c:	2203      	movs	r2, #3
    676e:	2138      	movs	r1, #56	; 0x38
    6770:	1d18      	adds	r0, r3, #4
    6772:	f007 fd81 	bl	e278 <mem_init>
	mem_init(mem_link_done.pool, sizeof(memq_link_t), EVENT_DONE_MAX,
    6776:	4b63      	ldr	r3, [pc, #396]	; (6904 <ll_reset+0x1e8>)
    6778:	2203      	movs	r2, #3
    677a:	2108      	movs	r1, #8
    677c:	1d18      	adds	r0, r3, #4
    677e:	f007 fd7b 	bl	e278 <mem_init>
static inline void done_alloc(void)
    6782:	e05e      	b.n	6842 <ll_reset+0x126>
	LL_ASSERT(!err);
    6784:	f240 136b 	movw	r3, #363	; 0x16b
    6788:	4a5f      	ldr	r2, [pc, #380]	; (6908 <ll_reset+0x1ec>)
    678a:	4960      	ldr	r1, [pc, #384]	; (690c <ll_reset+0x1f0>)
    678c:	4860      	ldr	r0, [pc, #384]	; (6910 <ll_reset+0x1f4>)
    678e:	f006 fc4e 	bl	d02e <printk>
    6792:	4040      	eors	r0, r0
    6794:	f380 8811 	msr	BASEPRI, r0
    6798:	f04f 0003 	mov.w	r0, #3
    679c:	df02      	svc	2
    679e:	e7c2      	b.n	6726 <ll_reset+0xa>
		LL_ASSERT(!retval);
    67a0:	f240 13b7 	movw	r3, #439	; 0x1b7
    67a4:	4a58      	ldr	r2, [pc, #352]	; (6908 <ll_reset+0x1ec>)
    67a6:	495b      	ldr	r1, [pc, #364]	; (6914 <ll_reset+0x1f8>)
    67a8:	4859      	ldr	r0, [pc, #356]	; (6910 <ll_reset+0x1f4>)
    67aa:	f006 fc40 	bl	d02e <printk>
    67ae:	4040      	eors	r0, r0
    67b0:	f380 8811 	msr	BASEPRI, r0
    67b4:	f04f 0003 	mov.w	r0, #3
    67b8:	df02      	svc	2
    67ba:	e7cf      	b.n	675c <ll_reset+0x40>
			mem_release(link, &mem_link_done.free);
    67bc:	4951      	ldr	r1, [pc, #324]	; (6904 <ll_reset+0x1e8>)
    67be:	4628      	mov	r0, r5
    67c0:	f007 fd8c 	bl	e2dc <mem_release>
	mem_init(mem_pdu_rx.pool, (PDU_RX_NODE_POOL_ELEMENT_SIZE),
    67c4:	4b54      	ldr	r3, [pc, #336]	; (6918 <ll_reset+0x1fc>)
    67c6:	2206      	movs	r2, #6
    67c8:	21dc      	movs	r1, #220	; 0xdc
    67ca:	1d18      	adds	r0, r3, #4
    67cc:	f007 fd54 	bl	e278 <mem_init>
	mem_init(mem_link_rx.pool, sizeof(memq_link_t),
    67d0:	4852      	ldr	r0, [pc, #328]	; (691c <ll_reset+0x200>)
    67d2:	1d04      	adds	r4, r0, #4
    67d4:	4623      	mov	r3, r4
    67d6:	2208      	movs	r2, #8
    67d8:	4611      	mov	r1, r2
    67da:	4410      	add	r0, r2
    67dc:	f007 fd4c 	bl	e278 <mem_init>
	link = mem_acquire(&mem_link_rx.free);
    67e0:	4620      	mov	r0, r4
    67e2:	f007 fd65 	bl	e2b0 <mem_acquire>
	LL_ASSERT(link);
    67e6:	4604      	mov	r4, r0
    67e8:	2800      	cmp	r0, #0
    67ea:	d034      	beq.n	6856 <ll_reset+0x13a>
	MEMQ_INIT(ull_rx, link);
    67ec:	494c      	ldr	r1, [pc, #304]	; (6920 <ll_reset+0x204>)
    67ee:	1d0a      	adds	r2, r1, #4
    67f0:	4620      	mov	r0, r4
    67f2:	f007 fd9e 	bl	e332 <memq_init>
	link = mem_acquire(&mem_link_rx.free);
    67f6:	484b      	ldr	r0, [pc, #300]	; (6924 <ll_reset+0x208>)
    67f8:	f007 fd5a 	bl	e2b0 <mem_acquire>
	LL_ASSERT(link);
    67fc:	4604      	mov	r4, r0
    67fe:	2800      	cmp	r0, #0
    6800:	d037      	beq.n	6872 <ll_reset+0x156>
	MEMQ_INIT(ll_rx, link);
    6802:	4949      	ldr	r1, [pc, #292]	; (6928 <ll_reset+0x20c>)
    6804:	1d0a      	adds	r2, r1, #4
    6806:	4620      	mov	r0, r4
    6808:	f007 fd93 	bl	e332 <memq_init>
	mem_link_rx.quota_pdu = RX_CNT;
    680c:	2306      	movs	r3, #6
    680e:	4a43      	ldr	r2, [pc, #268]	; (691c <ll_reset+0x200>)
    6810:	7013      	strb	r3, [r2, #0]
	if (max > mem_link_rx.quota_pdu) {
    6812:	e05e      	b.n	68d2 <ll_reset+0x1b6>
	if (last == first) {
    6814:	4294      	cmp	r4, r2
    6816:	d0d5      	beq.n	67c4 <ll_reset+0xa8>
		link = mem_acquire(&mem_link_done.free);
    6818:	483a      	ldr	r0, [pc, #232]	; (6904 <ll_reset+0x1e8>)
    681a:	f007 fd49 	bl	e2b0 <mem_acquire>
		if (!link) {
    681e:	4605      	mov	r5, r0
    6820:	2800      	cmp	r0, #0
    6822:	d0cf      	beq.n	67c4 <ll_reset+0xa8>
		rx = mem_acquire(&mem_done.free);
    6824:	4836      	ldr	r0, [pc, #216]	; (6900 <ll_reset+0x1e4>)
    6826:	f007 fd43 	bl	e2b0 <mem_acquire>
		if (!rx) {
    682a:	4601      	mov	r1, r0
    682c:	2800      	cmp	r0, #0
    682e:	d0c5      	beq.n	67bc <ll_reset+0xa0>
		rx->link = link;
    6830:	6005      	str	r5, [r0, #0]
		MFIFO_BY_IDX_ENQUEUE(done, idx, rx);
    6832:	4b30      	ldr	r3, [pc, #192]	; (68f4 <ll_reset+0x1d8>)
    6834:	7818      	ldrb	r0, [r3, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    6836:	78da      	ldrb	r2, [r3, #3]
    6838:	fb02 f200 	mul.w	r2, r2, r0
    683c:	1d18      	adds	r0, r3, #4
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    683e:	5081      	str	r1, [r0, r2]
	*last = idx; /* Commit: Update write index */
    6840:	70dc      	strb	r4, [r3, #3]
	while (MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
    6842:	4b2c      	ldr	r3, [pc, #176]	; (68f4 <ll_reset+0x1d8>)
    6844:	7859      	ldrb	r1, [r3, #1]
    6846:	789a      	ldrb	r2, [r3, #2]
    6848:	78dc      	ldrb	r4, [r3, #3]
	last = last + 1;
    684a:	3401      	adds	r4, #1
    684c:	b2e4      	uxtb	r4, r4
	if (last == count) {
    684e:	42a1      	cmp	r1, r4
    6850:	d1e0      	bne.n	6814 <ll_reset+0xf8>
		last = 0U;
    6852:	2400      	movs	r4, #0
    6854:	e7de      	b.n	6814 <ll_reset+0xf8>
	LL_ASSERT(link);
    6856:	f240 43b6 	movw	r3, #1206	; 0x4b6
    685a:	4a2b      	ldr	r2, [pc, #172]	; (6908 <ll_reset+0x1ec>)
    685c:	4933      	ldr	r1, [pc, #204]	; (692c <ll_reset+0x210>)
    685e:	482c      	ldr	r0, [pc, #176]	; (6910 <ll_reset+0x1f4>)
    6860:	f006 fbe5 	bl	d02e <printk>
    6864:	4040      	eors	r0, r0
    6866:	f380 8811 	msr	BASEPRI, r0
    686a:	f04f 0003 	mov.w	r0, #3
    686e:	df02      	svc	2
    6870:	e7bc      	b.n	67ec <ll_reset+0xd0>
	LL_ASSERT(link);
    6872:	f240 43bd 	movw	r3, #1213	; 0x4bd
    6876:	4a24      	ldr	r2, [pc, #144]	; (6908 <ll_reset+0x1ec>)
    6878:	492c      	ldr	r1, [pc, #176]	; (692c <ll_reset+0x210>)
    687a:	4825      	ldr	r0, [pc, #148]	; (6910 <ll_reset+0x1f4>)
    687c:	f006 fbd7 	bl	d02e <printk>
    6880:	4040      	eors	r0, r0
    6882:	f380 8811 	msr	BASEPRI, r0
    6886:	f04f 0003 	mov.w	r0, #3
    688a:	df02      	svc	2
    688c:	e7b9      	b.n	6802 <ll_reset+0xe6>
			mem_release(link, &mem_link_rx.free);
    688e:	4925      	ldr	r1, [pc, #148]	; (6924 <ll_reset+0x208>)
    6890:	4630      	mov	r0, r6
    6892:	f007 fd23 	bl	e2dc <mem_release>
}
    6896:	b006      	add	sp, #24
    6898:	bd70      	pop	{r4, r5, r6, pc}
	if (last == first) {
    689a:	4294      	cmp	r4, r2
    689c:	d0fb      	beq.n	6896 <ll_reset+0x17a>
		link = mem_acquire(&mem_link_rx.free);
    689e:	4821      	ldr	r0, [pc, #132]	; (6924 <ll_reset+0x208>)
    68a0:	f007 fd06 	bl	e2b0 <mem_acquire>
		if (!link) {
    68a4:	4606      	mov	r6, r0
    68a6:	2800      	cmp	r0, #0
    68a8:	d0f5      	beq.n	6896 <ll_reset+0x17a>
		rx = mem_acquire(&mem_pdu_rx.free);
    68aa:	481b      	ldr	r0, [pc, #108]	; (6918 <ll_reset+0x1fc>)
    68ac:	f007 fd00 	bl	e2b0 <mem_acquire>
		if (!rx) {
    68b0:	4601      	mov	r1, r0
    68b2:	2800      	cmp	r0, #0
    68b4:	d0eb      	beq.n	688e <ll_reset+0x172>
		rx->link = link;
    68b6:	6006      	str	r6, [r0, #0]
		MFIFO_BY_IDX_ENQUEUE(pdu_rx_free, idx, rx);
    68b8:	4b0f      	ldr	r3, [pc, #60]	; (68f8 <ll_reset+0x1dc>)
    68ba:	7818      	ldrb	r0, [r3, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    68bc:	78da      	ldrb	r2, [r3, #3]
    68be:	fb02 f200 	mul.w	r2, r2, r0
    68c2:	1d18      	adds	r0, r3, #4
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    68c4:	5081      	str	r1, [r0, r2]
	*last = idx; /* Commit: Update write index */
    68c6:	70dc      	strb	r4, [r3, #3]
	mem_link_rx.quota_pdu += delta;
    68c8:	4a14      	ldr	r2, [pc, #80]	; (691c <ll_reset+0x200>)
    68ca:	7813      	ldrb	r3, [r2, #0]
    68cc:	3b01      	subs	r3, #1
    68ce:	7013      	strb	r3, [r2, #0]
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
    68d0:	462b      	mov	r3, r5
    68d2:	1e5d      	subs	r5, r3, #1
    68d4:	b2ed      	uxtb	r5, r5
    68d6:	2b00      	cmp	r3, #0
    68d8:	d0dd      	beq.n	6896 <ll_reset+0x17a>
    68da:	4b07      	ldr	r3, [pc, #28]	; (68f8 <ll_reset+0x1dc>)
    68dc:	7859      	ldrb	r1, [r3, #1]
    68de:	789a      	ldrb	r2, [r3, #2]
    68e0:	78dc      	ldrb	r4, [r3, #3]
	last = last + 1;
    68e2:	3401      	adds	r4, #1
    68e4:	b2e4      	uxtb	r4, r4
	if (last == count) {
    68e6:	42a1      	cmp	r1, r4
    68e8:	d1d7      	bne.n	689a <ll_reset+0x17e>
		last = 0U;
    68ea:	2400      	movs	r4, #0
    68ec:	e7d5      	b.n	689a <ll_reset+0x17e>
    68ee:	bf00      	nop
    68f0:	20000148 	.word	0x20000148
    68f4:	2000011c 	.word	0x2000011c
    68f8:	20000130 	.word	0x20000130
    68fc:	2000026c 	.word	0x2000026c
    6900:	200041ec 	.word	0x200041ec
    6904:	20004298 	.word	0x20004298
    6908:	0001269c 	.word	0x0001269c
    690c:	00012710 	.word	0x00012710
    6910:	00011fec 	.word	0x00011fec
    6914:	00012720 	.word	0x00012720
    6918:	200042fc 	.word	0x200042fc
    691c:	200042b4 	.word	0x200042b4
    6920:	20004830 	.word	0x20004830
    6924:	200042b8 	.word	0x200042b8
    6928:	20004828 	.word	0x20004828
    692c:	00012718 	.word	0x00012718

00006930 <ll_rx_get>:
{
    6930:	b510      	push	{r4, lr}
    6932:	b082      	sub	sp, #8
    6934:	4604      	mov	r4, r0
	*node_rx = NULL;
    6936:	2300      	movs	r3, #0
    6938:	6003      	str	r3, [r0, #0]
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
    693a:	4b06      	ldr	r3, [pc, #24]	; (6954 <ll_rx_get+0x24>)
    693c:	aa01      	add	r2, sp, #4
    693e:	6859      	ldr	r1, [r3, #4]
    6940:	6818      	ldr	r0, [r3, #0]
    6942:	f007 fd01 	bl	e348 <memq_peek>
	if (link) {
    6946:	b108      	cbz	r0, 694c <ll_rx_get+0x1c>
			*node_rx = rx;
    6948:	9b01      	ldr	r3, [sp, #4]
    694a:	6023      	str	r3, [r4, #0]
}
    694c:	2000      	movs	r0, #0
    694e:	b002      	add	sp, #8
    6950:	bd10      	pop	{r4, pc}
    6952:	bf00      	nop
    6954:	20004828 	.word	0x20004828

00006958 <ll_rx_dequeue>:
{
    6958:	b510      	push	{r4, lr}
    695a:	b082      	sub	sp, #8
	struct node_rx_hdr *rx = NULL;
    695c:	2300      	movs	r3, #0
    695e:	9301      	str	r3, [sp, #4]
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
    6960:	491e      	ldr	r1, [pc, #120]	; (69dc <ll_rx_dequeue+0x84>)
    6962:	aa01      	add	r2, sp, #4
    6964:	6848      	ldr	r0, [r1, #4]
    6966:	f007 fcf7 	bl	e358 <memq_dequeue>
	LL_ASSERT(link);
    696a:	4604      	mov	r4, r0
    696c:	b158      	cbz	r0, 6986 <ll_rx_dequeue+0x2e>
	mem_release(link, &mem_link_rx.free);
    696e:	491c      	ldr	r1, [pc, #112]	; (69e0 <ll_rx_dequeue+0x88>)
    6970:	4620      	mov	r0, r4
    6972:	f007 fcb3 	bl	e2dc <mem_release>
	switch (rx->type) {
    6976:	9b01      	ldr	r3, [sp, #4]
    6978:	791b      	ldrb	r3, [r3, #4]
    697a:	b10b      	cbz	r3, 6980 <ll_rx_dequeue+0x28>
    697c:	2b04      	cmp	r3, #4
    697e:	d11e      	bne.n	69be <ll_rx_dequeue+0x66>
		LL_ASSERT(rx->type != NODE_RX_TYPE_NONE);
    6980:	b17b      	cbz	r3, 69a2 <ll_rx_dequeue+0x4a>
}
    6982:	b002      	add	sp, #8
    6984:	bd10      	pop	{r4, pc}
	LL_ASSERT(link);
    6986:	f240 2315 	movw	r3, #533	; 0x215
    698a:	4a16      	ldr	r2, [pc, #88]	; (69e4 <ll_rx_dequeue+0x8c>)
    698c:	4916      	ldr	r1, [pc, #88]	; (69e8 <ll_rx_dequeue+0x90>)
    698e:	4817      	ldr	r0, [pc, #92]	; (69ec <ll_rx_dequeue+0x94>)
    6990:	f006 fb4d 	bl	d02e <printk>
    6994:	4040      	eors	r0, r0
    6996:	f380 8811 	msr	BASEPRI, r0
    699a:	f04f 0003 	mov.w	r0, #3
    699e:	df02      	svc	2
    69a0:	e7e5      	b.n	696e <ll_rx_dequeue+0x16>
		LL_ASSERT(rx->type != NODE_RX_TYPE_NONE);
    69a2:	f240 23a1 	movw	r3, #673	; 0x2a1
    69a6:	4a0f      	ldr	r2, [pc, #60]	; (69e4 <ll_rx_dequeue+0x8c>)
    69a8:	4911      	ldr	r1, [pc, #68]	; (69f0 <ll_rx_dequeue+0x98>)
    69aa:	4810      	ldr	r0, [pc, #64]	; (69ec <ll_rx_dequeue+0x94>)
    69ac:	f006 fb3f 	bl	d02e <printk>
    69b0:	4040      	eors	r0, r0
    69b2:	f380 8811 	msr	BASEPRI, r0
    69b6:	f04f 0003 	mov.w	r0, #3
    69ba:	df02      	svc	2
    69bc:	e7e1      	b.n	6982 <ll_rx_dequeue+0x2a>
		LL_ASSERT(0);
    69be:	f240 23a5 	movw	r3, #677	; 0x2a5
    69c2:	4a08      	ldr	r2, [pc, #32]	; (69e4 <ll_rx_dequeue+0x8c>)
    69c4:	490b      	ldr	r1, [pc, #44]	; (69f4 <ll_rx_dequeue+0x9c>)
    69c6:	4809      	ldr	r0, [pc, #36]	; (69ec <ll_rx_dequeue+0x94>)
    69c8:	f006 fb31 	bl	d02e <printk>
    69cc:	4040      	eors	r0, r0
    69ce:	f380 8811 	msr	BASEPRI, r0
    69d2:	f04f 0003 	mov.w	r0, #3
    69d6:	df02      	svc	2
}
    69d8:	e7d3      	b.n	6982 <ll_rx_dequeue+0x2a>
    69da:	bf00      	nop
    69dc:	20004828 	.word	0x20004828
    69e0:	200042b8 	.word	0x200042b8
    69e4:	0001269c 	.word	0x0001269c
    69e8:	00012718 	.word	0x00012718
    69ec:	00011fec 	.word	0x00011fec
    69f0:	00012728 	.word	0x00012728
    69f4:	00010df0 	.word	0x00010df0

000069f8 <ll_rx_mem_release>:
{
    69f8:	b570      	push	{r4, r5, r6, lr}
    69fa:	4606      	mov	r6, r0
	rx = *node_rx;
    69fc:	6804      	ldr	r4, [r0, #0]
	while (rx) {
    69fe:	e023      	b.n	6a48 <ll_rx_mem_release+0x50>
			LL_ASSERT(rx_free->type != NODE_RX_TYPE_NONE);
    6a00:	f240 333e 	movw	r3, #830	; 0x33e
    6a04:	4a37      	ldr	r2, [pc, #220]	; (6ae4 <ll_rx_mem_release+0xec>)
    6a06:	4938      	ldr	r1, [pc, #224]	; (6ae8 <ll_rx_mem_release+0xf0>)
    6a08:	4838      	ldr	r0, [pc, #224]	; (6aec <ll_rx_mem_release+0xf4>)
    6a0a:	f006 fb10 	bl	d02e <printk>
    6a0e:	4040      	eors	r0, r0
    6a10:	f380 8811 	msr	BASEPRI, r0
    6a14:	f04f 0003 	mov.w	r0, #3
    6a18:	df02      	svc	2
    6a1a:	e01d      	b.n	6a58 <ll_rx_mem_release+0x60>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
    6a1c:	f44f 7359 	mov.w	r3, #868	; 0x364
    6a20:	4a30      	ldr	r2, [pc, #192]	; (6ae4 <ll_rx_mem_release+0xec>)
    6a22:	4933      	ldr	r1, [pc, #204]	; (6af0 <ll_rx_mem_release+0xf8>)
    6a24:	4831      	ldr	r0, [pc, #196]	; (6aec <ll_rx_mem_release+0xf4>)
    6a26:	f006 fb02 	bl	d02e <printk>
    6a2a:	4040      	eors	r0, r0
    6a2c:	f380 8811 	msr	BASEPRI, r0
    6a30:	f04f 0003 	mov.w	r0, #3
    6a34:	df02      	svc	2
	mem_link_rx.quota_pdu += delta;
    6a36:	4a2f      	ldr	r2, [pc, #188]	; (6af4 <ll_rx_mem_release+0xfc>)
    6a38:	7813      	ldrb	r3, [r2, #0]
    6a3a:	3301      	adds	r3, #1
    6a3c:	7013      	strb	r3, [r2, #0]
			mem_release(rx_free, &mem_pdu_rx.free);
    6a3e:	492e      	ldr	r1, [pc, #184]	; (6af8 <ll_rx_mem_release+0x100>)
    6a40:	4620      	mov	r0, r4
    6a42:	f007 fc4b 	bl	e2dc <mem_release>
{
    6a46:	462c      	mov	r4, r5
	while (rx) {
    6a48:	b1cc      	cbz	r4, 6a7e <ll_rx_mem_release+0x86>
		rx = rx->next;
    6a4a:	6825      	ldr	r5, [r4, #0]
		switch (rx_free->type) {
    6a4c:	7923      	ldrb	r3, [r4, #4]
    6a4e:	b10b      	cbz	r3, 6a54 <ll_rx_mem_release+0x5c>
    6a50:	2b04      	cmp	r3, #4
    6a52:	d106      	bne.n	6a62 <ll_rx_mem_release+0x6a>
			LL_ASSERT(rx_free->type != NODE_RX_TYPE_NONE);
    6a54:	2b00      	cmp	r3, #0
    6a56:	d0d3      	beq.n	6a00 <ll_rx_mem_release+0x8>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
    6a58:	4b26      	ldr	r3, [pc, #152]	; (6af4 <ll_rx_mem_release+0xfc>)
    6a5a:	781b      	ldrb	r3, [r3, #0]
    6a5c:	2b05      	cmp	r3, #5
    6a5e:	d9ea      	bls.n	6a36 <ll_rx_mem_release+0x3e>
    6a60:	e7dc      	b.n	6a1c <ll_rx_mem_release+0x24>
			LL_ASSERT(0);
    6a62:	f44f 7356 	mov.w	r3, #856	; 0x358
    6a66:	4a1f      	ldr	r2, [pc, #124]	; (6ae4 <ll_rx_mem_release+0xec>)
    6a68:	4924      	ldr	r1, [pc, #144]	; (6afc <ll_rx_mem_release+0x104>)
    6a6a:	4820      	ldr	r0, [pc, #128]	; (6aec <ll_rx_mem_release+0xf4>)
    6a6c:	f006 fadf 	bl	d02e <printk>
    6a70:	4040      	eors	r0, r0
    6a72:	f380 8811 	msr	BASEPRI, r0
    6a76:	f04f 0003 	mov.w	r0, #3
    6a7a:	df02      	svc	2
			break;
    6a7c:	e7e3      	b.n	6a46 <ll_rx_mem_release+0x4e>
	*node_rx = rx;
    6a7e:	6034      	str	r4, [r6, #0]
	if (max > mem_link_rx.quota_pdu) {
    6a80:	4b1c      	ldr	r3, [pc, #112]	; (6af4 <ll_rx_mem_release+0xfc>)
    6a82:	781b      	ldrb	r3, [r3, #0]
    6a84:	e020      	b.n	6ac8 <ll_rx_mem_release+0xd0>
			mem_release(link, &mem_link_rx.free);
    6a86:	491e      	ldr	r1, [pc, #120]	; (6b00 <ll_rx_mem_release+0x108>)
    6a88:	4630      	mov	r0, r6
    6a8a:	f007 fc27 	bl	e2dc <mem_release>
}
    6a8e:	bd70      	pop	{r4, r5, r6, pc}
	if (last == first) {
    6a90:	4294      	cmp	r4, r2
    6a92:	d0fc      	beq.n	6a8e <ll_rx_mem_release+0x96>
		link = mem_acquire(&mem_link_rx.free);
    6a94:	481a      	ldr	r0, [pc, #104]	; (6b00 <ll_rx_mem_release+0x108>)
    6a96:	f007 fc0b 	bl	e2b0 <mem_acquire>
		if (!link) {
    6a9a:	4606      	mov	r6, r0
    6a9c:	2800      	cmp	r0, #0
    6a9e:	d0f6      	beq.n	6a8e <ll_rx_mem_release+0x96>
		rx = mem_acquire(&mem_pdu_rx.free);
    6aa0:	4815      	ldr	r0, [pc, #84]	; (6af8 <ll_rx_mem_release+0x100>)
    6aa2:	f007 fc05 	bl	e2b0 <mem_acquire>
		if (!rx) {
    6aa6:	4601      	mov	r1, r0
    6aa8:	2800      	cmp	r0, #0
    6aaa:	d0ec      	beq.n	6a86 <ll_rx_mem_release+0x8e>
		rx->link = link;
    6aac:	6006      	str	r6, [r0, #0]
		MFIFO_BY_IDX_ENQUEUE(pdu_rx_free, idx, rx);
    6aae:	4b15      	ldr	r3, [pc, #84]	; (6b04 <ll_rx_mem_release+0x10c>)
    6ab0:	7818      	ldrb	r0, [r3, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    6ab2:	78da      	ldrb	r2, [r3, #3]
    6ab4:	fb02 f200 	mul.w	r2, r2, r0
    6ab8:	1d18      	adds	r0, r3, #4
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    6aba:	5081      	str	r1, [r0, r2]
	*last = idx; /* Commit: Update write index */
    6abc:	70dc      	strb	r4, [r3, #3]
	mem_link_rx.quota_pdu += delta;
    6abe:	4a0d      	ldr	r2, [pc, #52]	; (6af4 <ll_rx_mem_release+0xfc>)
    6ac0:	7813      	ldrb	r3, [r2, #0]
    6ac2:	3b01      	subs	r3, #1
    6ac4:	7013      	strb	r3, [r2, #0]
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
    6ac6:	462b      	mov	r3, r5
    6ac8:	1e5d      	subs	r5, r3, #1
    6aca:	b2ed      	uxtb	r5, r5
    6acc:	2b00      	cmp	r3, #0
    6ace:	d0de      	beq.n	6a8e <ll_rx_mem_release+0x96>
    6ad0:	4b0c      	ldr	r3, [pc, #48]	; (6b04 <ll_rx_mem_release+0x10c>)
    6ad2:	7859      	ldrb	r1, [r3, #1]
    6ad4:	789a      	ldrb	r2, [r3, #2]
    6ad6:	78dc      	ldrb	r4, [r3, #3]
	last = last + 1;
    6ad8:	3401      	adds	r4, #1
    6ada:	b2e4      	uxtb	r4, r4
	if (last == count) {
    6adc:	42a1      	cmp	r1, r4
    6ade:	d1d7      	bne.n	6a90 <ll_rx_mem_release+0x98>
		last = 0U;
    6ae0:	2400      	movs	r4, #0
    6ae2:	e7d5      	b.n	6a90 <ll_rx_mem_release+0x98>
    6ae4:	0001269c 	.word	0x0001269c
    6ae8:	00012748 	.word	0x00012748
    6aec:	00011fec 	.word	0x00011fec
    6af0:	0001276c 	.word	0x0001276c
    6af4:	200042b4 	.word	0x200042b4
    6af8:	200042fc 	.word	0x200042fc
    6afc:	00010df0 	.word	0x00010df0
    6b00:	200042b8 	.word	0x200042b8
    6b04:	20000130 	.word	0x20000130

00006b08 <ll_rx_put>:
{
    6b08:	b508      	push	{r3, lr}
	memq_enqueue(link, rx, &memq_ll_rx.tail);
    6b0a:	4a02      	ldr	r2, [pc, #8]	; (6b14 <ll_rx_put+0xc>)
    6b0c:	f007 fc14 	bl	e338 <memq_enqueue>
}
    6b10:	bd08      	pop	{r3, pc}
    6b12:	bf00      	nop
    6b14:	2000482c 	.word	0x2000482c

00006b18 <ll_rx_sched>:
{
    6b18:	b508      	push	{r3, lr}
	k_sem_give(sem_recv);
    6b1a:	4b02      	ldr	r3, [pc, #8]	; (6b24 <ll_rx_sched+0xc>)
    6b1c:	6818      	ldr	r0, [r3, #0]
	z_impl_k_sem_give(sem);
    6b1e:	f004 fbed 	bl	b2fc <z_impl_k_sem_give>
}
    6b22:	bd08      	pop	{r3, pc}
    6b24:	20004838 	.word	0x20004838

00006b28 <ull_ticker_status_give>:
{
    6b28:	b508      	push	{r3, lr}
	*((u32_t volatile *)param) = status;
    6b2a:	6008      	str	r0, [r1, #0]
    6b2c:	4801      	ldr	r0, [pc, #4]	; (6b34 <ull_ticker_status_give+0xc>)
    6b2e:	f004 fbe5 	bl	b2fc <z_impl_k_sem_give>
}
    6b32:	bd08      	pop	{r3, pc}
    6b34:	2000483c 	.word	0x2000483c

00006b38 <ull_ticker_status_take>:
{
    6b38:	b510      	push	{r4, lr}
    6b3a:	460c      	mov	r4, r1
	return z_impl_k_sem_take(sem, timeout);
    6b3c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    6b40:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    6b44:	4802      	ldr	r0, [pc, #8]	; (6b50 <ull_ticker_status_take+0x18>)
    6b46:	f004 fc01 	bl	b34c <z_impl_k_sem_take>
	return *ret_cb;
    6b4a:	6820      	ldr	r0, [r4, #0]
}
    6b4c:	bd10      	pop	{r4, pc}
    6b4e:	bf00      	nop
    6b50:	2000483c 	.word	0x2000483c

00006b54 <ull_disable_mark>:
	if (!*m) {
    6b54:	4b04      	ldr	r3, [pc, #16]	; (6b68 <ull_disable_mark+0x14>)
    6b56:	681b      	ldr	r3, [r3, #0]
    6b58:	b113      	cbz	r3, 6b60 <ull_disable_mark+0xc>
}
    6b5a:	4b03      	ldr	r3, [pc, #12]	; (6b68 <ull_disable_mark+0x14>)
    6b5c:	6818      	ldr	r0, [r3, #0]
    6b5e:	4770      	bx	lr
		*m = param;
    6b60:	4b01      	ldr	r3, [pc, #4]	; (6b68 <ull_disable_mark+0x14>)
    6b62:	6018      	str	r0, [r3, #0]
    6b64:	e7f9      	b.n	6b5a <ull_disable_mark+0x6>
    6b66:	bf00      	nop
    6b68:	200041e8 	.word	0x200041e8

00006b6c <ull_disable_unmark>:
{
    6b6c:	4603      	mov	r3, r0
	if (*m && *m == param) {
    6b6e:	4a05      	ldr	r2, [pc, #20]	; (6b84 <ull_disable_unmark+0x18>)
    6b70:	6810      	ldr	r0, [r2, #0]
    6b72:	b110      	cbz	r0, 6b7a <ull_disable_unmark+0xe>
    6b74:	4283      	cmp	r3, r0
    6b76:	d001      	beq.n	6b7c <ull_disable_unmark+0x10>
	return NULL;
    6b78:	2000      	movs	r0, #0
}
    6b7a:	4770      	bx	lr
		*m = NULL;
    6b7c:	2100      	movs	r1, #0
    6b7e:	6011      	str	r1, [r2, #0]
		return param;
    6b80:	4618      	mov	r0, r3
    6b82:	4770      	bx	lr
    6b84:	200041e8 	.word	0x200041e8

00006b88 <ull_disable>:
{
    6b88:	b530      	push	{r4, r5, lr}
    6b8a:	b087      	sub	sp, #28
	hdr = HDR_ULL(((struct lll_hdr *)lll)->parent);
    6b8c:	6805      	ldr	r5, [r0, #0]
	if (!hdr) {
    6b8e:	f115 0f10 	cmn.w	r5, #16
    6b92:	d02c      	beq.n	6bee <ull_disable+0x66>
    6b94:	4604      	mov	r4, r0
	return z_impl_k_sem_init(sem, initial_count, limit);
    6b96:	2201      	movs	r2, #1
    6b98:	2100      	movs	r1, #0
    6b9a:	4668      	mov	r0, sp
    6b9c:	f009 fb79 	bl	10292 <z_impl_k_sem_init>
	hdr->disabled_param = &sem;
    6ba0:	f8c5 d018 	str.w	sp, [r5, #24]
	hdr->disabled_cb = disabled_cb;
    6ba4:	4b13      	ldr	r3, [pc, #76]	; (6bf4 <ull_disable+0x6c>)
    6ba6:	616b      	str	r3, [r5, #20]
	if (!hdr->ref) {
    6ba8:	7c2b      	ldrb	r3, [r5, #16]
    6baa:	b913      	cbnz	r3, 6bb2 <ull_disable+0x2a>
		return ULL_STATUS_SUCCESS;
    6bac:	2000      	movs	r0, #0
}
    6bae:	b007      	add	sp, #28
    6bb0:	bd30      	pop	{r4, r5, pc}
	mfy.param = lll;
    6bb2:	4b11      	ldr	r3, [pc, #68]	; (6bf8 <ull_disable+0x70>)
    6bb4:	609c      	str	r4, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
    6bb6:	2200      	movs	r2, #0
    6bb8:	4611      	mov	r1, r2
    6bba:	2003      	movs	r0, #3
    6bbc:	f7fe fa78 	bl	50b0 <mayfly_enqueue>
	LL_ASSERT(!ret);
    6bc0:	b938      	cbnz	r0, 6bd2 <ull_disable+0x4a>
	return z_impl_k_sem_take(sem, timeout);
    6bc2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    6bc6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    6bca:	4668      	mov	r0, sp
    6bcc:	f004 fbbe 	bl	b34c <z_impl_k_sem_take>
	return k_sem_take(&sem, K_FOREVER);
    6bd0:	e7ed      	b.n	6bae <ull_disable+0x26>
	LL_ASSERT(!ret);
    6bd2:	f240 4319 	movw	r3, #1049	; 0x419
    6bd6:	4a09      	ldr	r2, [pc, #36]	; (6bfc <ull_disable+0x74>)
    6bd8:	4909      	ldr	r1, [pc, #36]	; (6c00 <ull_disable+0x78>)
    6bda:	480a      	ldr	r0, [pc, #40]	; (6c04 <ull_disable+0x7c>)
    6bdc:	f006 fa27 	bl	d02e <printk>
    6be0:	4040      	eors	r0, r0
    6be2:	f380 8811 	msr	BASEPRI, r0
    6be6:	f04f 0003 	mov.w	r0, #3
    6bea:	df02      	svc	2
    6bec:	e7e9      	b.n	6bc2 <ull_disable+0x3a>
		return ULL_STATUS_SUCCESS;
    6bee:	2000      	movs	r0, #0
    6bf0:	e7dd      	b.n	6bae <ull_disable+0x26>
    6bf2:	bf00      	nop
    6bf4:	0000ee6d 	.word	0x0000ee6d
    6bf8:	2000027c 	.word	0x2000027c
    6bfc:	0001269c 	.word	0x0001269c
    6c00:	000127a0 	.word	0x000127a0
    6c04:	00011fec 	.word	0x00011fec

00006c08 <ull_pdu_rx_alloc_peek>:
	if (count > MFIFO_AVAIL_COUNT_GET(pdu_rx_free)) {
    6c08:	490d      	ldr	r1, [pc, #52]	; (6c40 <ull_pdu_rx_alloc_peek+0x38>)
    6c0a:	784b      	ldrb	r3, [r1, #1]
    6c0c:	788a      	ldrb	r2, [r1, #2]
    6c0e:	78c9      	ldrb	r1, [r1, #3]
 * @details API 1 and 2
 *   Empty if first == last
 */
static inline u8_t mfifo_avail_count_get(u8_t count, u8_t first, u8_t last)
{
	if (last >= first) {
    6c10:	428a      	cmp	r2, r1
    6c12:	d80c      	bhi.n	6c2e <ull_pdu_rx_alloc_peek+0x26>
		return last - first;
    6c14:	1a8b      	subs	r3, r1, r2
    6c16:	b2db      	uxtb	r3, r3
    6c18:	4298      	cmp	r0, r3
    6c1a:	d80d      	bhi.n	6c38 <ull_pdu_rx_alloc_peek+0x30>
	return MFIFO_DEQUEUE_PEEK(pdu_rx_free);
    6c1c:	4b08      	ldr	r3, [pc, #32]	; (6c40 <ull_pdu_rx_alloc_peek+0x38>)
    6c1e:	781b      	ldrb	r3, [r3, #0]
 * @details API 2
 */
static inline void *mfifo_dequeue_peek(u8_t *fifo, u8_t size, u8_t first,
				       u8_t last)
{
	if (first == last) {
    6c20:	428a      	cmp	r2, r1
    6c22:	d00b      	beq.n	6c3c <ull_pdu_rx_alloc_peek+0x34>
		return NULL; /* Queue is empty */
	}

	/* API 2: fifo is array of void-ptrs */
	return *((void **)(fifo + first * size));
    6c24:	fb03 f202 	mul.w	r2, r3, r2
    6c28:	4b06      	ldr	r3, [pc, #24]	; (6c44 <ull_pdu_rx_alloc_peek+0x3c>)
    6c2a:	5898      	ldr	r0, [r3, r2]
    6c2c:	4770      	bx	lr
		return count - first + last;
    6c2e:	1a9b      	subs	r3, r3, r2
    6c30:	fa41 f383 	sxtab	r3, r1, r3
    6c34:	b2db      	uxtb	r3, r3
    6c36:	e7ef      	b.n	6c18 <ull_pdu_rx_alloc_peek+0x10>
		return NULL;
    6c38:	2000      	movs	r0, #0
    6c3a:	4770      	bx	lr
		return NULL; /* Queue is empty */
    6c3c:	2000      	movs	r0, #0
}
    6c3e:	4770      	bx	lr
    6c40:	20000130 	.word	0x20000130
    6c44:	20000134 	.word	0x20000134

00006c48 <ull_pdu_rx_alloc>:
{
    6c48:	b410      	push	{r4}
	return MFIFO_DEQUEUE(pdu_rx_free);
    6c4a:	4b0b      	ldr	r3, [pc, #44]	; (6c78 <ull_pdu_rx_alloc+0x30>)
    6c4c:	781a      	ldrb	r2, [r3, #0]
    6c4e:	785c      	ldrb	r4, [r3, #1]
    6c50:	78d9      	ldrb	r1, [r3, #3]
 * @return              Head buffer; or NULL if queue was empty
 */
static inline void *mfifo_dequeue(u8_t *fifo, u8_t size, u8_t count,
				  u8_t last, u8_t *first)
{
	u8_t _first = *first; /* Copy read-index */
    6c52:	789b      	ldrb	r3, [r3, #2]
	void *mem;

	/* Queue is empty if first == last */
	if (_first == last) {
    6c54:	4299      	cmp	r1, r3
    6c56:	d00d      	beq.n	6c74 <ull_pdu_rx_alloc+0x2c>
	}

	/* Obtain address of head buffer.
	 * API 2: fifo is array of void-ptrs
	 */
	mem = *((void **)(fifo + _first * size));
    6c58:	fb02 f203 	mul.w	r2, r2, r3
    6c5c:	4907      	ldr	r1, [pc, #28]	; (6c7c <ull_pdu_rx_alloc+0x34>)
    6c5e:	5888      	ldr	r0, [r1, r2]

	/* Circular buffer increment read-index modulo 'count' */
	_first += 1U;
    6c60:	3301      	adds	r3, #1
    6c62:	b2db      	uxtb	r3, r3
	if (_first == count) {
    6c64:	429c      	cmp	r4, r3
    6c66:	d003      	beq.n	6c70 <ull_pdu_rx_alloc+0x28>
		_first = 0U;
	}

	*first = _first; /* Write back read-index */
    6c68:	4a03      	ldr	r2, [pc, #12]	; (6c78 <ull_pdu_rx_alloc+0x30>)
    6c6a:	7093      	strb	r3, [r2, #2]
}
    6c6c:	bc10      	pop	{r4}
    6c6e:	4770      	bx	lr
		_first = 0U;
    6c70:	2300      	movs	r3, #0
    6c72:	e7f9      	b.n	6c68 <ull_pdu_rx_alloc+0x20>
		return NULL;
    6c74:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(pdu_rx_free);
    6c76:	e7f9      	b.n	6c6c <ull_pdu_rx_alloc+0x24>
    6c78:	20000130 	.word	0x20000130
    6c7c:	20000134 	.word	0x20000134

00006c80 <ull_rx_put>:
{
    6c80:	b508      	push	{r3, lr}
	memq_enqueue(link, rx, &memq_ull_rx.tail);
    6c82:	4a02      	ldr	r2, [pc, #8]	; (6c8c <ull_rx_put+0xc>)
    6c84:	f007 fb58 	bl	e338 <memq_enqueue>
}
    6c88:	bd08      	pop	{r3, pc}
    6c8a:	bf00      	nop
    6c8c:	20004834 	.word	0x20004834

00006c90 <ull_rx_sched>:
{
    6c90:	b508      	push	{r3, lr}
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
    6c92:	4b03      	ldr	r3, [pc, #12]	; (6ca0 <ull_rx_sched+0x10>)
    6c94:	2201      	movs	r2, #1
    6c96:	4611      	mov	r1, r2
    6c98:	2000      	movs	r0, #0
    6c9a:	f7fe fa09 	bl	50b0 <mayfly_enqueue>
}
    6c9e:	bd08      	pop	{r3, pc}
    6ca0:	2000028c 	.word	0x2000028c

00006ca4 <ull_prepare_enqueue>:
{
    6ca4:	b4f0      	push	{r4, r5, r6, r7}
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
    6ca6:	4d1b      	ldr	r5, [pc, #108]	; (6d14 <ull_prepare_enqueue+0x70>)
    6ca8:	f895 c000 	ldrb.w	ip, [r5]
    6cac:	786f      	ldrb	r7, [r5, #1]
    6cae:	78ae      	ldrb	r6, [r5, #2]
    6cb0:	78ec      	ldrb	r4, [r5, #3]
	last = last + 1;
    6cb2:	1c65      	adds	r5, r4, #1
    6cb4:	b2ed      	uxtb	r5, r5
	if (last == count) {
    6cb6:	42af      	cmp	r7, r5
    6cb8:	d023      	beq.n	6d02 <ull_prepare_enqueue+0x5e>
	if (last == first) {
    6cba:	42ae      	cmp	r6, r5
    6cbc:	d023      	beq.n	6d06 <ull_prepare_enqueue+0x62>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
    6cbe:	4e16      	ldr	r6, [pc, #88]	; (6d18 <ull_prepare_enqueue+0x74>)
    6cc0:	fb0c 6404 	mla	r4, ip, r4, r6
	if (!e) {
    6cc4:	b314      	cbz	r4, 6d0c <ull_prepare_enqueue+0x68>
    6cc6:	f8d2 c000 	ldr.w	ip, [r2]
    6cca:	6857      	ldr	r7, [r2, #4]
    6ccc:	6896      	ldr	r6, [r2, #8]
    6cce:	68d2      	ldr	r2, [r2, #12]
    6cd0:	f8c4 c000 	str.w	ip, [r4]
    6cd4:	6067      	str	r7, [r4, #4]
    6cd6:	60a6      	str	r6, [r4, #8]
    6cd8:	60e2      	str	r2, [r4, #12]
	e->prepare_cb = prepare_cb;
    6cda:	6123      	str	r3, [r4, #16]
	e->is_abort_cb = is_abort_cb;
    6cdc:	6160      	str	r0, [r4, #20]
	e->abort_cb = abort_cb;
    6cde:	61a1      	str	r1, [r4, #24]
	e->prio = prio;
    6ce0:	9b04      	ldr	r3, [sp, #16]
    6ce2:	61e3      	str	r3, [r4, #28]
	e->is_resume = is_resume;
    6ce4:	f894 3020 	ldrb.w	r3, [r4, #32]
    6ce8:	f89d 2014 	ldrb.w	r2, [sp, #20]
    6cec:	f362 0300 	bfi	r3, r2, #0, #1
	e->is_aborted = 0U;
    6cf0:	f36f 0341 	bfc	r3, #1, #1
    6cf4:	f884 3020 	strb.w	r3, [r4, #32]
	*last = idx; /* Commit: Update write index */
    6cf8:	4b06      	ldr	r3, [pc, #24]	; (6d14 <ull_prepare_enqueue+0x70>)
    6cfa:	70dd      	strb	r5, [r3, #3]
	return 0;
    6cfc:	2000      	movs	r0, #0
}
    6cfe:	bcf0      	pop	{r4, r5, r6, r7}
    6d00:	4770      	bx	lr
		last = 0U;
    6d02:	2500      	movs	r5, #0
    6d04:	e7d9      	b.n	6cba <ull_prepare_enqueue+0x16>
		*mem = NULL; /* Signal the failure */
    6d06:	2400      	movs	r4, #0
		return 0;    /* DontCare */
    6d08:	4625      	mov	r5, r4
    6d0a:	e7db      	b.n	6cc4 <ull_prepare_enqueue+0x20>
		return -ENOBUFS;
    6d0c:	f06f 0068 	mvn.w	r0, #104	; 0x68
    6d10:	e7f5      	b.n	6cfe <ull_prepare_enqueue+0x5a>
    6d12:	bf00      	nop
    6d14:	20000148 	.word	0x20000148
    6d18:	2000014c 	.word	0x2000014c

00006d1c <ull_prepare_dequeue_get>:
	return MFIFO_DEQUEUE_GET(prep);
    6d1c:	4a05      	ldr	r2, [pc, #20]	; (6d34 <ull_prepare_dequeue_get+0x18>)
    6d1e:	7810      	ldrb	r0, [r2, #0]
    6d20:	7893      	ldrb	r3, [r2, #2]
    6d22:	78d2      	ldrb	r2, [r2, #3]
	if (first == last) {
    6d24:	4293      	cmp	r3, r2
    6d26:	d003      	beq.n	6d30 <ull_prepare_dequeue_get+0x14>
	return (void *)(fifo + first * size);
    6d28:	4a03      	ldr	r2, [pc, #12]	; (6d38 <ull_prepare_dequeue_get+0x1c>)
    6d2a:	fb00 2003 	mla	r0, r0, r3, r2
    6d2e:	4770      	bx	lr
		return NULL;
    6d30:	2000      	movs	r0, #0
}
    6d32:	4770      	bx	lr
    6d34:	20000148 	.word	0x20000148
    6d38:	2000014c 	.word	0x2000014c

00006d3c <rx_demux>:
		}
}
#endif /* CONFIG_BT_CONN */

static void rx_demux(void *param)
{
    6d3c:	b5f0      	push	{r4, r5, r6, r7, lr}
    6d3e:	b083      	sub	sp, #12
    6d40:	e0b8      	b.n	6eb4 <rx_demux+0x178>
			memq_link_t *link_tx;
			u16_t handle; /* Handle to Ack TX */
#endif /* CONFIG_BT_CONN */
			int nack = 0;

			LL_ASSERT(rx);
    6d42:	f240 53d1 	movw	r3, #1489	; 0x5d1
    6d46:	4a6d      	ldr	r2, [pc, #436]	; (6efc <rx_demux+0x1c0>)
    6d48:	496d      	ldr	r1, [pc, #436]	; (6f00 <rx_demux+0x1c4>)
    6d4a:	486e      	ldr	r0, [pc, #440]	; (6f04 <rx_demux+0x1c8>)
    6d4c:	f006 f96f 	bl	d02e <printk>
    6d50:	4040      	eors	r0, r0
    6d52:	f380 8811 	msr	BASEPRI, r0
    6d56:	f04f 0003 	mov.w	r0, #3
    6d5a:	df02      	svc	2
    6d5c:	e0b7      	b.n	6ece <rx_demux+0x192>
{
	/* Demux Rx objects */
	switch (rx->type) {
	case NODE_RX_TYPE_EVENT_DONE:
	{
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
    6d5e:	496a      	ldr	r1, [pc, #424]	; (6f08 <rx_demux+0x1cc>)
    6d60:	2200      	movs	r2, #0
    6d62:	6848      	ldr	r0, [r1, #4]
    6d64:	f007 faf8 	bl	e358 <memq_dequeue>
	struct ull_hdr *ull_hdr;
	struct lll_event *next;
	void *release;

	/* Get the ull instance */
	ull_hdr = done->param;
    6d68:	6a2e      	ldr	r6, [r5, #32]

	/* Process role dependent event done */
	switch (done->extra.type) {
    6d6a:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
    6d6e:	2b00      	cmp	r3, #0
    6d70:	d15b      	bne.n	6e2a <rx_demux+0xee>
		LL_ASSERT(0);
		break;
	}

	/* release done */
	done->extra.type = 0U;
    6d72:	2300      	movs	r3, #0
    6d74:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
	if (!MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
    6d78:	4b64      	ldr	r3, [pc, #400]	; (6f0c <rx_demux+0x1d0>)
    6d7a:	7859      	ldrb	r1, [r3, #1]
    6d7c:	789a      	ldrb	r2, [r3, #2]
    6d7e:	78db      	ldrb	r3, [r3, #3]
	last = last + 1;
    6d80:	3301      	adds	r3, #1
    6d82:	b2db      	uxtb	r3, r3
	if (last == count) {
    6d84:	4299      	cmp	r1, r3
    6d86:	d05e      	beq.n	6e46 <rx_demux+0x10a>
	if (last == first) {
    6d88:	429a      	cmp	r2, r3
    6d8a:	d05e      	beq.n	6e4a <rx_demux+0x10e>
	done->hdr.link = link;
    6d8c:	602c      	str	r4, [r5, #0]
	MFIFO_BY_IDX_ENQUEUE(done, idx, done);
    6d8e:	4a5f      	ldr	r2, [pc, #380]	; (6f0c <rx_demux+0x1d0>)
    6d90:	7810      	ldrb	r0, [r2, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    6d92:	78d1      	ldrb	r1, [r2, #3]
    6d94:	fb01 f100 	mul.w	r1, r1, r0
    6d98:	1d10      	adds	r0, r2, #4
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    6d9a:	5045      	str	r5, [r0, r1]
	*last = idx; /* Commit: Update write index */
    6d9c:	70d3      	strb	r3, [r2, #3]
	return done;
    6d9e:	462b      	mov	r3, r5
	release = done_release(link, done);
	LL_ASSERT(release == done);
    6da0:	429d      	cmp	r5, r3
    6da2:	d00c      	beq.n	6dbe <rx_demux+0x82>
    6da4:	f240 6391 	movw	r3, #1681	; 0x691
    6da8:	4a54      	ldr	r2, [pc, #336]	; (6efc <rx_demux+0x1c0>)
    6daa:	4959      	ldr	r1, [pc, #356]	; (6f10 <rx_demux+0x1d4>)
    6dac:	4855      	ldr	r0, [pc, #340]	; (6f04 <rx_demux+0x1c8>)
    6dae:	f006 f93e 	bl	d02e <printk>
    6db2:	4040      	eors	r0, r0
    6db4:	f380 8811 	msr	BASEPRI, r0
    6db8:	f04f 0003 	mov.w	r0, #3
    6dbc:	df02      	svc	2

	/* dequeue prepare pipeline */
	next = ull_prepare_dequeue_get();
    6dbe:	f7ff ffad 	bl	6d1c <ull_prepare_dequeue_get>
    6dc2:	4602      	mov	r2, r0
	while (next) {
    6dc4:	b302      	cbz	r2, 6e08 <rx_demux+0xcc>
		u8_t is_aborted = next->is_aborted;
    6dc6:	f892 3020 	ldrb.w	r3, [r2, #32]
    6dca:	f3c3 0740 	ubfx	r7, r3, #1, #1
		u8_t is_resume = next->is_resume;
    6dce:	f003 0501 	and.w	r5, r3, #1

		if (!is_aborted) {
    6dd2:	f013 0f02 	tst.w	r3, #2
    6dd6:	d03a      	beq.n	6e4e <rx_demux+0x112>
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
					     TICKER_USER_ID_LLL, 0, &mfy);
			LL_ASSERT(!ret);
		}

		MFIFO_DEQUEUE(prep);
    6dd8:	4b4e      	ldr	r3, [pc, #312]	; (6f14 <rx_demux+0x1d8>)
    6dda:	785a      	ldrb	r2, [r3, #1]
    6ddc:	78d9      	ldrb	r1, [r3, #3]
	u8_t _first = *first; /* Copy read-index */
    6dde:	789b      	ldrb	r3, [r3, #2]
	if (_first == last) {
    6de0:	4299      	cmp	r1, r3
    6de2:	d005      	beq.n	6df0 <rx_demux+0xb4>
	_first += 1U;
    6de4:	3301      	adds	r3, #1
    6de6:	b2db      	uxtb	r3, r3
	if (_first == count) {
    6de8:	429a      	cmp	r2, r3
    6dea:	d047      	beq.n	6e7c <rx_demux+0x140>
	*first = _first; /* Write back read-index */
    6dec:	4a49      	ldr	r2, [pc, #292]	; (6f14 <rx_demux+0x1d8>)
    6dee:	7093      	strb	r3, [r2, #2]

		next = ull_prepare_dequeue_get();
    6df0:	f7ff ff94 	bl	6d1c <ull_prepare_dequeue_get>

		if (!next || (!is_aborted && (!is_resume || next->is_resume))) {
    6df4:	4602      	mov	r2, r0
    6df6:	b138      	cbz	r0, 6e08 <rx_demux+0xcc>
    6df8:	2f00      	cmp	r7, #0
    6dfa:	d1e3      	bne.n	6dc4 <rx_demux+0x88>
    6dfc:	b125      	cbz	r5, 6e08 <rx_demux+0xcc>
    6dfe:	f890 3020 	ldrb.w	r3, [r0, #32]
    6e02:	f013 0f01 	tst.w	r3, #1
    6e06:	d0dd      	beq.n	6dc4 <rx_demux+0x88>
			break;
		}
	}

	/* ull instance will resume, dont decrement ref */
	if (!ull_hdr) {
    6e08:	2e00      	cmp	r6, #0
    6e0a:	d052      	beq.n	6eb2 <rx_demux+0x176>
		return;
	}

	/* Decrement prepare reference */
	LL_ASSERT(ull_hdr->ref);
    6e0c:	7833      	ldrb	r3, [r6, #0]
    6e0e:	2b00      	cmp	r3, #0
    6e10:	d036      	beq.n	6e80 <rx_demux+0x144>
	return hdr->ref--;
    6e12:	7833      	ldrb	r3, [r6, #0]
    6e14:	3b01      	subs	r3, #1
    6e16:	b2db      	uxtb	r3, r3
    6e18:	7033      	strb	r3, [r6, #0]
	ull_ref_dec(ull_hdr);

	/* If disable initiated, signal the semaphore */
	if (!ull_hdr->ref && ull_hdr->disabled_cb) {
    6e1a:	2b00      	cmp	r3, #0
    6e1c:	d149      	bne.n	6eb2 <rx_demux+0x176>
    6e1e:	6873      	ldr	r3, [r6, #4]
    6e20:	2b00      	cmp	r3, #0
    6e22:	d046      	beq.n	6eb2 <rx_demux+0x176>
		ull_hdr->disabled_cb(ull_hdr->disabled_param);
    6e24:	68b0      	ldr	r0, [r6, #8]
    6e26:	4798      	blx	r3
    6e28:	e043      	b.n	6eb2 <rx_demux+0x176>
		LL_ASSERT(0);
    6e2a:	f240 638a 	movw	r3, #1674	; 0x68a
    6e2e:	4a33      	ldr	r2, [pc, #204]	; (6efc <rx_demux+0x1c0>)
    6e30:	4939      	ldr	r1, [pc, #228]	; (6f18 <rx_demux+0x1dc>)
    6e32:	4834      	ldr	r0, [pc, #208]	; (6f04 <rx_demux+0x1c8>)
    6e34:	f006 f8fb 	bl	d02e <printk>
    6e38:	4040      	eors	r0, r0
    6e3a:	f380 8811 	msr	BASEPRI, r0
    6e3e:	f04f 0003 	mov.w	r0, #3
    6e42:	df02      	svc	2
		break;
    6e44:	e795      	b.n	6d72 <rx_demux+0x36>
		last = 0U;
    6e46:	2300      	movs	r3, #0
    6e48:	e79e      	b.n	6d88 <rx_demux+0x4c>
		return NULL;
    6e4a:	2300      	movs	r3, #0
    6e4c:	e7a8      	b.n	6da0 <rx_demux+0x64>
			mfy.param = next;
    6e4e:	4b33      	ldr	r3, [pc, #204]	; (6f1c <rx_demux+0x1e0>)
    6e50:	609a      	str	r2, [r3, #8]
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
    6e52:	2200      	movs	r2, #0
    6e54:	4611      	mov	r1, r2
    6e56:	2001      	movs	r0, #1
    6e58:	f7fe f92a 	bl	50b0 <mayfly_enqueue>
			LL_ASSERT(!ret);
    6e5c:	2800      	cmp	r0, #0
    6e5e:	d0bb      	beq.n	6dd8 <rx_demux+0x9c>
    6e60:	f240 63a2 	movw	r3, #1698	; 0x6a2
    6e64:	4a25      	ldr	r2, [pc, #148]	; (6efc <rx_demux+0x1c0>)
    6e66:	492e      	ldr	r1, [pc, #184]	; (6f20 <rx_demux+0x1e4>)
    6e68:	4826      	ldr	r0, [pc, #152]	; (6f04 <rx_demux+0x1c8>)
    6e6a:	f006 f8e0 	bl	d02e <printk>
    6e6e:	4040      	eors	r0, r0
    6e70:	f380 8811 	msr	BASEPRI, r0
    6e74:	f04f 0003 	mov.w	r0, #3
    6e78:	df02      	svc	2
    6e7a:	e7ad      	b.n	6dd8 <rx_demux+0x9c>
		_first = 0U;
    6e7c:	2300      	movs	r3, #0
    6e7e:	e7b5      	b.n	6dec <rx_demux+0xb0>
	LL_ASSERT(ull_hdr->ref);
    6e80:	f240 63b4 	movw	r3, #1716	; 0x6b4
    6e84:	4a1d      	ldr	r2, [pc, #116]	; (6efc <rx_demux+0x1c0>)
    6e86:	4927      	ldr	r1, [pc, #156]	; (6f24 <rx_demux+0x1e8>)
    6e88:	481e      	ldr	r0, [pc, #120]	; (6f04 <rx_demux+0x1c8>)
    6e8a:	f006 f8d0 	bl	d02e <printk>
    6e8e:	4040      	eors	r0, r0
    6e90:	f380 8811 	msr	BASEPRI, r0
    6e94:	f04f 0003 	mov.w	r0, #3
    6e98:	df02      	svc	2
    6e9a:	e7ba      	b.n	6e12 <rx_demux+0xd6>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
    6e9c:	491a      	ldr	r1, [pc, #104]	; (6f08 <rx_demux+0x1cc>)
    6e9e:	2200      	movs	r2, #0
    6ea0:	6848      	ldr	r0, [r1, #4]
    6ea2:	f007 fa59 	bl	e358 <memq_dequeue>
		ll_rx_put(link, rx);
    6ea6:	4629      	mov	r1, r5
    6ea8:	4620      	mov	r0, r4
    6eaa:	f7ff fe2d 	bl	6b08 <ll_rx_put>
		ll_rx_sched();
    6eae:	f7ff fe33 	bl	6b18 <ll_rx_sched>
	} while (link);
    6eb2:	b30c      	cbz	r4, 6ef8 <rx_demux+0x1bc>
		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
    6eb4:	4b14      	ldr	r3, [pc, #80]	; (6f08 <rx_demux+0x1cc>)
    6eb6:	aa01      	add	r2, sp, #4
    6eb8:	6859      	ldr	r1, [r3, #4]
    6eba:	6818      	ldr	r0, [r3, #0]
    6ebc:	f007 fa44 	bl	e348 <memq_peek>
		if (link) {
    6ec0:	4604      	mov	r4, r0
    6ec2:	2800      	cmp	r0, #0
    6ec4:	d0f5      	beq.n	6eb2 <rx_demux+0x176>
			LL_ASSERT(rx);
    6ec6:	9b01      	ldr	r3, [sp, #4]
    6ec8:	2b00      	cmp	r3, #0
    6eca:	f43f af3a 	beq.w	6d42 <rx_demux+0x6>
				nack = rx_demux_rx(link, rx);
    6ece:	9d01      	ldr	r5, [sp, #4]
	switch (rx->type) {
    6ed0:	792b      	ldrb	r3, [r5, #4]
    6ed2:	2b01      	cmp	r3, #1
    6ed4:	f43f af43 	beq.w	6d5e <rx_demux+0x22>
    6ed8:	2b04      	cmp	r3, #4
    6eda:	d0df      	beq.n	6e9c <rx_demux+0x160>
		LL_ASSERT(0);
    6edc:	f240 6362 	movw	r3, #1634	; 0x662
    6ee0:	4a06      	ldr	r2, [pc, #24]	; (6efc <rx_demux+0x1c0>)
    6ee2:	490d      	ldr	r1, [pc, #52]	; (6f18 <rx_demux+0x1dc>)
    6ee4:	4807      	ldr	r0, [pc, #28]	; (6f04 <rx_demux+0x1c8>)
    6ee6:	f006 f8a2 	bl	d02e <printk>
    6eea:	4040      	eors	r0, r0
    6eec:	f380 8811 	msr	BASEPRI, r0
    6ef0:	f04f 0003 	mov.w	r0, #3
    6ef4:	df02      	svc	2
	break;
    6ef6:	e7dc      	b.n	6eb2 <rx_demux+0x176>
}
    6ef8:	b003      	add	sp, #12
    6efa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6efc:	0001269c 	.word	0x0001269c
    6f00:	000127a8 	.word	0x000127a8
    6f04:	00011fec 	.word	0x00011fec
    6f08:	20004830 	.word	0x20004830
    6f0c:	2000011c 	.word	0x2000011c
    6f10:	000127ac 	.word	0x000127ac
    6f14:	20000148 	.word	0x20000148
    6f18:	00010df0 	.word	0x00010df0
    6f1c:	2000029c 	.word	0x2000029c
    6f20:	000127a0 	.word	0x000127a0
    6f24:	000127bc 	.word	0x000127bc

00006f28 <ull_prepare_dequeue_iter>:
{
    6f28:	b430      	push	{r4, r5}
    6f2a:	4602      	mov	r2, r0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
    6f2c:	4b0d      	ldr	r3, [pc, #52]	; (6f64 <ull_prepare_dequeue_iter+0x3c>)
    6f2e:	7818      	ldrb	r0, [r3, #0]
    6f30:	785c      	ldrb	r4, [r3, #1]
    6f32:	789d      	ldrb	r5, [r3, #2]
    6f34:	78db      	ldrb	r3, [r3, #3]
	if (*idx >= count) {
    6f36:	7811      	ldrb	r1, [r2, #0]
    6f38:	428c      	cmp	r4, r1
    6f3a:	d800      	bhi.n	6f3e <ull_prepare_dequeue_iter+0x16>
		*idx = first;
    6f3c:	7015      	strb	r5, [r2, #0]
	if (*idx == last) {
    6f3e:	7811      	ldrb	r1, [r2, #0]
    6f40:	428b      	cmp	r3, r1
    6f42:	d00c      	beq.n	6f5e <ull_prepare_dequeue_iter+0x36>
	i = *idx + 1;
    6f44:	b24b      	sxtb	r3, r1
    6f46:	3301      	adds	r3, #1
    6f48:	b2db      	uxtb	r3, r3
	if (i == count) {
    6f4a:	429c      	cmp	r4, r3
    6f4c:	d005      	beq.n	6f5a <ull_prepare_dequeue_iter+0x32>
	p = (void *)(fifo + (*idx) * size);
    6f4e:	4c06      	ldr	r4, [pc, #24]	; (6f68 <ull_prepare_dequeue_iter+0x40>)
    6f50:	fb01 4000 	mla	r0, r1, r0, r4
	*idx = i;
    6f54:	7013      	strb	r3, [r2, #0]
}
    6f56:	bc30      	pop	{r4, r5}
    6f58:	4770      	bx	lr
		i = 0U;
    6f5a:	2300      	movs	r3, #0
    6f5c:	e7f7      	b.n	6f4e <ull_prepare_dequeue_iter+0x26>
		return NULL;
    6f5e:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
    6f60:	e7f9      	b.n	6f56 <ull_prepare_dequeue_iter+0x2e>
    6f62:	bf00      	nop
    6f64:	20000148 	.word	0x20000148
    6f68:	2000014c 	.word	0x2000014c

00006f6c <ull_event_done>:
{
    6f6c:	b538      	push	{r3, r4, r5, lr}
    6f6e:	4605      	mov	r5, r0
	evdone = MFIFO_DEQUEUE(done);
    6f70:	4b11      	ldr	r3, [pc, #68]	; (6fb8 <ull_event_done+0x4c>)
    6f72:	781a      	ldrb	r2, [r3, #0]
    6f74:	7858      	ldrb	r0, [r3, #1]
    6f76:	78d9      	ldrb	r1, [r3, #3]
	u8_t _first = *first; /* Copy read-index */
    6f78:	789b      	ldrb	r3, [r3, #2]
	if (_first == last) {
    6f7a:	4299      	cmp	r1, r3
    6f7c:	d019      	beq.n	6fb2 <ull_event_done+0x46>
	mem = *((void **)(fifo + _first * size));
    6f7e:	fb02 f203 	mul.w	r2, r2, r3
    6f82:	490e      	ldr	r1, [pc, #56]	; (6fbc <ull_event_done+0x50>)
    6f84:	588c      	ldr	r4, [r1, r2]
	_first += 1U;
    6f86:	3301      	adds	r3, #1
    6f88:	b2db      	uxtb	r3, r3
	if (_first == count) {
    6f8a:	4298      	cmp	r0, r3
    6f8c:	d00f      	beq.n	6fae <ull_event_done+0x42>
	*first = _first; /* Write back read-index */
    6f8e:	4a0a      	ldr	r2, [pc, #40]	; (6fb8 <ull_event_done+0x4c>)
    6f90:	7093      	strb	r3, [r2, #2]
	if (!evdone) {
    6f92:	b174      	cbz	r4, 6fb2 <ull_event_done+0x46>
	link = evdone->hdr.link;
    6f94:	6820      	ldr	r0, [r4, #0]
	evdone->hdr.link = NULL;
    6f96:	2300      	movs	r3, #0
    6f98:	6023      	str	r3, [r4, #0]
	evdone->hdr.type = NODE_RX_TYPE_EVENT_DONE;
    6f9a:	2301      	movs	r3, #1
    6f9c:	7123      	strb	r3, [r4, #4]
	evdone->param = param;
    6f9e:	6225      	str	r5, [r4, #32]
	ull_rx_put(link, evdone);
    6fa0:	4621      	mov	r1, r4
    6fa2:	f7ff fe6d 	bl	6c80 <ull_rx_put>
	ull_rx_sched();
    6fa6:	f7ff fe73 	bl	6c90 <ull_rx_sched>
}
    6faa:	4620      	mov	r0, r4
    6fac:	bd38      	pop	{r3, r4, r5, pc}
		_first = 0U;
    6fae:	2300      	movs	r3, #0
    6fb0:	e7ed      	b.n	6f8e <ull_event_done+0x22>
		return NULL;
    6fb2:	2400      	movs	r4, #0
    6fb4:	e7f9      	b.n	6faa <ull_event_done+0x3e>
    6fb6:	bf00      	nop
    6fb8:	2000011c 	.word	0x2000011c
    6fbc:	20000120 	.word	0x20000120

00006fc0 <ticker_cb>:
	return 0;
}

static void ticker_cb(u32_t ticks_at_expire, u32_t remainder, u16_t lazy,
		      void *param)
{
    6fc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6fc2:	4607      	mov	r7, r0
    6fc4:	460e      	mov	r6, r1
    6fc6:	4615      	mov	r5, r2
    6fc8:	461c      	mov	r4, r3
	return ++hdr->ref;
    6fca:	7c1b      	ldrb	r3, [r3, #16]
    6fcc:	3301      	adds	r3, #1
    6fce:	b2db      	uxtb	r3, r3
    6fd0:	7423      	strb	r3, [r4, #16]

	DEBUG_RADIO_PREPARE_O(1);

	/* Increment prepare reference count */
	ref = ull_ref_inc(&scan->ull);
	LL_ASSERT(ref);
    6fd2:	b173      	cbz	r3, 6ff2 <ticker_cb+0x32>

	/* Append timing parameters */
	p.ticks_at_expire = ticks_at_expire;
    6fd4:	4a15      	ldr	r2, [pc, #84]	; (702c <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x2c>)
    6fd6:	6017      	str	r7, [r2, #0]
	p.remainder = remainder;
    6fd8:	6056      	str	r6, [r2, #4]
	p.lazy = lazy;
    6fda:	8115      	strh	r5, [r2, #8]
	p.param = &scan->lll;
    6fdc:	341c      	adds	r4, #28
    6fde:	60d4      	str	r4, [r2, #12]
	mfy.param = &p;
    6fe0:	4b13      	ldr	r3, [pc, #76]	; (7030 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x30>)
    6fe2:	609a      	str	r2, [r3, #8]

	/* Kick LLL prepare */
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
    6fe4:	2200      	movs	r2, #0
    6fe6:	4611      	mov	r1, r2
    6fe8:	2001      	movs	r0, #1
    6fea:	f7fe f861 	bl	50b0 <mayfly_enqueue>
			     0, &mfy);
	LL_ASSERT(!ret);
    6fee:	b970      	cbnz	r0, 700e <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0xe>
		LL_ASSERT(!retval);
	}
#endif /* CONFIG_BT_CENTRAL && CONFIG_BT_CTLR_SCHED_ADVANCED */

	DEBUG_RADIO_PREPARE_O(1);
}
    6ff0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	LL_ASSERT(ref);
    6ff2:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
    6ff6:	4a0f      	ldr	r2, [pc, #60]	; (7034 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x34>)
    6ff8:	490f      	ldr	r1, [pc, #60]	; (7038 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x38>)
    6ffa:	4810      	ldr	r0, [pc, #64]	; (703c <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x3c>)
    6ffc:	f006 f817 	bl	d02e <printk>
    7000:	4040      	eors	r0, r0
    7002:	f380 8811 	msr	BASEPRI, r0
    7006:	f04f 0003 	mov.w	r0, #3
    700a:	df02      	svc	2
    700c:	e7e2      	b.n	6fd4 <ticker_cb+0x14>
	LL_ASSERT(!ret);
    700e:	f44f 73d6 	mov.w	r3, #428	; 0x1ac
    7012:	4a08      	ldr	r2, [pc, #32]	; (7034 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x34>)
    7014:	490a      	ldr	r1, [pc, #40]	; (7040 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x40>)
    7016:	4809      	ldr	r0, [pc, #36]	; (703c <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x3c>)
    7018:	f006 f809 	bl	d02e <printk>
    701c:	4040      	eors	r0, r0
    701e:	f380 8811 	msr	BASEPRI, r0
    7022:	f04f 0003 	mov.w	r0, #3
    7026:	df02      	svc	2
}
    7028:	e7e2      	b.n	6ff0 <ticker_cb+0x30>
    702a:	bf00      	nop
    702c:	20004b84 	.word	0x20004b84
    7030:	200002ac 	.word	0x200002ac
    7034:	000127ec 	.word	0x000127ec
    7038:	00012868 	.word	0x00012868
    703c:	00011fec 	.word	0x00011fec
    7040:	000127a0 	.word	0x000127a0

00007044 <ull_scan_disable>:
{
    7044:	b530      	push	{r4, r5, lr}
    7046:	b085      	sub	sp, #20
    7048:	4605      	mov	r5, r0
    704a:	460c      	mov	r4, r1
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
    704c:	2302      	movs	r3, #2
    704e:	9303      	str	r3, [sp, #12]
	mark = ull_disable_mark(scan);
    7050:	4608      	mov	r0, r1
    7052:	f7ff fd7f 	bl	6b54 <ull_disable_mark>
	LL_ASSERT(mark == scan);
    7056:	4284      	cmp	r4, r0
    7058:	d00c      	beq.n	7074 <ull_scan_disable+0x30>
    705a:	f240 1327 	movw	r3, #295	; 0x127
    705e:	4a2b      	ldr	r2, [pc, #172]	; (710c <ull_scan_disable+0xc8>)
    7060:	492b      	ldr	r1, [pc, #172]	; (7110 <ull_scan_disable+0xcc>)
    7062:	482c      	ldr	r0, [pc, #176]	; (7114 <ull_scan_disable+0xd0>)
    7064:	f005 ffe3 	bl	d02e <printk>
    7068:	4040      	eors	r0, r0
    706a:	f380 8811 	msr	BASEPRI, r0
    706e:	f04f 0003 	mov.w	r0, #3
    7072:	df02      	svc	2
			  TICKER_ID_SCAN_BASE + handle,
    7074:	1caa      	adds	r2, r5, #2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
    7076:	ad03      	add	r5, sp, #12
    7078:	9500      	str	r5, [sp, #0]
    707a:	4b27      	ldr	r3, [pc, #156]	; (7118 <ull_scan_disable+0xd4>)
    707c:	b2d2      	uxtb	r2, r2
    707e:	2103      	movs	r1, #3
    7080:	2000      	movs	r0, #0
    7082:	f7fe fa01 	bl	5488 <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
    7086:	4629      	mov	r1, r5
    7088:	f7ff fd56 	bl	6b38 <ull_ticker_status_take>
	if (ret) {
    708c:	b9c8      	cbnz	r0, 70c2 <ull_scan_disable+0x7e>
	ret = ull_disable(&scan->lll);
    708e:	f104 001c 	add.w	r0, r4, #28
    7092:	f7ff fd79 	bl	6b88 <ull_disable>
	LL_ASSERT(!ret);
    7096:	bb40      	cbnz	r0, 70ea <ull_scan_disable+0xa6>
	mark = ull_disable_unmark(scan);
    7098:	4620      	mov	r0, r4
    709a:	f7ff fd67 	bl	6b6c <ull_disable_unmark>
	LL_ASSERT(mark == scan);
    709e:	4284      	cmp	r4, r0
    70a0:	d031      	beq.n	7106 <ull_scan_disable+0xc2>
    70a2:	f240 1339 	movw	r3, #313	; 0x139
    70a6:	4a19      	ldr	r2, [pc, #100]	; (710c <ull_scan_disable+0xc8>)
    70a8:	4919      	ldr	r1, [pc, #100]	; (7110 <ull_scan_disable+0xcc>)
    70aa:	481a      	ldr	r0, [pc, #104]	; (7114 <ull_scan_disable+0xd0>)
    70ac:	f005 ffbf 	bl	d02e <printk>
    70b0:	4040      	eors	r0, r0
    70b2:	f380 8811 	msr	BASEPRI, r0
    70b6:	f04f 0003 	mov.w	r0, #3
    70ba:	df02      	svc	2
	return 0;
    70bc:	2000      	movs	r0, #0
}
    70be:	b005      	add	sp, #20
    70c0:	bd30      	pop	{r4, r5, pc}
		mark = ull_disable_unmark(scan);
    70c2:	4620      	mov	r0, r4
    70c4:	f7ff fd52 	bl	6b6c <ull_disable_unmark>
		LL_ASSERT(mark == scan);
    70c8:	4284      	cmp	r4, r0
    70ca:	d00c      	beq.n	70e6 <ull_scan_disable+0xa2>
    70cc:	f44f 7398 	mov.w	r3, #304	; 0x130
    70d0:	4a0e      	ldr	r2, [pc, #56]	; (710c <ull_scan_disable+0xc8>)
    70d2:	490f      	ldr	r1, [pc, #60]	; (7110 <ull_scan_disable+0xcc>)
    70d4:	480f      	ldr	r0, [pc, #60]	; (7114 <ull_scan_disable+0xd0>)
    70d6:	f005 ffaa 	bl	d02e <printk>
    70da:	4040      	eors	r0, r0
    70dc:	f380 8811 	msr	BASEPRI, r0
    70e0:	f04f 0003 	mov.w	r0, #3
    70e4:	df02      	svc	2
		return BT_HCI_ERR_CMD_DISALLOWED;
    70e6:	200c      	movs	r0, #12
    70e8:	e7e9      	b.n	70be <ull_scan_disable+0x7a>
	LL_ASSERT(!ret);
    70ea:	f44f 739b 	mov.w	r3, #310	; 0x136
    70ee:	4a07      	ldr	r2, [pc, #28]	; (710c <ull_scan_disable+0xc8>)
    70f0:	490a      	ldr	r1, [pc, #40]	; (711c <ull_scan_disable+0xd8>)
    70f2:	4808      	ldr	r0, [pc, #32]	; (7114 <ull_scan_disable+0xd0>)
    70f4:	f005 ff9b 	bl	d02e <printk>
    70f8:	4040      	eors	r0, r0
    70fa:	f380 8811 	msr	BASEPRI, r0
    70fe:	f04f 0003 	mov.w	r0, #3
    7102:	df02      	svc	2
    7104:	e7c8      	b.n	7098 <ull_scan_disable+0x54>
	return 0;
    7106:	2000      	movs	r0, #0
    7108:	e7d9      	b.n	70be <ull_scan_disable+0x7a>
    710a:	bf00      	nop
    710c:	000127ec 	.word	0x000127ec
    7110:	0001286c 	.word	0x0001286c
    7114:	00011fec 	.word	0x00011fec
    7118:	00006b29 	.word	0x00006b29
    711c:	000127a0 	.word	0x000127a0

00007120 <ull_scan_set_get>:
	if (handle >= BT_CTLR_SCAN_MAX) {
    7120:	b928      	cbnz	r0, 712e <ull_scan_set_get+0xe>
	return &ll_scan[handle];
    7122:	ebc0 1300 	rsb	r3, r0, r0, lsl #4
    7126:	4803      	ldr	r0, [pc, #12]	; (7134 <ull_scan_set_get+0x14>)
    7128:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    712c:	4770      	bx	lr
		return NULL;
    712e:	2000      	movs	r0, #0
}
    7130:	4770      	bx	lr
    7132:	bf00      	nop
    7134:	20004b48 	.word	0x20004b48

00007138 <ull_scan_handle_get>:
	return ((u8_t *)scan - (u8_t *)ll_scan) / sizeof(*scan);
    7138:	4b03      	ldr	r3, [pc, #12]	; (7148 <ull_scan_handle_get+0x10>)
    713a:	1ac0      	subs	r0, r0, r3
    713c:	4b03      	ldr	r3, [pc, #12]	; (714c <ull_scan_handle_get+0x14>)
    713e:	fba3 3000 	umull	r3, r0, r3, r0
}
    7142:	f3c0 104f 	ubfx	r0, r0, #5, #16
    7146:	4770      	bx	lr
    7148:	20004b48 	.word	0x20004b48
    714c:	88888889 	.word	0x88888889

00007150 <dfe_set_mode>:
/*****************************************************************************
 *DFE
 ****************************************************************************/
int dfe_set_mode(u8_t mode)
{
	if (mode != RADIO_DFEMODE_DFEOPMODE_Disabled &&
    7150:	4603      	mov	r3, r0
    7152:	b118      	cbz	r0, 715c <dfe_set_mode+0xc>
    7154:	2802      	cmp	r0, #2
    7156:	d001      	beq.n	715c <dfe_set_mode+0xc>
	    mode != RADIO_DFEMODE_DFEOPMODE_AoD &&
    7158:	2803      	cmp	r0, #3
    715a:	d103      	bne.n	7164 <dfe_set_mode+0x14>

#if defined(CONFIG_BT_CTLR_DFE_TX)
	dfe_tx.dfe_op_mode = mode;
#endif /* CONFIG_BT_CTLR_DFE_TX */
#if defined(CONFIG_BT_CTLR_DFE_RX)
	dfe_rx.dfe_op_mode = mode;
    715c:	4a03      	ldr	r2, [pc, #12]	; (716c <dfe_set_mode+0x1c>)
    715e:	7093      	strb	r3, [r2, #2]
#endif /* CONFIG_BT_CTLR_DFE_RX */
	return 0;
    7160:	2000      	movs	r0, #0
    7162:	4770      	bx	lr
		return -EINVAL;
    7164:	f06f 0015 	mvn.w	r0, #21
	return 0;
}
    7168:	4770      	bx	lr
    716a:	bf00      	nop
    716c:	20004b94 	.word	0x20004b94

00007170 <dfe_set_duration>:

int dfe_set_duration(u8_t numb_of_8us_periods)
{
	if (numb_of_8us_periods > DFE_MAX_8US_PERIODS)
    7170:	2814      	cmp	r0, #20
    7172:	d805      	bhi.n	7180 <dfe_set_duration+0x10>
		return -EINVAL;
	else if(numb_of_8us_periods < DFE_MIN_8US_PERIODS)
    7174:	2801      	cmp	r0, #1
    7176:	d906      	bls.n	7186 <dfe_set_duration+0x16>

#if defined(CONFIG_BT_CTLR_DFE_TX)
	dfe_tx.dfe_duration = numb_of_8us_periods;
#endif /* CONFIG_BT_CTLR_DFE_TX */
#if defined(CONFIG_BT_CTLR_DFE_RX)
	dfe_rx.dfe_duration = numb_of_8us_periods;
    7178:	4b04      	ldr	r3, [pc, #16]	; (718c <dfe_set_duration+0x1c>)
    717a:	7058      	strb	r0, [r3, #1]
#endif /* CONFIG_BT_CTLR_DFE_RX */
	return 0;
    717c:	2000      	movs	r0, #0
    717e:	4770      	bx	lr
		return -EINVAL;
    7180:	f06f 0015 	mvn.w	r0, #21
    7184:	4770      	bx	lr
		return -EINVAL;
    7186:	f06f 0015 	mvn.w	r0, #21
}
    718a:	4770      	bx	lr
    718c:	20004b94 	.word	0x20004b94

00007190 <dfe_set_start_point>:
	return duration * DFE_DURATION_MIN_UNIT_US;
}

int dfe_set_start_point(u8_t start_point)
{
	if (start_point != RADIO_DFECTRL1_DFEINEXTENSION_Payload &&
    7190:	2801      	cmp	r0, #1
    7192:	d803      	bhi.n	719c <dfe_set_start_point+0xc>
	}
#if defined(CONFIG_BT_CTLR_DFE_TX)
	dfe_tx.start_of_dfe = start_point;
#endif /* CONFIG_BT_CTLR_DFE_TX */
#if defined(CONFIG_BT_CTLR_DFE_RX)
	dfe_rx.start_of_dfe = start_point;
    7194:	4b03      	ldr	r3, [pc, #12]	; (71a4 <dfe_set_start_point+0x14>)
    7196:	7018      	strb	r0, [r3, #0]
#endif /* CONFIG_BT_CTLR_DFE_RX */
	return 0;
    7198:	2000      	movs	r0, #0
    719a:	4770      	bx	lr
		return -EINVAL;
    719c:	f06f 0015 	mvn.w	r0, #21
}
    71a0:	4770      	bx	lr
    71a2:	bf00      	nop
    71a4:	20004b94 	.word	0x20004b94

000071a8 <dfe_set_sample_on_crc_error>:

#if defined(CONFIG_BT_CTLR_DFE_RX)
void dfe_set_sample_on_crc_error(bool value)
{
	dfe_rx.sampl_conf.en_sampling_on_crc_error = value;
    71a8:	4b01      	ldr	r3, [pc, #4]	; (71b0 <dfe_set_sample_on_crc_error+0x8>)
    71aa:	7118      	strb	r0, [r3, #4]
}
    71ac:	4770      	bx	lr
    71ae:	bf00      	nop
    71b0:	20004b94 	.word	0x20004b94

000071b4 <dfe_set_trig_dfe_start_task_only>:

void dfe_set_trig_dfe_start_task_only(bool value)
{
	dfe_rx.sampl_conf.trig_task_only = value;
    71b4:	4b01      	ldr	r3, [pc, #4]	; (71bc <dfe_set_trig_dfe_start_task_only+0x8>)
    71b6:	7158      	strb	r0, [r3, #5]
}
    71b8:	4770      	bx	lr
    71ba:	bf00      	nop
    71bc:	20004b94 	.word	0x20004b94

000071c0 <dfe_set_sampling_spacing_ref>:

int dfe_set_sampling_spacing_ref(u8_t spacing)
{
	if((spacing < RADIO_DFECTRL1_TSAMPLESPACINGREF_4us) ||
    71c0:	1e43      	subs	r3, r0, #1
    71c2:	b2db      	uxtb	r3, r3
    71c4:	2b04      	cmp	r3, #4
    71c6:	d803      	bhi.n	71d0 <dfe_set_sampling_spacing_ref+0x10>
	  (spacing > RADIO_DFECTRL1_TSAMPLESPACINGREF_250ns)) {
		return -EINVAL;
	}
	dfe_rx.sampl_conf.sample_spacing_ref = spacing;
    71c8:	4b03      	ldr	r3, [pc, #12]	; (71d8 <dfe_set_sampling_spacing_ref+0x18>)
    71ca:	7198      	strb	r0, [r3, #6]
	return 0;
    71cc:	2000      	movs	r0, #0
    71ce:	4770      	bx	lr
		return -EINVAL;
    71d0:	f06f 0015 	mvn.w	r0, #21
}
    71d4:	4770      	bx	lr
    71d6:	bf00      	nop
    71d8:	20004b94 	.word	0x20004b94

000071dc <dfe_set_sampling_type>:

int dfe_set_sampling_type(u8_t type)
{
	if((type != RADIO_DFECTRL1_SAMPLETYPE_IQ) &&
    71dc:	2801      	cmp	r0, #1
    71de:	d803      	bhi.n	71e8 <dfe_set_sampling_type+0xc>
	  (type != RADIO_DFECTRL1_SAMPLETYPE_MagPhase)) {
		return -EINVAL;
	}
	dfe_rx.sampl_conf.sampling_type = type;
    71e0:	4b03      	ldr	r3, [pc, #12]	; (71f0 <dfe_set_sampling_type+0x14>)
    71e2:	71d8      	strb	r0, [r3, #7]
	return 0;
    71e4:	2000      	movs	r0, #0
    71e6:	4770      	bx	lr
		return -EINVAL;
    71e8:	f06f 0015 	mvn.w	r0, #21
}
    71ec:	4770      	bx	lr
    71ee:	bf00      	nop
    71f0:	20004b94 	.word	0x20004b94

000071f4 <dfe_set_sample_spacing>:

int dfe_set_sample_spacing(u8_t spacing)
{
	if((spacing < RADIO_DFECTRL1_TSAMPLESPACING_4us) ||
    71f4:	1e43      	subs	r3, r0, #1
    71f6:	b2db      	uxtb	r3, r3
    71f8:	2b04      	cmp	r3, #4
    71fa:	d803      	bhi.n	7204 <dfe_set_sample_spacing+0x10>
	  (spacing > RADIO_DFECTRL1_TSAMPLESPACING_250ns)) {
		return -EINVAL;
	}
	dfe_rx.sampl_conf.sample_spacing = spacing;
    71fc:	4b03      	ldr	r3, [pc, #12]	; (720c <dfe_set_sample_spacing+0x18>)
    71fe:	7218      	strb	r0, [r3, #8]
	return 0;
    7200:	2000      	movs	r0, #0
    7202:	4770      	bx	lr
		return -EINVAL;
    7204:	f06f 0015 	mvn.w	r0, #21
}
    7208:	4770      	bx	lr
    720a:	bf00      	nop
    720c:	20004b94 	.word	0x20004b94

00007210 <dfe_set_backoff_gain>:

int dfe_set_backoff_gain(u8_t value)
{
	if(value > DFE_MAX_BACKOFF_STEPS) {
    7210:	280f      	cmp	r0, #15
    7212:	d803      	bhi.n	721c <dfe_set_backoff_gain+0xc>
		return -EINVAL;
	}
	dfe_rx.sampl_conf.backoff_gain = value;
    7214:	4b03      	ldr	r3, [pc, #12]	; (7224 <dfe_set_backoff_gain+0x14>)
    7216:	7258      	strb	r0, [r3, #9]
	return 0;
    7218:	2000      	movs	r0, #0
    721a:	4770      	bx	lr
		return -EINVAL;
    721c:	f06f 0015 	mvn.w	r0, #21
}
    7220:	4770      	bx	lr
    7222:	bf00      	nop
    7224:	20004b94 	.word	0x20004b94

00007228 <dfe_set_ant_switch_spacing>:

int dfe_set_ant_switch_spacing(u8_t spacing)
{
	if((spacing < RADIO_DFECTRL1_TSWITCHSPACING_4us) ||
    7228:	1e43      	subs	r3, r0, #1
    722a:	b2db      	uxtb	r3, r3
    722c:	2b02      	cmp	r3, #2
    722e:	d803      	bhi.n	7238 <dfe_set_ant_switch_spacing+0x10>
	  (spacing > RADIO_DFECTRL1_TSWITCHSPACING_1us)) {
		return -EINVAL;
	}
	dfe_rx.ant_conf.switch_spacing = spacing;
    7230:	4b03      	ldr	r3, [pc, #12]	; (7240 <dfe_set_ant_switch_spacing+0x18>)
    7232:	8198      	strh	r0, [r3, #12]
	return 0;
    7234:	2000      	movs	r0, #0
    7236:	4770      	bx	lr
		return -EINVAL;
    7238:	f06f 0015 	mvn.w	r0, #21
}
    723c:	4770      	bx	lr
    723e:	bf00      	nop
    7240:	20004b94 	.word	0x20004b94

00007244 <dfe_set_switch_offset>:
{
	if((offset < DFE_SWITCH_OFFSET_MIN) ||
	  (offset > DFE_SWITCH_OFFSET_MAX)) {
		return -EINVAL;
	}
	dfe_rx.ant_conf.switch_offset = offset;
    7244:	4b01      	ldr	r3, [pc, #4]	; (724c <dfe_set_switch_offset+0x8>)
    7246:	81d8      	strh	r0, [r3, #14]
	return 0;
}
    7248:	2000      	movs	r0, #0
    724a:	4770      	bx	lr
    724c:	20004b94 	.word	0x20004b94

00007250 <dfe_set_sample_offset>:
{
	if((offset < DFE_SAMPLE_OFFSET_MIN) &&
	  (offset > DFE_SAMPLE_OFFSET_MIN)) {
		return -EINVAL;
	}
	dfe_rx.sampl_conf.sample_offset = offset;
    7250:	4b01      	ldr	r3, [pc, #4]	; (7258 <dfe_set_sample_offset+0x8>)
    7252:	8158      	strh	r0, [r3, #10]
	return 0;
}
    7254:	2000      	movs	r0, #0
    7256:	4770      	bx	lr
    7258:	20004b94 	.word	0x20004b94

0000725c <dfe_set_ant_gpios>:

int dfe_set_ant_gpios(const struct dfe_ant_gpio *gpio, u8_t len)
{
	if (len >= DFE_ANT_GPIO_MAX) {
    725c:	2907      	cmp	r1, #7
    725e:	d819      	bhi.n	7294 <dfe_set_ant_gpios+0x38>
		return -EINVAL;
	}

	for(u8_t idx=0; idx < len; ++idx) {
    7260:	2300      	movs	r3, #0
    7262:	428b      	cmp	r3, r1
    7264:	d219      	bcs.n	729a <dfe_set_ant_gpios+0x3e>
{
    7266:	b470      	push	{r4, r5, r6}
		dfe_rx.ant_conf.gpio[idx].reg_idx = gpio[idx].idx;
    7268:	eb00 0443 	add.w	r4, r0, r3, lsl #1
    726c:	f810 5013 	ldrb.w	r5, [r0, r3, lsl #1]
    7270:	f103 0618 	add.w	r6, r3, #24
    7274:	4a0b      	ldr	r2, [pc, #44]	; (72a4 <dfe_set_ant_gpios+0x48>)
    7276:	eb02 0246 	add.w	r2, r2, r6, lsl #1
    727a:	7255      	strb	r5, [r2, #9]
		dfe_rx.ant_conf.gpio[idx].gpio_num = gpio[idx].gpio_num;
    727c:	7864      	ldrb	r4, [r4, #1]
    727e:	7294      	strb	r4, [r2, #10]
	for(u8_t idx=0; idx < len; ++idx) {
    7280:	3301      	adds	r3, #1
    7282:	b2db      	uxtb	r3, r3
    7284:	428b      	cmp	r3, r1
    7286:	d3ef      	bcc.n	7268 <dfe_set_ant_gpios+0xc>
	}
	dfe_rx.ant_conf.gpio_len = len;
    7288:	4b06      	ldr	r3, [pc, #24]	; (72a4 <dfe_set_ant_gpios+0x48>)
    728a:	f883 1049 	strb.w	r1, [r3, #73]	; 0x49

	return 0;
    728e:	2000      	movs	r0, #0
}
    7290:	bc70      	pop	{r4, r5, r6}
    7292:	4770      	bx	lr
		return -EINVAL;
    7294:	f06f 0015 	mvn.w	r0, #21
    7298:	4770      	bx	lr
	dfe_rx.ant_conf.gpio_len = len;
    729a:	4b02      	ldr	r3, [pc, #8]	; (72a4 <dfe_set_ant_gpios+0x48>)
    729c:	f883 1049 	strb.w	r1, [r3, #73]	; 0x49
	return 0;
    72a0:	2000      	movs	r0, #0
}
    72a2:	4770      	bx	lr
    72a4:	20004b94 	.word	0x20004b94

000072a8 <dfe_set_ant_gpio_patterns>:
#define DFE_IDLE_ANT_PATTERN_IDX 0
#define DFE_REF_ANT_PATTERN_IDX 1
#define DFE_SWITCH_ANT_PATTERN_OFFSET 2
int dfe_set_ant_gpio_patterns(u8_t idle, u8_t ref, u8_t *switching, u8_t switching_len)
{
	if (switching == NULL || (switching_len + 2) >= DFE_ANT_PATTERN_MAX) {
    72a8:	b1ca      	cbz	r2, 72de <dfe_set_ant_gpio_patterns+0x36>
{
    72aa:	b430      	push	{r4, r5}
    72ac:	4615      	mov	r5, r2
	if (switching == NULL || (switching_len + 2) >= DFE_ANT_PATTERN_MAX) {
    72ae:	1c9a      	adds	r2, r3, #2
    72b0:	2a27      	cmp	r2, #39	; 0x27
    72b2:	dc17      	bgt.n	72e4 <dfe_set_ant_gpio_patterns+0x3c>
		return -EINVAL;
	}

	dfe_rx.ant_conf.gpio_patterns[DFE_IDLE_ANT_PATTERN_IDX] = idle;
    72b4:	4a0d      	ldr	r2, [pc, #52]	; (72ec <dfe_set_ant_gpio_patterns+0x44>)
    72b6:	7410      	strb	r0, [r2, #16]
	dfe_rx.ant_conf.gpio_patterns[DFE_REF_ANT_PATTERN_IDX] = ref;
    72b8:	7451      	strb	r1, [r2, #17]
	for(u8_t idx=0; idx < switching_len; ++idx) {
    72ba:	2200      	movs	r2, #0
    72bc:	e006      	b.n	72cc <dfe_set_ant_gpio_patterns+0x24>
		dfe_rx.ant_conf.gpio_patterns[idx + DFE_SWITCH_ANT_PATTERN_OFFSET] = switching[idx];
    72be:	1c94      	adds	r4, r2, #2
    72c0:	5ca8      	ldrb	r0, [r5, r2]
    72c2:	490a      	ldr	r1, [pc, #40]	; (72ec <dfe_set_ant_gpio_patterns+0x44>)
    72c4:	4421      	add	r1, r4
    72c6:	7408      	strb	r0, [r1, #16]
	for(u8_t idx=0; idx < switching_len; ++idx) {
    72c8:	3201      	adds	r2, #1
    72ca:	b2d2      	uxtb	r2, r2
    72cc:	429a      	cmp	r2, r3
    72ce:	d3f6      	bcc.n	72be <dfe_set_ant_gpio_patterns+0x16>
	}
	dfe_rx.ant_conf.gpio_patterns_len = switching_len + DFE_SWITCH_ANT_PATTERN_OFFSET;
    72d0:	3302      	adds	r3, #2
    72d2:	4a06      	ldr	r2, [pc, #24]	; (72ec <dfe_set_ant_gpio_patterns+0x44>)
    72d4:	f882 3038 	strb.w	r3, [r2, #56]	; 0x38
	return 0;
    72d8:	2000      	movs	r0, #0
}
    72da:	bc30      	pop	{r4, r5}
    72dc:	4770      	bx	lr
		return -EINVAL;
    72de:	f06f 0015 	mvn.w	r0, #21
}
    72e2:	4770      	bx	lr
		return -EINVAL;
    72e4:	f06f 0015 	mvn.w	r0, #21
    72e8:	e7f7      	b.n	72da <dfe_set_ant_gpio_patterns+0x32>
    72ea:	bf00      	nop
    72ec:	20004b94 	.word	0x20004b94

000072f0 <dfe_init_scan_rx>:
}
#endif /* CONFIG_BT_CTLR_DFE_TX */

#if defined(CONFIG_BT_CTLR_DFE_RX)
void dfe_init_scan_rx(void)
{
    72f0:	b510      	push	{r4, lr}
	if (dfe_rx.dfe_op_mode == RADIO_DFEMODE_DFEOPMODE_AoA &&
    72f2:	4b1f      	ldr	r3, [pc, #124]	; (7370 <dfe_init_scan_rx+0x80>)
    72f4:	789b      	ldrb	r3, [r3, #2]
    72f6:	2b03      	cmp	r3, #3
    72f8:	d103      	bne.n	7302 <dfe_init_scan_rx+0x12>
	    dfe_rx.dfe_duration >= DFE_MIN_8US_PERIODS) {
    72fa:	4b1d      	ldr	r3, [pc, #116]	; (7370 <dfe_init_scan_rx+0x80>)
    72fc:	785b      	ldrb	r3, [r3, #1]
	if (dfe_rx.dfe_op_mode == RADIO_DFEMODE_DFEOPMODE_AoA &&
    72fe:	2b01      	cmp	r3, #1
    7300:	d803      	bhi.n	730a <dfe_init_scan_rx+0x1a>
		radio_dfe_gpio_set(dfe_rx.ant_conf.gpio,
				     dfe_rx.ant_conf.gpio_len);
		radio_dfe_switch_patterns_set(dfe_rx.ant_conf.gpio_patterns,
					      dfe_rx.ant_conf.gpio_patterns_len);
	} else {
		radio_dfe_mode_set(RADIO_DFEMODE_DFEOPMODE_Disabled);
    7302:	2000      	movs	r0, #0
    7304:	f001 fb90 	bl	8a28 <radio_dfe_mode_set>
	}
}
    7308:	bd10      	pop	{r4, pc}
		radio_dfe_mode_set(RADIO_DFEMODE_DFEOPMODE_AoA);
    730a:	2003      	movs	r0, #3
    730c:	f001 fb8c 	bl	8a28 <radio_dfe_mode_set>
		radio_cte_inline_ctrl_set(RADIO_CTEINLINECONF_CTEINLINECTRLEN_Disabled);
    7310:	2000      	movs	r0, #0
    7312:	f001 fb9b 	bl	8a4c <radio_cte_inline_ctrl_set>
		radio_cte_infos1_set(RADIO_CTEINLINECONF_CTEINFOINS1_NotInS1);
    7316:	2000      	movs	r0, #0
    7318:	f001 fbaa 	bl	8a70 <radio_cte_infos1_set>
		radio_dfe_numberof8us_set(dfe_rx.dfe_duration);
    731c:	4c14      	ldr	r4, [pc, #80]	; (7370 <dfe_init_scan_rx+0x80>)
    731e:	7860      	ldrb	r0, [r4, #1]
    7320:	f001 fbb8 	bl	8a94 <radio_dfe_numberof8us_set>
		radio_dfe_inextension_set(dfe_rx.start_of_dfe);
    7324:	7820      	ldrb	r0, [r4, #0]
    7326:	f001 fbc7 	bl	8ab8 <radio_dfe_inextension_set>
		radio_dfe_backoff_gain_set(dfe_rx.sampl_conf.backoff_gain);
    732a:	7a60      	ldrb	r0, [r4, #9]
    732c:	f001 fbd6 	bl	8adc <radio_dfe_backoff_gain_set>
		radio_cte_error_handling_set(dfe_rx.sampl_conf.en_sampling_on_crc_error);
    7330:	7920      	ldrb	r0, [r4, #4]
    7332:	f001 fbe1 	bl	8af8 <radio_cte_error_handling_set>
		radio_dfe_tsampleoffset_set(dfe_rx.sampl_conf.sample_offset);
    7336:	f9b4 000a 	ldrsh.w	r0, [r4, #10]
    733a:	f001 fbef 	bl	8b1c <radio_dfe_tsampleoffset_set>
		radio_dfe_sampletype_set(dfe_rx.sampl_conf.sampling_type);
    733e:	79e0      	ldrb	r0, [r4, #7]
    7340:	f001 fc02 	bl	8b48 <radio_dfe_sampletype_set>
		radio_dfe_tsamplespacingref_set(dfe_rx.sampl_conf.sample_spacing_ref);
    7344:	79a0      	ldrb	r0, [r4, #6]
    7346:	f001 fc11 	bl	8b6c <radio_dfe_tsamplespacingref_set>
		radio_dfe_tsamplespacing_set(dfe_rx.sampl_conf.sample_spacing);
    734a:	7a20      	ldrb	r0, [r4, #8]
    734c:	f001 fc20 	bl	8b90 <radio_dfe_tsamplespacing_set>
		radio_dfe_tswitchspacing_set(dfe_rx.ant_conf.switch_spacing);
    7350:	7b20      	ldrb	r0, [r4, #12]
    7352:	f001 fc2f 	bl	8bb4 <radio_dfe_tswitchspacing_set>
		radio_dfe_gpio_set(dfe_rx.ant_conf.gpio,
    7356:	f894 1049 	ldrb.w	r1, [r4, #73]	; 0x49
    735a:	f104 0039 	add.w	r0, r4, #57	; 0x39
    735e:	f001 fc3b 	bl	8bd8 <radio_dfe_gpio_set>
		radio_dfe_switch_patterns_set(dfe_rx.ant_conf.gpio_patterns,
    7362:	f894 1038 	ldrb.w	r1, [r4, #56]	; 0x38
    7366:	f104 0010 	add.w	r0, r4, #16
    736a:	f001 fc4d 	bl	8c08 <radio_dfe_switch_patterns_set>
    736e:	e7cb      	b.n	7308 <dfe_init_scan_rx+0x18>
    7370:	20004b94 	.word	0x20004b94

00007374 <dfe_setup_package_header>:
	 */
	node_rx->df_data_packet.hdr.length = 0;
}

void dfe_setup_package_header(struct node_rx_pdu *node_rx)
{
    7374:	b510      	push	{r4, lr}
    7376:	4604      	mov	r4, r0
	NRF_RADIO->EVENTS_CTEPRESENT = 0;
    7378:	4b05      	ldr	r3, [pc, #20]	; (7390 <dfe_setup_package_header+0x1c>)
    737a:	2200      	movs	r2, #0
    737c:	f8c3 2170 	str.w	r2, [r3, #368]	; 0x170
	node_rx->df_data_packet.hdr.length = radio_dfe_get_recv_sampl_num();
    7380:	f001 fc6a 	bl	8c58 <radio_dfe_get_recv_sampl_num>
    7384:	8420      	strh	r0, [r4, #32]
	node_rx->df_data_packet.hdr.frequency = radio_dfe_frequency();
    7386:	f001 fc55 	bl	8c34 <radio_dfe_frequency>
    738a:	8460      	strh	r0, [r4, #34]	; 0x22
}
    738c:	bd10      	pop	{r4, pc}
    738e:	bf00      	nop
    7390:	40001000 	.word	0x40001000

00007394 <ll_wl_clear>:
{
	return WL_SIZE;
}

u8_t ll_wl_clear(void)
{
    7394:	b508      	push	{r3, lr}
		return BT_HCI_ERR_CMD_DISALLOWED;
	}
#endif /* CONFIG_BT_BROADCASTER */

#if defined(CONFIG_BT_OBSERVER)
	if (ull_scan_filter_pol_get(0) & 0x1) {
    7396:	2000      	movs	r0, #0
    7398:	f007 fe06 	bl	efa8 <ull_scan_filter_pol_get>
    739c:	f010 0f01 	tst.w	r0, #1
    73a0:	d106      	bne.n	73b0 <ll_wl_clear+0x1c>
#endif /* CONFIG_BT_OBSERVER */

#if defined(CONFIG_BT_CTLR_PRIVACY)
	wl_clear();
#else
	filter_clear(&wl_filter);
    73a2:	4804      	ldr	r0, [pc, #16]	; (73b4 <ll_wl_clear+0x20>)
    73a4:	f007 fe15 	bl	efd2 <filter_clear>
#endif /* CONFIG_BT_CTLR_PRIVACY */

	wl_anon = 0U;
    73a8:	2000      	movs	r0, #0
    73aa:	4b03      	ldr	r3, [pc, #12]	; (73b8 <ll_wl_clear+0x24>)
    73ac:	7018      	strb	r0, [r3, #0]

	return 0;
}
    73ae:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
    73b0:	200c      	movs	r0, #12
    73b2:	e7fc      	b.n	73ae <ll_wl_clear+0x1a>
    73b4:	20004be0 	.word	0x20004be0
    73b8:	20005950 	.word	0x20005950

000073bc <ll_wl_add>:

u8_t ll_wl_add(bt_addr_le_t *addr)
{
    73bc:	b510      	push	{r4, lr}
    73be:	4604      	mov	r4, r0
		return BT_HCI_ERR_CMD_DISALLOWED;
	}
#endif /* CONFIG_BT_BROADCASTER */

#if defined(CONFIG_BT_OBSERVER)
	if (ull_scan_filter_pol_get(0) & 0x1) {
    73c0:	2000      	movs	r0, #0
    73c2:	f007 fdf1 	bl	efa8 <ull_scan_filter_pol_get>
    73c6:	f010 0f01 	tst.w	r0, #1
    73ca:	d10d      	bne.n	73e8 <ll_wl_add+0x2c>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}
#endif /* CONFIG_BT_OBSERVER */

	if (addr->type == ADDR_TYPE_ANON) {
    73cc:	7821      	ldrb	r1, [r4, #0]
    73ce:	29ff      	cmp	r1, #255	; 0xff
    73d0:	d005      	beq.n	73de <ll_wl_add+0x22>
	}

#if defined(CONFIG_BT_CTLR_PRIVACY)
	return wl_add(addr);
#else
	return filter_add(&wl_filter, addr->type, addr->a.val);
    73d2:	1c62      	adds	r2, r4, #1
    73d4:	4805      	ldr	r0, [pc, #20]	; (73ec <ll_wl_add+0x30>)
    73d6:	f007 fe18 	bl	f00a <filter_add>
    73da:	b2c0      	uxtb	r0, r0
#endif /* CONFIG_BT_CTLR_PRIVACY */
}
    73dc:	bd10      	pop	{r4, pc}
		wl_anon = 1U;
    73de:	4b04      	ldr	r3, [pc, #16]	; (73f0 <ll_wl_add+0x34>)
    73e0:	2201      	movs	r2, #1
    73e2:	701a      	strb	r2, [r3, #0]
		return 0;
    73e4:	2000      	movs	r0, #0
    73e6:	e7f9      	b.n	73dc <ll_wl_add+0x20>
		return BT_HCI_ERR_CMD_DISALLOWED;
    73e8:	200c      	movs	r0, #12
    73ea:	e7f7      	b.n	73dc <ll_wl_add+0x20>
    73ec:	20004be0 	.word	0x20004be0
    73f0:	20005950 	.word	0x20005950

000073f4 <ll_wl_remove>:

u8_t ll_wl_remove(bt_addr_le_t *addr)
{
    73f4:	b510      	push	{r4, lr}
    73f6:	4604      	mov	r4, r0
		return BT_HCI_ERR_CMD_DISALLOWED;
	}
#endif /* CONFIG_BT_BROADCASTER */

#if defined(CONFIG_BT_OBSERVER)
	if (ull_scan_filter_pol_get(0) & 0x1) {
    73f8:	2000      	movs	r0, #0
    73fa:	f007 fdd5 	bl	efa8 <ull_scan_filter_pol_get>
    73fe:	f010 0f01 	tst.w	r0, #1
    7402:	d10c      	bne.n	741e <ll_wl_remove+0x2a>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}
#endif /* CONFIG_BT_OBSERVER */

	if (addr->type == ADDR_TYPE_ANON) {
    7404:	7821      	ldrb	r1, [r4, #0]
    7406:	29ff      	cmp	r1, #255	; 0xff
    7408:	d005      	beq.n	7416 <ll_wl_remove+0x22>
	}

#if defined(CONFIG_BT_CTLR_PRIVACY)
	return wl_remove(addr);
#else
	return filter_remove(&wl_filter, addr->type, addr->a.val);
    740a:	1c62      	adds	r2, r4, #1
    740c:	4805      	ldr	r0, [pc, #20]	; (7424 <ll_wl_remove+0x30>)
    740e:	f007 fe11 	bl	f034 <filter_remove>
    7412:	b2c0      	uxtb	r0, r0
#endif /* CONFIG_BT_CTLR_PRIVACY */
}
    7414:	bd10      	pop	{r4, pc}
		wl_anon = 0U;
    7416:	2000      	movs	r0, #0
    7418:	4b03      	ldr	r3, [pc, #12]	; (7428 <ll_wl_remove+0x34>)
    741a:	7018      	strb	r0, [r3, #0]
		return 0;
    741c:	e7fa      	b.n	7414 <ll_wl_remove+0x20>
		return BT_HCI_ERR_CMD_DISALLOWED;
    741e:	200c      	movs	r0, #12
    7420:	e7f8      	b.n	7414 <ll_wl_remove+0x20>
    7422:	bf00      	nop
    7424:	20004be0 	.word	0x20004be0
    7428:	20005950 	.word	0x20005950

0000742c <ull_filter_reset>:
	return FILTER_IDX_NONE;
}
#endif /* CONFIG_BT_CTLR_PRIVACY */

void ull_filter_reset(bool init)
{
    742c:	b508      	push	{r3, lr}
	wl_anon = 0U;
    742e:	4b03      	ldr	r3, [pc, #12]	; (743c <ull_filter_reset+0x10>)
    7430:	2200      	movs	r2, #0
    7432:	701a      	strb	r2, [r3, #0]
#endif
	} else {
		k_delayed_work_cancel(&rpa_work);
	}
#else
	filter_clear(&wl_filter);
    7434:	4802      	ldr	r0, [pc, #8]	; (7440 <ull_filter_reset+0x14>)
    7436:	f007 fdcc 	bl	efd2 <filter_clear>
#endif /* CONFIG_BT_CTLR_PRIVACY */
}
    743a:	bd08      	pop	{r3, pc}
    743c:	20005950 	.word	0x20005950
    7440:	20004be0 	.word	0x20004be0

00007444 <ull_filter_lll_get>:
	if (whitelist) {
		return &wl_filter;
	}
	return &rl_filter;
#else
	LL_ASSERT(whitelist);
    7444:	b108      	cbz	r0, 744a <ull_filter_lll_get+0x6>
	return &wl_filter;
#endif
}
    7446:	4809      	ldr	r0, [pc, #36]	; (746c <ull_filter_lll_get+0x28>)
    7448:	4770      	bx	lr
{
    744a:	b508      	push	{r3, lr}
	LL_ASSERT(whitelist);
    744c:	f44f 7336 	mov.w	r3, #728	; 0x2d8
    7450:	4a07      	ldr	r2, [pc, #28]	; (7470 <ull_filter_lll_get+0x2c>)
    7452:	4908      	ldr	r1, [pc, #32]	; (7474 <ull_filter_lll_get+0x30>)
    7454:	4808      	ldr	r0, [pc, #32]	; (7478 <ull_filter_lll_get+0x34>)
    7456:	f005 fdea 	bl	d02e <printk>
    745a:	4040      	eors	r0, r0
    745c:	f380 8811 	msr	BASEPRI, r0
    7460:	f04f 0003 	mov.w	r0, #3
    7464:	df02      	svc	2
}
    7466:	4801      	ldr	r0, [pc, #4]	; (746c <ull_filter_lll_get+0x28>)
    7468:	bd08      	pop	{r3, pc}
    746a:	bf00      	nop
    746c:	20004be0 	.word	0x20004be0
    7470:	00012890 	.word	0x00012890
    7474:	0001290c 	.word	0x0001290c
    7478:	00011fec 	.word	0x00011fec

0000747c <rtc0_nrf5_isr>:
	DEBUG_RADIO_ISR(0);
	return 1;
}

static void rtc0_nrf5_isr(void *arg)
{
    747c:	b508      	push	{r3, lr}
	DEBUG_TICKER_ISR(1);

	/* On compare0 run ticker worker instance0 */
	if (NRF_RTC0->EVENTS_COMPARE[0]) {
    747e:	4b09      	ldr	r3, [pc, #36]	; (74a4 <rtc0_nrf5_isr+0x28>)
    7480:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
    7484:	b933      	cbnz	r3, 7494 <rtc0_nrf5_isr+0x18>
		NRF_RTC0->EVENTS_COMPARE[0] = 0;

		ticker_trigger(0);
	}

	mayfly_run(TICKER_USER_ID_ULL_HIGH);
    7486:	2001      	movs	r0, #1
    7488:	f7fd fe74 	bl	5174 <mayfly_run>

#if !defined(CONFIG_BT_CTLR_LOW_LAT) && \
	(CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	mayfly_run(TICKER_USER_ID_ULL_LOW);
    748c:	2002      	movs	r0, #2
    748e:	f7fd fe71 	bl	5174 <mayfly_run>
#endif

	DEBUG_TICKER_ISR(0);
}
    7492:	bd08      	pop	{r3, pc}
		NRF_RTC0->EVENTS_COMPARE[0] = 0;
    7494:	2000      	movs	r0, #0
    7496:	4b03      	ldr	r3, [pc, #12]	; (74a4 <rtc0_nrf5_isr+0x28>)
    7498:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
		ticker_trigger(0);
    749c:	f7fd ff94 	bl	53c8 <ticker_trigger>
    74a0:	e7f1      	b.n	7486 <rtc0_nrf5_isr+0xa>
    74a2:	bf00      	nop
    74a4:	4000b000 	.word	0x4000b000

000074a8 <resume_enqueue>:

	return err;
}

static int resume_enqueue(lll_prepare_cb_t resume_cb, int resume_prio)
{
    74a8:	b510      	push	{r4, lr}
    74aa:	b086      	sub	sp, #24
    74ac:	4603      	mov	r3, r0
	struct lll_prepare_param prepare_param;

	prepare_param.param = event.curr.param;
    74ae:	4c07      	ldr	r4, [pc, #28]	; (74cc <resume_enqueue+0x24>)
    74b0:	6822      	ldr	r2, [r4, #0]
    74b2:	9205      	str	r2, [sp, #20]
	event.curr.param = NULL;
    74b4:	2200      	movs	r2, #0
    74b6:	6022      	str	r2, [r4, #0]

	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
    74b8:	2201      	movs	r2, #1
    74ba:	9201      	str	r2, [sp, #4]
    74bc:	9100      	str	r1, [sp, #0]
    74be:	aa02      	add	r2, sp, #8
    74c0:	68a1      	ldr	r1, [r4, #8]
    74c2:	6860      	ldr	r0, [r4, #4]
    74c4:	f7ff fbee 	bl	6ca4 <ull_prepare_enqueue>
				   &prepare_param, resume_cb, resume_prio, 1);
}
    74c8:	b006      	add	sp, #24
    74ca:	bd10      	pop	{r4, pc}
    74cc:	20004c18 	.word	0x20004c18

000074d0 <ticker_start_op_cb>:
	/* NOTE: this callback is present only for addition of debug messages
	 * when needed, else can be dispensed with.
	 */
	ARG_UNUSED(param);

	LL_ASSERT((status == TICKER_STATUS_SUCCESS) ||
    74d0:	2801      	cmp	r0, #1
    74d2:	d800      	bhi.n	74d6 <ticker_start_op_cb+0x6>
    74d4:	4770      	bx	lr
{
    74d6:	b508      	push	{r3, lr}
	LL_ASSERT((status == TICKER_STATUS_SUCCESS) ||
    74d8:	f240 2319 	movw	r3, #537	; 0x219
    74dc:	4a05      	ldr	r2, [pc, #20]	; (74f4 <ticker_start_op_cb+0x24>)
    74de:	4906      	ldr	r1, [pc, #24]	; (74f8 <ticker_start_op_cb+0x28>)
    74e0:	4806      	ldr	r0, [pc, #24]	; (74fc <ticker_start_op_cb+0x2c>)
    74e2:	f005 fda4 	bl	d02e <printk>
    74e6:	4040      	eors	r0, r0
    74e8:	f380 8811 	msr	BASEPRI, r0
    74ec:	f04f 0003 	mov.w	r0, #3
    74f0:	df02      	svc	2
		  (status == TICKER_STATUS_FAILURE));
}
    74f2:	bd08      	pop	{r3, pc}
    74f4:	0001292c 	.word	0x0001292c
    74f8:	000129ac 	.word	0x000129ac
    74fc:	00011fec 	.word	0x00011fec

00007500 <preempt_ticker_start>:

static void preempt_ticker_start(struct lll_prepare_param *prepare_param)
{
    7500:	b510      	push	{r4, lr}
    7502:	b08a      	sub	sp, #40	; 0x28
    7504:	4603      	mov	r3, r0
	struct evt_hdr *evt;
	u32_t preempt_to;
	int ret;

	/* Calc the preempt timeout */
	evt = HDR_LLL2EVT(prepare_param->param);
    7506:	68c2      	ldr	r2, [r0, #12]
    7508:	6811      	ldr	r1, [r2, #0]
	preempt_anchor = prepare_param->ticks_at_expire;
	preempt_to = MAX(evt->ticks_active_to_start,
    750a:	680c      	ldr	r4, [r1, #0]
    750c:	6848      	ldr	r0, [r1, #4]
			 evt->ticks_xtal_to_start) -
			 evt->ticks_preempt_to_start;
    750e:	688a      	ldr	r2, [r1, #8]
	preempt_to = MAX(evt->ticks_active_to_start,
    7510:	4284      	cmp	r4, r0
    7512:	bf2c      	ite	cs
    7514:	ebc2 0204 	rsbcs	r2, r2, r4
    7518:	ebc2 0200 	rsbcc	r2, r2, r0

	/* Setup pre empt timeout */
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    751c:	2000      	movs	r0, #0
    751e:	9008      	str	r0, [sp, #32]
    7520:	4910      	ldr	r1, [pc, #64]	; (7564 <preempt_ticker_start+0x64>)
    7522:	9107      	str	r1, [sp, #28]
    7524:	9006      	str	r0, [sp, #24]
    7526:	4910      	ldr	r1, [pc, #64]	; (7568 <preempt_ticker_start+0x68>)
    7528:	9105      	str	r1, [sp, #20]
    752a:	9004      	str	r0, [sp, #16]
    752c:	9003      	str	r0, [sp, #12]
    752e:	9002      	str	r0, [sp, #8]
    7530:	9001      	str	r0, [sp, #4]
    7532:	9200      	str	r2, [sp, #0]
    7534:	681b      	ldr	r3, [r3, #0]
    7536:	4602      	mov	r2, r0
    7538:	4601      	mov	r1, r0
    753a:	f007 f8d0 	bl	e6de <ticker_start>
			   TICKER_NULL_REMAINDER,
			   TICKER_NULL_LAZY,
			   TICKER_NULL_SLOT,
			   preempt_ticker_cb, NULL,
			   ticker_start_op_cb, NULL);
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    753e:	2802      	cmp	r0, #2
    7540:	d801      	bhi.n	7546 <preempt_ticker_start+0x46>
		  (ret == TICKER_STATUS_FAILURE) ||
		  (ret == TICKER_STATUS_BUSY));
}
    7542:	b00a      	add	sp, #40	; 0x28
    7544:	bd10      	pop	{r4, pc}
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    7546:	f240 2337 	movw	r3, #567	; 0x237
    754a:	4a08      	ldr	r2, [pc, #32]	; (756c <preempt_ticker_start+0x6c>)
    754c:	4908      	ldr	r1, [pc, #32]	; (7570 <preempt_ticker_start+0x70>)
    754e:	4809      	ldr	r0, [pc, #36]	; (7574 <preempt_ticker_start+0x74>)
    7550:	f005 fd6d 	bl	d02e <printk>
    7554:	4040      	eors	r0, r0
    7556:	f380 8811 	msr	BASEPRI, r0
    755a:	f04f 0003 	mov.w	r0, #3
    755e:	df02      	svc	2
}
    7560:	e7ef      	b.n	7542 <preempt_ticker_start+0x42>
    7562:	bf00      	nop
    7564:	000074d1 	.word	0x000074d1
    7568:	00007631 	.word	0x00007631
    756c:	0001292c 	.word	0x0001292c
    7570:	000129cc 	.word	0x000129cc
    7574:	00011fec 	.word	0x00011fec

00007578 <prepare>:
{
    7578:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    757c:	b085      	sub	sp, #20
    757e:	4606      	mov	r6, r0
    7580:	460d      	mov	r5, r1
    7582:	4614      	mov	r4, r2
    7584:	461f      	mov	r7, r3
    7586:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
    758a:	f89d 8034 	ldrb.w	r8, [sp, #52]	; 0x34
	u8_t idx = UINT8_MAX;
    758e:	23ff      	movs	r3, #255	; 0xff
    7590:	f88d 300f 	strb.w	r3, [sp, #15]
	p = ull_prepare_dequeue_iter(&idx);
    7594:	f10d 000f 	add.w	r0, sp, #15
    7598:	f7ff fcc6 	bl	6f28 <ull_prepare_dequeue_iter>
	while (p && (p->is_aborted || p->is_resume)) {
    759c:	b148      	cbz	r0, 75b2 <prepare+0x3a>
    759e:	f890 3020 	ldrb.w	r3, [r0, #32]
    75a2:	f013 0f03 	tst.w	r3, #3
    75a6:	d004      	beq.n	75b2 <prepare+0x3a>
		p = ull_prepare_dequeue_iter(&idx);
    75a8:	f10d 000f 	add.w	r0, sp, #15
    75ac:	f7ff fcbc 	bl	6f28 <ull_prepare_dequeue_iter>
    75b0:	e7f4      	b.n	759c <prepare+0x24>
	if (event.curr.abort_cb || (p && is_resume)) {
    75b2:	4b1b      	ldr	r3, [pc, #108]	; (7620 <prepare+0xa8>)
    75b4:	689b      	ldr	r3, [r3, #8]
    75b6:	b18b      	cbz	r3, 75dc <prepare+0x64>
		ret = ull_prepare_enqueue(is_abort_cb, abort_cb, prepare_param,
    75b8:	f8cd 8004 	str.w	r8, [sp, #4]
    75bc:	9700      	str	r7, [sp, #0]
    75be:	4623      	mov	r3, r4
    75c0:	464a      	mov	r2, r9
    75c2:	4629      	mov	r1, r5
    75c4:	4630      	mov	r0, r6
    75c6:	f7ff fb6d 	bl	6ca4 <ull_prepare_enqueue>
		LL_ASSERT(!ret);
    75ca:	b9a0      	cbnz	r0, 75f6 <prepare+0x7e>
		if (is_resume) {
    75cc:	f1b8 0f00 	cmp.w	r8, #0
    75d0:	d01f      	beq.n	7612 <prepare+0x9a>
			return -EINPROGRESS;
    75d2:	f06f 0076 	mvn.w	r0, #118	; 0x76
}
    75d6:	b005      	add	sp, #20
    75d8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (event.curr.abort_cb || (p && is_resume)) {
    75dc:	b110      	cbz	r0, 75e4 <prepare+0x6c>
    75de:	f1b8 0f00 	cmp.w	r8, #0
    75e2:	d1e9      	bne.n	75b8 <prepare+0x40>
	event.curr.param = prepare_param->param;
    75e4:	f8d9 200c 	ldr.w	r2, [r9, #12]
    75e8:	4b0d      	ldr	r3, [pc, #52]	; (7620 <prepare+0xa8>)
    75ea:	601a      	str	r2, [r3, #0]
	event.curr.is_abort_cb = is_abort_cb;
    75ec:	605e      	str	r6, [r3, #4]
	event.curr.abort_cb = abort_cb;
    75ee:	609d      	str	r5, [r3, #8]
	err = prepare_cb(prepare_param);
    75f0:	4648      	mov	r0, r9
    75f2:	47a0      	blx	r4
	return err;
    75f4:	e7ef      	b.n	75d6 <prepare+0x5e>
		LL_ASSERT(!ret);
    75f6:	f240 13cd 	movw	r3, #461	; 0x1cd
    75fa:	4a0a      	ldr	r2, [pc, #40]	; (7624 <prepare+0xac>)
    75fc:	490a      	ldr	r1, [pc, #40]	; (7628 <prepare+0xb0>)
    75fe:	480b      	ldr	r0, [pc, #44]	; (762c <prepare+0xb4>)
    7600:	f005 fd15 	bl	d02e <printk>
    7604:	4040      	eors	r0, r0
    7606:	f380 8811 	msr	BASEPRI, r0
    760a:	f04f 0003 	mov.w	r0, #3
    760e:	df02      	svc	2
    7610:	e7dc      	b.n	75cc <prepare+0x54>
		preempt_ticker_start(prepare_param);
    7612:	4648      	mov	r0, r9
    7614:	f7ff ff74 	bl	7500 <preempt_ticker_start>
		return -EINPROGRESS;
    7618:	f06f 0076 	mvn.w	r0, #118	; 0x76
    761c:	e7db      	b.n	75d6 <prepare+0x5e>
    761e:	bf00      	nop
    7620:	20004c18 	.word	0x20004c18
    7624:	0001292c 	.word	0x0001292c
    7628:	000127a0 	.word	0x000127a0
    762c:	00011fec 	.word	0x00011fec

00007630 <preempt_ticker_cb>:

static void preempt_ticker_cb(u32_t ticks_at_expire, u32_t remainder,
			       u16_t lazy, void *param)
{
    7630:	b508      	push	{r3, lr}
	static memq_link_t link;
	static struct mayfly mfy = {0, 0, &link, NULL, preempt};
	u32_t ret;

	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
    7632:	4b0b      	ldr	r3, [pc, #44]	; (7660 <preempt_ticker_cb+0x30>)
    7634:	2200      	movs	r2, #0
    7636:	4611      	mov	r1, r2
    7638:	2001      	movs	r0, #1
    763a:	f7fd fd39 	bl	50b0 <mayfly_enqueue>
			     0, &mfy);
	LL_ASSERT(!ret);
    763e:	b900      	cbnz	r0, 7642 <preempt_ticker_cb+0x12>
}
    7640:	bd08      	pop	{r3, pc}
	LL_ASSERT(!ret);
    7642:	f240 2345 	movw	r3, #581	; 0x245
    7646:	4a07      	ldr	r2, [pc, #28]	; (7664 <preempt_ticker_cb+0x34>)
    7648:	4907      	ldr	r1, [pc, #28]	; (7668 <preempt_ticker_cb+0x38>)
    764a:	4808      	ldr	r0, [pc, #32]	; (766c <preempt_ticker_cb+0x3c>)
    764c:	f005 fcef 	bl	d02e <printk>
    7650:	4040      	eors	r0, r0
    7652:	f380 8811 	msr	BASEPRI, r0
    7656:	f04f 0003 	mov.w	r0, #3
    765a:	df02      	svc	2
}
    765c:	e7f0      	b.n	7640 <preempt_ticker_cb+0x10>
    765e:	bf00      	nop
    7660:	200002bc 	.word	0x200002bc
    7664:	0001292c 	.word	0x0001292c
    7668:	000127a0 	.word	0x000127a0
    766c:	00011fec 	.word	0x00011fec

00007670 <preempt>:

static void preempt(void *param)
{
    7670:	b530      	push	{r4, r5, lr}
    7672:	b087      	sub	sp, #28
	struct lll_event *next = ull_prepare_dequeue_get();
    7674:	f7ff fb52 	bl	6d1c <ull_prepare_dequeue_get>
	lll_prepare_cb_t resume_cb;
	u8_t idx = UINT8_MAX;
    7678:	23ff      	movs	r3, #255	; 0xff
    767a:	f88d 3013 	strb.w	r3, [sp, #19]
	int resume_prio;
	int ret;

	if (!event.curr.abort_cb || !event.curr.param) {
    767e:	4b46      	ldr	r3, [pc, #280]	; (7798 <preempt+0x128>)
    7680:	689b      	ldr	r3, [r3, #8]
    7682:	2b00      	cmp	r3, #0
    7684:	d052      	beq.n	772c <preempt+0xbc>
    7686:	4b44      	ldr	r3, [pc, #272]	; (7798 <preempt+0x128>)
    7688:	681b      	ldr	r3, [r3, #0]
    768a:	2b00      	cmp	r3, #0
    768c:	d04e      	beq.n	772c <preempt+0xbc>
		return;
	}

	next = ull_prepare_dequeue_iter(&idx);
    768e:	f10d 0013 	add.w	r0, sp, #19
    7692:	f7ff fc49 	bl	6f28 <ull_prepare_dequeue_iter>
	if (!next) {
    7696:	4604      	mov	r4, r0
    7698:	2800      	cmp	r0, #0
    769a:	d047      	beq.n	772c <preempt+0xbc>
		return;
	}

	while (next && (next->is_aborted || next->is_resume)) {
    769c:	b154      	cbz	r4, 76b4 <preempt+0x44>
    769e:	f894 3020 	ldrb.w	r3, [r4, #32]
    76a2:	f013 0f03 	tst.w	r3, #3
    76a6:	d005      	beq.n	76b4 <preempt+0x44>
		next = ull_prepare_dequeue_iter(&idx);
    76a8:	f10d 0013 	add.w	r0, sp, #19
    76ac:	f7ff fc3c 	bl	6f28 <ull_prepare_dequeue_iter>
    76b0:	4604      	mov	r4, r0
    76b2:	e7f3      	b.n	769c <preempt+0x2c>
	}

	if (!next) {
    76b4:	2c00      	cmp	r4, #0
    76b6:	d039      	beq.n	772c <preempt+0xbc>
		return;
	}

	ret = event.curr.is_abort_cb(next->prepare_param.param, next->prio,
    76b8:	4a37      	ldr	r2, [pc, #220]	; (7798 <preempt+0x128>)
    76ba:	6855      	ldr	r5, [r2, #4]
    76bc:	69e1      	ldr	r1, [r4, #28]
    76be:	68e0      	ldr	r0, [r4, #12]
    76c0:	ab03      	add	r3, sp, #12
    76c2:	9300      	str	r3, [sp, #0]
    76c4:	ab05      	add	r3, sp, #20
    76c6:	6812      	ldr	r2, [r2, #0]
    76c8:	47a8      	blx	r5
				     event.curr.param,
				     &resume_cb, &resume_prio);
	if (!ret) {
    76ca:	4605      	mov	r5, r0
    76cc:	b1c0      	cbz	r0, 7700 <preempt+0x90>
		next->abort_cb(&next->prepare_param, next->prepare_param.param);

		goto preempt_next;
	}

	event.curr.abort_cb(NULL, event.curr.param);
    76ce:	4b32      	ldr	r3, [pc, #200]	; (7798 <preempt+0x128>)
    76d0:	689a      	ldr	r2, [r3, #8]
    76d2:	6819      	ldr	r1, [r3, #0]
    76d4:	2000      	movs	r0, #0
    76d6:	4790      	blx	r2

	if (ret == -EAGAIN) {
    76d8:	f115 0f0b 	cmn.w	r5, #11
    76dc:	d028      	beq.n	7730 <preempt+0xc0>
		}

		ret = resume_enqueue(resume_cb, resume_prio);
		LL_ASSERT(!ret);
	} else {
		LL_ASSERT(ret == -ECANCELED);
    76de:	f115 0f8c 	cmn.w	r5, #140	; 0x8c
    76e2:	d017      	beq.n	7714 <preempt+0xa4>
    76e4:	f240 2381 	movw	r3, #641	; 0x281
    76e8:	4a2c      	ldr	r2, [pc, #176]	; (779c <preempt+0x12c>)
    76ea:	492d      	ldr	r1, [pc, #180]	; (77a0 <preempt+0x130>)
    76ec:	482d      	ldr	r0, [pc, #180]	; (77a4 <preempt+0x134>)
    76ee:	f005 fc9e 	bl	d02e <printk>
    76f2:	4040      	eors	r0, r0
    76f4:	f380 8811 	msr	BASEPRI, r0
    76f8:	f04f 0003 	mov.w	r0, #3
    76fc:	df02      	svc	2
    76fe:	e009      	b.n	7714 <preempt+0xa4>
		next->is_aborted = 1;
    7700:	f894 3020 	ldrb.w	r3, [r4, #32]
    7704:	f043 0302 	orr.w	r3, r3, #2
    7708:	f884 3020 	strb.w	r3, [r4, #32]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
    770c:	69a3      	ldr	r3, [r4, #24]
    770e:	68e1      	ldr	r1, [r4, #12]
    7710:	4620      	mov	r0, r4
    7712:	4798      	blx	r3
	}

preempt_next:
	do {
		next = ull_prepare_dequeue_iter(&idx);
    7714:	f10d 0013 	add.w	r0, sp, #19
    7718:	f7ff fc06 	bl	6f28 <ull_prepare_dequeue_iter>
		if (!next) {
    771c:	b130      	cbz	r0, 772c <preempt+0xbc>
			return;
		}
	} while (next->is_aborted || next->is_resume);
    771e:	f890 2020 	ldrb.w	r2, [r0, #32]
    7722:	f012 0f03 	tst.w	r2, #3
    7726:	d1f5      	bne.n	7714 <preempt+0xa4>

	preempt_ticker_start(&next->prepare_param);
    7728:	f7ff feea 	bl	7500 <preempt_ticker_start>
}
    772c:	b007      	add	sp, #28
    772e:	bd30      	pop	{r4, r5, pc}
		u8_t iter_idx = UINT8_MAX;
    7730:	23ff      	movs	r3, #255	; 0xff
    7732:	f88d 300b 	strb.w	r3, [sp, #11]
		iter = ull_prepare_dequeue_iter(&iter_idx);
    7736:	f10d 000b 	add.w	r0, sp, #11
    773a:	f7ff fbf5 	bl	6f28 <ull_prepare_dequeue_iter>
		while (iter) {
    773e:	e003      	b.n	7748 <preempt+0xd8>
			iter = ull_prepare_dequeue_iter(&iter_idx);
    7740:	f10d 000b 	add.w	r0, sp, #11
    7744:	f7ff fbf0 	bl	6f28 <ull_prepare_dequeue_iter>
		while (iter) {
    7748:	b190      	cbz	r0, 7770 <preempt+0x100>
			if (!iter->is_aborted &&
    774a:	f890 3020 	ldrb.w	r3, [r0, #32]
    774e:	f013 0f02 	tst.w	r3, #2
    7752:	d1f5      	bne.n	7740 <preempt+0xd0>
			    event.curr.param == iter->prepare_param.param) {
    7754:	4b10      	ldr	r3, [pc, #64]	; (7798 <preempt+0x128>)
    7756:	681b      	ldr	r3, [r3, #0]
    7758:	68c1      	ldr	r1, [r0, #12]
			if (!iter->is_aborted &&
    775a:	428b      	cmp	r3, r1
    775c:	d1f0      	bne.n	7740 <preempt+0xd0>
				iter->is_aborted = 1;
    775e:	f890 3020 	ldrb.w	r3, [r0, #32]
    7762:	f043 0302 	orr.w	r3, r3, #2
    7766:	f880 3020 	strb.w	r3, [r0, #32]
				iter->abort_cb(&iter->prepare_param,
    776a:	6983      	ldr	r3, [r0, #24]
    776c:	4798      	blx	r3
    776e:	e7e7      	b.n	7740 <preempt+0xd0>
		ret = resume_enqueue(resume_cb, resume_prio);
    7770:	9903      	ldr	r1, [sp, #12]
    7772:	9805      	ldr	r0, [sp, #20]
    7774:	f7ff fe98 	bl	74a8 <resume_enqueue>
		LL_ASSERT(!ret);
    7778:	2800      	cmp	r0, #0
    777a:	d0cb      	beq.n	7714 <preempt+0xa4>
    777c:	f240 237f 	movw	r3, #639	; 0x27f
    7780:	4a06      	ldr	r2, [pc, #24]	; (779c <preempt+0x12c>)
    7782:	4909      	ldr	r1, [pc, #36]	; (77a8 <preempt+0x138>)
    7784:	4807      	ldr	r0, [pc, #28]	; (77a4 <preempt+0x134>)
    7786:	f005 fc52 	bl	d02e <printk>
    778a:	4040      	eors	r0, r0
    778c:	f380 8811 	msr	BASEPRI, r0
    7790:	f04f 0003 	mov.w	r0, #3
    7794:	df02      	svc	2
    7796:	e7bd      	b.n	7714 <preempt+0xa4>
    7798:	20004c18 	.word	0x20004c18
    779c:	0001292c 	.word	0x0001292c
    77a0:	000129f4 	.word	0x000129f4
    77a4:	00011fec 	.word	0x00011fec
    77a8:	000127a0 	.word	0x000127a0

000077ac <lll_init>:
{
    77ac:	b510      	push	{r4, lr}
    77ae:	4819      	ldr	r0, [pc, #100]	; (7814 <lll_init+0x68>)
    77b0:	f002 fd8a 	bl	a2c8 <z_impl_device_get_binding>
	dev_entropy = device_get_binding(DT_LABEL(DT_NODELABEL(rng)));
    77b4:	4b18      	ldr	r3, [pc, #96]	; (7818 <lll_init+0x6c>)
    77b6:	6018      	str	r0, [r3, #0]
	if (!dev_entropy) {
    77b8:	b340      	cbz	r0, 780c <lll_init+0x60>
	event.curr.abort_cb = NULL;
    77ba:	4b18      	ldr	r3, [pc, #96]	; (781c <lll_init+0x70>)
    77bc:	2200      	movs	r2, #0
    77be:	609a      	str	r2, [r3, #8]
	err = lll_clock_init();
    77c0:	f000 f942 	bl	7a48 <lll_clock_init>
	if (err) {
    77c4:	4604      	mov	r4, r0
    77c6:	b108      	cbz	r0, 77cc <lll_init+0x20>
}
    77c8:	4620      	mov	r0, r4
    77ca:	bd10      	pop	{r4, pc}
	dfe_common_init();
    77cc:	f007 fbf7 	bl	efbe <dfe_common_init>
	err = init_reset();
    77d0:	f007 fc63 	bl	f09a <init_reset>
	if (err) {
    77d4:	4604      	mov	r4, r0
    77d6:	2800      	cmp	r0, #0
    77d8:	d1f6      	bne.n	77c8 <lll_init+0x1c>
	IRQ_DIRECT_CONNECT(RADIO_IRQn, CONFIG_BT_CTLR_LLL_PRIO,
    77da:	2200      	movs	r2, #0
    77dc:	4611      	mov	r1, r2
    77de:	2001      	movs	r0, #1
    77e0:	f7fb f86e 	bl	28c0 <z_arm_irq_priority_set>
	IRQ_CONNECT(RTC0_IRQn, CONFIG_BT_CTLR_ULL_HIGH_PRIO,
    77e4:	2200      	movs	r2, #0
    77e6:	4611      	mov	r1, r2
    77e8:	200b      	movs	r0, #11
    77ea:	f7fb f869 	bl	28c0 <z_arm_irq_priority_set>
	IRQ_CONNECT(HAL_SWI_RADIO_IRQ, CONFIG_BT_CTLR_LLL_PRIO,
    77ee:	2200      	movs	r2, #0
    77f0:	4611      	mov	r1, r2
    77f2:	2018      	movs	r0, #24
    77f4:	f7fb f864 	bl	28c0 <z_arm_irq_priority_set>
	irq_enable(RADIO_IRQn);
    77f8:	2001      	movs	r0, #1
    77fa:	f7fb f82f 	bl	285c <arch_irq_enable>
	irq_enable(RTC0_IRQn);
    77fe:	200b      	movs	r0, #11
    7800:	f7fb f82c 	bl	285c <arch_irq_enable>
	irq_enable(HAL_SWI_RADIO_IRQ);
    7804:	2018      	movs	r0, #24
    7806:	f7fb f829 	bl	285c <arch_irq_enable>
	return 0;
    780a:	e7dd      	b.n	77c8 <lll_init+0x1c>
		return -ENODEV;
    780c:	f06f 0412 	mvn.w	r4, #18
    7810:	e7da      	b.n	77c8 <lll_init+0x1c>
    7812:	bf00      	nop
    7814:	00012a00 	.word	0x00012a00
    7818:	20004c14 	.word	0x20004c14
    781c:	20004c18 	.word	0x20004c18

00007820 <lll_trng_get>:
{
    7820:	b510      	push	{r4, lr}
    7822:	4603      	mov	r3, r0
	return entropy_get_entropy(dev_entropy, buf, len);
    7824:	4a03      	ldr	r2, [pc, #12]	; (7834 <lll_trng_get+0x14>)
    7826:	6810      	ldr	r0, [r2, #0]
    7828:	b28a      	uxth	r2, r1

static inline int z_impl_entropy_get_entropy(struct device *dev,
					    u8_t *buffer,
					    u16_t length)
{
	const struct entropy_driver_api *api =
    782a:	6881      	ldr	r1, [r0, #8]
		(const struct entropy_driver_api *)dev->driver_api;

	__ASSERT(api->get_entropy != NULL,
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
    782c:	680c      	ldr	r4, [r1, #0]
    782e:	4619      	mov	r1, r3
    7830:	47a0      	blx	r4
}
    7832:	bd10      	pop	{r4, pc}
    7834:	20004c14 	.word	0x20004c14

00007838 <lll_resume>:
{
    7838:	b500      	push	{lr}
    783a:	b083      	sub	sp, #12
		      next->prio, &next->prepare_param, next->is_resume);
    783c:	f890 3020 	ldrb.w	r3, [r0, #32]
    7840:	f003 0301 	and.w	r3, r3, #1
	ret = prepare(next->is_abort_cb, next->abort_cb, next->prepare_cb,
    7844:	9301      	str	r3, [sp, #4]
    7846:	9000      	str	r0, [sp, #0]
    7848:	69c3      	ldr	r3, [r0, #28]
    784a:	6902      	ldr	r2, [r0, #16]
    784c:	6981      	ldr	r1, [r0, #24]
    784e:	6940      	ldr	r0, [r0, #20]
    7850:	f7ff fe92 	bl	7578 <prepare>
	LL_ASSERT(!ret || ret == -EINPROGRESS);
    7854:	b110      	cbz	r0, 785c <lll_resume+0x24>
    7856:	f110 0f77 	cmn.w	r0, #119	; 0x77
    785a:	d102      	bne.n	7862 <lll_resume+0x2a>
}
    785c:	b003      	add	sp, #12
    785e:	f85d fb04 	ldr.w	pc, [sp], #4
	LL_ASSERT(!ret || ret == -EINPROGRESS);
    7862:	23e9      	movs	r3, #233	; 0xe9
    7864:	4a05      	ldr	r2, [pc, #20]	; (787c <lll_resume+0x44>)
    7866:	4906      	ldr	r1, [pc, #24]	; (7880 <lll_resume+0x48>)
    7868:	4806      	ldr	r0, [pc, #24]	; (7884 <lll_resume+0x4c>)
    786a:	f005 fbe0 	bl	d02e <printk>
    786e:	4040      	eors	r0, r0
    7870:	f380 8811 	msr	BASEPRI, r0
    7874:	f04f 0003 	mov.w	r0, #3
    7878:	df02      	svc	2
}
    787a:	e7ef      	b.n	785c <lll_resume+0x24>
    787c:	0001292c 	.word	0x0001292c
    7880:	00012a04 	.word	0x00012a04
    7884:	00011fec 	.word	0x00011fec

00007888 <lll_disable>:
{
    7888:	b510      	push	{r4, lr}
    788a:	b082      	sub	sp, #8
	if (!param || (param == event.curr.param)) {
    788c:	4604      	mov	r4, r0
    788e:	b158      	cbz	r0, 78a8 <lll_disable+0x20>
    7890:	4b1f      	ldr	r3, [pc, #124]	; (7910 <lll_disable+0x88>)
    7892:	681b      	ldr	r3, [r3, #0]
    7894:	4283      	cmp	r3, r0
    7896:	d007      	beq.n	78a8 <lll_disable+0x20>
		u8_t idx = UINT8_MAX;
    7898:	23ff      	movs	r3, #255	; 0xff
    789a:	f88d 3007 	strb.w	r3, [sp, #7]
		next = ull_prepare_dequeue_iter(&idx);
    789e:	f10d 0007 	add.w	r0, sp, #7
    78a2:	f7ff fb41 	bl	6f28 <ull_prepare_dequeue_iter>
		while (next) {
    78a6:	e024      	b.n	78f2 <lll_disable+0x6a>
		if (event.curr.abort_cb && event.curr.param) {
    78a8:	4b19      	ldr	r3, [pc, #100]	; (7910 <lll_disable+0x88>)
    78aa:	689b      	ldr	r3, [r3, #8]
    78ac:	b12b      	cbz	r3, 78ba <lll_disable+0x32>
    78ae:	4a18      	ldr	r2, [pc, #96]	; (7910 <lll_disable+0x88>)
    78b0:	6811      	ldr	r1, [r2, #0]
    78b2:	b111      	cbz	r1, 78ba <lll_disable+0x32>
			event.curr.abort_cb(NULL, event.curr.param);
    78b4:	2000      	movs	r0, #0
    78b6:	4798      	blx	r3
    78b8:	e7ee      	b.n	7898 <lll_disable+0x10>
			LL_ASSERT(!param);
    78ba:	2c00      	cmp	r4, #0
    78bc:	d0ec      	beq.n	7898 <lll_disable+0x10>
    78be:	23f3      	movs	r3, #243	; 0xf3
    78c0:	4a14      	ldr	r2, [pc, #80]	; (7914 <lll_disable+0x8c>)
    78c2:	4915      	ldr	r1, [pc, #84]	; (7918 <lll_disable+0x90>)
    78c4:	4815      	ldr	r0, [pc, #84]	; (791c <lll_disable+0x94>)
    78c6:	f005 fbb2 	bl	d02e <printk>
    78ca:	4040      	eors	r0, r0
    78cc:	f380 8811 	msr	BASEPRI, r0
    78d0:	f04f 0003 	mov.w	r0, #3
    78d4:	df02      	svc	2
    78d6:	e7df      	b.n	7898 <lll_disable+0x10>
				next->is_aborted = 1;
    78d8:	f890 3020 	ldrb.w	r3, [r0, #32]
    78dc:	f043 0302 	orr.w	r3, r3, #2
    78e0:	f880 3020 	strb.w	r3, [r0, #32]
				next->abort_cb(&next->prepare_param,
    78e4:	6983      	ldr	r3, [r0, #24]
    78e6:	68c1      	ldr	r1, [r0, #12]
    78e8:	4798      	blx	r3
			next = ull_prepare_dequeue_iter(&idx);
    78ea:	f10d 0007 	add.w	r0, sp, #7
    78ee:	f7ff fb1b 	bl	6f28 <ull_prepare_dequeue_iter>
		while (next) {
    78f2:	b150      	cbz	r0, 790a <lll_disable+0x82>
			if (!next->is_aborted &&
    78f4:	f890 3020 	ldrb.w	r3, [r0, #32]
    78f8:	f013 0f02 	tst.w	r3, #2
    78fc:	d1f5      	bne.n	78ea <lll_disable+0x62>
    78fe:	2c00      	cmp	r4, #0
    7900:	d0ea      	beq.n	78d8 <lll_disable+0x50>
			    (!param || (param == next->prepare_param.param))) {
    7902:	68c3      	ldr	r3, [r0, #12]
    7904:	42a3      	cmp	r3, r4
    7906:	d1f0      	bne.n	78ea <lll_disable+0x62>
    7908:	e7e6      	b.n	78d8 <lll_disable+0x50>
}
    790a:	b002      	add	sp, #8
    790c:	bd10      	pop	{r4, pc}
    790e:	bf00      	nop
    7910:	20004c18 	.word	0x20004c18
    7914:	0001292c 	.word	0x0001292c
    7918:	00012a18 	.word	0x00012a18
    791c:	00011fec 	.word	0x00011fec

00007920 <lll_done>:
{
    7920:	b510      	push	{r4, lr}
    7922:	4604      	mov	r4, r0
	struct lll_event *next = ull_prepare_dequeue_get();
    7924:	f7ff f9fa 	bl	6d1c <ull_prepare_dequeue_get>
	LL_ASSERT(!param || next);
    7928:	b104      	cbz	r4, 792c <lll_done+0xc>
    792a:	b140      	cbz	r0, 793e <lll_done+0x1e>
	if (!param) {
    792c:	b1ac      	cbz	r4, 795a <lll_done+0x3a>
		ull = HDR_ULL(((struct lll_hdr *)param)->parent);
    792e:	6820      	ldr	r0, [r4, #0]
    7930:	3010      	adds	r0, #16
	evdone = ull_event_done(ull);
    7932:	f7ff fb1b 	bl	6f6c <ull_event_done>
	LL_ASSERT(evdone);
    7936:	2800      	cmp	r0, #0
    7938:	d02a      	beq.n	7990 <lll_done+0x70>
}
    793a:	2000      	movs	r0, #0
    793c:	bd10      	pop	{r4, pc}
	LL_ASSERT(!param || next);
    793e:	f44f 7391 	mov.w	r3, #290	; 0x122
    7942:	4a1a      	ldr	r2, [pc, #104]	; (79ac <lll_done+0x8c>)
    7944:	491a      	ldr	r1, [pc, #104]	; (79b0 <lll_done+0x90>)
    7946:	481b      	ldr	r0, [pc, #108]	; (79b4 <lll_done+0x94>)
    7948:	f005 fb71 	bl	d02e <printk>
    794c:	4040      	eors	r0, r0
    794e:	f380 8811 	msr	BASEPRI, r0
    7952:	f04f 0003 	mov.w	r0, #3
    7956:	df02      	svc	2
    7958:	e7e8      	b.n	792c <lll_done+0xc>
		LL_ASSERT(event.curr.abort_cb);
    795a:	4b17      	ldr	r3, [pc, #92]	; (79b8 <lll_done+0x98>)
    795c:	689b      	ldr	r3, [r3, #8]
    795e:	b14b      	cbz	r3, 7974 <lll_done+0x54>
		event.curr.abort_cb = NULL;
    7960:	4b15      	ldr	r3, [pc, #84]	; (79b8 <lll_done+0x98>)
    7962:	2200      	movs	r2, #0
    7964:	609a      	str	r2, [r3, #8]
		param = event.curr.param;
    7966:	6818      	ldr	r0, [r3, #0]
		event.curr.param = NULL;
    7968:	601a      	str	r2, [r3, #0]
		if (param) {
    796a:	2800      	cmp	r0, #0
    796c:	d0e1      	beq.n	7932 <lll_done+0x12>
			ull = HDR_ULL(((struct lll_hdr *)param)->parent);
    796e:	6800      	ldr	r0, [r0, #0]
    7970:	3010      	adds	r0, #16
    7972:	e7de      	b.n	7932 <lll_done+0x12>
		LL_ASSERT(event.curr.abort_cb);
    7974:	f240 1327 	movw	r3, #295	; 0x127
    7978:	4a0c      	ldr	r2, [pc, #48]	; (79ac <lll_done+0x8c>)
    797a:	4910      	ldr	r1, [pc, #64]	; (79bc <lll_done+0x9c>)
    797c:	480d      	ldr	r0, [pc, #52]	; (79b4 <lll_done+0x94>)
    797e:	f005 fb56 	bl	d02e <printk>
    7982:	4040      	eors	r0, r0
    7984:	f380 8811 	msr	BASEPRI, r0
    7988:	f04f 0003 	mov.w	r0, #3
    798c:	df02      	svc	2
    798e:	e7e7      	b.n	7960 <lll_done+0x40>
	LL_ASSERT(evdone);
    7990:	f240 133f 	movw	r3, #319	; 0x13f
    7994:	4a05      	ldr	r2, [pc, #20]	; (79ac <lll_done+0x8c>)
    7996:	490a      	ldr	r1, [pc, #40]	; (79c0 <lll_done+0xa0>)
    7998:	4806      	ldr	r0, [pc, #24]	; (79b4 <lll_done+0x94>)
    799a:	f005 fb48 	bl	d02e <printk>
    799e:	4040      	eors	r0, r0
    79a0:	f380 8811 	msr	BASEPRI, r0
    79a4:	f04f 0003 	mov.w	r0, #3
    79a8:	df02      	svc	2
    79aa:	e7c6      	b.n	793a <lll_done+0x1a>
    79ac:	0001292c 	.word	0x0001292c
    79b0:	00012a20 	.word	0x00012a20
    79b4:	00011fec 	.word	0x00011fec
    79b8:	20004c18 	.word	0x20004c18
    79bc:	00012a30 	.word	0x00012a30
    79c0:	00012a44 	.word	0x00012a44

000079c4 <lll_is_done>:
	return !event.curr.abort_cb;
    79c4:	4b02      	ldr	r3, [pc, #8]	; (79d0 <lll_is_done+0xc>)
    79c6:	6898      	ldr	r0, [r3, #8]
}
    79c8:	fab0 f080 	clz	r0, r0
    79cc:	0940      	lsrs	r0, r0, #5
    79ce:	4770      	bx	lr
    79d0:	20004c18 	.word	0x20004c18

000079d4 <lll_chan_set>:
{
    79d4:	b510      	push	{r4, lr}
    79d6:	4604      	mov	r4, r0
	switch (chan) {
    79d8:	2826      	cmp	r0, #38	; 0x26
    79da:	d013      	beq.n	7a04 <lll_chan_set+0x30>
    79dc:	2827      	cmp	r0, #39	; 0x27
    79de:	d015      	beq.n	7a0c <lll_chan_set+0x38>
    79e0:	2825      	cmp	r0, #37	; 0x25
    79e2:	d008      	beq.n	79f6 <lll_chan_set+0x22>
		if (chan < 11) {
    79e4:	280a      	cmp	r0, #10
    79e6:	d915      	bls.n	7a14 <lll_chan_set+0x40>
		} else if (chan < 40) {
    79e8:	2827      	cmp	r0, #39	; 0x27
    79ea:	d818      	bhi.n	7a1e <lll_chan_set+0x4a>
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
    79ec:	3003      	adds	r0, #3
    79ee:	0040      	lsls	r0, r0, #1
    79f0:	f000 fd70 	bl	84d4 <radio_freq_chan_set>
    79f4:	e002      	b.n	79fc <lll_chan_set+0x28>
		radio_freq_chan_set(2);
    79f6:	2002      	movs	r0, #2
    79f8:	f000 fd6c 	bl	84d4 <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
    79fc:	4620      	mov	r0, r4
    79fe:	f000 fd6f 	bl	84e0 <radio_whiten_iv_set>
}
    7a02:	bd10      	pop	{r4, pc}
		radio_freq_chan_set(26);
    7a04:	201a      	movs	r0, #26
    7a06:	f000 fd65 	bl	84d4 <radio_freq_chan_set>
		break;
    7a0a:	e7f7      	b.n	79fc <lll_chan_set+0x28>
		radio_freq_chan_set(80);
    7a0c:	2050      	movs	r0, #80	; 0x50
    7a0e:	f000 fd61 	bl	84d4 <radio_freq_chan_set>
		break;
    7a12:	e7f3      	b.n	79fc <lll_chan_set+0x28>
			radio_freq_chan_set(4 + (chan * 2U));
    7a14:	3002      	adds	r0, #2
    7a16:	0040      	lsls	r0, r0, #1
    7a18:	f000 fd5c 	bl	84d4 <radio_freq_chan_set>
    7a1c:	e7ee      	b.n	79fc <lll_chan_set+0x28>
			LL_ASSERT(0);
    7a1e:	f240 138d 	movw	r3, #397	; 0x18d
    7a22:	4a06      	ldr	r2, [pc, #24]	; (7a3c <lll_chan_set+0x68>)
    7a24:	4906      	ldr	r1, [pc, #24]	; (7a40 <lll_chan_set+0x6c>)
    7a26:	4807      	ldr	r0, [pc, #28]	; (7a44 <lll_chan_set+0x70>)
    7a28:	f005 fb01 	bl	d02e <printk>
    7a2c:	4040      	eors	r0, r0
    7a2e:	f380 8811 	msr	BASEPRI, r0
    7a32:	f04f 0003 	mov.w	r0, #3
    7a36:	df02      	svc	2
    7a38:	e7e0      	b.n	79fc <lll_chan_set+0x28>
    7a3a:	bf00      	nop
    7a3c:	0001292c 	.word	0x0001292c
    7a40:	00010df0 	.word	0x00010df0
    7a44:	00011fec 	.word	0x00011fec

00007a48 <lll_clock_init>:
			void *user_data);

static struct device *dev;

int lll_clock_init(void)
{
    7a48:	b508      	push	{r3, lr}
    7a4a:	4807      	ldr	r0, [pc, #28]	; (7a68 <lll_clock_init+0x20>)
    7a4c:	f002 fc3c 	bl	a2c8 <z_impl_device_get_binding>
	int err;

	dev = device_get_binding(DT_LABEL(DT_INST(0, nordic_nrf_clock)));
    7a50:	4b06      	ldr	r3, [pc, #24]	; (7a6c <lll_clock_init+0x24>)
    7a52:	6018      	str	r0, [r3, #0]
	if (!dev) {
    7a54:	b120      	cbz	r0, 7a60 <lll_clock_init+0x18>
	const struct clock_control_driver_api *api =
    7a56:	6883      	ldr	r3, [r0, #8]
	return api->on(dev, sys);
    7a58:	681b      	ldr	r3, [r3, #0]
    7a5a:	2101      	movs	r1, #1
    7a5c:	4798      	blx	r3
	}

	err = clock_control_on(dev, CLOCK_CONTROL_NRF_SUBSYS_LF);

	return err;
}
    7a5e:	bd08      	pop	{r3, pc}
		return -ENODEV;
    7a60:	f06f 0012 	mvn.w	r0, #18
    7a64:	e7fb      	b.n	7a5e <lll_clock_init+0x16>
    7a66:	bf00      	nop
    7a68:	00011798 	.word	0x00011798
    7a6c:	20004c2c 	.word	0x20004c2c

00007a70 <lll_hfclock_on>:

	return err;
}

int lll_hfclock_on(void)
{
    7a70:	b508      	push	{r3, lr}
	int err;

	/* turn on radio clock in non-blocking mode. */
	err = clock_control_on(dev, CLOCK_CONTROL_NRF_SUBSYS_HF);
    7a72:	4b03      	ldr	r3, [pc, #12]	; (7a80 <lll_hfclock_on+0x10>)
    7a74:	6818      	ldr	r0, [r3, #0]
	const struct clock_control_driver_api *api =
    7a76:	6883      	ldr	r3, [r0, #8]
	return api->on(dev, sys);
    7a78:	681b      	ldr	r3, [r3, #0]
    7a7a:	2100      	movs	r1, #0
    7a7c:	4798      	blx	r3
	if (!err || err == -EINPROGRESS) {
		DEBUG_RADIO_XTAL(1);
	}

	return err;
}
    7a7e:	bd08      	pop	{r3, pc}
    7a80:	20004c2c 	.word	0x20004c2c

00007a84 <lll_hfclock_off>:

	return err;
}

int lll_hfclock_off(void)
{
    7a84:	b508      	push	{r3, lr}
	int err;

	/* turn off radio clock in non-blocking mode. */
	err = clock_control_off(dev, CLOCK_CONTROL_NRF_SUBSYS_HF);
    7a86:	4b03      	ldr	r3, [pc, #12]	; (7a94 <lll_hfclock_off+0x10>)
    7a88:	6818      	ldr	r0, [r3, #0]
 * @return 0 on success, negative errno on failure.
 */
static inline int clock_control_off(struct device *dev,
				    clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
    7a8a:	6883      	ldr	r3, [r0, #8]
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->off(dev, sys);
    7a8c:	685b      	ldr	r3, [r3, #4]
    7a8e:	2100      	movs	r1, #0
    7a90:	4798      	blx	r3
	} else if (err == -EBUSY) {
		DEBUG_RADIO_XTAL(1);
	}

	return err;
}
    7a92:	bd08      	pop	{r3, pc}
    7a94:	20004c2c 	.word	0x20004c2c

00007a98 <ticker_op_start_cb>:

static void ticker_op_start_cb(u32_t status, void *param)
{
	ARG_UNUSED(param);

	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
    7a98:	b900      	cbnz	r0, 7a9c <ticker_op_start_cb+0x4>
    7a9a:	4770      	bx	lr
{
    7a9c:	b508      	push	{r3, lr}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
    7a9e:	f44f 73c3 	mov.w	r3, #390	; 0x186
    7aa2:	4a06      	ldr	r2, [pc, #24]	; (7abc <ticker_op_start_cb+0x24>)
    7aa4:	4906      	ldr	r1, [pc, #24]	; (7ac0 <ticker_op_start_cb+0x28>)
    7aa6:	4807      	ldr	r0, [pc, #28]	; (7ac4 <ticker_op_start_cb+0x2c>)
    7aa8:	f005 fac1 	bl	d02e <printk>
    7aac:	4040      	eors	r0, r0
    7aae:	f380 8811 	msr	BASEPRI, r0
    7ab2:	f04f 0003 	mov.w	r0, #3
    7ab6:	df02      	svc	2
}
    7ab8:	bd08      	pop	{r3, pc}
    7aba:	bf00      	nop
    7abc:	00012a6c 	.word	0x00012a6c
    7ac0:	00012af0 	.word	0x00012af0
    7ac4:	00011fec 	.word	0x00011fec

00007ac8 <ticker_stop_cb>:
{
    7ac8:	b508      	push	{r3, lr}
	radio_isr_set(isr_cleanup, param);
    7aca:	4619      	mov	r1, r3
    7acc:	4802      	ldr	r0, [pc, #8]	; (7ad8 <ticker_stop_cb+0x10>)
    7ace:	f000 fcaf 	bl	8430 <radio_isr_set>
	radio_disable();
    7ad2:	f000 fd6f 	bl	85b4 <radio_disable>
}
    7ad6:	bd08      	pop	{r3, pc}
    7ad8:	00007d95 	.word	0x00007d95

00007adc <abort_cb>:
{
    7adc:	b510      	push	{r4, lr}
    7ade:	460c      	mov	r4, r1
	if (!prepare_param) {
    7ae0:	b148      	cbz	r0, 7af6 <abort_cb+0x1a>
	err = lll_hfclock_off();
    7ae2:	f7ff ffcf 	bl	7a84 <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
    7ae6:	b110      	cbz	r0, 7aee <abort_cb+0x12>
    7ae8:	f110 0f10 	cmn.w	r0, #16
    7aec:	d109      	bne.n	7b02 <abort_cb+0x26>
	lll_done(param);
    7aee:	4620      	mov	r0, r4
    7af0:	f7ff ff16 	bl	7920 <lll_done>
}
    7af4:	bd10      	pop	{r4, pc}
			radio_isr_set(isr_abort, param);
    7af6:	480a      	ldr	r0, [pc, #40]	; (7b20 <abort_cb+0x44>)
    7af8:	f000 fc9a 	bl	8430 <radio_isr_set>
			radio_disable();
    7afc:	f000 fd5a 	bl	85b4 <radio_disable>
		return;
    7b00:	e7f8      	b.n	7af4 <abort_cb+0x18>
	LL_ASSERT(!err || err == -EBUSY);
    7b02:	f44f 73bb 	mov.w	r3, #374	; 0x176
    7b06:	4a07      	ldr	r2, [pc, #28]	; (7b24 <abort_cb+0x48>)
    7b08:	4907      	ldr	r1, [pc, #28]	; (7b28 <abort_cb+0x4c>)
    7b0a:	4808      	ldr	r0, [pc, #32]	; (7b2c <abort_cb+0x50>)
    7b0c:	f005 fa8f 	bl	d02e <printk>
    7b10:	4040      	eors	r0, r0
    7b12:	f380 8811 	msr	BASEPRI, r0
    7b16:	f04f 0003 	mov.w	r0, #3
    7b1a:	df02      	svc	2
    7b1c:	e7e7      	b.n	7aee <abort_cb+0x12>
    7b1e:	bf00      	nop
    7b20:	0000f131 	.word	0x0000f131
    7b24:	00012a6c 	.word	0x00012a6c
    7b28:	00012afc 	.word	0x00012afc
    7b2c:	00011fec 	.word	0x00011fec

00007b30 <is_abort_cb>:
{
    7b30:	b510      	push	{r4, lr}
	if (next != curr) {
    7b32:	4282      	cmp	r2, r0
    7b34:	d119      	bne.n	7b6a <is_abort_cb+0x3a>
    7b36:	4614      	mov	r4, r2
	radio_isr_set(isr_window, lll);
    7b38:	4611      	mov	r1, r2
    7b3a:	481c      	ldr	r0, [pc, #112]	; (7bac <is_abort_cb+0x7c>)
    7b3c:	f000 fc78 	bl	8430 <radio_isr_set>
	radio_disable();
    7b40:	f000 fd38 	bl	85b4 <radio_disable>
}

static inline void chan_prepare(struct lll_scan *lll)
{
	if (!IS_ENABLED(CONFIG_BT_CTLR_DFE_ADV_SINGLE_CHANNEL_MODE)) {
		if (++lll->chan == 3U) {
    7b44:	7a22      	ldrb	r2, [r4, #8]
    7b46:	f3c2 0341 	ubfx	r3, r2, #1, #2
    7b4a:	3301      	adds	r3, #1
    7b4c:	f003 0303 	and.w	r3, r3, #3
    7b50:	f363 0242 	bfi	r2, r3, #1, #2
    7b54:	7222      	strb	r2, [r4, #8]
    7b56:	2b03      	cmp	r3, #3
    7b58:	d023      	beq.n	7ba2 <is_abort_cb+0x72>
		lll_chan_set(37 + lll->chan);
    7b5a:	7a20      	ldrb	r0, [r4, #8]
    7b5c:	f3c0 0041 	ubfx	r0, r0, #1, #2
    7b60:	3025      	adds	r0, #37	; 0x25
    7b62:	f7ff ff37 	bl	79d4 <lll_chan_set>
	return 0;
    7b66:	2000      	movs	r0, #0
}
    7b68:	bd10      	pop	{r4, pc}
		*resume_cb = resume_prepare_cb;
    7b6a:	4a11      	ldr	r2, [pc, #68]	; (7bb0 <is_abort_cb+0x80>)
    7b6c:	601a      	str	r2, [r3, #0]
		*resume_prio = 0; /* TODO: */
    7b6e:	9b02      	ldr	r3, [sp, #8]
    7b70:	2200      	movs	r2, #0
    7b72:	601a      	str	r2, [r3, #0]
		err = lll_hfclock_on();
    7b74:	f7ff ff7c 	bl	7a70 <lll_hfclock_on>
		LL_ASSERT(!err || err == -EINPROGRESS);
    7b78:	b110      	cbz	r0, 7b80 <is_abort_cb+0x50>
    7b7a:	f110 0f77 	cmn.w	r0, #119	; 0x77
    7b7e:	d102      	bne.n	7b86 <is_abort_cb+0x56>
		return -EAGAIN;
    7b80:	f06f 000a 	mvn.w	r0, #10
    7b84:	e7f0      	b.n	7b68 <is_abort_cb+0x38>
		LL_ASSERT(!err || err == -EINPROGRESS);
    7b86:	f240 1345 	movw	r3, #325	; 0x145
    7b8a:	4a0a      	ldr	r2, [pc, #40]	; (7bb4 <is_abort_cb+0x84>)
    7b8c:	490a      	ldr	r1, [pc, #40]	; (7bb8 <is_abort_cb+0x88>)
    7b8e:	480b      	ldr	r0, [pc, #44]	; (7bbc <is_abort_cb+0x8c>)
    7b90:	f005 fa4d 	bl	d02e <printk>
    7b94:	4040      	eors	r0, r0
    7b96:	f380 8811 	msr	BASEPRI, r0
    7b9a:	f04f 0003 	mov.w	r0, #3
    7b9e:	df02      	svc	2
    7ba0:	e7ee      	b.n	7b80 <is_abort_cb+0x50>
				lll->chan = 0U;
    7ba2:	b2d3      	uxtb	r3, r2
    7ba4:	f36f 0342 	bfc	r3, #1, #2
    7ba8:	7223      	strb	r3, [r4, #8]
    7baa:	e7d6      	b.n	7b5a <is_abort_cb+0x2a>
    7bac:	0000f1dd 	.word	0x0000f1dd
    7bb0:	0000f1b7 	.word	0x0000f1b7
    7bb4:	00012a6c 	.word	0x00012a6c
    7bb8:	00012b10 	.word	0x00012b10
    7bbc:	00011fec 	.word	0x00011fec

00007bc0 <prepare_cb>:
{
    7bc0:	b5f0      	push	{r4, r5, r6, r7, lr}
    7bc2:	b08d      	sub	sp, #52	; 0x34
	struct lll_scan *lll = prepare_param->param;
    7bc4:	68c4      	ldr	r4, [r0, #12]
	u32_t aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
    7bc6:	4b67      	ldr	r3, [pc, #412]	; (7d64 <prepare_cb+0x1a4>)
    7bc8:	930b      	str	r3, [sp, #44]	; 0x2c

static inline int lll_is_stop(void *lll)
{
	struct lll_hdr *hdr = lll;

	return !!hdr->is_stop;
    7bca:	7923      	ldrb	r3, [r4, #4]
	if (lll_is_stop(lll)) {
    7bcc:	f013 0f01 	tst.w	r3, #1
    7bd0:	d16c      	bne.n	7cac <prepare_cb+0xec>
    7bd2:	4605      	mov	r5, r0
	radio_reset();
    7bd4:	f000 fc4c 	bl	8470 <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
    7bd8:	2000      	movs	r0, #0
    7bda:	f000 fc75 	bl	84c8 <radio_tx_power_set>
	radio_phy_set(0, 0);
    7bde:	2100      	movs	r1, #0
    7be0:	4608      	mov	r0, r1
    7be2:	f000 fc5d 	bl	84a0 <radio_phy_set>
	radio_pkt_configure(8, PDU_AC_PAYLOAD_SIZE_MAX, 0);
    7be6:	2200      	movs	r2, #0
    7be8:	2125      	movs	r1, #37	; 0x25
    7bea:	2008      	movs	r0, #8
    7bec:	f000 fca2 	bl	8534 <radio_pkt_configure>
	node_rx = ull_pdu_rx_alloc_peek(1);
    7bf0:	2001      	movs	r0, #1
    7bf2:	f7ff f809 	bl	6c08 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    7bf6:	4606      	mov	r6, r0
    7bf8:	2800      	cmp	r0, #0
    7bfa:	d070      	beq.n	7cde <prepare_cb+0x11e>
	radio_pkt_rx_set(node_rx->pdu);
    7bfc:	f106 00b4 	add.w	r0, r6, #180	; 0xb4
    7c00:	f000 fcc6 	bl	8590 <radio_pkt_rx_set>
	dfe_packet_buffer_set(node_rx);
    7c04:	4630      	mov	r0, r6
    7c06:	f007 f9db 	bl	efc0 <dfe_packet_buffer_set>
	dfe_init_scan_rx();
    7c0a:	f7ff fb71 	bl	72f0 <dfe_init_scan_rx>
	radio_aa_set((u8_t *)&aa);
    7c0e:	a80b      	add	r0, sp, #44	; 0x2c
    7c10:	f000 fc78 	bl	8504 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
    7c14:	4954      	ldr	r1, [pc, #336]	; (7d68 <prepare_cb+0x1a8>)
    7c16:	f240 605b 	movw	r0, #1627	; 0x65b
    7c1a:	f000 fd1f 	bl	865c <radio_crc_configure>
		lll_chan_set(37 + lll->chan);
    7c1e:	7a20      	ldrb	r0, [r4, #8]
    7c20:	f3c0 0041 	ubfx	r0, r0, #1, #2
    7c24:	3025      	adds	r0, #37	; 0x25
    7c26:	f7ff fed5 	bl	79d4 <lll_chan_set>
	radio_isr_set(isr_rx, lll);
    7c2a:	4621      	mov	r1, r4
    7c2c:	484f      	ldr	r0, [pc, #316]	; (7d6c <prepare_cb+0x1ac>)
    7c2e:	f000 fbff 	bl	8430 <radio_isr_set>
	radio_tmr_tifs_set(EVENT_IFS_US);
    7c32:	2096      	movs	r0, #150	; 0x96
    7c34:	f000 fde2 	bl	87fc <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
    7c38:	2300      	movs	r3, #0
    7c3a:	461a      	mov	r2, r3
    7c3c:	4619      	mov	r1, r3
    7c3e:	4618      	mov	r0, r3
    7c40:	f000 fd3a 	bl	86b8 <radio_switch_complete_and_tx>
	if (IS_ENABLED(CONFIG_BT_CTLR_FILTER) && lll->filter_policy) {
    7c44:	7a23      	ldrb	r3, [r4, #8]
    7c46:	f013 0f18 	tst.w	r3, #24
    7c4a:	d155      	bne.n	7cf8 <prepare_cb+0x138>
	ticks_at_event = prepare_param->ticks_at_expire;
    7c4c:	682e      	ldr	r6, [r5, #0]
	evt = HDR_LLL2EVT(lll);
    7c4e:	6827      	ldr	r7, [r4, #0]
	ticks_at_event += lll_evt_offset_get(evt);
    7c50:	4638      	mov	r0, r7
    7c52:	f007 fa48 	bl	f0e6 <lll_evt_offset_get>
    7c56:	4406      	add	r6, r0
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
    7c58:	686a      	ldr	r2, [r5, #4]
    7c5a:	f106 0109 	add.w	r1, r6, #9
    7c5e:	2000      	movs	r0, #0
    7c60:	f000 fdd8 	bl	8814 <radio_tmr_start>
	radio_tmr_end_capture();
    7c64:	f000 fea6 	bl	89b4 <radio_tmr_end_capture>
	radio_rssi_measure();
    7c68:	f000 fd3a 	bl	86e0 <radio_rssi_measure>
				   ull_scan_lll_handle_get(lll)),
    7c6c:	4620      	mov	r0, r4
    7c6e:	f007 f907 	bl	ee80 <ull_scan_lll_handle_get>
	if (lll_preempt_calc(evt, (TICKER_ID_SCAN_BASE +
    7c72:	1c81      	adds	r1, r0, #2
    7c74:	4632      	mov	r2, r6
    7c76:	b2c9      	uxtb	r1, r1
    7c78:	4638      	mov	r0, r7
    7c7a:	f007 fa42 	bl	f102 <lll_preempt_calc>
    7c7e:	2800      	cmp	r0, #0
    7c80:	d143      	bne.n	7d0a <prepare_cb+0x14a>
		if (lll->ticks_window) {
    7c82:	69a3      	ldr	r3, [r4, #24]
    7c84:	2b00      	cmp	r3, #0
    7c86:	d147      	bne.n	7d18 <prepare_cb+0x158>
		ret = lll_prepare_done(lll);
    7c88:	4620      	mov	r0, r4
    7c8a:	f007 fa2a 	bl	f0e2 <lll_prepare_done>
		LL_ASSERT(!ret);
    7c8e:	b1b0      	cbz	r0, 7cbe <prepare_cb+0xfe>
    7c90:	f240 1323 	movw	r3, #291	; 0x123
    7c94:	4a36      	ldr	r2, [pc, #216]	; (7d70 <prepare_cb+0x1b0>)
    7c96:	4937      	ldr	r1, [pc, #220]	; (7d74 <prepare_cb+0x1b4>)
    7c98:	4837      	ldr	r0, [pc, #220]	; (7d78 <prepare_cb+0x1b8>)
    7c9a:	f005 f9c8 	bl	d02e <printk>
    7c9e:	4040      	eors	r0, r0
    7ca0:	f380 8811 	msr	BASEPRI, r0
    7ca4:	f04f 0003 	mov.w	r0, #3
    7ca8:	df02      	svc	2
    7caa:	e008      	b.n	7cbe <prepare_cb+0xfe>
		err = lll_hfclock_off();
    7cac:	f7ff feea 	bl	7a84 <lll_hfclock_off>
		LL_ASSERT(!err || err == -EBUSY);
    7cb0:	b110      	cbz	r0, 7cb8 <prepare_cb+0xf8>
    7cb2:	f110 0f10 	cmn.w	r0, #16
    7cb6:	d105      	bne.n	7cc4 <prepare_cb+0x104>
		lll_done(NULL);
    7cb8:	2000      	movs	r0, #0
    7cba:	f7ff fe31 	bl	7920 <lll_done>
}
    7cbe:	2000      	movs	r0, #0
    7cc0:	b00d      	add	sp, #52	; 0x34
    7cc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LL_ASSERT(!err || err == -EBUSY);
    7cc4:	2397      	movs	r3, #151	; 0x97
    7cc6:	4a2a      	ldr	r2, [pc, #168]	; (7d70 <prepare_cb+0x1b0>)
    7cc8:	492c      	ldr	r1, [pc, #176]	; (7d7c <prepare_cb+0x1bc>)
    7cca:	482b      	ldr	r0, [pc, #172]	; (7d78 <prepare_cb+0x1b8>)
    7ccc:	f005 f9af 	bl	d02e <printk>
    7cd0:	4040      	eors	r0, r0
    7cd2:	f380 8811 	msr	BASEPRI, r0
    7cd6:	f04f 0003 	mov.w	r0, #3
    7cda:	df02      	svc	2
    7cdc:	e7ec      	b.n	7cb8 <prepare_cb+0xf8>
	LL_ASSERT(node_rx);
    7cde:	23b4      	movs	r3, #180	; 0xb4
    7ce0:	4a23      	ldr	r2, [pc, #140]	; (7d70 <prepare_cb+0x1b0>)
    7ce2:	4927      	ldr	r1, [pc, #156]	; (7d80 <prepare_cb+0x1c0>)
    7ce4:	4824      	ldr	r0, [pc, #144]	; (7d78 <prepare_cb+0x1b8>)
    7ce6:	f005 f9a2 	bl	d02e <printk>
    7cea:	4040      	eors	r0, r0
    7cec:	f380 8811 	msr	BASEPRI, r0
    7cf0:	f04f 0003 	mov.w	r0, #3
    7cf4:	df02      	svc	2
    7cf6:	e781      	b.n	7bfc <prepare_cb+0x3c>
		struct lll_filter *wl = ull_filter_lll_get(true);
    7cf8:	2001      	movs	r0, #1
    7cfa:	f7ff fba3 	bl	7444 <ull_filter_lll_get>
		radio_filter_configure(wl->enable_bitmask,
    7cfe:	1c82      	adds	r2, r0, #2
    7d00:	7841      	ldrb	r1, [r0, #1]
    7d02:	7800      	ldrb	r0, [r0, #0]
    7d04:	f000 fd0e 	bl	8724 <radio_filter_configure>
    7d08:	e7a0      	b.n	7c4c <prepare_cb+0x8c>
		radio_isr_set(isr_abort, lll);
    7d0a:	4621      	mov	r1, r4
    7d0c:	481d      	ldr	r0, [pc, #116]	; (7d84 <prepare_cb+0x1c4>)
    7d0e:	f000 fb8f 	bl	8430 <radio_isr_set>
		radio_disable();
    7d12:	f000 fc4f 	bl	85b4 <radio_disable>
    7d16:	e7d2      	b.n	7cbe <prepare_cb+0xfe>
			ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    7d18:	f240 121d 	movw	r2, #285	; 0x11d
    7d1c:	9208      	str	r2, [sp, #32]
    7d1e:	4a1a      	ldr	r2, [pc, #104]	; (7d88 <prepare_cb+0x1c8>)
    7d20:	9207      	str	r2, [sp, #28]
    7d22:	9406      	str	r4, [sp, #24]
    7d24:	4a19      	ldr	r2, [pc, #100]	; (7d8c <prepare_cb+0x1cc>)
    7d26:	9205      	str	r2, [sp, #20]
    7d28:	2000      	movs	r0, #0
    7d2a:	9004      	str	r0, [sp, #16]
    7d2c:	9003      	str	r0, [sp, #12]
    7d2e:	9002      	str	r0, [sp, #8]
    7d30:	9001      	str	r0, [sp, #4]
    7d32:	9300      	str	r3, [sp, #0]
    7d34:	4633      	mov	r3, r6
    7d36:	2201      	movs	r2, #1
    7d38:	4601      	mov	r1, r0
    7d3a:	f006 fcd0 	bl	e6de <ticker_start>
			LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    7d3e:	2800      	cmp	r0, #0
    7d40:	d0a2      	beq.n	7c88 <prepare_cb+0xc8>
    7d42:	2802      	cmp	r0, #2
    7d44:	d0a0      	beq.n	7c88 <prepare_cb+0xc8>
    7d46:	f44f 738f 	mov.w	r3, #286	; 0x11e
    7d4a:	4a09      	ldr	r2, [pc, #36]	; (7d70 <prepare_cb+0x1b0>)
    7d4c:	4910      	ldr	r1, [pc, #64]	; (7d90 <prepare_cb+0x1d0>)
    7d4e:	480a      	ldr	r0, [pc, #40]	; (7d78 <prepare_cb+0x1b8>)
    7d50:	f005 f96d 	bl	d02e <printk>
    7d54:	4040      	eors	r0, r0
    7d56:	f380 8811 	msr	BASEPRI, r0
    7d5a:	f04f 0003 	mov.w	r0, #3
    7d5e:	df02      	svc	2
    7d60:	e792      	b.n	7c88 <prepare_cb+0xc8>
    7d62:	bf00      	nop
    7d64:	8e89bed6 	.word	0x8e89bed6
    7d68:	00555555 	.word	0x00555555
    7d6c:	00007f4d 	.word	0x00007f4d
    7d70:	00012a6c 	.word	0x00012a6c
    7d74:	000127a0 	.word	0x000127a0
    7d78:	00011fec 	.word	0x00011fec
    7d7c:	00012afc 	.word	0x00012afc
    7d80:	00012b24 	.word	0x00012b24
    7d84:	0000f131 	.word	0x0000f131
    7d88:	00007a99 	.word	0x00007a99
    7d8c:	00007ac9 	.word	0x00007ac9
    7d90:	00012b2c 	.word	0x00012b2c

00007d94 <isr_cleanup>:
{
    7d94:	b510      	push	{r4, lr}
    7d96:	4604      	mov	r4, r0
	if (lll_is_done(param)) {
    7d98:	f7ff fe14 	bl	79c4 <lll_is_done>
    7d9c:	b100      	cbz	r0, 7da0 <isr_cleanup+0xc>
}
    7d9e:	bd10      	pop	{r4, pc}
	radio_filter_disable();
    7da0:	f000 fce8 	bl	8774 <radio_filter_disable>
		if (++lll->chan == 3U) {
    7da4:	7a22      	ldrb	r2, [r4, #8]
    7da6:	f3c2 0341 	ubfx	r3, r2, #1, #2
    7daa:	3301      	adds	r3, #1
    7dac:	f003 0303 	and.w	r3, r3, #3
    7db0:	f363 0242 	bfi	r2, r3, #1, #2
    7db4:	7222      	strb	r2, [r4, #8]
    7db6:	2b03      	cmp	r3, #3
    7db8:	d012      	beq.n	7de0 <isr_cleanup+0x4c>
	radio_isr_set(isr_race, param);
    7dba:	4621      	mov	r1, r4
    7dbc:	4813      	ldr	r0, [pc, #76]	; (7e0c <isr_cleanup+0x78>)
    7dbe:	f000 fb37 	bl	8430 <radio_isr_set>
	if (!radio_is_idle()) {
    7dc2:	f000 fc41 	bl	8648 <radio_is_idle>
    7dc6:	b180      	cbz	r0, 7dea <isr_cleanup+0x56>
	radio_tmr_stop();
    7dc8:	f000 fdda 	bl	8980 <radio_tmr_stop>
	err = lll_hfclock_off();
    7dcc:	f7ff fe5a 	bl	7a84 <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
    7dd0:	b110      	cbz	r0, 7dd8 <isr_cleanup+0x44>
    7dd2:	f110 0f10 	cmn.w	r0, #16
    7dd6:	d10b      	bne.n	7df0 <isr_cleanup+0x5c>
	lll_done(NULL);
    7dd8:	2000      	movs	r0, #0
    7dda:	f7ff fda1 	bl	7920 <lll_done>
    7dde:	e7de      	b.n	7d9e <isr_cleanup+0xa>
				lll->chan = 0U;
    7de0:	b2d3      	uxtb	r3, r2
    7de2:	f36f 0342 	bfc	r3, #1, #2
    7de6:	7223      	strb	r3, [r4, #8]
    7de8:	e7e7      	b.n	7dba <isr_cleanup+0x26>
		radio_disable();
    7dea:	f000 fbe3 	bl	85b4 <radio_disable>
    7dee:	e7eb      	b.n	7dc8 <isr_cleanup+0x34>
	LL_ASSERT(!err || err == -EBUSY);
    7df0:	f240 23b3 	movw	r3, #691	; 0x2b3
    7df4:	4a06      	ldr	r2, [pc, #24]	; (7e10 <isr_cleanup+0x7c>)
    7df6:	4907      	ldr	r1, [pc, #28]	; (7e14 <isr_cleanup+0x80>)
    7df8:	4807      	ldr	r0, [pc, #28]	; (7e18 <isr_cleanup+0x84>)
    7dfa:	f005 f918 	bl	d02e <printk>
    7dfe:	4040      	eors	r0, r0
    7e00:	f380 8811 	msr	BASEPRI, r0
    7e04:	f04f 0003 	mov.w	r0, #3
    7e08:	df02      	svc	2
    7e0a:	e7e5      	b.n	7dd8 <isr_cleanup+0x44>
    7e0c:	0000f129 	.word	0x0000f129
    7e10:	00012a6c 	.word	0x00012a6c
    7e14:	00012afc 	.word	0x00012afc
    7e18:	00011fec 	.word	0x00011fec

00007e1c <isr_common_done>:
{
    7e1c:	b538      	push	{r3, r4, r5, lr}
    7e1e:	4604      	mov	r4, r0
	radio_status_reset();
    7e20:	f000 fbda 	bl	85d8 <radio_status_reset>
	radio_tmr_status_reset();
    7e24:	f000 fcda 	bl	87dc <radio_tmr_status_reset>
	radio_filter_status_reset();
    7e28:	f000 fcae 	bl	8788 <radio_filter_status_reset>
	radio_ar_status_reset();
    7e2c:	f000 fdd6 	bl	89dc <radio_ar_status_reset>
	radio_rssi_status_reset();
    7e30:	f000 fc66 	bl	8700 <radio_rssi_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
    7e34:	2096      	movs	r0, #150	; 0x96
    7e36:	f000 fce1 	bl	87fc <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
    7e3a:	2300      	movs	r3, #0
    7e3c:	461a      	mov	r2, r3
    7e3e:	4619      	mov	r1, r3
    7e40:	4618      	mov	r0, r3
    7e42:	f000 fc39 	bl	86b8 <radio_switch_complete_and_tx>
	node_rx = ull_pdu_rx_alloc_peek(1);
    7e46:	2001      	movs	r0, #1
    7e48:	f7fe fede 	bl	6c08 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    7e4c:	4605      	mov	r5, r0
    7e4e:	b168      	cbz	r0, 7e6c <isr_common_done+0x50>
	radio_pkt_rx_set(node_rx->pdu);
    7e50:	f105 00b4 	add.w	r0, r5, #180	; 0xb4
    7e54:	f000 fb9c 	bl	8590 <radio_pkt_rx_set>
		dfe_packet_buffer_set(node_rx);
    7e58:	4628      	mov	r0, r5
    7e5a:	f007 f8b1 	bl	efc0 <dfe_packet_buffer_set>
	radio_rssi_measure();
    7e5e:	f000 fc3f 	bl	86e0 <radio_rssi_measure>
	radio_isr_set(isr_rx, param);
    7e62:	4621      	mov	r1, r4
    7e64:	4808      	ldr	r0, [pc, #32]	; (7e88 <isr_common_done+0x6c>)
    7e66:	f000 fae3 	bl	8430 <radio_isr_set>
}
    7e6a:	bd38      	pop	{r3, r4, r5, pc}
	LL_ASSERT(node_rx);
    7e6c:	f240 2322 	movw	r3, #546	; 0x222
    7e70:	4a06      	ldr	r2, [pc, #24]	; (7e8c <isr_common_done+0x70>)
    7e72:	4907      	ldr	r1, [pc, #28]	; (7e90 <isr_common_done+0x74>)
    7e74:	4807      	ldr	r0, [pc, #28]	; (7e94 <isr_common_done+0x78>)
    7e76:	f005 f8da 	bl	d02e <printk>
    7e7a:	4040      	eors	r0, r0
    7e7c:	f380 8811 	msr	BASEPRI, r0
    7e80:	f04f 0003 	mov.w	r0, #3
    7e84:	df02      	svc	2
    7e86:	e7e3      	b.n	7e50 <isr_common_done+0x34>
    7e88:	00007f4d 	.word	0x00007f4d
    7e8c:	00012a6c 	.word	0x00012a6c
    7e90:	00012b24 	.word	0x00012b24
    7e94:	00011fec 	.word	0x00011fec

00007e98 <isr_tx>:
{
    7e98:	b538      	push	{r3, r4, r5, lr}
    7e9a:	4605      	mov	r5, r0
	radio_status_reset();
    7e9c:	f000 fb9c 	bl	85d8 <radio_status_reset>
	radio_tmr_status_reset();
    7ea0:	f000 fc9c 	bl	87dc <radio_tmr_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
    7ea4:	2096      	movs	r0, #150	; 0x96
    7ea6:	f000 fca9 	bl	87fc <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
    7eaa:	2300      	movs	r3, #0
    7eac:	461a      	mov	r2, r3
    7eae:	4619      	mov	r1, r3
    7eb0:	4618      	mov	r0, r3
    7eb2:	f000 fc01 	bl	86b8 <radio_switch_complete_and_tx>
	node_rx = ull_pdu_rx_alloc_peek(1);
    7eb6:	2001      	movs	r0, #1
    7eb8:	f7fe fea6 	bl	6c08 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    7ebc:	4604      	mov	r4, r0
    7ebe:	b1f0      	cbz	r0, 7efe <isr_tx+0x66>
	radio_pkt_rx_set(node_rx->pdu);
    7ec0:	f104 00b4 	add.w	r0, r4, #180	; 0xb4
    7ec4:	f000 fb64 	bl	8590 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
    7ec8:	f000 fb92 	bl	85f0 <radio_is_ready>
    7ecc:	bb28      	cbnz	r0, 7f1a <isr_tx+0x82>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
    7ece:	f007 f9c3 	bl	f258 <radio_tmr_tifs_base_get>
    7ed2:	f100 049b 	add.w	r4, r0, #155	; 0x9b
	hcto += radio_rx_chain_delay_get(0, 0);
    7ed6:	2100      	movs	r1, #0
    7ed8:	4608      	mov	r0, r1
    7eda:	f007 f9b7 	bl	f24c <radio_rx_chain_delay_get>
    7ede:	4404      	add	r4, r0
	hcto += addr_us_get(0);
    7ee0:	3428      	adds	r4, #40	; 0x28
	hcto -= radio_tx_chain_delay_get(0, 0);
    7ee2:	2100      	movs	r1, #0
    7ee4:	4608      	mov	r0, r1
    7ee6:	f007 f9af 	bl	f248 <radio_tx_chain_delay_get>
	radio_tmr_hcto_configure(hcto);
    7eea:	1a20      	subs	r0, r4, r0
    7eec:	f000 fd56 	bl	899c <radio_tmr_hcto_configure>
	radio_rssi_measure();
    7ef0:	f000 fbf6 	bl	86e0 <radio_rssi_measure>
	radio_isr_set(isr_rx, param);
    7ef4:	4629      	mov	r1, r5
    7ef6:	4810      	ldr	r0, [pc, #64]	; (7f38 <isr_tx+0xa0>)
    7ef8:	f000 fa9a 	bl	8430 <radio_isr_set>
}
    7efc:	bd38      	pop	{r3, r4, r5, pc}
	LL_ASSERT(node_rx);
    7efe:	f240 13e9 	movw	r3, #489	; 0x1e9
    7f02:	4a0e      	ldr	r2, [pc, #56]	; (7f3c <isr_tx+0xa4>)
    7f04:	490e      	ldr	r1, [pc, #56]	; (7f40 <isr_tx+0xa8>)
    7f06:	480f      	ldr	r0, [pc, #60]	; (7f44 <isr_tx+0xac>)
    7f08:	f005 f891 	bl	d02e <printk>
    7f0c:	4040      	eors	r0, r0
    7f0e:	f380 8811 	msr	BASEPRI, r0
    7f12:	f04f 0003 	mov.w	r0, #3
    7f16:	df02      	svc	2
    7f18:	e7d2      	b.n	7ec0 <isr_tx+0x28>
	LL_ASSERT(!radio_is_ready());
    7f1a:	f240 13ed 	movw	r3, #493	; 0x1ed
    7f1e:	4a07      	ldr	r2, [pc, #28]	; (7f3c <isr_tx+0xa4>)
    7f20:	4909      	ldr	r1, [pc, #36]	; (7f48 <isr_tx+0xb0>)
    7f22:	4808      	ldr	r0, [pc, #32]	; (7f44 <isr_tx+0xac>)
    7f24:	f005 f883 	bl	d02e <printk>
    7f28:	4040      	eors	r0, r0
    7f2a:	f380 8811 	msr	BASEPRI, r0
    7f2e:	f04f 0003 	mov.w	r0, #3
    7f32:	df02      	svc	2
    7f34:	e7cb      	b.n	7ece <isr_tx+0x36>
    7f36:	bf00      	nop
    7f38:	00007f4d 	.word	0x00007f4d
    7f3c:	00012a6c 	.word	0x00012a6c
    7f40:	00012b24 	.word	0x00012b24
    7f44:	00011fec 	.word	0x00011fec
    7f48:	00012b48 	.word	0x00012b48

00007f4c <isr_rx>:
{
    7f4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7f50:	4605      	mov	r5, r0
	trx_done = radio_is_done();
    7f52:	f000 fb57 	bl	8604 <radio_is_done>
	if (trx_done) {
    7f56:	f010 04ff 	ands.w	r4, r0, #255	; 0xff
    7f5a:	d115      	bne.n	7f88 <isr_rx+0x3c>
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready = 0U;
    7f5c:	46a0      	mov	r8, r4
    7f5e:	4627      	mov	r7, r4
    7f60:	4626      	mov	r6, r4
	radio_status_reset();
    7f62:	f000 fb39 	bl	85d8 <radio_status_reset>
	radio_tmr_status_reset();
    7f66:	f000 fc39 	bl	87dc <radio_tmr_status_reset>
	radio_filter_status_reset();
    7f6a:	f000 fc0d 	bl	8788 <radio_filter_status_reset>
	radio_ar_status_reset();
    7f6e:	f000 fd35 	bl	89dc <radio_ar_status_reset>
	radio_rssi_status_reset();
    7f72:	f000 fbc5 	bl	8700 <radio_rssi_status_reset>
	if (!trx_done) {
    7f76:	b1dc      	cbz	r4, 7fb0 <isr_rx+0x64>
	if (crc_ok && isr_rx_scan_check(lll, irkmatch_ok, devmatch_ok,
    7f78:	b1d6      	cbz	r6, 7fb0 <isr_rx+0x64>
	return ((lll->filter_policy & 0x01) == 0U) ||
    7f7a:	7a2b      	ldrb	r3, [r5, #8]
    7f7c:	f013 0f08 	tst.w	r3, #8
    7f80:	d013      	beq.n	7faa <isr_rx+0x5e>
    7f82:	b1ef      	cbz	r7, 7fc0 <isr_rx+0x74>
    7f84:	2301      	movs	r3, #1
    7f86:	e011      	b.n	7fac <isr_rx+0x60>
		crc_ok = radio_crc_is_valid();
    7f88:	f000 fb74 	bl	8674 <radio_crc_is_valid>
    7f8c:	b2c6      	uxtb	r6, r0
		devmatch_ok = radio_filter_has_match();
    7f8e:	f000 fc03 	bl	8798 <radio_filter_has_match>
    7f92:	b2c7      	uxtb	r7, r0
		devmatch_id = radio_filter_match_get();
    7f94:	f000 fc0a 	bl	87ac <radio_filter_match_get>
		irkmatch_ok = radio_ar_has_match();
    7f98:	f000 fd2a 	bl	89f0 <radio_ar_has_match>
		irkmatch_id = radio_ar_match_get();
    7f9c:	f000 fd18 	bl	89d0 <radio_ar_match_get>
		rssi_ready = radio_rssi_is_ready();
    7fa0:	f000 fbb6 	bl	8710 <radio_rssi_is_ready>
    7fa4:	fa5f f880 	uxtb.w	r8, r0
    7fa8:	e7db      	b.n	7f62 <isr_rx+0x16>
	return ((lll->filter_policy & 0x01) == 0U) ||
    7faa:	2301      	movs	r3, #1
	if (crc_ok && isr_rx_scan_check(lll, irkmatch_ok, devmatch_ok,
    7fac:	461e      	mov	r6, r3
    7fae:	b94b      	cbnz	r3, 7fc4 <isr_rx+0x78>
	radio_isr_set(isr_done, lll);
    7fb0:	4629      	mov	r1, r5
    7fb2:	487f      	ldr	r0, [pc, #508]	; (81b0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1b0>)
    7fb4:	f000 fa3c 	bl	8430 <radio_isr_set>
	radio_disable();
    7fb8:	f000 fafc 	bl	85b4 <radio_disable>
}
    7fbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return ((lll->filter_policy & 0x01) == 0U) ||
    7fc0:	2300      	movs	r3, #0
    7fc2:	e7f3      	b.n	7fac <isr_rx+0x60>
	node_rx = ull_pdu_rx_alloc_peek(1);
    7fc4:	2001      	movs	r0, #1
    7fc6:	f7fe fe1f 	bl	6c08 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    7fca:	4604      	mov	r4, r0
    7fcc:	b358      	cbz	r0, 8026 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x26>
	pdu_adv_rx = (void *)node_rx->pdu;
    7fce:	f104 07b4 	add.w	r7, r4, #180	; 0xb4
	dfe_setup_package_header(node_rx);
    7fd2:	4620      	mov	r0, r4
    7fd4:	f7ff f9ce 	bl	7374 <dfe_setup_package_header>
	} else if (((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
    7fd8:	f894 30b4 	ldrb.w	r3, [r4, #180]	; 0xb4
    7fdc:	f013 030f 	ands.w	r3, r3, #15
    7fe0:	d02f      	beq.n	8042 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x42>
    7fe2:	2b06      	cmp	r3, #6
    7fe4:	d02d      	beq.n	8042 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x42>
	else if (((((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
    7fe6:	b11b      	cbz	r3, 7ff0 <isr_rx+0xa4>
    7fe8:	2b02      	cmp	r3, #2
    7fea:	d001      	beq.n	7ff0 <isr_rx+0xa4>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_NONCONN_IND) ||
    7fec:	2b06      	cmp	r3, #6
    7fee:	d104      	bne.n	7ffa <isr_rx+0xae>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind))) ||
    7ff0:	f894 20b5 	ldrb.w	r2, [r4, #181]	; 0xb5
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
    7ff4:	2a25      	cmp	r2, #37	; 0x25
    7ff6:	f240 80c9 	bls.w	818c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x18c>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind))) ||
    7ffa:	2b01      	cmp	r3, #1
    7ffc:	d07c      	beq.n	80f8 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xf8>
	bool dir_report = false;
    7ffe:	2600      	movs	r6, #0
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_RSP) &&
    8000:	f894 30b4 	ldrb.w	r3, [r4, #180]	; 0xb4
    8004:	f003 030f 	and.w	r3, r3, #15
					&dir_report))) ||
    8008:	2b04      	cmp	r3, #4
    800a:	d108      	bne.n	801e <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1e>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_scan_rsp)) &&
    800c:	f894 30b5 	ldrb.w	r3, [r4, #181]	; 0xb5
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_RSP) &&
    8010:	2b25      	cmp	r3, #37	; 0x25
    8012:	d804      	bhi.n	801e <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1e>
		   (lll->state != 0U) &&
    8014:	7a2b      	ldrb	r3, [r5, #8]
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_scan_rsp)) &&
    8016:	f013 0f01 	tst.w	r3, #1
    801a:	f040 80a0 	bne.w	815e <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x15e>
		return 1;
    801e:	2601      	movs	r6, #1
		if (!err) {
    8020:	2e00      	cmp	r6, #0
    8022:	d1c5      	bne.n	7fb0 <isr_rx+0x64>
    8024:	e7ca      	b.n	7fbc <isr_rx+0x70>
	LL_ASSERT(node_rx);
    8026:	f240 23d6 	movw	r3, #726	; 0x2d6
    802a:	4a62      	ldr	r2, [pc, #392]	; (81b4 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1b4>)
    802c:	4962      	ldr	r1, [pc, #392]	; (81b8 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1b8>)
    802e:	4863      	ldr	r0, [pc, #396]	; (81bc <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1bc>)
    8030:	f004 fffd 	bl	d02e <printk>
    8034:	4040      	eors	r0, r0
    8036:	f380 8811 	msr	BASEPRI, r0
    803a:	f04f 0003 	mov.w	r0, #3
    803e:	df02      	svc	2
    8040:	e7c5      	b.n	7fce <isr_rx+0x82>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind)) &&
    8042:	f894 20b5 	ldrb.w	r2, [r4, #181]	; 0xb5
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
    8046:	2a25      	cmp	r2, #37	; 0x25
    8048:	d8cd      	bhi.n	7fe6 <isr_rx+0x9a>
		   lll->type &&
    804a:	f995 2008 	ldrsb.w	r2, [r5, #8]
    804e:	2a00      	cmp	r2, #0
    8050:	dac9      	bge.n	7fe6 <isr_rx+0x9a>
		radio_tmr_tifs_set(EVENT_IFS_US);
    8052:	2096      	movs	r0, #150	; 0x96
    8054:	f000 fbd2 	bl	87fc <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
    8058:	2000      	movs	r0, #0
    805a:	f000 fb19 	bl	8690 <radio_switch_complete_and_rx>
		err = isr_rx_scan_report(lll, rssi_ready,
    805e:	2300      	movs	r3, #0
    8060:	22ff      	movs	r2, #255	; 0xff
    8062:	4641      	mov	r1, r8
    8064:	4628      	mov	r0, r5
    8066:	f007 f886 	bl	f176 <isr_rx_scan_report>
		if (err) {
    806a:	4606      	mov	r6, r0
    806c:	2800      	cmp	r0, #0
    806e:	d1d7      	bne.n	8020 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x20>
		pdu_tx = (void *)radio_pkt_scratch_get();
    8070:	f000 fb0a 	bl	8688 <radio_pkt_scratch_get>
		pdu_tx->type = PDU_ADV_TYPE_SCAN_REQ;
    8074:	7802      	ldrb	r2, [r0, #0]
    8076:	2103      	movs	r1, #3
    8078:	f361 0203 	bfi	r2, r1, #0, #4
    807c:	7002      	strb	r2, [r0, #0]
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
    807e:	f894 20b4 	ldrb.w	r2, [r4, #180]	; 0xb4
    8082:	f3c2 1280 	ubfx	r2, r2, #6, #1
    8086:	7801      	ldrb	r1, [r0, #0]
    8088:	f362 11c7 	bfi	r1, r2, #7, #1
    808c:	7001      	strb	r1, [r0, #0]
		pdu_tx->len = sizeof(struct pdu_adv_scan_req);
    808e:	220c      	movs	r2, #12
    8090:	7042      	strb	r2, [r0, #1]
			pdu_tx->tx_addr = lll->init_addr_type;
    8092:	7a2a      	ldrb	r2, [r5, #8]
    8094:	f3c2 1280 	ubfx	r2, r2, #6, #1
    8098:	b2c9      	uxtb	r1, r1
    809a:	f362 1186 	bfi	r1, r2, #6, #1
    809e:	4602      	mov	r2, r0
    80a0:	f802 1b02 	strb.w	r1, [r2], #2
			memcpy(&pdu_tx->scan_req.scan_addr[0],
    80a4:	4629      	mov	r1, r5
    80a6:	f851 7f09 	ldr.w	r7, [r1, #9]!
    80aa:	f8c0 7002 	str.w	r7, [r0, #2]
    80ae:	8889      	ldrh	r1, [r1, #4]
    80b0:	8091      	strh	r1, [r2, #4]
    80b2:	f854 2fb6 	ldr.w	r2, [r4, #182]!
    80b6:	6082      	str	r2, [r0, #8]
    80b8:	88a2      	ldrh	r2, [r4, #4]
    80ba:	8182      	strh	r2, [r0, #12]
		radio_pkt_tx_set(pdu_tx);
    80bc:	f000 fa6e 	bl	859c <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
    80c0:	f000 fa96 	bl	85f0 <radio_is_ready>
    80c4:	b950      	cbnz	r0, 80dc <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xdc>
		radio_tmr_end_capture();
    80c6:	f000 fc75 	bl	89b4 <radio_tmr_end_capture>
		lll->state = 1U;
    80ca:	7a2b      	ldrb	r3, [r5, #8]
    80cc:	f043 0301 	orr.w	r3, r3, #1
    80d0:	722b      	strb	r3, [r5, #8]
		radio_isr_set(isr_tx, lll);
    80d2:	4629      	mov	r1, r5
    80d4:	483a      	ldr	r0, [pc, #232]	; (81c0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1c0>)
    80d6:	f000 f9ab 	bl	8430 <radio_isr_set>
		return 0;
    80da:	e7a1      	b.n	8020 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x20>
		LL_ASSERT(!radio_is_ready());
    80dc:	f44f 7375 	mov.w	r3, #980	; 0x3d4
    80e0:	4a34      	ldr	r2, [pc, #208]	; (81b4 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1b4>)
    80e2:	4938      	ldr	r1, [pc, #224]	; (81c4 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1c4>)
    80e4:	4835      	ldr	r0, [pc, #212]	; (81bc <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1bc>)
    80e6:	f004 ffa2 	bl	d02e <printk>
    80ea:	4040      	eors	r0, r0
    80ec:	f380 8811 	msr	BASEPRI, r0
    80f0:	f04f 0003 	mov.w	r0, #3
    80f4:	df02      	svc	2
    80f6:	e7e6      	b.n	80c6 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xc6>
		   (pdu_adv_rx->len == sizeof(struct pdu_adv_direct_ind)) &&
    80f8:	f894 30b5 	ldrb.w	r3, [r4, #181]	; 0xb5
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_DIRECT_IND) &&
    80fc:	2b0c      	cmp	r3, #12
    80fe:	d001      	beq.n	8104 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x104>
	bool dir_report = false;
    8100:	2600      	movs	r6, #0
    8102:	e77d      	b.n	8000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC>
	return (((lll->init_addr_type == pdu->rx_addr) &&
    8104:	7a2b      	ldrb	r3, [r5, #8]
    8106:	f3c3 1380 	ubfx	r3, r3, #6, #1
    810a:	f894 20b4 	ldrb.w	r2, [r4, #180]	; 0xb4
			BDADDR_SIZE))) ||
    810e:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
    8112:	d00a      	beq.n	812a <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x12a>
	if (((lll->filter_policy & 0x02) != 0U) &&
    8114:	7a2b      	ldrb	r3, [r5, #8]
    8116:	f013 0f10 	tst.w	r3, #16
    811a:	d01a      	beq.n	8152 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x152>
    811c:	f994 30b4 	ldrsb.w	r3, [r4, #180]	; 0xb4
    8120:	2b00      	cmp	r3, #0
    8122:	db0e      	blt.n	8142 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x142>
	bool dir_report = false;
    8124:	2600      	movs	r6, #0
			BDADDR_SIZE))) ||
    8126:	4633      	mov	r3, r6
    8128:	e015      	b.n	8156 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x156>
		!memcmp(lll->init_addr, pdu->direct_ind.tgt_addr,
    812a:	2206      	movs	r2, #6
    812c:	f107 0108 	add.w	r1, r7, #8
    8130:	f105 0009 	add.w	r0, r5, #9
    8134:	f008 fa27 	bl	10586 <memcmp>
	return (((lll->init_addr_type == pdu->rx_addr) &&
    8138:	2800      	cmp	r0, #0
    813a:	d1eb      	bne.n	8114 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x114>
	bool dir_report = false;
    813c:	2600      	movs	r6, #0
			BDADDR_SIZE))) ||
    813e:	2301      	movs	r3, #1
    8140:	e009      	b.n	8156 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x156>
	    ((pdu->direct_ind.tgt_addr[5] & 0xc0) == 0x40)) {
    8142:	7b7b      	ldrb	r3, [r7, #13]
	    (pdu->rx_addr != 0) &&
    8144:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    8148:	2b40      	cmp	r3, #64	; 0x40
    814a:	d006      	beq.n	815a <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x15a>
	bool dir_report = false;
    814c:	2600      	movs	r6, #0
			BDADDR_SIZE))) ||
    814e:	4633      	mov	r3, r6
    8150:	e001      	b.n	8156 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x156>
	bool dir_report = false;
    8152:	2600      	movs	r6, #0
			BDADDR_SIZE))) ||
    8154:	4633      	mov	r3, r6
		   (pdu_adv_rx->len == sizeof(struct pdu_adv_direct_ind)) &&
    8156:	b9d3      	cbnz	r3, 818e <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x18e>
    8158:	e752      	b.n	8000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC>
			BDADDR_SIZE))) ||
    815a:	2301      	movs	r3, #1
    815c:	e7fb      	b.n	8156 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x156>
	struct pdu_adv *sreq = (void *)radio_pkt_scratch_get();
    815e:	f000 fa93 	bl	8688 <radio_pkt_scratch_get>
	return ((sreq->rx_addr == srsp->tx_addr) &&
    8162:	7802      	ldrb	r2, [r0, #0]
    8164:	f894 30b4 	ldrb.w	r3, [r4, #180]	; 0xb4
    8168:	f3c3 1380 	ubfx	r3, r3, #6, #1
    816c:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
    8170:	d002      	beq.n	8178 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x178>
    8172:	2300      	movs	r3, #0
		   (lll->state != 0U) &&
    8174:	b95b      	cbnz	r3, 818e <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x18e>
    8176:	e752      	b.n	801e <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1e>
		(memcmp(&sreq->scan_req.adv_addr[0],
    8178:	2206      	movs	r2, #6
    817a:	1cb9      	adds	r1, r7, #2
    817c:	3008      	adds	r0, #8
    817e:	f008 fa02 	bl	10586 <memcmp>
	return ((sreq->rx_addr == srsp->tx_addr) &&
    8182:	b908      	cbnz	r0, 8188 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x188>
    8184:	2301      	movs	r3, #1
    8186:	e7f5      	b.n	8174 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x174>
    8188:	2300      	movs	r3, #0
    818a:	e7f3      	b.n	8174 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x174>
	bool dir_report = false;
    818c:	2600      	movs	r6, #0
		 (pdu_adv_rx->len != 0) &&
    818e:	f894 30b5 	ldrb.w	r3, [r4, #181]	; 0xb5
		   isr_scan_rsp_adva_matches(pdu_adv_rx))) &&
    8192:	2b00      	cmp	r3, #0
    8194:	f43f af43 	beq.w	801e <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1e>
		err = isr_rx_scan_report(lll, rssi_ready,
    8198:	4633      	mov	r3, r6
    819a:	22ff      	movs	r2, #255	; 0xff
    819c:	4641      	mov	r1, r8
    819e:	4628      	mov	r0, r5
    81a0:	f006 ffe9 	bl	f176 <isr_rx_scan_report>
		if (err) {
    81a4:	4606      	mov	r6, r0
    81a6:	2800      	cmp	r0, #0
    81a8:	f47f af3a 	bne.w	8020 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x20>
	return 1;
    81ac:	2601      	movs	r6, #1
    81ae:	e737      	b.n	8020 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x20>
    81b0:	0000f167 	.word	0x0000f167
    81b4:	00012a6c 	.word	0x00012a6c
    81b8:	00012b24 	.word	0x00012b24
    81bc:	00011fec 	.word	0x00011fec
    81c0:	00007e99 	.word	0x00007e99
    81c4:	00012b48 	.word	0x00012b48

000081c8 <lll_scan_prepare>:
{
    81c8:	b510      	push	{r4, lr}
    81ca:	b082      	sub	sp, #8
    81cc:	4604      	mov	r4, r0
	err = lll_hfclock_on();
    81ce:	f7ff fc4f 	bl	7a70 <lll_hfclock_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
    81d2:	b110      	cbz	r0, 81da <lll_scan_prepare+0x12>
    81d4:	f110 0f77 	cmn.w	r0, #119	; 0x77
    81d8:	d10c      	bne.n	81f4 <lll_scan_prepare+0x2c>
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, p);
    81da:	9400      	str	r4, [sp, #0]
    81dc:	2300      	movs	r3, #0
    81de:	4a12      	ldr	r2, [pc, #72]	; (8228 <lll_scan_prepare+0x60>)
    81e0:	4912      	ldr	r1, [pc, #72]	; (822c <lll_scan_prepare+0x64>)
    81e2:	4813      	ldr	r0, [pc, #76]	; (8230 <lll_scan_prepare+0x68>)
    81e4:	f006 ff73 	bl	f0ce <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
    81e8:	b110      	cbz	r0, 81f0 <lll_scan_prepare+0x28>
    81ea:	f110 0f77 	cmn.w	r0, #119	; 0x77
    81ee:	d10e      	bne.n	820e <lll_scan_prepare+0x46>
}
    81f0:	b002      	add	sp, #8
    81f2:	bd10      	pop	{r4, pc}
	LL_ASSERT(!err || err == -EINPROGRESS);
    81f4:	2379      	movs	r3, #121	; 0x79
    81f6:	4a0f      	ldr	r2, [pc, #60]	; (8234 <lll_scan_prepare+0x6c>)
    81f8:	490f      	ldr	r1, [pc, #60]	; (8238 <lll_scan_prepare+0x70>)
    81fa:	4810      	ldr	r0, [pc, #64]	; (823c <lll_scan_prepare+0x74>)
    81fc:	f004 ff17 	bl	d02e <printk>
    8200:	4040      	eors	r0, r0
    8202:	f380 8811 	msr	BASEPRI, r0
    8206:	f04f 0003 	mov.w	r0, #3
    820a:	df02      	svc	2
    820c:	e7e5      	b.n	81da <lll_scan_prepare+0x12>
	LL_ASSERT(!err || err == -EINPROGRESS);
    820e:	237c      	movs	r3, #124	; 0x7c
    8210:	4a08      	ldr	r2, [pc, #32]	; (8234 <lll_scan_prepare+0x6c>)
    8212:	4909      	ldr	r1, [pc, #36]	; (8238 <lll_scan_prepare+0x70>)
    8214:	4809      	ldr	r0, [pc, #36]	; (823c <lll_scan_prepare+0x74>)
    8216:	f004 ff0a 	bl	d02e <printk>
    821a:	4040      	eors	r0, r0
    821c:	f380 8811 	msr	BASEPRI, r0
    8220:	f04f 0003 	mov.w	r0, #3
    8224:	df02      	svc	2
}
    8226:	e7e3      	b.n	81f0 <lll_scan_prepare+0x28>
    8228:	00007bc1 	.word	0x00007bc1
    822c:	00007add 	.word	0x00007add
    8230:	00007b31 	.word	0x00007b31
    8234:	00012a6c 	.word	0x00012a6c
    8238:	00012b10 	.word	0x00012b10
    823c:	00011fec 	.word	0x00011fec

00008240 <cntr_init>:

static u8_t _refcount;

void cntr_init(void)
{
	NRF_RTC->PRESCALER = 0;
    8240:	4b05      	ldr	r3, [pc, #20]	; (8258 <cntr_init+0x18>)
    8242:	2200      	movs	r2, #0
    8244:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
    8248:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    824c:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
    p_reg->INTENSET = mask;
    8250:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	nrf_rtc_event_enable(NRF_RTC, RTC_EVTENSET_COMPARE0_Msk);
	nrf_rtc_int_enable(NRF_RTC, RTC_INTENSET_COMPARE0_Msk);
}
    8254:	4770      	bx	lr
    8256:	bf00      	nop
    8258:	4000b000 	.word	0x4000b000

0000825c <cntr_start>:

u32_t cntr_start(void)
{
	if (_refcount++) {
    825c:	4a05      	ldr	r2, [pc, #20]	; (8274 <cntr_start+0x18>)
    825e:	7813      	ldrb	r3, [r2, #0]
    8260:	1c59      	adds	r1, r3, #1
    8262:	7011      	strb	r1, [r2, #0]
    8264:	b923      	cbnz	r3, 8270 <cntr_start+0x14>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    8266:	4b04      	ldr	r3, [pc, #16]	; (8278 <cntr_start+0x1c>)
    8268:	2201      	movs	r2, #1
    826a:	601a      	str	r2, [r3, #0]
		return 1;
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_START);

	return 0;
    826c:	2000      	movs	r0, #0
    826e:	4770      	bx	lr
		return 1;
    8270:	2001      	movs	r0, #1
}
    8272:	4770      	bx	lr
    8274:	20005951 	.word	0x20005951
    8278:	4000b000 	.word	0x4000b000

0000827c <cntr_stop>:

u32_t cntr_stop(void)
{
    827c:	b508      	push	{r3, lr}
	LL_ASSERT(_refcount);
    827e:	4b0e      	ldr	r3, [pc, #56]	; (82b8 <cntr_stop+0x3c>)
    8280:	781b      	ldrb	r3, [r3, #0]
    8282:	b153      	cbz	r3, 829a <cntr_stop+0x1e>

	if (--_refcount) {
    8284:	4a0c      	ldr	r2, [pc, #48]	; (82b8 <cntr_stop+0x3c>)
    8286:	7813      	ldrb	r3, [r2, #0]
    8288:	3b01      	subs	r3, #1
    828a:	b2db      	uxtb	r3, r3
    828c:	7013      	strb	r3, [r2, #0]
    828e:	b98b      	cbnz	r3, 82b4 <cntr_stop+0x38>
    8290:	4b0a      	ldr	r3, [pc, #40]	; (82bc <cntr_stop+0x40>)
    8292:	2201      	movs	r2, #1
    8294:	601a      	str	r2, [r3, #0]
		return 1;
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_STOP);

	return 0;
    8296:	2000      	movs	r0, #0
}
    8298:	bd08      	pop	{r3, pc}
	LL_ASSERT(_refcount);
    829a:	232e      	movs	r3, #46	; 0x2e
    829c:	4a08      	ldr	r2, [pc, #32]	; (82c0 <cntr_stop+0x44>)
    829e:	4909      	ldr	r1, [pc, #36]	; (82c4 <cntr_stop+0x48>)
    82a0:	4809      	ldr	r0, [pc, #36]	; (82c8 <cntr_stop+0x4c>)
    82a2:	f004 fec4 	bl	d02e <printk>
    82a6:	4040      	eors	r0, r0
    82a8:	f380 8811 	msr	BASEPRI, r0
    82ac:	f04f 0003 	mov.w	r0, #3
    82b0:	df02      	svc	2
    82b2:	e7e7      	b.n	8284 <cntr_stop+0x8>
		return 1;
    82b4:	2001      	movs	r0, #1
    82b6:	e7ef      	b.n	8298 <cntr_stop+0x1c>
    82b8:	20005951 	.word	0x20005951
    82bc:	4000b004 	.word	0x4000b004
    82c0:	00012b70 	.word	0x00012b70
    82c4:	00012bf8 	.word	0x00012bf8
    82c8:	00011fec 	.word	0x00011fec

000082cc <cntr_cnt_get>:
     return p_reg->COUNTER;
    82cc:	4b01      	ldr	r3, [pc, #4]	; (82d4 <cntr_cnt_get+0x8>)
    82ce:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

u32_t cntr_cnt_get(void)
{
	return nrf_rtc_counter_get(NRF_RTC);
}
    82d2:	4770      	bx	lr
    82d4:	4000b000 	.word	0x4000b000

000082d8 <cntr_cmp_set>:
    p_reg->CC[ch] = cc_val;
    82d8:	f500 70a8 	add.w	r0, r0, #336	; 0x150
    82dc:	4b01      	ldr	r3, [pc, #4]	; (82e4 <cntr_cmp_set+0xc>)
    82de:	f843 1020 	str.w	r1, [r3, r0, lsl #2]

void cntr_cmp_set(u8_t cmp, u32_t value)
{
	nrf_rtc_cc_set(NRF_RTC, cmp, value);
}
    82e2:	4770      	bx	lr
    82e4:	4000b000 	.word	0x4000b000

000082e8 <do_ecb>:
	u8_t clear_text[16];
	u8_t cipher_text[16];
} __packed;

static void do_ecb(struct ecb_param *ecb)
{
    82e8:	e00a      	b.n	8300 <do_ecb+0x18>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ecb_task_trigger(NRF_ECB_Type * p_reg, nrf_ecb_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    82ea:	4b16      	ldr	r3, [pc, #88]	; (8344 <do_ecb+0x5c>)
    82ec:	2201      	movs	r2, #1
    82ee:	601a      	str	r2, [r3, #0]
#else
			/*__WFE();*/
#endif
		}
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
	} while ((NRF_ECB->EVENTS_ERRORECB != 0) || (NRF_ECB->ECBDATAPTR == 0));
    82f0:	3b04      	subs	r3, #4
    82f2:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
    82f6:	b91b      	cbnz	r3, 8300 <do_ecb+0x18>
    82f8:	4b13      	ldr	r3, [pc, #76]	; (8348 <do_ecb+0x60>)
    82fa:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
    82fe:	b9db      	cbnz	r3, 8338 <do_ecb+0x50>
    8300:	2201      	movs	r2, #1
    8302:	4b10      	ldr	r3, [pc, #64]	; (8344 <do_ecb+0x5c>)
    8304:	601a      	str	r2, [r3, #0]
		NRF_ECB->ECBDATAPTR = (u32_t)ecb;
    8306:	3b04      	subs	r3, #4
    8308:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
		NRF_ECB->EVENTS_ENDECB = 0;
    830c:	2100      	movs	r1, #0
    830e:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
		NRF_ECB->EVENTS_ERRORECB = 0;
    8312:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
    8316:	601a      	str	r2, [r3, #0]
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
    8318:	4b0b      	ldr	r3, [pc, #44]	; (8348 <do_ecb+0x60>)
    831a:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    831e:	2b00      	cmp	r3, #0
    8320:	d1e3      	bne.n	82ea <do_ecb+0x2>
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
    8322:	4b09      	ldr	r3, [pc, #36]	; (8348 <do_ecb+0x60>)
    8324:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
    8328:	2b00      	cmp	r3, #0
    832a:	d1de      	bne.n	82ea <do_ecb+0x2>
		       (NRF_ECB->ECBDATAPTR != 0)) {
    832c:	4b06      	ldr	r3, [pc, #24]	; (8348 <do_ecb+0x60>)
    832e:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
    8332:	2b00      	cmp	r3, #0
    8334:	d1f0      	bne.n	8318 <do_ecb+0x30>
    8336:	e7d8      	b.n	82ea <do_ecb+0x2>

	NRF_ECB->ECBDATAPTR = 0;
    8338:	4b03      	ldr	r3, [pc, #12]	; (8348 <do_ecb+0x60>)
    833a:	2200      	movs	r2, #0
    833c:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
    8340:	4770      	bx	lr
    8342:	bf00      	nop
    8344:	4000e004 	.word	0x4000e004
    8348:	4000e000 	.word	0x4000e000

0000834c <sw_switch>:
#if !defined(CONFIG_BT_CTLR_TIFS_HW)
static u8_t sw_tifs_toggle;

static void sw_switch(u8_t dir, u8_t phy_curr, u8_t flags_curr, u8_t phy_next,
		      u8_t flags_next)
{
    834c:	b4f0      	push	{r4, r5, r6, r7}
	u8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
    834e:	4a30      	ldr	r2, [pc, #192]	; (8410 <sw_switch+0xc4>)
    8350:	7814      	ldrb	r4, [r2, #0]
    8352:	f104 020b 	add.w	r2, r4, #11
    8356:	b2d2      	uxtb	r2, r2
	 */
	nrf_ppi_channel_endpoint_setup(
		NRF_PPI,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_EVT,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_TASK(ppi_group_index));
    8358:	00e5      	lsls	r5, r4, #3
    835a:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
    835e:	f505 35f8 	add.w	r5, r5, #126976	; 0x1f000
NRF_STATIC_INLINE void nrf_ppi_channel_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                      nrf_ppi_channel_t channel,
                                                      uint32_t          eep,
                                                      uint32_t          tep)
{
    p_reg->CH[(uint32_t) channel].EEP = eep;
    8362:	4e2c      	ldr	r6, [pc, #176]	; (8414 <sw_switch+0xc8>)
    8364:	4f2c      	ldr	r7, [pc, #176]	; (8418 <sw_switch+0xcc>)
    8366:	f8c6 7560 	str.w	r7, [r6, #1376]	; 0x560
    p_reg->CH[(uint32_t) channel].TEP = tep;
    836a:	f8c6 5564 	str.w	r5, [r6, #1380]	; 0x564
	 * (TX/RX).
	 */
	nrf_ppi_event_endpoint_setup(
		NRF_PPI,
		radio_enable_ppi,
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(compare_reg));
    836e:	4d2b      	ldr	r5, [pc, #172]	; (841c <sw_switch+0xd0>)
    8370:	eb05 0584 	add.w	r5, r5, r4, lsl #2

NRF_STATIC_INLINE void nrf_ppi_event_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                    nrf_ppi_channel_t channel,
                                                    uint32_t          eep)
{
    p_reg->CH[(uint32_t) channel].EEP = eep;
    8374:	f102 07a2 	add.w	r7, r2, #162	; 0xa2
    8378:	f846 5037 	str.w	r5, [r6, r7, lsl #3]
	u8_t cc = SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle);
	u32_t delay;

	hal_radio_sw_switch_setup(cc, ppi, sw_tifs_toggle);

	if (dir) {
    837c:	b3b0      	cbz	r0, 83ec <sw_switch+0xa0>
	}
}

static inline u32_t hal_radio_tx_ready_delay_ns_get(u8_t phy, u8_t flags)
{
	switch (phy) {
    837e:	2b02      	cmp	r3, #2
    8380:	d02e      	beq.n	83e0 <sw_switch+0x94>
	default:
	case BIT(0):
		return HAL_RADIO_NRF52833_TXEN_TXIDLE_TX_1M_NS;
    8382:	f649 70c4 	movw	r0, #40900	; 0x9fc4
	}
}

static inline u32_t hal_radio_rx_chain_delay_ns_get(u8_t phy, u8_t flags)
{
	switch (phy) {
    8386:	2902      	cmp	r1, #2
    8388:	d02d      	beq.n	83e6 <sw_switch+0x9a>
	default:
	case BIT(0):
		return HAL_RADIO_NRF52833_RX_CHAIN_DELAY_1M_NS;
    838a:	f242 43b8 	movw	r3, #9400	; 0x24b8

		/* Calculate delay with respect to current (RX) and next
		 * (TX) PHY. If RX PHY is LE Coded, assume S8 coding scheme.
		 */
#if defined(CONFIG_BT_CTLR_DF_SUBSYSTEM)
		delay = HAL_RADIO_NS2US_ROUND(
    838e:	4403      	add	r3, r0
    8390:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
    8394:	4922      	ldr	r1, [pc, #136]	; (8420 <sw_switch+0xd4>)
    8396:	fba1 1303 	umull	r1, r3, r1, r3
    839a:	099b      	lsrs	r3, r3, #6

NRF_STATIC_INLINE void nrf_ppi_task_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                   nrf_ppi_channel_t channel,
                                                   uint32_t          tep)
{
    p_reg->CH[(uint32_t) channel].TEP = tep;
    839c:	32a2      	adds	r2, #162	; 0xa2
    839e:	00d2      	lsls	r2, r2, #3
    83a0:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    83a4:	f502 32f8 	add.w	r2, r2, #126976	; 0x1f000
    83a8:	491e      	ldr	r1, [pc, #120]	; (8424 <sw_switch+0xd8>)
    83aa:	6051      	str	r1, [r2, #4]
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	}

	if (delay <
		SW_SWITCH_TIMER->CC[cc]) {
    83ac:	f504 72a8 	add.w	r2, r4, #336	; 0x150
    83b0:	491d      	ldr	r1, [pc, #116]	; (8428 <sw_switch+0xdc>)
    83b2:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
	if (delay <
    83b6:	429a      	cmp	r2, r3
    83b8:	d922      	bls.n	8400 <sw_switch+0xb4>
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
				 SW_SWITCH_TIMER->CC[cc] - delay);
    83ba:	f504 70a8 	add.w	r0, r4, #336	; 0x150
    83be:	f851 2020 	ldr.w	r2, [r1, r0, lsl #2]
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
    83c2:	1ad3      	subs	r3, r2, r3

NRF_STATIC_INLINE void nrf_timer_cc_set(NRF_TIMER_Type *       p_reg,
                                        nrf_timer_cc_channel_t cc_channel,
                                        uint32_t               cc_value)
{
    p_reg->CC[cc_channel] = cc_value;
    83c4:	f841 3020 	str.w	r3, [r1, r0, lsl #2]
    p_reg->CHENSET = mask;
    83c8:	4b12      	ldr	r3, [pc, #72]	; (8414 <sw_switch+0xc8>)
    83ca:	f44f 6290 	mov.w	r2, #1152	; 0x480
    83ce:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	 * always need to capture the PDU END time-stamp.
	 */
	radio_tmr_end_capture();
#endif /* CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */

	sw_tifs_toggle += 1U;
    83d2:	1c63      	adds	r3, r4, #1
	sw_tifs_toggle &= 1;
    83d4:	f003 0301 	and.w	r3, r3, #1
    83d8:	4a0d      	ldr	r2, [pc, #52]	; (8410 <sw_switch+0xc4>)
    83da:	7013      	strb	r3, [r2, #0]
}
    83dc:	bcf0      	pop	{r4, r5, r6, r7}
    83de:	4770      	bx	lr
		return HAL_RADIO_NRF52833_TXEN_TXIDLE_TX_2M_NS;
    83e0:	f649 4040 	movw	r0, #40000	; 0x9c40
    83e4:	e7cf      	b.n	8386 <sw_switch+0x3a>
	case BIT(1):
		return HAL_RADIO_NRF52833_RX_CHAIN_DELAY_2M_NS;
    83e6:	f241 3388 	movw	r3, #5000	; 0x1388
    83ea:	e7d0      	b.n	838e <sw_switch+0x42>
    p_reg->CH[(uint32_t) channel].TEP = tep;
    83ec:	32a2      	adds	r2, #162	; 0xa2
    83ee:	00d2      	lsls	r2, r2, #3
    83f0:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    83f4:	f502 32f8 	add.w	r2, r2, #126976	; 0x1f000
    83f8:	4b0c      	ldr	r3, [pc, #48]	; (842c <sw_switch+0xe0>)
    83fa:	6053      	str	r3, [r2, #4]
		delay = HAL_RADIO_NS2US_CEIL(
    83fc:	2328      	movs	r3, #40	; 0x28
{
	nrf_ppi_task_endpoint_setup(
		NRF_PPI,
		ppi,
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_TASK_RX);
}
    83fe:	e7d5      	b.n	83ac <sw_switch+0x60>
    8400:	f504 73a8 	add.w	r3, r4, #336	; 0x150
    8404:	4a08      	ldr	r2, [pc, #32]	; (8428 <sw_switch+0xdc>)
    8406:	2101      	movs	r1, #1
    8408:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
}
    840c:	e7dc      	b.n	83c8 <sw_switch+0x7c>
    840e:	bf00      	nop
    8410:	20005952 	.word	0x20005952
    8414:	4001f000 	.word	0x4001f000
    8418:	4000116c 	.word	0x4000116c
    841c:	40009140 	.word	0x40009140
    8420:	10624dd3 	.word	0x10624dd3
    8424:	40001000 	.word	0x40001000
    8428:	40009000 	.word	0x40009000
    842c:	40001004 	.word	0x40001004

00008430 <radio_isr_set>:
{
    8430:	b538      	push	{r3, r4, r5, lr}
    8432:	4604      	mov	r4, r0
    8434:	460d      	mov	r5, r1
	irq_disable(RADIO_IRQn);
    8436:	2001      	movs	r0, #1
    8438:	f7fa fa20 	bl	287c <arch_irq_disable>
	isr_cb_param = param;
    843c:	4b07      	ldr	r3, [pc, #28]	; (845c <radio_isr_set+0x2c>)
    843e:	601d      	str	r5, [r3, #0]
	isr_cb = cb;
    8440:	4b07      	ldr	r3, [pc, #28]	; (8460 <radio_isr_set+0x30>)
    8442:	601c      	str	r4, [r3, #0]
    return p_reg->SHORTS;
}

NRF_STATIC_INLINE void nrf_radio_int_enable(NRF_RADIO_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
    8444:	4b07      	ldr	r3, [pc, #28]	; (8464 <radio_isr_set+0x34>)
    8446:	4a08      	ldr	r2, [pc, #32]	; (8468 <radio_isr_set+0x38>)
    8448:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    844c:	4b07      	ldr	r3, [pc, #28]	; (846c <radio_isr_set+0x3c>)
    844e:	2202      	movs	r2, #2
    8450:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	irq_enable(RADIO_IRQn);
    8454:	2001      	movs	r0, #1
    8456:	f7fa fa01 	bl	285c <arch_irq_enable>
}
    845a:	bd38      	pop	{r3, r4, r5, pc}
    845c:	20004d38 	.word	0x20004d38
    8460:	20004d34 	.word	0x20004d34
    8464:	40001000 	.word	0x40001000
    8468:	10000010 	.word	0x10000010
    846c:	e000e100 	.word	0xe000e100

00008470 <radio_reset>:
{
    8470:	b508      	push	{r3, lr}
	irq_disable(RADIO_IRQn);
    8472:	2001      	movs	r0, #1
    8474:	f7fa fa02 	bl	287c <arch_irq_disable>
}
#endif

NRF_STATIC_INLINE void nrf_radio_power_set(NRF_RADIO_Type * p_reg, bool radio_power)
{
    p_reg->POWER = (uint32_t) radio_power;
    8478:	4b08      	ldr	r3, [pc, #32]	; (849c <radio_reset+0x2c>)
    847a:	2200      	movs	r2, #0
    847c:	f8c3 2ffc 	str.w	r2, [r3, #4092]	; 0xffc
    8480:	2201      	movs	r2, #1
    8482:	f8c3 2ffc 	str.w	r2, [r3, #4092]	; 0xffc
static inline void hal_radio_sw_switch_ppi_group_setup(void)
{
	/* Include the appropriate PPI channels in the two PPI Groups. */
#if !defined(CONFIG_BT_CTLR_PHY_CODED) || \
	!defined(CONFIG_HAS_HW_NRF_RADIO_BLE_CODED)
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(0)] =
    8486:	f503 33f0 	add.w	r3, r3, #122880	; 0x1e000
    848a:	f44f 6210 	mov.w	r2, #2304	; 0x900
    848e:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_0_INCLUDE |
			HAL_SW_SWITCH_RADIO_ENABLE_PPI_0_INCLUDE;
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
    8492:	f44f 5290 	mov.w	r2, #4608	; 0x1200
    8496:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
}
    849a:	bd08      	pop	{r3, pc}
    849c:	40001000 	.word	0x40001000

000084a0 <radio_phy_set>:
	switch (phy) {
    84a0:	2802      	cmp	r0, #2
    84a2:	d00c      	beq.n	84be <radio_phy_set+0x1e>
		mode = RADIO_MODE_MODE_Ble_1Mbit;
    84a4:	2203      	movs	r2, #3
	NRF_RADIO->MODE = (mode << RADIO_MODE_MODE_Pos) & RADIO_MODE_MODE_Msk;
    84a6:	f002 020f 	and.w	r2, r2, #15
    84aa:	4b06      	ldr	r3, [pc, #24]	; (84c4 <radio_phy_set+0x24>)
    84ac:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_RADIO->MODECNF0 |= (RADIO_MODECNF0_RU_Fast <<
    84b0:	f8d3 2650 	ldr.w	r2, [r3, #1616]	; 0x650
    84b4:	f042 0201 	orr.w	r2, r2, #1
    84b8:	f8c3 2650 	str.w	r2, [r3, #1616]	; 0x650
}
    84bc:	4770      	bx	lr
		mode = RADIO_MODE_MODE_Ble_2Mbit;
    84be:	2204      	movs	r2, #4
    84c0:	e7f1      	b.n	84a6 <radio_phy_set+0x6>
    84c2:	bf00      	nop
    84c4:	40001000 	.word	0x40001000

000084c8 <radio_tx_power_set>:
	NRF_RADIO->TXPOWER = (u32_t)power;
    84c8:	4b01      	ldr	r3, [pc, #4]	; (84d0 <radio_tx_power_set+0x8>)
    84ca:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
}
    84ce:	4770      	bx	lr
    84d0:	40001000 	.word	0x40001000

000084d4 <radio_freq_chan_set>:
	NRF_RADIO->FREQUENCY = chan;
    84d4:	4b01      	ldr	r3, [pc, #4]	; (84dc <radio_freq_chan_set+0x8>)
    84d6:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
}
    84da:	4770      	bx	lr
    84dc:	40001000 	.word	0x40001000

000084e0 <radio_whiten_iv_set>:
	NRF_RADIO->DATAWHITEIV = iv;
    84e0:	4b07      	ldr	r3, [pc, #28]	; (8500 <radio_whiten_iv_set+0x20>)
    84e2:	f8c3 0554 	str.w	r0, [r3, #1364]	; 0x554
	NRF_RADIO->PCNF1 &= ~RADIO_PCNF1_WHITEEN_Msk;
    84e6:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
    84ea:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
    84ee:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((1UL) << RADIO_PCNF1_WHITEEN_Pos) &
    84f2:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
    84f6:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
    84fa:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
    84fe:	4770      	bx	lr
    8500:	40001000 	.word	0x40001000

00008504 <radio_aa_set>:
	NRF_RADIO->TXADDRESS =
    8504:	4a0a      	ldr	r2, [pc, #40]	; (8530 <radio_aa_set+0x2c>)
    8506:	2300      	movs	r3, #0
    8508:	f8c2 352c 	str.w	r3, [r2, #1324]	; 0x52c
	NRF_RADIO->RXADDRESSES =
    850c:	2301      	movs	r3, #1
    850e:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
	NRF_RADIO->PREFIX0 = aa[3];
    8512:	78c3      	ldrb	r3, [r0, #3]
    8514:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
	NRF_RADIO->BASE0 = (aa[2] << 24) | (aa[1] << 16) | (aa[0] << 8);
    8518:	7881      	ldrb	r1, [r0, #2]
    851a:	7843      	ldrb	r3, [r0, #1]
    851c:	041b      	lsls	r3, r3, #16
    851e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    8522:	7801      	ldrb	r1, [r0, #0]
    8524:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    8528:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
}
    852c:	4770      	bx	lr
    852e:	bf00      	nop
    8530:	40001000 	.word	0x40001000

00008534 <radio_pkt_configure>:
	u8_t dc = flags & 0x01; /* Adv or Data channel */
    8534:	f002 0301 	and.w	r3, r2, #1
	phy = (flags >> 1) & 0x07; /* phy */
    8538:	f3c2 0242 	ubfx	r2, r2, #1, #3
	switch (phy) {
    853c:	2a02      	cmp	r2, #2
    853e:	d01f      	beq.n	8580 <radio_pkt_configure+0x4c>
		extra |= (RADIO_PCNF0_PLEN_8bit << RADIO_PCNF0_PLEN_Pos) &
    8540:	2200      	movs	r2, #0
	if (dc) {
    8542:	b10b      	cbz	r3, 8548 <radio_pkt_configure+0x14>
		extra |= (RADIO_PCNF0_S1INCL_Include <<
    8544:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
			   ((((u32_t)bits_len) << RADIO_PCNF0_LFLEN_Pos) &
    8548:	f000 030f 	and.w	r3, r0, #15
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
    854c:	f1c0 0008 	rsb	r0, r0, #8
    8550:	0400      	lsls	r0, r0, #16
    8552:	f400 2070 	and.w	r0, r0, #983040	; 0xf0000
			    RADIO_PCNF0_LFLEN_Msk) |
    8556:	4318      	orrs	r0, r3
			    RADIO_PCNF0_S1LEN_Msk) |
    8558:	4310      	orrs	r0, r2
    855a:	f440 7080 	orr.w	r0, r0, #256	; 0x100
	NRF_RADIO->PCNF0 = (((1UL) << RADIO_PCNF0_S0LEN_Pos) &
    855e:	4b0a      	ldr	r3, [pc, #40]	; (8588 <radio_pkt_configure+0x54>)
    8560:	f8c3 0514 	str.w	r0, [r3, #1300]	; 0x514
	NRF_RADIO->PCNF1 &= ~(RADIO_PCNF1_MAXLEN_Msk | RADIO_PCNF1_STATLEN_Msk |
    8564:	f8d3 0518 	ldr.w	r0, [r3, #1304]	; 0x518
    8568:	4a08      	ldr	r2, [pc, #32]	; (858c <radio_pkt_configure+0x58>)
    856a:	4002      	ands	r2, r0
    856c:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((((u32_t)max_len) << RADIO_PCNF1_MAXLEN_Pos) &
    8570:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
    8574:	4311      	orrs	r1, r2
    8576:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
    857a:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
}
    857e:	4770      	bx	lr
		extra |= (RADIO_PCNF0_PLEN_16bit << RADIO_PCNF0_PLEN_Pos) &
    8580:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    8584:	e7dd      	b.n	8542 <radio_pkt_configure+0xe>
    8586:	bf00      	nop
    8588:	40001000 	.word	0x40001000
    858c:	fef80000 	.word	0xfef80000

00008590 <radio_pkt_rx_set>:
	NRF_RADIO->PACKETPTR = (u32_t)rx_packet;
    8590:	4b01      	ldr	r3, [pc, #4]	; (8598 <radio_pkt_rx_set+0x8>)
    8592:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
}
    8596:	4770      	bx	lr
    8598:	40001000 	.word	0x40001000

0000859c <radio_pkt_tx_set>:
	NRF_RADIO->PACKETPTR = (u32_t)tx_packet;
    859c:	4b01      	ldr	r3, [pc, #4]	; (85a4 <radio_pkt_tx_set+0x8>)
    859e:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
}
    85a2:	4770      	bx	lr
    85a4:	40001000 	.word	0x40001000

000085a8 <radio_rx_enable>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    85a8:	4b01      	ldr	r3, [pc, #4]	; (85b0 <radio_rx_enable+0x8>)
    85aa:	2201      	movs	r2, #1
    85ac:	601a      	str	r2, [r3, #0]
}
    85ae:	4770      	bx	lr
    85b0:	40001004 	.word	0x40001004

000085b4 <radio_disable>:
    p_reg->CHENCLR = mask;
    85b4:	4a07      	ldr	r2, [pc, #28]	; (85d4 <radio_disable+0x20>)
    85b6:	f44f 6390 	mov.w	r3, #1152	; 0x480
    85ba:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    p_reg->TASKS_CHG[(uint32_t) group].EN = 1UL;
}

NRF_STATIC_INLINE void nrf_ppi_group_disable(NRF_PPI_Type * p_reg, nrf_ppi_channel_group_t group)
{
    p_reg->TASKS_CHG[(uint32_t) group].DIS = 1UL;
    85be:	2301      	movs	r3, #1
    85c0:	6053      	str	r3, [r2, #4]
    85c2:	60d3      	str	r3, [r2, #12]
	NRF_RADIO->SHORTS = 0;
    85c4:	f5a2 32f0 	sub.w	r2, r2, #122880	; 0x1e000
    85c8:	2100      	movs	r1, #0
    85ca:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
    85ce:	3210      	adds	r2, #16
    85d0:	6013      	str	r3, [r2, #0]
}
    85d2:	4770      	bx	lr
    85d4:	4001f000 	.word	0x4001f000

000085d8 <radio_status_reset>:
	NRF_RADIO->EVENTS_READY = 0;
    85d8:	4b04      	ldr	r3, [pc, #16]	; (85ec <radio_status_reset+0x14>)
    85da:	2200      	movs	r2, #0
    85dc:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	NRF_RADIO->EVENTS_END = 0;
    85e0:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
	NRF_RADIO->EVENTS_DISABLED = 0;
    85e4:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
}
    85e8:	4770      	bx	lr
    85ea:	bf00      	nop
    85ec:	40001000 	.word	0x40001000

000085f0 <radio_is_ready>:
	return (NRF_RADIO->EVENTS_READY != 0);
    85f0:	4b03      	ldr	r3, [pc, #12]	; (8600 <radio_is_ready+0x10>)
    85f2:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
}
    85f6:	3800      	subs	r0, #0
    85f8:	bf18      	it	ne
    85fa:	2001      	movne	r0, #1
    85fc:	4770      	bx	lr
    85fe:	bf00      	nop
    8600:	40001000 	.word	0x40001000

00008604 <radio_is_done>:
	return (NRF_RADIO->EVENTS_PHYEND != 0);
    8604:	4b03      	ldr	r3, [pc, #12]	; (8614 <radio_is_done+0x10>)
    8606:	f8d3 016c 	ldr.w	r0, [r3, #364]	; 0x16c
}
    860a:	3800      	subs	r0, #0
    860c:	bf18      	it	ne
    860e:	2001      	movne	r0, #1
    8610:	4770      	bx	lr
    8612:	bf00      	nop
    8614:	40001000 	.word	0x40001000

00008618 <radio_has_disabled>:
	return (NRF_RADIO->EVENTS_DISABLED != 0);
    8618:	4b03      	ldr	r3, [pc, #12]	; (8628 <radio_has_disabled+0x10>)
    861a:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
}
    861e:	3800      	subs	r0, #0
    8620:	bf18      	it	ne
    8622:	2001      	movne	r0, #1
    8624:	4770      	bx	lr
    8626:	bf00      	nop
    8628:	40001000 	.word	0x40001000

0000862c <isr_radio>:
{
    862c:	b508      	push	{r3, lr}
	if (radio_has_disabled()) {
    862e:	f7ff fff3 	bl	8618 <radio_has_disabled>
    8632:	b120      	cbz	r0, 863e <isr_radio+0x12>
		isr_cb(isr_cb_param);
    8634:	4b02      	ldr	r3, [pc, #8]	; (8640 <isr_radio+0x14>)
    8636:	681b      	ldr	r3, [r3, #0]
    8638:	4a02      	ldr	r2, [pc, #8]	; (8644 <isr_radio+0x18>)
    863a:	6810      	ldr	r0, [r2, #0]
    863c:	4798      	blx	r3
}
    863e:	bd08      	pop	{r3, pc}
    8640:	20004d34 	.word	0x20004d34
    8644:	20004d38 	.word	0x20004d38

00008648 <radio_is_idle>:
	return (NRF_RADIO->STATE == 0);
    8648:	4b03      	ldr	r3, [pc, #12]	; (8658 <radio_is_idle+0x10>)
    864a:	f8d3 0550 	ldr.w	r0, [r3, #1360]	; 0x550
}
    864e:	fab0 f080 	clz	r0, r0
    8652:	0940      	lsrs	r0, r0, #5
    8654:	4770      	bx	lr
    8656:	bf00      	nop
    8658:	40001000 	.word	0x40001000

0000865c <radio_crc_configure>:
	NRF_RADIO->CRCCNF =
    865c:	4b04      	ldr	r3, [pc, #16]	; (8670 <radio_crc_configure+0x14>)
    865e:	f240 1203 	movw	r2, #259	; 0x103
    8662:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
	NRF_RADIO->CRCPOLY = polynomial;
    8666:	f8c3 0538 	str.w	r0, [r3, #1336]	; 0x538
	NRF_RADIO->CRCINIT = iv;
    866a:	f8c3 153c 	str.w	r1, [r3, #1340]	; 0x53c
}
    866e:	4770      	bx	lr
    8670:	40001000 	.word	0x40001000

00008674 <radio_crc_is_valid>:
	return (NRF_RADIO->CRCSTATUS != 0);
    8674:	4b03      	ldr	r3, [pc, #12]	; (8684 <radio_crc_is_valid+0x10>)
    8676:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
    867a:	3800      	subs	r0, #0
    867c:	bf18      	it	ne
    867e:	2001      	movne	r0, #1
    8680:	4770      	bx	lr
    8682:	bf00      	nop
    8684:	40001000 	.word	0x40001000

00008688 <radio_pkt_scratch_get>:
}
    8688:	4800      	ldr	r0, [pc, #0]	; (868c <radio_pkt_scratch_get+0x4>)
    868a:	4770      	bx	lr
    868c:	20004c30 	.word	0x20004c30

00008690 <radio_switch_complete_and_rx>:
#endif /* CONFIG_BT_CTLR_TIFS_HW */

void radio_switch_complete_and_rx(u8_t phy_rx)
{
    8690:	b500      	push	{lr}
    8692:	b083      	sub	sp, #12
    8694:	4603      	mov	r3, r0

	//printk("b\n");
#endif /* CONFIG_CTLR_DF_SUBSYSTEM */
#else /* !CONFIG_BT_CTLR_TIFS_HW */
#if defined(CONFIG_BT_CTLR_DF_SUBSYSTEM)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
    8696:	4a06      	ldr	r2, [pc, #24]	; (86b0 <radio_switch_complete_and_rx+0x20>)
    8698:	4906      	ldr	r1, [pc, #24]	; (86b4 <radio_switch_complete_and_rx+0x24>)
    869a:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
			    RADIO_SHORTS_PHYEND_DISABLE_Msk;
	sw_switch(0, 0, 0, phy_rx, 0);
    869e:	2000      	movs	r0, #0
    86a0:	9000      	str	r0, [sp, #0]
    86a2:	4602      	mov	r2, r0
    86a4:	4601      	mov	r1, r0
    86a6:	f7ff fe51 	bl	834c <sw_switch>
			    RADIO_SHORTS_END_DISABLE_Msk;
	sw_switch(0, 0, 0, phy_rx, 0);
	//printk("d\n");
#endif /* CONFIG_CTLR_DF_SUBSYSTEM */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
    86aa:	b003      	add	sp, #12
    86ac:	f85d fb04 	ldr.w	pc, [sp], #4
    86b0:	40001000 	.word	0x40001000
    86b4:	00100001 	.word	0x00100001

000086b8 <radio_switch_complete_and_tx>:

void radio_switch_complete_and_tx(u8_t phy_rx, u8_t flags_rx, u8_t phy_tx,
				  u8_t flags_tx)
{
    86b8:	b530      	push	{r4, r5, lr}
    86ba:	b083      	sub	sp, #12

	//printk("f\n");
#endif /* CONFIG_CTLR_DF_SUBSYSTEM */
#else /* !CONFIG_BT_CTLR_TIFS_HW */
#if defined(CONFIG_BT_CTLR_DF_SUBSYSTEM)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
    86bc:	4c06      	ldr	r4, [pc, #24]	; (86d8 <radio_switch_complete_and_tx+0x20>)
    86be:	4d07      	ldr	r5, [pc, #28]	; (86dc <radio_switch_complete_and_tx+0x24>)
    86c0:	f8c4 5200 	str.w	r5, [r4, #512]	; 0x200
			    RADIO_SHORTS_PHYEND_DISABLE_Msk;
	sw_switch(1, phy_rx, flags_rx, phy_tx, flags_tx);
    86c4:	9300      	str	r3, [sp, #0]
    86c6:	4613      	mov	r3, r2
    86c8:	460a      	mov	r2, r1
    86ca:	4601      	mov	r1, r0
    86cc:	2001      	movs	r0, #1
    86ce:	f7ff fe3d 	bl	834c <sw_switch>
	sw_switch(1, phy_rx, flags_rx, phy_tx, flags_tx);

	//printk("h\n");
#endif /* CONFIG_CTLR_DF_SUBSYSTEM */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
    86d2:	b003      	add	sp, #12
    86d4:	bd30      	pop	{r4, r5, pc}
    86d6:	bf00      	nop
    86d8:	40001000 	.word	0x40001000
    86dc:	00100001 	.word	0x00100001

000086e0 <radio_rssi_measure>:
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}

void radio_rssi_measure(void)
{
	NRF_RADIO->SHORTS |=
    86e0:	4a03      	ldr	r2, [pc, #12]	; (86f0 <radio_rssi_measure+0x10>)
    86e2:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
    86e6:	f443 7388 	orr.w	r3, r3, #272	; 0x110
    86ea:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
	    (RADIO_SHORTS_ADDRESS_RSSISTART_Msk |
	     RADIO_SHORTS_DISABLED_RSSISTOP_Msk);
}
    86ee:	4770      	bx	lr
    86f0:	40001000 	.word	0x40001000

000086f4 <radio_rssi_get>:

u32_t radio_rssi_get(void)
{
	return NRF_RADIO->RSSISAMPLE;
    86f4:	4b01      	ldr	r3, [pc, #4]	; (86fc <radio_rssi_get+0x8>)
    86f6:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
}
    86fa:	4770      	bx	lr
    86fc:	40001000 	.word	0x40001000

00008700 <radio_rssi_status_reset>:

void radio_rssi_status_reset(void)
{
	NRF_RADIO->EVENTS_RSSIEND = 0;
    8700:	4b02      	ldr	r3, [pc, #8]	; (870c <radio_rssi_status_reset+0xc>)
    8702:	2200      	movs	r2, #0
    8704:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
}
    8708:	4770      	bx	lr
    870a:	bf00      	nop
    870c:	40001000 	.word	0x40001000

00008710 <radio_rssi_is_ready>:

u32_t radio_rssi_is_ready(void)
{
	return (NRF_RADIO->EVENTS_RSSIEND != 0);
    8710:	4b03      	ldr	r3, [pc, #12]	; (8720 <radio_rssi_is_ready+0x10>)
    8712:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
}
    8716:	3800      	subs	r0, #0
    8718:	bf18      	it	ne
    871a:	2001      	movne	r0, #1
    871c:	4770      	bx	lr
    871e:	bf00      	nop
    8720:	40001000 	.word	0x40001000

00008724 <radio_filter_configure>:

void radio_filter_configure(u8_t bitmask_enable, u8_t bitmask_addr_type,
			    u8_t *bdaddr)
{
    8724:	b470      	push	{r4, r5, r6}
	u8_t index;

	for (index = 0U; index < 8; index++) {
    8726:	2400      	movs	r4, #0
    8728:	e019      	b.n	875e <radio_filter_configure+0x3a>
		NRF_RADIO->DAB[index] = ((u32_t)bdaddr[3] << 24) |
    872a:	78d5      	ldrb	r5, [r2, #3]
			((u32_t)bdaddr[2] << 16) |
    872c:	7893      	ldrb	r3, [r2, #2]
    872e:	041b      	lsls	r3, r3, #16
		NRF_RADIO->DAB[index] = ((u32_t)bdaddr[3] << 24) |
    8730:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
			((u32_t)bdaddr[1] << 8) |
    8734:	7855      	ldrb	r5, [r2, #1]
			((u32_t)bdaddr[2] << 16) |
    8736:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
			bdaddr[0];
    873a:	7815      	ldrb	r5, [r2, #0]
			((u32_t)bdaddr[1] << 8) |
    873c:	432b      	orrs	r3, r5
		NRF_RADIO->DAB[index] = ((u32_t)bdaddr[3] << 24) |
    873e:	4d0c      	ldr	r5, [pc, #48]	; (8770 <radio_filter_configure+0x4c>)
    8740:	f504 76c0 	add.w	r6, r4, #384	; 0x180
    8744:	f845 3026 	str.w	r3, [r5, r6, lsl #2]
		NRF_RADIO->DAP[index] = ((u32_t)bdaddr[5] << 8) | bdaddr[4];
    8748:	7956      	ldrb	r6, [r2, #5]
    874a:	7913      	ldrb	r3, [r2, #4]
    874c:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
    8750:	f504 76c4 	add.w	r6, r4, #392	; 0x188
    8754:	f845 3026 	str.w	r3, [r5, r6, lsl #2]
		bdaddr += 6;
    8758:	3206      	adds	r2, #6
	for (index = 0U; index < 8; index++) {
    875a:	3401      	adds	r4, #1
    875c:	b2e4      	uxtb	r4, r4
    875e:	2c07      	cmp	r4, #7
    8760:	d9e3      	bls.n	872a <radio_filter_configure+0x6>
	}

	NRF_RADIO->DACNF = ((u32_t)bitmask_addr_type << 8) | bitmask_enable;
    8762:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
    8766:	4b02      	ldr	r3, [pc, #8]	; (8770 <radio_filter_configure+0x4c>)
    8768:	f8c3 0640 	str.w	r0, [r3, #1600]	; 0x640
}
    876c:	bc70      	pop	{r4, r5, r6}
    876e:	4770      	bx	lr
    8770:	40001000 	.word	0x40001000

00008774 <radio_filter_disable>:

void radio_filter_disable(void)
{
	NRF_RADIO->DACNF &= ~(0x000000FF);
    8774:	4a03      	ldr	r2, [pc, #12]	; (8784 <radio_filter_disable+0x10>)
    8776:	f8d2 3640 	ldr.w	r3, [r2, #1600]	; 0x640
    877a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    877e:	f8c2 3640 	str.w	r3, [r2, #1600]	; 0x640
}
    8782:	4770      	bx	lr
    8784:	40001000 	.word	0x40001000

00008788 <radio_filter_status_reset>:

void radio_filter_status_reset(void)
{
	NRF_RADIO->EVENTS_DEVMATCH = 0;
    8788:	4b02      	ldr	r3, [pc, #8]	; (8794 <radio_filter_status_reset+0xc>)
    878a:	2200      	movs	r2, #0
    878c:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
    8790:	4770      	bx	lr
    8792:	bf00      	nop
    8794:	40001000 	.word	0x40001000

00008798 <radio_filter_has_match>:

u32_t radio_filter_has_match(void)
{
	return (NRF_RADIO->EVENTS_DEVMATCH != 0);
    8798:	4b03      	ldr	r3, [pc, #12]	; (87a8 <radio_filter_has_match+0x10>)
    879a:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
    879e:	3800      	subs	r0, #0
    87a0:	bf18      	it	ne
    87a2:	2001      	movne	r0, #1
    87a4:	4770      	bx	lr
    87a6:	bf00      	nop
    87a8:	40001000 	.word	0x40001000

000087ac <radio_filter_match_get>:

u32_t radio_filter_match_get(void)
{
	return NRF_RADIO->DAI;
    87ac:	4b01      	ldr	r3, [pc, #4]	; (87b4 <radio_filter_match_get+0x8>)
    87ae:	f8d3 0410 	ldr.w	r0, [r3, #1040]	; 0x410
}
    87b2:	4770      	bx	lr
    87b4:	40001000 	.word	0x40001000

000087b8 <radio_bc_status_reset>:
	NRF_RADIO->SHORTS |= RADIO_SHORTS_ADDRESS_BCSTART_Msk;
}

void radio_bc_status_reset(void)
{
	NRF_RADIO->EVENTS_BCMATCH = 0;
    87b8:	4b02      	ldr	r3, [pc, #8]	; (87c4 <radio_bc_status_reset+0xc>)
    87ba:	2200      	movs	r2, #0
    87bc:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
}
    87c0:	4770      	bx	lr
    87c2:	bf00      	nop
    87c4:	40001000 	.word	0x40001000

000087c8 <radio_bc_has_match>:

u32_t radio_bc_has_match(void)
{
	return (NRF_RADIO->EVENTS_BCMATCH != 0);
    87c8:	4b03      	ldr	r3, [pc, #12]	; (87d8 <radio_bc_has_match+0x10>)
    87ca:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128
}
    87ce:	3800      	subs	r0, #0
    87d0:	bf18      	it	ne
    87d2:	2001      	movne	r0, #1
    87d4:	4770      	bx	lr
    87d6:	bf00      	nop
    87d8:	40001000 	.word	0x40001000

000087dc <radio_tmr_status_reset>:
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
    87dc:	4b05      	ldr	r3, [pc, #20]	; (87f4 <radio_tmr_status_reset+0x18>)
    87de:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    87e2:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
    p_reg->CHENCLR = mask;
    87e6:	f503 33a0 	add.w	r3, r3, #81920	; 0x14000
    87ea:	4a03      	ldr	r2, [pc, #12]	; (87f8 <radio_tmr_status_reset+0x1c>)
    87ec:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
			BIT(HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI) |
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
			BIT(HAL_TRIGGER_CRYPT_PPI));
}
    87f0:	4770      	bx	lr
    87f2:	bf00      	nop
    87f4:	4000b000 	.word	0x4000b000
    87f8:	0e700060 	.word	0x0e700060

000087fc <radio_tmr_tifs_set>:
void radio_tmr_tifs_set(u32_t tifs)
{
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->TIFS = tifs;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	nrf_timer_cc_set(SW_SWITCH_TIMER,
    87fc:	4b03      	ldr	r3, [pc, #12]	; (880c <radio_tmr_tifs_set+0x10>)
    87fe:	781b      	ldrb	r3, [r3, #0]
    p_reg->CC[cc_channel] = cc_value;
    8800:	f503 73a8 	add.w	r3, r3, #336	; 0x150
    8804:	4a02      	ldr	r2, [pc, #8]	; (8810 <radio_tmr_tifs_set+0x14>)
    8806:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
			 SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle), tifs);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
    880a:	4770      	bx	lr
    880c:	20005952 	.word	0x20005952
    8810:	40009000 	.word	0x40009000

00008814 <radio_tmr_start>:

u32_t radio_tmr_start(u8_t trx, u32_t ticks_start, u32_t remainder)
{
    8814:	b470      	push	{r4, r5, r6}
    8816:	4604      	mov	r4, r0
	if ((!(remainder / 1000000UL)) || (remainder & 0x80000000)) {
    8818:	f5a2 2374 	sub.w	r3, r2, #999424	; 0xf4000
    881c:	f5a3 7310 	sub.w	r3, r3, #576	; 0x240
    8820:	4834      	ldr	r0, [pc, #208]	; (88f4 <radio_tmr_start+0xe0>)
    8822:	4283      	cmp	r3, r0
    8824:	d906      	bls.n	8834 <radio_tmr_start+0x20>
		ticks_start--;
    8826:	3901      	subs	r1, #1
		remainder += 30517578UL;
    8828:	f102 72e8 	add.w	r2, r2, #30408704	; 0x1d00000
    882c:	f502 32d4 	add.w	r2, r2, #108544	; 0x1a800
    8830:	f502 72a5 	add.w	r2, r2, #330	; 0x14a
	}
	remainder /= 1000000UL;
    8834:	4830      	ldr	r0, [pc, #192]	; (88f8 <radio_tmr_start+0xe4>)
    8836:	fba0 3202 	umull	r3, r2, r0, r2
    883a:	0c90      	lsrs	r0, r2, #18
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    883c:	4b2f      	ldr	r3, [pc, #188]	; (88fc <radio_tmr_start+0xe8>)
    883e:	2201      	movs	r2, #1
    8840:	601a      	str	r2, [r3, #0]

	nrf_timer_task_trigger(EVENT_TIMER, NRF_TIMER_TASK_CLEAR);
	EVENT_TIMER->MODE = 0;
    8842:	3b0c      	subs	r3, #12
    8844:	2200      	movs	r2, #0
    8846:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	EVENT_TIMER->PRESCALER = 4;
    884a:	2204      	movs	r2, #4
    884c:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
    8850:	2202      	movs	r2, #2
    8852:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    p_reg->CC[cc_channel] = cc_value;
    8856:	f8c3 0540 	str.w	r0, [r3, #1344]	; 0x540
    p_reg->CC[ch] = cc_val;
    885a:	4a29      	ldr	r2, [pc, #164]	; (8900 <radio_tmr_start+0xec>)
    885c:	f8c2 1548 	str.w	r1, [r2, #1352]	; 0x548
    p_reg->EVTENSET = mask;
    8860:	f44f 2180 	mov.w	r1, #262144	; 0x40000
    8864:	f8c2 1344 	str.w	r1, [r2, #836]	; 0x344
    p_reg->CH[(uint32_t) channel].EEP = eep;
    8868:	f502 32a0 	add.w	r2, r2, #81920	; 0x14000
    886c:	4925      	ldr	r1, [pc, #148]	; (8904 <radio_tmr_start+0xf0>)
    886e:	f8c2 1538 	str.w	r1, [r2, #1336]	; 0x538
    p_reg->CH[(uint32_t) channel].TEP = tep;
    8872:	f8c2 353c 	str.w	r3, [r2, #1340]	; 0x53c
    p_reg->CHENSET = mask;
    8876:	2320      	movs	r3, #32
    8878:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
	nrf_ppi_channels_disable(
    887c:	b3a4      	cbz	r4, 88e8 <radio_tmr_start+0xd4>
    887e:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    p_reg->CHENCLR = mask;
    8882:	4b21      	ldr	r3, [pc, #132]	; (8908 <radio_tmr_start+0xf4>)
    8884:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
	nrf_ppi_channels_enable(
    8888:	b38c      	cbz	r4, 88ee <radio_tmr_start+0xda>
    888a:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    p_reg->CHENSET = mask;
    888e:	4b1e      	ldr	r3, [pc, #120]	; (8908 <radio_tmr_start+0xf4>)
    8890:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    8894:	491d      	ldr	r1, [pc, #116]	; (890c <radio_tmr_start+0xf8>)
    8896:	2401      	movs	r4, #1
    8898:	600c      	str	r4, [r1, #0]
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	last_pdu_end_us = 0U;

#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_CLEAR);
	SW_SWITCH_TIMER->MODE = 0;
    889a:	4a1d      	ldr	r2, [pc, #116]	; (8910 <radio_tmr_start+0xfc>)
    889c:	2500      	movs	r5, #0
    889e:	f8c2 5504 	str.w	r5, [r2, #1284]	; 0x504
	SW_SWITCH_TIMER->PRESCALER = 4;
    88a2:	2604      	movs	r6, #4
    88a4:	f8c2 6510 	str.w	r6, [r2, #1296]	; 0x510
	SW_SWITCH_TIMER->BITMODE = 0; /* 16 bit */
    88a8:	f8c2 5508 	str.w	r5, [r2, #1288]	; 0x508
    88ac:	6014      	str	r4, [r2, #0]
    p_reg->CH[(uint32_t) channel].EEP = eep;
    88ae:	f5a2 42fd 	sub.w	r2, r2, #32384	; 0x7e80
    88b2:	3a14      	subs	r2, #20
    88b4:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    p_reg->CH[(uint32_t) channel].TEP = tep;
    88b8:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
    p_reg->CH[(uint32_t) channel].EEP = eep;
    88bc:	f502 42ff 	add.w	r2, r2, #32640	; 0x7f80
    88c0:	3254      	adds	r2, #84	; 0x54
    88c2:	f8c3 2550 	str.w	r2, [r3, #1360]	; 0x550
    p_reg->CH[(uint32_t) channel].TEP = tep;
    88c6:	f502 32af 	add.w	r2, r2, #89600	; 0x15e00
    88ca:	32c4      	adds	r2, #196	; 0xc4
    88cc:	f8c3 2554 	str.w	r2, [r3, #1364]	; 0x554
    p_reg->CH[(uint32_t) channel].EEP = eep;
    88d0:	f5a2 32af 	sub.w	r2, r2, #89600	; 0x15e00
    88d4:	3ac0      	subs	r2, #192	; 0xc0
    88d6:	f8c3 2558 	str.w	r2, [r3, #1368]	; 0x558
    p_reg->CH[(uint32_t) channel].TEP = tep;
    88da:	f502 32af 	add.w	r2, r2, #89600	; 0x15e00
    88de:	32c8      	adds	r2, #200	; 0xc8
    88e0:	f8c3 255c 	str.w	r2, [r3, #1372]	; 0x55c
	 */
#endif /* CONFIG_BT_CTLR_PHY_CODED && CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder;
}
    88e4:	bc70      	pop	{r4, r5, r6}
    88e6:	4770      	bx	lr
	nrf_ppi_channels_disable(
    88e8:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    88ec:	e7c9      	b.n	8882 <radio_tmr_start+0x6e>
	nrf_ppi_channels_enable(
    88ee:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    88f2:	e7cc      	b.n	888e <radio_tmr_start+0x7a>
    88f4:	7ff0bdbf 	.word	0x7ff0bdbf
    88f8:	431bde83 	.word	0x431bde83
    88fc:	4000800c 	.word	0x4000800c
    8900:	4000b000 	.word	0x4000b000
    8904:	4000b148 	.word	0x4000b148
    8908:	4001f000 	.word	0x4001f000
    890c:	4000900c 	.word	0x4000900c
    8910:	40009000 	.word	0x40009000

00008914 <radio_tmr_start_tick>:
    8914:	2301      	movs	r3, #1
    8916:	4a16      	ldr	r2, [pc, #88]	; (8970 <radio_tmr_start_tick+0x5c>)
    8918:	6013      	str	r3, [r2, #0]
    891a:	3208      	adds	r2, #8
    891c:	6013      	str	r3, [r2, #0]
    p_reg->CC[cc_channel] = cc_value;
    891e:	3a0c      	subs	r2, #12
    8920:	f8c2 3540 	str.w	r3, [r2, #1344]	; 0x540
    p_reg->CC[ch] = cc_val;
    8924:	4b13      	ldr	r3, [pc, #76]	; (8974 <radio_tmr_start_tick+0x60>)
    8926:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
    p_reg->EVTENSET = mask;
    892a:	f44f 2180 	mov.w	r1, #262144	; 0x40000
    892e:	f8c3 1344 	str.w	r1, [r3, #836]	; 0x344
    p_reg->CH[(uint32_t) channel].EEP = eep;
    8932:	f503 33a0 	add.w	r3, r3, #81920	; 0x14000
    8936:	4910      	ldr	r1, [pc, #64]	; (8978 <radio_tmr_start_tick+0x64>)
    8938:	f8c3 1538 	str.w	r1, [r3, #1336]	; 0x538
    p_reg->CH[(uint32_t) channel].TEP = tep;
    893c:	f8c3 253c 	str.w	r2, [r3, #1340]	; 0x53c
    p_reg->CHENSET = mask;
    8940:	2220      	movs	r2, #32
    8942:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	nrf_ppi_channels_disable(
    8946:	4603      	mov	r3, r0
    8948:	b160      	cbz	r0, 8964 <radio_tmr_start_tick+0x50>
    894a:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
    p_reg->CHENCLR = mask;
    894e:	4a0b      	ldr	r2, [pc, #44]	; (897c <radio_tmr_start_tick+0x68>)
    8950:	f8c2 1508 	str.w	r1, [r2, #1288]	; 0x508
	nrf_ppi_channels_enable(
    8954:	b14b      	cbz	r3, 896a <radio_tmr_start_tick+0x56>
    8956:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    p_reg->CHENSET = mask;
    895a:	4b08      	ldr	r3, [pc, #32]	; (897c <radio_tmr_start_tick+0x68>)
    895c:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	last_pdu_end_us = 0U;
#endif /* CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder_us;
}
    8960:	2001      	movs	r0, #1
    8962:	4770      	bx	lr
	nrf_ppi_channels_disable(
    8964:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
    8968:	e7f1      	b.n	894e <radio_tmr_start_tick+0x3a>
	nrf_ppi_channels_enable(
    896a:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    896e:	e7f4      	b.n	895a <radio_tmr_start_tick+0x46>
    8970:	40008004 	.word	0x40008004
    8974:	4000b000 	.word	0x4000b000
    8978:	4000b148 	.word	0x4000b148
    897c:	4001f000 	.word	0x4001f000

00008980 <radio_tmr_stop>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    8980:	2301      	movs	r3, #1
    8982:	4a05      	ldr	r2, [pc, #20]	; (8998 <radio_tmr_stop+0x18>)
    8984:	6013      	str	r3, [r2, #0]
    8986:	320c      	adds	r2, #12
    8988:	6013      	str	r3, [r2, #0]
    898a:	f602 72f4 	addw	r2, r2, #4084	; 0xff4
    898e:	6013      	str	r3, [r2, #0]
    8990:	320c      	adds	r2, #12
    8992:	6013      	str	r3, [r2, #0]

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_STOP);
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_SHUTDOWN);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
    8994:	4770      	bx	lr
    8996:	bf00      	nop
    8998:	40008004 	.word	0x40008004

0000899c <radio_tmr_hcto_configure>:
    p_reg->CC[cc_channel] = cc_value;
    899c:	4b04      	ldr	r3, [pc, #16]	; (89b0 <radio_tmr_hcto_configure+0x14>)
    899e:	f8c3 0544 	str.w	r0, [r3, #1348]	; 0x544
    89a2:	f503 33b8 	add.w	r3, r3, #94208	; 0x17000
    89a6:	f04f 6288 	mov.w	r2, #71303168	; 0x4400000
    89aa:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_disable_on_hcto_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI) |
		BIT(HAL_RADIO_DISABLE_ON_HCTO_PPI));
}
    89ae:	4770      	bx	lr
    89b0:	40008000 	.word	0x40008000

000089b4 <radio_tmr_end_capture>:
    89b4:	4b02      	ldr	r3, [pc, #8]	; (89c0 <radio_tmr_end_capture+0xc>)
    89b6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    89ba:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504

void radio_tmr_end_capture(void)
{
	hal_radio_end_time_capture_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_RADIO_END_TIME_CAPTURE_PPI));
}
    89be:	4770      	bx	lr
    89c0:	4001f000 	.word	0x4001f000

000089c4 <radio_tmr_end_get>:
u32_t radio_tmr_end_get(void)
{
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	return last_pdu_end_us;
#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	return EVENT_TIMER->CC[2];
    89c4:	4b01      	ldr	r3, [pc, #4]	; (89cc <radio_tmr_end_get+0x8>)
    89c6:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
#endif /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
}
    89ca:	4770      	bx	lr
    89cc:	40008000 	.word	0x40008000

000089d0 <radio_ar_match_get>:
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_TRIGGER_AAR_PPI));
}

u32_t radio_ar_match_get(void)
{
	return NRF_AAR->STATUS;
    89d0:	4b01      	ldr	r3, [pc, #4]	; (89d8 <radio_ar_match_get+0x8>)
    89d2:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
    89d6:	4770      	bx	lr
    89d8:	4000f000 	.word	0x4000f000

000089dc <radio_ar_status_reset>:

void radio_ar_status_reset(void)
{
    89dc:	b508      	push	{r3, lr}
	radio_bc_status_reset();
    89de:	f7ff feeb 	bl	87b8 <radio_bc_status_reset>

	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Disabled << AAR_ENABLE_ENABLE_Pos) &
    89e2:	4b02      	ldr	r3, [pc, #8]	; (89ec <radio_ar_status_reset+0x10>)
    89e4:	2200      	movs	r2, #0
    89e6:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
			  AAR_ENABLE_ENABLE_Msk;
}
    89ea:	bd08      	pop	{r3, pc}
    89ec:	4000f000 	.word	0x4000f000

000089f0 <radio_ar_has_match>:

u32_t radio_ar_has_match(void)
{
    89f0:	b508      	push	{r3, lr}
	return (radio_bc_has_match() &&
    89f2:	f7ff fee9 	bl	87c8 <radio_bc_has_match>
		NRF_AAR->EVENTS_END &&
		NRF_AAR->EVENTS_RESOLVED &&
    89f6:	b168      	cbz	r0, 8a14 <radio_ar_has_match+0x24>
		NRF_AAR->EVENTS_END &&
    89f8:	4b0a      	ldr	r3, [pc, #40]	; (8a24 <radio_ar_has_match+0x34>)
    89fa:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
	return (radio_bc_has_match() &&
    89fe:	b15b      	cbz	r3, 8a18 <radio_ar_has_match+0x28>
		NRF_AAR->EVENTS_RESOLVED &&
    8a00:	4b08      	ldr	r3, [pc, #32]	; (8a24 <radio_ar_has_match+0x34>)
    8a02:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
		NRF_AAR->EVENTS_END &&
    8a06:	b14b      	cbz	r3, 8a1c <radio_ar_has_match+0x2c>
		!NRF_AAR->EVENTS_NOTRESOLVED);
    8a08:	4b06      	ldr	r3, [pc, #24]	; (8a24 <radio_ar_has_match+0x34>)
    8a0a:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
		NRF_AAR->EVENTS_RESOLVED &&
    8a0e:	b13b      	cbz	r3, 8a20 <radio_ar_has_match+0x30>
    8a10:	2000      	movs	r0, #0
    8a12:	e000      	b.n	8a16 <radio_ar_has_match+0x26>
    8a14:	2000      	movs	r0, #0
}
    8a16:	bd08      	pop	{r3, pc}
		NRF_AAR->EVENTS_RESOLVED &&
    8a18:	2000      	movs	r0, #0
    8a1a:	e7fc      	b.n	8a16 <radio_ar_has_match+0x26>
    8a1c:	2000      	movs	r0, #0
    8a1e:	e7fa      	b.n	8a16 <radio_ar_has_match+0x26>
    8a20:	2001      	movs	r0, #1
    8a22:	e7f8      	b.n	8a16 <radio_ar_has_match+0x26>
    8a24:	4000f000 	.word	0x4000f000

00008a28 <radio_dfe_mode_set>:
 *DFE
 ****************************************************************************/
#if defined(CONFIG_BT_CTLR_DF_SUBSYSTEM)
void radio_dfe_mode_set(u8_t mode)
{
	NRF_RADIO->DFEMODE &= ~RADIO_DFEMODE_DFEOPMODE_Msk;
    8a28:	4b07      	ldr	r3, [pc, #28]	; (8a48 <radio_dfe_mode_set+0x20>)
    8a2a:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
    8a2e:	f022 0203 	bic.w	r2, r2, #3
    8a32:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
	NRF_RADIO->DFEMODE |= (mode << RADIO_DFEMODE_DFEOPMODE_Pos)
    8a36:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
			      & RADIO_DFEMODE_DFEOPMODE_Msk;
    8a3a:	f000 0003 	and.w	r0, r0, #3
	NRF_RADIO->DFEMODE |= (mode << RADIO_DFEMODE_DFEOPMODE_Pos)
    8a3e:	4302      	orrs	r2, r0
    8a40:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
}
    8a44:	4770      	bx	lr
    8a46:	bf00      	nop
    8a48:	40001000 	.word	0x40001000

00008a4c <radio_cte_inline_ctrl_set>:

void radio_cte_inline_ctrl_set(u8_t value)
{
	NRF_RADIO->CTEINLINECONF &= ~RADIO_CTEINLINECONF_CTEINLINECTRLEN_Msk;
    8a4c:	4b07      	ldr	r3, [pc, #28]	; (8a6c <radio_cte_inline_ctrl_set+0x20>)
    8a4e:	f8d3 2904 	ldr.w	r2, [r3, #2308]	; 0x904
    8a52:	f022 0201 	bic.w	r2, r2, #1
    8a56:	f8c3 2904 	str.w	r2, [r3, #2308]	; 0x904
	NRF_RADIO->CTEINLINECONF |= (value << RADIO_CTEINLINECONF_CTEINLINECTRLEN_Pos)
    8a5a:	f8d3 2904 	ldr.w	r2, [r3, #2308]	; 0x904
				    & RADIO_CTEINLINECONF_CTEINLINECTRLEN_Msk;
    8a5e:	f000 0001 	and.w	r0, r0, #1
	NRF_RADIO->CTEINLINECONF |= (value << RADIO_CTEINLINECONF_CTEINLINECTRLEN_Pos)
    8a62:	4302      	orrs	r2, r0
    8a64:	f8c3 2904 	str.w	r2, [r3, #2308]	; 0x904
}
    8a68:	4770      	bx	lr
    8a6a:	bf00      	nop
    8a6c:	40001000 	.word	0x40001000

00008a70 <radio_cte_infos1_set>:

void radio_cte_infos1_set(u8_t info)
{
	NRF_RADIO->CTEINLINECONF &= ~RADIO_CTEINLINECONF_CTEINFOINS1_Msk;
    8a70:	4b07      	ldr	r3, [pc, #28]	; (8a90 <radio_cte_infos1_set+0x20>)
    8a72:	f8d3 2904 	ldr.w	r2, [r3, #2308]	; 0x904
    8a76:	f022 0208 	bic.w	r2, r2, #8
    8a7a:	f8c3 2904 	str.w	r2, [r3, #2308]	; 0x904
	NRF_RADIO->CTEINLINECONF |= (info << RADIO_CTEINLINECONF_CTEINFOINS1_Pos)
    8a7e:	f8d3 2904 	ldr.w	r2, [r3, #2308]	; 0x904
    8a82:	00c0      	lsls	r0, r0, #3
				    & RADIO_CTEINLINECONF_CTEINFOINS1_Msk;
    8a84:	f000 0008 	and.w	r0, r0, #8
	NRF_RADIO->CTEINLINECONF |= (info << RADIO_CTEINLINECONF_CTEINFOINS1_Pos)
    8a88:	4310      	orrs	r0, r2
    8a8a:	f8c3 0904 	str.w	r0, [r3, #2308]	; 0x904
}
    8a8e:	4770      	bx	lr
    8a90:	40001000 	.word	0x40001000

00008a94 <radio_dfe_numberof8us_set>:

void radio_dfe_numberof8us_set(u8_t value)
{
	NRF_RADIO->DFECTRL1 &= ~RADIO_DFECTRL1_NUMBEROF8US_Msk;
    8a94:	4b07      	ldr	r3, [pc, #28]	; (8ab4 <radio_dfe_numberof8us_set+0x20>)
    8a96:	f8d3 2910 	ldr.w	r2, [r3, #2320]	; 0x910
    8a9a:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
    8a9e:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
	NRF_RADIO->DFECTRL1 |= (value << RADIO_DFECTRL1_NUMBEROF8US_Pos)
    8aa2:	f8d3 2910 	ldr.w	r2, [r3, #2320]	; 0x910
			       & RADIO_DFECTRL1_NUMBEROF8US_Msk;
    8aa6:	f000 003f 	and.w	r0, r0, #63	; 0x3f
	NRF_RADIO->DFECTRL1 |= (value << RADIO_DFECTRL1_NUMBEROF8US_Pos)
    8aaa:	4302      	orrs	r2, r0
    8aac:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
}
    8ab0:	4770      	bx	lr
    8ab2:	bf00      	nop
    8ab4:	40001000 	.word	0x40001000

00008ab8 <radio_dfe_inextension_set>:

void radio_dfe_inextension_set(u8_t dfe_start_pos)
{
	NRF_RADIO->DFECTRL1 &= ~RADIO_DFECTRL1_DFEINEXTENSION_Msk;
    8ab8:	4b07      	ldr	r3, [pc, #28]	; (8ad8 <radio_dfe_inextension_set+0x20>)
    8aba:	f8d3 2910 	ldr.w	r2, [r3, #2320]	; 0x910
    8abe:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    8ac2:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
	NRF_RADIO->DFECTRL1 |= (dfe_start_pos <<
    8ac6:	f8d3 2910 	ldr.w	r2, [r3, #2320]	; 0x910
    8aca:	01c0      	lsls	r0, r0, #7
			       RADIO_DFECTRL1_DFEINEXTENSION_Pos)
			       & RADIO_DFECTRL1_DFEINEXTENSION_Msk;
    8acc:	b2c0      	uxtb	r0, r0
	NRF_RADIO->DFECTRL1 |= (dfe_start_pos <<
    8ace:	4310      	orrs	r0, r2
    8ad0:	f8c3 0910 	str.w	r0, [r3, #2320]	; 0x910
}
    8ad4:	4770      	bx	lr
    8ad6:	bf00      	nop
    8ad8:	40001000 	.word	0x40001000

00008adc <radio_dfe_backoff_gain_set>:

void radio_dfe_backoff_gain_set(u8_t bck_steps)
{
	NRF_RADIO->DFECTRL1 &= ~RADIO_DFECTRL1_AGCBACKOFFGAIN_Msk;
    8adc:	4b05      	ldr	r3, [pc, #20]	; (8af4 <radio_dfe_backoff_gain_set+0x18>)
    8ade:	f8d3 2910 	ldr.w	r2, [r3, #2320]	; 0x910
    8ae2:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
    8ae6:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
	NRF_RADIO->DFECTRL1 |= (bck_steps <<
    8aea:	f8d3 2910 	ldr.w	r2, [r3, #2320]	; 0x910
    8aee:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
				RADIO_CTEINLINECONF_CTEINLINECTRLEN_Pos) &
				RADIO_DFECTRL1_AGCBACKOFFGAIN_Msk;
}
    8af2:	4770      	bx	lr
    8af4:	40001000 	.word	0x40001000

00008af8 <radio_cte_error_handling_set>:

void radio_cte_error_handling_set(u8_t error_handling)
{
	NRF_RADIO->CTEINLINECONF &= ~RADIO_CTEINLINECONF_CTEERRORHANDLING_Msk;
    8af8:	4b07      	ldr	r3, [pc, #28]	; (8b18 <radio_cte_error_handling_set+0x20>)
    8afa:	f8d3 2904 	ldr.w	r2, [r3, #2308]	; 0x904
    8afe:	f022 0210 	bic.w	r2, r2, #16
    8b02:	f8c3 2904 	str.w	r2, [r3, #2308]	; 0x904
	NRF_RADIO->CTEINLINECONF |= (error_handling <<
    8b06:	f8d3 2904 	ldr.w	r2, [r3, #2308]	; 0x904
    8b0a:	0100      	lsls	r0, r0, #4
				    RADIO_CTEINLINECONF_CTEERRORHANDLING_Pos) &
    8b0c:	f000 0010 	and.w	r0, r0, #16
	NRF_RADIO->CTEINLINECONF |= (error_handling <<
    8b10:	4310      	orrs	r0, r2
    8b12:	f8c3 0904 	str.w	r0, [r3, #2308]	; 0x904
				    RADIO_CTEINLINECONF_CTEERRORHANDLING_Msk;
}
    8b16:	4770      	bx	lr
    8b18:	40001000 	.word	0x40001000

00008b1c <radio_dfe_tsampleoffset_set>:

void radio_dfe_tsampleoffset_set(s16_t offset)
{
	NRF_RADIO->DFECTRL2 &= ~RADIO_DFECTRL2_TSAMPLEOFFSET_Msk;
    8b1c:	4a08      	ldr	r2, [pc, #32]	; (8b40 <radio_dfe_tsampleoffset_set+0x24>)
    8b1e:	f8d2 3914 	ldr.w	r3, [r2, #2324]	; 0x914
    8b22:	f023 637f 	bic.w	r3, r3, #267386880	; 0xff00000
    8b26:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    8b2a:	f8c2 3914 	str.w	r3, [r2, #2324]	; 0x914
	NRF_RADIO->DFECTRL2 |= (offset << RADIO_DFECTRL2_TSAMPLEOFFSET_Pos) &
    8b2e:	f8d2 3914 	ldr.w	r3, [r2, #2324]	; 0x914
    8b32:	4904      	ldr	r1, [pc, #16]	; (8b44 <radio_dfe_tsampleoffset_set+0x28>)
    8b34:	ea01 4100 	and.w	r1, r1, r0, lsl #16
    8b38:	430b      	orrs	r3, r1
    8b3a:	f8c2 3914 	str.w	r3, [r2, #2324]	; 0x914
			       RADIO_DFECTRL2_TSAMPLEOFFSET_Msk;
}
    8b3e:	4770      	bx	lr
    8b40:	40001000 	.word	0x40001000
    8b44:	0fff0000 	.word	0x0fff0000

00008b48 <radio_dfe_sampletype_set>:

void radio_dfe_sampletype_set(u8_t type)
{
	NRF_RADIO->DFECTRL1 &= ~RADIO_DFECTRL1_SAMPLETYPE_Msk;
    8b48:	4b07      	ldr	r3, [pc, #28]	; (8b68 <radio_dfe_sampletype_set+0x20>)
    8b4a:	f8d3 2910 	ldr.w	r2, [r3, #2320]	; 0x910
    8b4e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    8b52:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
	NRF_RADIO->DFECTRL1 |= (type << RADIO_DFECTRL1_SAMPLETYPE_Pos)
    8b56:	f8d3 2910 	ldr.w	r2, [r3, #2320]	; 0x910
    8b5a:	03c0      	lsls	r0, r0, #15
			       & RADIO_DFECTRL1_SAMPLETYPE_Msk;
    8b5c:	b280      	uxth	r0, r0
	NRF_RADIO->DFECTRL1 |= (type << RADIO_DFECTRL1_SAMPLETYPE_Pos)
    8b5e:	4310      	orrs	r0, r2
    8b60:	f8c3 0910 	str.w	r0, [r3, #2320]	; 0x910
}
    8b64:	4770      	bx	lr
    8b66:	bf00      	nop
    8b68:	40001000 	.word	0x40001000

00008b6c <radio_dfe_tsamplespacingref_set>:

void radio_dfe_tsamplespacingref_set(u8_t spacing)
{
	NRF_RADIO->DFECTRL1 &= ~RADIO_DFECTRL1_TSAMPLESPACINGREF_Msk;
    8b6c:	4b07      	ldr	r3, [pc, #28]	; (8b8c <radio_dfe_tsamplespacingref_set+0x20>)
    8b6e:	f8d3 2910 	ldr.w	r2, [r3, #2320]	; 0x910
    8b72:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
    8b76:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
	NRF_RADIO->DFECTRL1 |= (spacing << RADIO_DFECTRL1_TSAMPLESPACINGREF_Pos)
    8b7a:	f8d3 2910 	ldr.w	r2, [r3, #2320]	; 0x910
    8b7e:	0300      	lsls	r0, r0, #12
			       & RADIO_DFECTRL1_TSAMPLESPACINGREF_Msk;
    8b80:	f400 40e0 	and.w	r0, r0, #28672	; 0x7000
	NRF_RADIO->DFECTRL1 |= (spacing << RADIO_DFECTRL1_TSAMPLESPACINGREF_Pos)
    8b84:	4310      	orrs	r0, r2
    8b86:	f8c3 0910 	str.w	r0, [r3, #2320]	; 0x910
}
    8b8a:	4770      	bx	lr
    8b8c:	40001000 	.word	0x40001000

00008b90 <radio_dfe_tsamplespacing_set>:

void radio_dfe_tsamplespacing_set(u8_t spacing)
{
	NRF_RADIO->DFECTRL1 &= ~RADIO_DFECTRL1_TSAMPLESPACING_Msk;
    8b90:	4b07      	ldr	r3, [pc, #28]	; (8bb0 <radio_dfe_tsamplespacing_set+0x20>)
    8b92:	f8d3 2910 	ldr.w	r2, [r3, #2320]	; 0x910
    8b96:	f422 22e0 	bic.w	r2, r2, #458752	; 0x70000
    8b9a:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
	NRF_RADIO->DFECTRL1 |= (spacing << RADIO_DFECTRL1_TSAMPLESPACING_Pos) &
    8b9e:	f8d3 2910 	ldr.w	r2, [r3, #2320]	; 0x910
    8ba2:	0400      	lsls	r0, r0, #16
    8ba4:	f400 20e0 	and.w	r0, r0, #458752	; 0x70000
    8ba8:	4310      	orrs	r0, r2
    8baa:	f8c3 0910 	str.w	r0, [r3, #2320]	; 0x910
			       RADIO_DFECTRL1_TSAMPLESPACING_Msk;
}
    8bae:	4770      	bx	lr
    8bb0:	40001000 	.word	0x40001000

00008bb4 <radio_dfe_tswitchspacing_set>:

void radio_dfe_tswitchspacing_set(u8_t spacing)
{
	NRF_RADIO->DFECTRL1 &= ~RADIO_DFECTRL1_TSWITCHSPACING_Msk;
    8bb4:	4b07      	ldr	r3, [pc, #28]	; (8bd4 <radio_dfe_tswitchspacing_set+0x20>)
    8bb6:	f8d3 2910 	ldr.w	r2, [r3, #2320]	; 0x910
    8bba:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    8bbe:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
	NRF_RADIO->DFECTRL1 |= ((spacing << RADIO_DFECTRL1_TSWITCHSPACING_Pos)
    8bc2:	f8d3 2910 	ldr.w	r2, [r3, #2320]	; 0x910
    8bc6:	0200      	lsls	r0, r0, #8
			       & RADIO_DFECTRL1_TSWITCHSPACING_Msk);
    8bc8:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
	NRF_RADIO->DFECTRL1 |= ((spacing << RADIO_DFECTRL1_TSWITCHSPACING_Pos)
    8bcc:	4310      	orrs	r0, r2
    8bce:	f8c3 0910 	str.w	r0, [r3, #2320]	; 0x910
}
    8bd2:	4770      	bx	lr
    8bd4:	40001000 	.word	0x40001000

00008bd8 <radio_dfe_gpio_set>:

/* antennas switching related configuration */
void radio_dfe_gpio_set(const struct dfe_gpio *gpio, u8_t length)
{
	for(u8_t idx=0;idx < length; ++idx) {
    8bd8:	2300      	movs	r3, #0
    8bda:	428b      	cmp	r3, r1
    8bdc:	d210      	bcs.n	8c00 <radio_dfe_gpio_set+0x28>
{
    8bde:	b430      	push	{r4, r5}
		NRF_RADIO->PSEL.DFEGPIO[gpio[idx].reg_idx] = (gpio[idx].gpio_num /*| (RADIO_PSEL_DFEGPIO_CONNECT_Connected << RADIO_PSEL_DFEGPIO_CONNECT_Pos)*/);
    8be0:	eb00 0443 	add.w	r4, r0, r3, lsl #1
    8be4:	f810 2013 	ldrb.w	r2, [r0, r3, lsl #1]
    8be8:	7865      	ldrb	r5, [r4, #1]
    8bea:	f502 7213 	add.w	r2, r2, #588	; 0x24c
    8bee:	4c05      	ldr	r4, [pc, #20]	; (8c04 <radio_dfe_gpio_set+0x2c>)
    8bf0:	f844 5022 	str.w	r5, [r4, r2, lsl #2]
	for(u8_t idx=0;idx < length; ++idx) {
    8bf4:	3301      	adds	r3, #1
    8bf6:	b2db      	uxtb	r3, r3
    8bf8:	428b      	cmp	r3, r1
    8bfa:	d3f1      	bcc.n	8be0 <radio_dfe_gpio_set+0x8>
	}
}
    8bfc:	bc30      	pop	{r4, r5}
    8bfe:	4770      	bx	lr
    8c00:	4770      	bx	lr
    8c02:	bf00      	nop
    8c04:	40001000 	.word	0x40001000

00008c08 <radio_dfe_switch_patterns_set>:
	}
}

void radio_dfe_switch_patterns_set(const u8_t *patterns, u8_t length)
{
	NRF_RADIO->CLEARPATTERN = RADIO_CLEARPATTERN_CLEARPATTERN_Clear;
    8c08:	4b09      	ldr	r3, [pc, #36]	; (8c30 <radio_dfe_switch_patterns_set+0x28>)
    8c0a:	2201      	movs	r2, #1
    8c0c:	f8c3 292c 	str.w	r2, [r3, #2348]	; 0x92c
	for(u8_t idx=0;idx < length; ++idx) {
    8c10:	2300      	movs	r3, #0
    8c12:	428b      	cmp	r3, r1
    8c14:	d20a      	bcs.n	8c2c <radio_dfe_switch_patterns_set+0x24>
{
    8c16:	b410      	push	{r4}
		NRF_RADIO->SWITCHPATTERN = (patterns[idx] << RADIO_SWITCHPATTERN_SWITCHPATTERN_Pos) & RADIO_SWITCHPATTERN_SWITCHPATTERN_Msk;
    8c18:	5cc4      	ldrb	r4, [r0, r3]
    8c1a:	4a05      	ldr	r2, [pc, #20]	; (8c30 <radio_dfe_switch_patterns_set+0x28>)
    8c1c:	f8c2 4928 	str.w	r4, [r2, #2344]	; 0x928
	for(u8_t idx=0;idx < length; ++idx) {
    8c20:	3301      	adds	r3, #1
    8c22:	b2db      	uxtb	r3, r3
    8c24:	428b      	cmp	r3, r1
    8c26:	d3f7      	bcc.n	8c18 <radio_dfe_switch_patterns_set+0x10>
	}
}
    8c28:	bc10      	pop	{r4}
    8c2a:	4770      	bx	lr
    8c2c:	4770      	bx	lr
    8c2e:	bf00      	nop
    8c30:	40001000 	.word	0x40001000

00008c34 <radio_dfe_frequency>:

#define DFE_CARRIER_FREQUECNY (2400)
u16_t radio_dfe_frequency()
{
	return NRF_RADIO->FREQUENCY + DFE_CARRIER_FREQUECNY;
    8c34:	4b03      	ldr	r3, [pc, #12]	; (8c44 <radio_dfe_frequency+0x10>)
    8c36:	f8d3 0508 	ldr.w	r0, [r3, #1288]	; 0x508
    8c3a:	f500 6016 	add.w	r0, r0, #2400	; 0x960
}
    8c3e:	b280      	uxth	r0, r0
    8c40:	4770      	bx	lr
    8c42:	bf00      	nop
    8c44:	40001000 	.word	0x40001000

00008c48 <radio_dfe_samples_buffer_set>:

void radio_dfe_samples_buffer_set(void * buffer, u16_t words_num)
{
	NRF_RADIO->DFEPACKET.PTR = (u32_t)buffer;
    8c48:	4b02      	ldr	r3, [pc, #8]	; (8c54 <radio_dfe_samples_buffer_set+0xc>)
    8c4a:	f8c3 0950 	str.w	r0, [r3, #2384]	; 0x950
	NRF_RADIO->DFEPACKET.MAXCNT = words_num;
    8c4e:	f8c3 1954 	str.w	r1, [r3, #2388]	; 0x954
}
    8c52:	4770      	bx	lr
    8c54:	40001000 	.word	0x40001000

00008c58 <radio_dfe_get_recv_sampl_num>:

u32_t radio_dfe_get_recv_sampl_num()
{
	return NRF_RADIO->DFEPACKET.AMOUNT;
    8c58:	4b01      	ldr	r3, [pc, #4]	; (8c60 <radio_dfe_get_recv_sampl_num+0x8>)
    8c5a:	f8d3 0958 	ldr.w	r0, [r3, #2392]	; 0x958
}
    8c5e:	4770      	bx	lr
    8c60:	40001000 	.word	0x40001000

00008c64 <mayfly_enable_cb>:
#else
#error Unknown LL variant.
#endif

void mayfly_enable_cb(u8_t caller_id, u8_t callee_id, u8_t enable)
{
    8c64:	b510      	push	{r4, lr}
    8c66:	4614      	mov	r4, r2
	(void)caller_id;

	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
    8c68:	2902      	cmp	r1, #2
    8c6a:	d104      	bne.n	8c76 <mayfly_enable_cb+0x12>

	if (enable) {
    8c6c:	b184      	cbz	r4, 8c90 <mayfly_enable_cb+0x2c>
		irq_enable(HAL_SWI_JOB_IRQ);
    8c6e:	200b      	movs	r0, #11
    8c70:	f7f9 fdf4 	bl	285c <arch_irq_enable>
	} else {
		irq_disable(HAL_SWI_JOB_IRQ);
	}
}
    8c74:	bd10      	pop	{r4, pc}
	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
    8c76:	2322      	movs	r3, #34	; 0x22
    8c78:	4a07      	ldr	r2, [pc, #28]	; (8c98 <mayfly_enable_cb+0x34>)
    8c7a:	4908      	ldr	r1, [pc, #32]	; (8c9c <mayfly_enable_cb+0x38>)
    8c7c:	4808      	ldr	r0, [pc, #32]	; (8ca0 <mayfly_enable_cb+0x3c>)
    8c7e:	f004 f9d6 	bl	d02e <printk>
    8c82:	4040      	eors	r0, r0
    8c84:	f380 8811 	msr	BASEPRI, r0
    8c88:	f04f 0003 	mov.w	r0, #3
    8c8c:	df02      	svc	2
    8c8e:	e7ed      	b.n	8c6c <mayfly_enable_cb+0x8>
		irq_disable(HAL_SWI_JOB_IRQ);
    8c90:	200b      	movs	r0, #11
    8c92:	f7f9 fdf3 	bl	287c <arch_irq_disable>
}
    8c96:	e7ed      	b.n	8c74 <mayfly_enable_cb+0x10>
    8c98:	00012c28 	.word	0x00012c28
    8c9c:	00012cb0 	.word	0x00012cb0
    8ca0:	00011fec 	.word	0x00011fec

00008ca4 <mayfly_is_enabled>:

u32_t mayfly_is_enabled(u8_t caller_id, u8_t callee_id)
{
    8ca4:	b508      	push	{r3, lr}
	(void)caller_id;

	switch (callee_id) {
    8ca6:	2901      	cmp	r1, #1
    8ca8:	d014      	beq.n	8cd4 <mayfly_is_enabled+0x30>
    8caa:	2902      	cmp	r1, #2
    8cac:	d016      	beq.n	8cdc <mayfly_is_enabled+0x38>
    8cae:	b169      	cbz	r1, 8ccc <mayfly_is_enabled+0x28>

	case MAYFLY_CALL_ID_JOB:
		return irq_is_enabled(HAL_SWI_JOB_IRQ);

	default:
		LL_ASSERT(0);
    8cb0:	233c      	movs	r3, #60	; 0x3c
    8cb2:	4a0c      	ldr	r2, [pc, #48]	; (8ce4 <mayfly_is_enabled+0x40>)
    8cb4:	490c      	ldr	r1, [pc, #48]	; (8ce8 <mayfly_is_enabled+0x44>)
    8cb6:	480d      	ldr	r0, [pc, #52]	; (8cec <mayfly_is_enabled+0x48>)
    8cb8:	f004 f9b9 	bl	d02e <printk>
    8cbc:	4040      	eors	r0, r0
    8cbe:	f380 8811 	msr	BASEPRI, r0
    8cc2:	f04f 0003 	mov.w	r0, #3
    8cc6:	df02      	svc	2
		break;
	}

	return 0;
    8cc8:	2000      	movs	r0, #0
    8cca:	e002      	b.n	8cd2 <mayfly_is_enabled+0x2e>
		return irq_is_enabled(HAL_SWI_RADIO_IRQ);
    8ccc:	2018      	movs	r0, #24
    8cce:	f7f9 fde9 	bl	28a4 <arch_irq_is_enabled>
}
    8cd2:	bd08      	pop	{r3, pc}
		return irq_is_enabled(HAL_SWI_WORKER_IRQ);
    8cd4:	200b      	movs	r0, #11
    8cd6:	f7f9 fde5 	bl	28a4 <arch_irq_is_enabled>
    8cda:	e7fa      	b.n	8cd2 <mayfly_is_enabled+0x2e>
		return irq_is_enabled(HAL_SWI_JOB_IRQ);
    8cdc:	200b      	movs	r0, #11
    8cde:	f7f9 fde1 	bl	28a4 <arch_irq_is_enabled>
    8ce2:	e7f6      	b.n	8cd2 <mayfly_is_enabled+0x2e>
    8ce4:	00012c28 	.word	0x00012c28
    8ce8:	00010df0 	.word	0x00010df0
    8cec:	00011fec 	.word	0x00011fec

00008cf0 <mayfly_pend>:
#endif
	       0;
}

void mayfly_pend(u8_t caller_id, u8_t callee_id)
{
    8cf0:	b508      	push	{r3, lr}
	(void)caller_id;

	switch (callee_id) {
    8cf2:	2901      	cmp	r1, #1
    8cf4:	d015      	beq.n	8d22 <mayfly_pend+0x32>
    8cf6:	2902      	cmp	r1, #2
    8cf8:	d019      	beq.n	8d2e <mayfly_pend+0x3e>
    8cfa:	b161      	cbz	r1, 8d16 <mayfly_pend+0x26>
	case MAYFLY_CALL_ID_JOB:
		hal_swi_job_pend();
		break;

	default:
		LL_ASSERT(0);
    8cfc:	2371      	movs	r3, #113	; 0x71
    8cfe:	4a0f      	ldr	r2, [pc, #60]	; (8d3c <mayfly_pend+0x4c>)
    8d00:	490f      	ldr	r1, [pc, #60]	; (8d40 <mayfly_pend+0x50>)
    8d02:	4810      	ldr	r0, [pc, #64]	; (8d44 <mayfly_pend+0x54>)
    8d04:	f004 f993 	bl	d02e <printk>
    8d08:	4040      	eors	r0, r0
    8d0a:	f380 8811 	msr	BASEPRI, r0
    8d0e:	f04f 0003 	mov.w	r0, #3
    8d12:	df02      	svc	2
		break;
	}
}
    8d14:	e004      	b.n	8d20 <mayfly_pend+0x30>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    8d16:	4b0c      	ldr	r3, [pc, #48]	; (8d48 <mayfly_pend+0x58>)
    8d18:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    8d1c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    8d20:	bd08      	pop	{r3, pc}
    8d22:	4b09      	ldr	r3, [pc, #36]	; (8d48 <mayfly_pend+0x58>)
    8d24:	f44f 6200 	mov.w	r2, #2048	; 0x800
    8d28:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
#endif

static inline void hal_swi_worker_pend(void)
{
	NVIC_SetPendingIRQ(HAL_SWI_WORKER_IRQ);
}
    8d2c:	e7f8      	b.n	8d20 <mayfly_pend+0x30>
    8d2e:	4b06      	ldr	r3, [pc, #24]	; (8d48 <mayfly_pend+0x58>)
    8d30:	f44f 6200 	mov.w	r2, #2048	; 0x800
    8d34:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100

static inline void hal_swi_job_pend(void)
{
	NVIC_SetPendingIRQ(HAL_SWI_JOB_IRQ);
}
    8d38:	e7f2      	b.n	8d20 <mayfly_pend+0x30>
    8d3a:	bf00      	nop
    8d3c:	00012c28 	.word	0x00012c28
    8d40:	00010df0 	.word	0x00010df0
    8d44:	00011fec 	.word	0x00011fec
    8d48:	e000e100 	.word	0xe000e100

00008d4c <hal_ticker_instance0_caller_id_get>:
#else
#error Unknown LL variant.
#endif

u8_t hal_ticker_instance0_caller_id_get(u8_t user_id)
{
    8d4c:	b510      	push	{r4, lr}
    8d4e:	4604      	mov	r4, r0
	u8_t caller_id;

	LL_ASSERT(user_id < sizeof(caller_id_lut));
    8d50:	2803      	cmp	r0, #3
    8d52:	d804      	bhi.n	8d5e <hal_ticker_instance0_caller_id_get+0x12>

	caller_id = caller_id_lut[user_id];
    8d54:	4b0f      	ldr	r3, [pc, #60]	; (8d94 <hal_ticker_instance0_caller_id_get+0x48>)
    8d56:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
    8d58:	b174      	cbz	r4, 8d78 <hal_ticker_instance0_caller_id_get+0x2c>

	return caller_id;
}
    8d5a:	4620      	mov	r0, r4
    8d5c:	bd10      	pop	{r4, pc}
	LL_ASSERT(user_id < sizeof(caller_id_lut));
    8d5e:	232d      	movs	r3, #45	; 0x2d
    8d60:	4a0d      	ldr	r2, [pc, #52]	; (8d98 <hal_ticker_instance0_caller_id_get+0x4c>)
    8d62:	490e      	ldr	r1, [pc, #56]	; (8d9c <hal_ticker_instance0_caller_id_get+0x50>)
    8d64:	480e      	ldr	r0, [pc, #56]	; (8da0 <hal_ticker_instance0_caller_id_get+0x54>)
    8d66:	f004 f962 	bl	d02e <printk>
    8d6a:	4040      	eors	r0, r0
    8d6c:	f380 8811 	msr	BASEPRI, r0
    8d70:	f04f 0003 	mov.w	r0, #3
    8d74:	df02      	svc	2
    8d76:	e7ed      	b.n	8d54 <hal_ticker_instance0_caller_id_get+0x8>
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
    8d78:	2330      	movs	r3, #48	; 0x30
    8d7a:	4a07      	ldr	r2, [pc, #28]	; (8d98 <hal_ticker_instance0_caller_id_get+0x4c>)
    8d7c:	4909      	ldr	r1, [pc, #36]	; (8da4 <hal_ticker_instance0_caller_id_get+0x58>)
    8d7e:	4808      	ldr	r0, [pc, #32]	; (8da0 <hal_ticker_instance0_caller_id_get+0x54>)
    8d80:	f004 f955 	bl	d02e <printk>
    8d84:	4040      	eors	r0, r0
    8d86:	f380 8811 	msr	BASEPRI, r0
    8d8a:	f04f 0003 	mov.w	r0, #3
    8d8e:	df02      	svc	2
    8d90:	e7e3      	b.n	8d5a <hal_ticker_instance0_caller_id_get+0xe>
    8d92:	bf00      	nop
    8d94:	00012da0 	.word	0x00012da0
    8d98:	00012cd4 	.word	0x00012cd4
    8d9c:	00012d5c 	.word	0x00012d5c
    8da0:	00011fec 	.word	0x00011fec
    8da4:	00012d7c 	.word	0x00012d7c

00008da8 <hal_ticker_instance0_sched>:

void hal_ticker_instance0_sched(u8_t caller_id, u8_t callee_id, u8_t chain,
				void *instance)
{
    8da8:	b508      	push	{r3, lr}
	/* return value not checked as we allow multiple calls to schedule
	 * before being actually needing the work to complete before new
	 * schedule.
	 */
	switch (caller_id) {
    8daa:	3801      	subs	r0, #1
    8dac:	2804      	cmp	r0, #4
    8dae:	f200 8082 	bhi.w	8eb6 <hal_ticker_instance0_sched+0x10e>
    8db2:	e8df f000 	tbb	[pc, r0]
    8db6:	1a03      	.short	0x1a03
    8db8:	4831      	.short	0x4831
    8dba:	69          	.byte	0x69
    8dbb:	00          	.byte	0x00
#if defined(CONFIG_BT_LL_SW_SPLIT)
	case TICKER_CALL_ID_ISR:
		switch (callee_id) {
    8dbc:	2904      	cmp	r1, #4
    8dbe:	d00c      	beq.n	8dda <hal_ticker_instance0_sched+0x32>
				       &m);
		}
		break;

		default:
			LL_ASSERT(0);
    8dc0:	2351      	movs	r3, #81	; 0x51
    8dc2:	4a43      	ldr	r2, [pc, #268]	; (8ed0 <hal_ticker_instance0_sched+0x128>)
    8dc4:	4943      	ldr	r1, [pc, #268]	; (8ed4 <hal_ticker_instance0_sched+0x12c>)
    8dc6:	4844      	ldr	r0, [pc, #272]	; (8ed8 <hal_ticker_instance0_sched+0x130>)
    8dc8:	f004 f931 	bl	d02e <printk>
    8dcc:	4040      	eors	r0, r0
    8dce:	f380 8811 	msr	BASEPRI, r0
    8dd2:	f04f 0003 	mov.w	r0, #3
    8dd6:	df02      	svc	2

	default:
		LL_ASSERT(0);
		break;
	}
}
    8dd8:	bd08      	pop	{r3, pc}
			m.param = instance;
    8dda:	4940      	ldr	r1, [pc, #256]	; (8edc <hal_ticker_instance0_sched+0x134>)
    8ddc:	608b      	str	r3, [r1, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
    8dde:	460b      	mov	r3, r1
    8de0:	2102      	movs	r1, #2
    8de2:	2000      	movs	r0, #0
    8de4:	f7fc f964 	bl	50b0 <mayfly_enqueue>
		break;
    8de8:	e7f6      	b.n	8dd8 <hal_ticker_instance0_sched+0x30>
		switch (callee_id) {
    8dea:	2903      	cmp	r1, #3
    8dec:	d00c      	beq.n	8e08 <hal_ticker_instance0_sched+0x60>
			LL_ASSERT(0);
    8dee:	2369      	movs	r3, #105	; 0x69
    8df0:	4a37      	ldr	r2, [pc, #220]	; (8ed0 <hal_ticker_instance0_sched+0x128>)
    8df2:	4938      	ldr	r1, [pc, #224]	; (8ed4 <hal_ticker_instance0_sched+0x12c>)
    8df4:	4838      	ldr	r0, [pc, #224]	; (8ed8 <hal_ticker_instance0_sched+0x130>)
    8df6:	f004 f91a 	bl	d02e <printk>
    8dfa:	4040      	eors	r0, r0
    8dfc:	f380 8811 	msr	BASEPRI, r0
    8e00:	f04f 0003 	mov.w	r0, #3
    8e04:	df02      	svc	2
			break;
    8e06:	e7e7      	b.n	8dd8 <hal_ticker_instance0_sched+0x30>
			m.param = instance;
    8e08:	4935      	ldr	r1, [pc, #212]	; (8ee0 <hal_ticker_instance0_sched+0x138>)
    8e0a:	608b      	str	r3, [r1, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
    8e0c:	460b      	mov	r3, r1
    8e0e:	2101      	movs	r1, #1
    8e10:	4608      	mov	r0, r1
    8e12:	f7fc f94d 	bl	50b0 <mayfly_enqueue>
		break;
    8e16:	e7df      	b.n	8dd8 <hal_ticker_instance0_sched+0x30>
		switch (callee_id) {
    8e18:	2904      	cmp	r1, #4
    8e1a:	d00c      	beq.n	8e36 <hal_ticker_instance0_sched+0x8e>
			LL_ASSERT(0);
    8e1c:	2380      	movs	r3, #128	; 0x80
    8e1e:	4a2c      	ldr	r2, [pc, #176]	; (8ed0 <hal_ticker_instance0_sched+0x128>)
    8e20:	492c      	ldr	r1, [pc, #176]	; (8ed4 <hal_ticker_instance0_sched+0x12c>)
    8e22:	482d      	ldr	r0, [pc, #180]	; (8ed8 <hal_ticker_instance0_sched+0x130>)
    8e24:	f004 f903 	bl	d02e <printk>
    8e28:	4040      	eors	r0, r0
    8e2a:	f380 8811 	msr	BASEPRI, r0
    8e2e:	f04f 0003 	mov.w	r0, #3
    8e32:	df02      	svc	2
			break;
    8e34:	e7d0      	b.n	8dd8 <hal_ticker_instance0_sched+0x30>
			m.param = instance;
    8e36:	492b      	ldr	r1, [pc, #172]	; (8ee4 <hal_ticker_instance0_sched+0x13c>)
    8e38:	608b      	str	r3, [r1, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
    8e3a:	460b      	mov	r3, r1
    8e3c:	2102      	movs	r1, #2
    8e3e:	2001      	movs	r0, #1
    8e40:	f7fc f936 	bl	50b0 <mayfly_enqueue>
		break;
    8e44:	e7c8      	b.n	8dd8 <hal_ticker_instance0_sched+0x30>
		switch (callee_id) {
    8e46:	2903      	cmp	r1, #3
    8e48:	d00e      	beq.n	8e68 <hal_ticker_instance0_sched+0xc0>
    8e4a:	2904      	cmp	r1, #4
    8e4c:	d014      	beq.n	8e78 <hal_ticker_instance0_sched+0xd0>
			LL_ASSERT(0);
    8e4e:	23a6      	movs	r3, #166	; 0xa6
    8e50:	4a1f      	ldr	r2, [pc, #124]	; (8ed0 <hal_ticker_instance0_sched+0x128>)
    8e52:	4920      	ldr	r1, [pc, #128]	; (8ed4 <hal_ticker_instance0_sched+0x12c>)
    8e54:	4820      	ldr	r0, [pc, #128]	; (8ed8 <hal_ticker_instance0_sched+0x130>)
    8e56:	f004 f8ea 	bl	d02e <printk>
    8e5a:	4040      	eors	r0, r0
    8e5c:	f380 8811 	msr	BASEPRI, r0
    8e60:	f04f 0003 	mov.w	r0, #3
    8e64:	df02      	svc	2
			break;
    8e66:	e7b7      	b.n	8dd8 <hal_ticker_instance0_sched+0x30>
			m.param = instance;
    8e68:	491f      	ldr	r1, [pc, #124]	; (8ee8 <hal_ticker_instance0_sched+0x140>)
    8e6a:	608b      	str	r3, [r1, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
    8e6c:	460b      	mov	r3, r1
    8e6e:	2101      	movs	r1, #1
    8e70:	2002      	movs	r0, #2
    8e72:	f7fc f91d 	bl	50b0 <mayfly_enqueue>
		break;
    8e76:	e7af      	b.n	8dd8 <hal_ticker_instance0_sched+0x30>
			m.param = instance;
    8e78:	491c      	ldr	r1, [pc, #112]	; (8eec <hal_ticker_instance0_sched+0x144>)
    8e7a:	608b      	str	r3, [r1, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
    8e7c:	460b      	mov	r3, r1
    8e7e:	2102      	movs	r1, #2
    8e80:	4608      	mov	r0, r1
    8e82:	f7fc f915 	bl	50b0 <mayfly_enqueue>
		break;
    8e86:	e7a7      	b.n	8dd8 <hal_ticker_instance0_sched+0x30>
		switch (callee_id) {
    8e88:	2904      	cmp	r1, #4
    8e8a:	d00c      	beq.n	8ea6 <hal_ticker_instance0_sched+0xfe>
			LL_ASSERT(0);
    8e8c:	23be      	movs	r3, #190	; 0xbe
    8e8e:	4a10      	ldr	r2, [pc, #64]	; (8ed0 <hal_ticker_instance0_sched+0x128>)
    8e90:	4910      	ldr	r1, [pc, #64]	; (8ed4 <hal_ticker_instance0_sched+0x12c>)
    8e92:	4811      	ldr	r0, [pc, #68]	; (8ed8 <hal_ticker_instance0_sched+0x130>)
    8e94:	f004 f8cb 	bl	d02e <printk>
    8e98:	4040      	eors	r0, r0
    8e9a:	f380 8811 	msr	BASEPRI, r0
    8e9e:	f04f 0003 	mov.w	r0, #3
    8ea2:	df02      	svc	2
			break;
    8ea4:	e798      	b.n	8dd8 <hal_ticker_instance0_sched+0x30>
			m.param = instance;
    8ea6:	4912      	ldr	r1, [pc, #72]	; (8ef0 <hal_ticker_instance0_sched+0x148>)
    8ea8:	608b      	str	r3, [r1, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
    8eaa:	460b      	mov	r3, r1
    8eac:	2102      	movs	r1, #2
    8eae:	2003      	movs	r0, #3
    8eb0:	f7fc f8fe 	bl	50b0 <mayfly_enqueue>
		break;
    8eb4:	e790      	b.n	8dd8 <hal_ticker_instance0_sched+0x30>
		LL_ASSERT(0);
    8eb6:	23c4      	movs	r3, #196	; 0xc4
    8eb8:	4a05      	ldr	r2, [pc, #20]	; (8ed0 <hal_ticker_instance0_sched+0x128>)
    8eba:	4906      	ldr	r1, [pc, #24]	; (8ed4 <hal_ticker_instance0_sched+0x12c>)
    8ebc:	4806      	ldr	r0, [pc, #24]	; (8ed8 <hal_ticker_instance0_sched+0x130>)
    8ebe:	f004 f8b6 	bl	d02e <printk>
    8ec2:	4040      	eors	r0, r0
    8ec4:	f380 8811 	msr	BASEPRI, r0
    8ec8:	f04f 0003 	mov.w	r0, #3
    8ecc:	df02      	svc	2
}
    8ece:	e783      	b.n	8dd8 <hal_ticker_instance0_sched+0x30>
    8ed0:	00012cd4 	.word	0x00012cd4
    8ed4:	00010df0 	.word	0x00010df0
    8ed8:	00011fec 	.word	0x00011fec
    8edc:	200002cc 	.word	0x200002cc
    8ee0:	200002dc 	.word	0x200002dc
    8ee4:	200002ec 	.word	0x200002ec
    8ee8:	200002fc 	.word	0x200002fc
    8eec:	2000030c 	.word	0x2000030c
    8ef0:	2000031c 	.word	0x2000031c

00008ef4 <pool_id>:
	return &_net_buf_pool_list[id];
}

static int pool_id(struct net_buf_pool *pool)
{
	return pool - _net_buf_pool_list;
    8ef4:	4b03      	ldr	r3, [pc, #12]	; (8f04 <pool_id+0x10>)
    8ef6:	1ac0      	subs	r0, r0, r3
    8ef8:	10c0      	asrs	r0, r0, #3
}
    8efa:	4b03      	ldr	r3, [pc, #12]	; (8f08 <pool_id+0x14>)
    8efc:	fb03 f000 	mul.w	r0, r3, r0
    8f00:	4770      	bx	lr
    8f02:	bf00      	nop
    8f04:	20000500 	.word	0x20000500
    8f08:	cccccccd 	.word	0xcccccccd

00008f0c <net_buf_pool_get>:
	return &_net_buf_pool_list[id];
    8f0c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
}
    8f10:	4b01      	ldr	r3, [pc, #4]	; (8f18 <net_buf_pool_get+0xc>)
    8f12:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    8f16:	4770      	bx	lr
    8f18:	20000500 	.word	0x20000500

00008f1c <net_buf_id>:

int net_buf_id(struct net_buf *buf)
{
    8f1c:	b510      	push	{r4, lr}
    8f1e:	4604      	mov	r4, r0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    8f20:	7980      	ldrb	r0, [r0, #6]
    8f22:	f7ff fff3 	bl	8f0c <net_buf_pool_get>

	return buf - pool->__bufs;
    8f26:	6a40      	ldr	r0, [r0, #36]	; 0x24
    8f28:	1a24      	subs	r4, r4, r0
    8f2a:	10e4      	asrs	r4, r4, #3
}
    8f2c:	4801      	ldr	r0, [pc, #4]	; (8f34 <net_buf_id+0x18>)
    8f2e:	fb00 f004 	mul.w	r0, r0, r4
    8f32:	bd10      	pop	{r4, pc}
    8f34:	aaaaaaab 	.word	0xaaaaaaab

00008f38 <gpiote_channel_alloc>:
	return port->config_info;
}

static int gpiote_channel_alloc(u32_t abs_pin, nrf_gpiote_polarity_t polarity)
{
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
    8f38:	2300      	movs	r3, #0
    8f3a:	2b07      	cmp	r3, #7
    8f3c:	d842      	bhi.n	8fc4 <gpiote_channel_alloc+0x8c>
{
    8f3e:	b4f0      	push	{r4, r5, r6, r7}
    8f40:	b082      	sub	sp, #8
    p_reg->CONFIG[idx] = 0;
}

NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return (p_reg->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
    8f42:	f503 72a2 	add.w	r2, r3, #324	; 0x144
    8f46:	4c21      	ldr	r4, [pc, #132]	; (8fcc <gpiote_channel_alloc+0x94>)
    8f48:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
		if (!nrf_gpiote_te_is_enabled(NRF_GPIOTE, channel)) {
    8f4c:	f012 0f03 	tst.w	r2, #3
    8f50:	d008      	beq.n	8f64 <gpiote_channel_alloc+0x2c>
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
    8f52:	3301      	adds	r3, #1
    8f54:	b2db      	uxtb	r3, r3
    8f56:	2b07      	cmp	r3, #7
    8f58:	d9f3      	bls.n	8f42 <gpiote_channel_alloc+0xa>
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
			return 0;
		}
	}

	return -ENODEV;
    8f5a:	f06f 0012 	mvn.w	r0, #18
}
    8f5e:	b002      	add	sp, #8
    8f60:	bcf0      	pop	{r4, r5, r6, r7}
    8f62:	4770      	bx	lr
			nrf_gpiote_event_t evt =
    8f64:	f103 0240 	add.w	r2, r3, #64	; 0x40
    8f68:	0092      	lsls	r2, r2, #2
    8f6a:	b294      	uxth	r4, r2
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    8f6c:	4e17      	ldr	r6, [pc, #92]	; (8fcc <gpiote_channel_alloc+0x94>)
    8f6e:	f503 75a2 	add.w	r5, r3, #324	; 0x144
    8f72:	f856 2025 	ldr.w	r2, [r6, r5, lsl #2]
    8f76:	f422 324f 	bic.w	r2, r2, #211968	; 0x33c00
    8f7a:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    8f7e:	f846 2025 	str.w	r2, [r6, r5, lsl #2]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    8f82:	f856 7025 	ldr.w	r7, [r6, r5, lsl #2]
    8f86:	0202      	lsls	r2, r0, #8
    8f88:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
    8f8c:	0409      	lsls	r1, r1, #16
    8f8e:	f401 3140 	and.w	r1, r1, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    8f92:	430a      	orrs	r2, r1
    8f94:	433a      	orrs	r2, r7
    8f96:	f846 2025 	str.w	r2, [r6, r5, lsl #2]
    return ((uint32_t)p_reg + event);
    8f9a:	f104 4280 	add.w	r2, r4, #1073741824	; 0x40000000
    8f9e:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    8fa2:	2000      	movs	r0, #0
    8fa4:	6010      	str	r0, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
    8fa6:	6812      	ldr	r2, [r2, #0]
    8fa8:	9201      	str	r2, [sp, #4]
    (void)dummy;
    8faa:	9a01      	ldr	r2, [sp, #4]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
    8fac:	f856 2025 	ldr.w	r2, [r6, r5, lsl #2]
    8fb0:	f042 0201 	orr.w	r2, r2, #1
    8fb4:	f846 2025 	str.w	r2, [r6, r5, lsl #2]
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
    8fb8:	2201      	movs	r2, #1
    8fba:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENSET = mask;
    8fbe:	f8c6 3304 	str.w	r3, [r6, #772]	; 0x304
			return 0;
    8fc2:	e7cc      	b.n	8f5e <gpiote_channel_alloc+0x26>
	return -ENODEV;
    8fc4:	f06f 0012 	mvn.w	r0, #18
}
    8fc8:	4770      	bx	lr
    8fca:	bf00      	nop
    8fcc:	40006000 	.word	0x40006000

00008fd0 <gpiote_channel_free>:

static void gpiote_channel_free(u32_t abs_pin)
{
    8fd0:	b410      	push	{r4}
    return p_reg->INTENSET & mask;
    8fd2:	4b13      	ldr	r3, [pc, #76]	; (9020 <gpiote_channel_free+0x50>)
    8fd4:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
    8fd8:	b2e4      	uxtb	r4, r4
	u32_t intenset = nrf_gpiote_int_enable_check(NRF_GPIOTE,
						     NRF_GPIOTE_INT_IN_MASK);

	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    8fda:	2300      	movs	r3, #0
    8fdc:	e000      	b.n	8fe0 <gpiote_channel_free+0x10>
    8fde:	3301      	adds	r3, #1
    8fe0:	2b07      	cmp	r3, #7
    8fe2:	d81b      	bhi.n	901c <gpiote_channel_free+0x4c>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    8fe4:	f503 72a2 	add.w	r2, r3, #324	; 0x144
    8fe8:	490d      	ldr	r1, [pc, #52]	; (9020 <gpiote_channel_free+0x50>)
    8fea:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    8fee:	f3c2 2205 	ubfx	r2, r2, #8, #6
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
    8ff2:	4290      	cmp	r0, r2
    8ff4:	d1f3      	bne.n	8fde <gpiote_channel_free+0xe>
		    && (intenset & BIT(i))) {
    8ff6:	fa24 f203 	lsr.w	r2, r4, r3
    8ffa:	f012 0f01 	tst.w	r2, #1
    8ffe:	d0ee      	beq.n	8fde <gpiote_channel_free+0xe>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
    9000:	460a      	mov	r2, r1
    9002:	f503 70a2 	add.w	r0, r3, #324	; 0x144
    9006:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
    900a:	f021 0101 	bic.w	r1, r1, #1
    900e:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
			nrf_gpiote_event_disable(NRF_GPIOTE, i);
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
    9012:	2101      	movs	r1, #1
    9014:	fa01 f303 	lsl.w	r3, r1, r3
    p_reg->INTENCLR = mask;
    9018:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
			return;
		}
	}
}
    901c:	bc10      	pop	{r4}
    901e:	4770      	bx	lr
    9020:	40006000 	.word	0x40006000

00009024 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(struct device *port)
{
    9024:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
    9026:	4b0b      	ldr	r3, [pc, #44]	; (9054 <gpio_nrfx_init+0x30>)
    9028:	781b      	ldrb	r3, [r3, #0]
    902a:	b10b      	cbz	r3, 9030 <gpio_nrfx_init+0xc>
		irq_enable(DT_IRQN(GPIOTE_NODE));
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
    902c:	2000      	movs	r0, #0
    902e:	bd08      	pop	{r3, pc}
		gpio_initialized = true;
    9030:	4b08      	ldr	r3, [pc, #32]	; (9054 <gpio_nrfx_init+0x30>)
    9032:	2201      	movs	r2, #1
    9034:	701a      	strb	r2, [r3, #0]
		IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    9036:	2200      	movs	r2, #0
    9038:	2105      	movs	r1, #5
    903a:	2006      	movs	r0, #6
    903c:	f7f9 fc40 	bl	28c0 <z_arm_irq_priority_set>
		irq_enable(DT_IRQN(GPIOTE_NODE));
    9040:	2006      	movs	r0, #6
    9042:	f7f9 fc0b 	bl	285c <arch_irq_enable>
    p_reg->INTENSET = mask;
    9046:	4b04      	ldr	r3, [pc, #16]	; (9058 <gpio_nrfx_init+0x34>)
    9048:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    904c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    9050:	e7ec      	b.n	902c <gpio_nrfx_init+0x8>
    9052:	bf00      	nop
    9054:	20005953 	.word	0x20005953
    9058:	40006000 	.word	0x40006000

0000905c <cfg_level_pins>:
{
    905c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return port->driver_data;
    905e:	68c6      	ldr	r6, [r0, #12]
	return port->config_info;
    9060:	6847      	ldr	r7, [r0, #4]
	u32_t out = data->int_en & data->pin_int_en;
    9062:	6933      	ldr	r3, [r6, #16]
    9064:	68f2      	ldr	r2, [r6, #12]
    9066:	401a      	ands	r2, r3
	out &= ~data->trig_edge & ~data->double_edge;
    9068:	69b3      	ldr	r3, [r6, #24]
    906a:	69f1      	ldr	r1, [r6, #28]
    906c:	430b      	orrs	r3, r1
    906e:	ea22 0203 	bic.w	r2, r2, r3
	u32_t bit = 1U << pin;
    9072:	2101      	movs	r1, #1
	u32_t pin = 0U;
    9074:	2000      	movs	r0, #0
	while (level_pins) {
    9076:	e019      	b.n	90ac <cfg_level_pins+0x50>
		return NRF_GPIO_PIN_SENSE_HIGH;
    9078:	f04f 0c02 	mov.w	ip, #2
    907c:	e025      	b.n	90ca <cfg_level_pins+0x6e>
 *
 * @return Pointer to port register set.
 */
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
{
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    907e:	4b17      	ldr	r3, [pc, #92]	; (90dc <cfg_level_pins+0x80>)
    9080:	4a17      	ldr	r2, [pc, #92]	; (90e0 <cfg_level_pins+0x84>)
    9082:	f44f 71ed 	mov.w	r1, #474	; 0x1da
    9086:	4817      	ldr	r0, [pc, #92]	; (90e4 <cfg_level_pins+0x88>)
    9088:	f002 fe10 	bl	bcac <__assert_func>
#if (GPIO_COUNT == 1)
    return NRF_P0;
#else
    if (*p_pin < P0_PIN_NUM)
    {
        return NRF_P0;
    908c:	f04f 45a0 	mov.w	r5, #1342177280	; 0x50000000
NRF_STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t             pin_number,
                                              nrf_gpio_pin_sense_t sense_config)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    9090:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    9094:	f855 4023 	ldr.w	r4, [r5, r3, lsl #2]
    9098:	f424 3440 	bic.w	r4, r4, #196608	; 0x30000

    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    909c:	ea44 440c 	orr.w	r4, r4, ip, lsl #16
    90a0:	f845 4023 	str.w	r4, [r5, r3, lsl #2]
			level_pins &= ~bit;
    90a4:	ea22 0201 	bic.w	r2, r2, r1
		++pin;
    90a8:	3001      	adds	r0, #1
		bit <<= 1;
    90aa:	0049      	lsls	r1, r1, #1
	while (level_pins) {
    90ac:	b1aa      	cbz	r2, 90da <cfg_level_pins+0x7e>
		if (level_pins & bit) {
    90ae:	4211      	tst	r1, r2
    90b0:	d0fa      	beq.n	90a8 <cfg_level_pins+0x4c>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    90b2:	7a3c      	ldrb	r4, [r7, #8]
    90b4:	f000 031f 	and.w	r3, r0, #31
    90b8:	ea43 1344 	orr.w	r3, r3, r4, lsl #5
	if ((BIT(pin) & data->int_active_level) != 0U) {
    90bc:	6974      	ldr	r4, [r6, #20]
    90be:	40c4      	lsrs	r4, r0
    90c0:	f014 0f01 	tst.w	r4, #1
    90c4:	d1d8      	bne.n	9078 <cfg_level_pins+0x1c>
	return NRF_GPIO_PIN_SENSE_LOW;
    90c6:	f04f 0c03 	mov.w	ip, #3
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    90ca:	2b29      	cmp	r3, #41	; 0x29
    90cc:	d8d7      	bhi.n	907e <cfg_level_pins+0x22>
    if (*p_pin < P0_PIN_NUM)
    90ce:	2b1f      	cmp	r3, #31
    90d0:	d9dc      	bls.n	908c <cfg_level_pins+0x30>
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    90d2:	f003 031f 	and.w	r3, r3, #31
        return NRF_P1;
    90d6:	4d04      	ldr	r5, [pc, #16]	; (90e8 <cfg_level_pins+0x8c>)
    90d8:	e7da      	b.n	9090 <cfg_level_pins+0x34>
}
    90da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    90dc:	00012db8 	.word	0x00012db8
    90e0:	00012e48 	.word	0x00012e48
    90e4:	00012dcc 	.word	0x00012dcc
    90e8:	50000300 	.word	0x50000300

000090ec <check_level_trigger_pins>:
{
    90ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return port->driver_data;
    90ee:	68c2      	ldr	r2, [r0, #12]
	return port->config_info;
    90f0:	6847      	ldr	r7, [r0, #4]
	u32_t out = data->int_en & data->pin_int_en;
    90f2:	6913      	ldr	r3, [r2, #16]
    90f4:	68d1      	ldr	r1, [r2, #12]
    90f6:	400b      	ands	r3, r1
	out &= ~data->trig_edge & ~data->double_edge;
    90f8:	6991      	ldr	r1, [r2, #24]
    90fa:	69d0      	ldr	r0, [r2, #28]
    90fc:	4301      	orrs	r1, r0
    90fe:	ea23 0301 	bic.w	r3, r3, r1
	u32_t port_in = nrf_gpio_port_in_read(cfg->port);
    9102:	6879      	ldr	r1, [r7, #4]
}


NRF_STATIC_INLINE uint32_t nrf_gpio_port_in_read(NRF_GPIO_Type const * p_reg)
{
    return p_reg->IN;
    9104:	f8d1 1510 	ldr.w	r1, [r1, #1296]	; 0x510
	u32_t pin_states = ~(port_in ^ data->int_active_level);
    9108:	6950      	ldr	r0, [r2, #20]
    910a:	4048      	eors	r0, r1
	u32_t out = pin_states & level_pins;
    910c:	ea23 0000 	bic.w	r0, r3, r0
	u32_t bit = 1U << pin;
    9110:	2201      	movs	r2, #1
	u32_t pin = 0U;
    9112:	2400      	movs	r4, #0
	while (level_pins) {
    9114:	e014      	b.n	9140 <check_level_trigger_pins+0x54>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    9116:	4b13      	ldr	r3, [pc, #76]	; (9164 <check_level_trigger_pins+0x78>)
    9118:	4a13      	ldr	r2, [pc, #76]	; (9168 <check_level_trigger_pins+0x7c>)
    911a:	f44f 71ed 	mov.w	r1, #474	; 0x1da
    911e:	4813      	ldr	r0, [pc, #76]	; (916c <check_level_trigger_pins+0x80>)
    9120:	f002 fdc4 	bl	bcac <__assert_func>
        return NRF_P0;
    9124:	f04f 46a0 	mov.w	r6, #1342177280	; 0x50000000
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    9128:	f501 71e0 	add.w	r1, r1, #448	; 0x1c0
    912c:	f856 5021 	ldr.w	r5, [r6, r1, lsl #2]
    9130:	f425 3540 	bic.w	r5, r5, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    9134:	f846 5021 	str.w	r5, [r6, r1, lsl #2]
			level_pins &= ~bit;
    9138:	ea23 0302 	bic.w	r3, r3, r2
		++pin;
    913c:	3401      	adds	r4, #1
		bit <<= 1;
    913e:	0052      	lsls	r2, r2, #1
	while (level_pins) {
    9140:	b173      	cbz	r3, 9160 <check_level_trigger_pins+0x74>
		if (level_pins & bit) {
    9142:	4213      	tst	r3, r2
    9144:	d0fa      	beq.n	913c <check_level_trigger_pins+0x50>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    9146:	7a3d      	ldrb	r5, [r7, #8]
    9148:	f004 011f 	and.w	r1, r4, #31
    914c:	ea41 1145 	orr.w	r1, r1, r5, lsl #5
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    9150:	2929      	cmp	r1, #41	; 0x29
    9152:	d8e0      	bhi.n	9116 <check_level_trigger_pins+0x2a>
    if (*p_pin < P0_PIN_NUM)
    9154:	291f      	cmp	r1, #31
    9156:	d9e5      	bls.n	9124 <check_level_trigger_pins+0x38>
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    9158:	f001 011f 	and.w	r1, r1, #31
        return NRF_P1;
    915c:	4e04      	ldr	r6, [pc, #16]	; (9170 <check_level_trigger_pins+0x84>)
    915e:	e7e3      	b.n	9128 <check_level_trigger_pins+0x3c>
}
    9160:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9162:	bf00      	nop
    9164:	00012db8 	.word	0x00012db8
    9168:	00012e48 	.word	0x00012e48
    916c:	00012dcc 	.word	0x00012dcc
    9170:	50000300 	.word	0x50000300

00009174 <gpiote_pin_int_cfg>:
{
    9174:	b570      	push	{r4, r5, r6, lr}
    9176:	460d      	mov	r5, r1
	return port->driver_data;
    9178:	68c6      	ldr	r6, [r0, #12]
	return port->config_info;
    917a:	6843      	ldr	r3, [r0, #4]
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    917c:	7a1b      	ldrb	r3, [r3, #8]
    917e:	f001 041f 	and.w	r4, r1, #31
    9182:	ea44 1443 	orr.w	r4, r4, r3, lsl #5
	gpiote_channel_free(abs_pin);
    9186:	4620      	mov	r0, r4
    9188:	f7ff ff22 	bl	8fd0 <gpiote_channel_free>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    918c:	2c29      	cmp	r4, #41	; 0x29
    918e:	d828      	bhi.n	91e2 <gpiote_pin_int_cfg+0x6e>
    if (*p_pin < P0_PIN_NUM)
    9190:	2c1f      	cmp	r4, #31
    9192:	d92d      	bls.n	91f0 <gpiote_pin_int_cfg+0x7c>
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    9194:	f004 031f 	and.w	r3, r4, #31
        return NRF_P1;
    9198:	4930      	ldr	r1, [pc, #192]	; (925c <gpiote_pin_int_cfg+0xe8>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    919a:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    919e:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    91a2:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    91a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	if ((data->pin_int_en & BIT(pin)) && (data->int_en & BIT(pin))) {
    91aa:	68f3      	ldr	r3, [r6, #12]
    91ac:	40eb      	lsrs	r3, r5
    91ae:	f013 0f01 	tst.w	r3, #1
    91b2:	d04e      	beq.n	9252 <gpiote_pin_int_cfg+0xde>
    91b4:	6933      	ldr	r3, [r6, #16]
    91b6:	40eb      	lsrs	r3, r5
    91b8:	f013 0f01 	tst.w	r3, #1
    91bc:	d04b      	beq.n	9256 <gpiote_pin_int_cfg+0xe2>
		if (data->trig_edge & BIT(pin)) {
    91be:	69b3      	ldr	r3, [r6, #24]
    91c0:	40eb      	lsrs	r3, r5
    91c2:	f013 0f01 	tst.w	r3, #1
    91c6:	d01e      	beq.n	9206 <gpiote_pin_int_cfg+0x92>
			if (data->double_edge & BIT(pin)) {
    91c8:	69f3      	ldr	r3, [r6, #28]
    91ca:	40eb      	lsrs	r3, r5
    91cc:	f013 0f01 	tst.w	r3, #1
    91d0:	d112      	bne.n	91f8 <gpiote_pin_int_cfg+0x84>
			} else if ((data->int_active_level & BIT(pin)) != 0U) {
    91d2:	6973      	ldr	r3, [r6, #20]
    91d4:	fa23 f505 	lsr.w	r5, r3, r5
    91d8:	f015 0f01 	tst.w	r5, #1
    91dc:	d011      	beq.n	9202 <gpiote_pin_int_cfg+0x8e>
				pol = NRF_GPIOTE_POLARITY_LOTOHI;
    91de:	2101      	movs	r1, #1
    91e0:	e00b      	b.n	91fa <gpiote_pin_int_cfg+0x86>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    91e2:	4b1f      	ldr	r3, [pc, #124]	; (9260 <gpiote_pin_int_cfg+0xec>)
    91e4:	4a1f      	ldr	r2, [pc, #124]	; (9264 <gpiote_pin_int_cfg+0xf0>)
    91e6:	f44f 71ed 	mov.w	r1, #474	; 0x1da
    91ea:	481f      	ldr	r0, [pc, #124]	; (9268 <gpiote_pin_int_cfg+0xf4>)
    91ec:	f002 fd5e 	bl	bcac <__assert_func>
    91f0:	4623      	mov	r3, r4
        return NRF_P0;
    91f2:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
    91f6:	e7d0      	b.n	919a <gpiote_pin_int_cfg+0x26>
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
    91f8:	2103      	movs	r1, #3
			res = gpiote_channel_alloc(abs_pin, pol);
    91fa:	4620      	mov	r0, r4
    91fc:	f7ff fe9c 	bl	8f38 <gpiote_channel_alloc>
    9200:	e028      	b.n	9254 <gpiote_pin_int_cfg+0xe0>
				pol = NRF_GPIOTE_POLARITY_HITOLO;
    9202:	2102      	movs	r1, #2
    9204:	e7f9      	b.n	91fa <gpiote_pin_int_cfg+0x86>
	if ((BIT(pin) & data->int_active_level) != 0U) {
    9206:	6971      	ldr	r1, [r6, #20]
    9208:	fa21 f505 	lsr.w	r5, r1, r5
    920c:	f015 0f01 	tst.w	r5, #1
    9210:	d113      	bne.n	923a <gpiote_pin_int_cfg+0xc6>
	return NRF_GPIO_PIN_SENSE_LOW;
    9212:	2103      	movs	r1, #3
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    9214:	2c29      	cmp	r4, #41	; 0x29
    9216:	d812      	bhi.n	923e <gpiote_pin_int_cfg+0xca>
    if (*p_pin < P0_PIN_NUM)
    9218:	2c1f      	cmp	r4, #31
    921a:	d917      	bls.n	924c <gpiote_pin_int_cfg+0xd8>
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    921c:	f004 041f 	and.w	r4, r4, #31
        return NRF_P1;
    9220:	4a0e      	ldr	r2, [pc, #56]	; (925c <gpiote_pin_int_cfg+0xe8>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    9222:	f504 74e0 	add.w	r4, r4, #448	; 0x1c0
    9226:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
    922a:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    922e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    9232:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
	int res = 0;
    9236:	2000      	movs	r0, #0
    9238:	e00c      	b.n	9254 <gpiote_pin_int_cfg+0xe0>
		return NRF_GPIO_PIN_SENSE_HIGH;
    923a:	2102      	movs	r1, #2
    923c:	e7ea      	b.n	9214 <gpiote_pin_int_cfg+0xa0>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    923e:	4b08      	ldr	r3, [pc, #32]	; (9260 <gpiote_pin_int_cfg+0xec>)
    9240:	4a08      	ldr	r2, [pc, #32]	; (9264 <gpiote_pin_int_cfg+0xf0>)
    9242:	f44f 71ed 	mov.w	r1, #474	; 0x1da
    9246:	4808      	ldr	r0, [pc, #32]	; (9268 <gpiote_pin_int_cfg+0xf4>)
    9248:	f002 fd30 	bl	bcac <__assert_func>
        return NRF_P0;
    924c:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    9250:	e7e7      	b.n	9222 <gpiote_pin_int_cfg+0xae>
	int res = 0;
    9252:	2000      	movs	r0, #0
}
    9254:	bd70      	pop	{r4, r5, r6, pc}
	int res = 0;
    9256:	2000      	movs	r0, #0
	return res;
    9258:	e7fc      	b.n	9254 <gpiote_pin_int_cfg+0xe0>
    925a:	bf00      	nop
    925c:	50000300 	.word	0x50000300
    9260:	00012db8 	.word	0x00012db8
    9264:	00012e48 	.word	0x00012e48
    9268:	00012dcc 	.word	0x00012dcc

0000926c <gpio_nrfx_config>:
{
    926c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return port->config_info;
    926e:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    9270:	685f      	ldr	r7, [r3, #4]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    9272:	4b3b      	ldr	r3, [pc, #236]	; (9360 <gpio_nrfx_config+0xf4>)
    9274:	4013      	ands	r3, r2
    9276:	4c3b      	ldr	r4, [pc, #236]	; (9364 <gpio_nrfx_config+0xf8>)
    9278:	42a3      	cmp	r3, r4
    927a:	d027      	beq.n	92cc <gpio_nrfx_config+0x60>
    927c:	d812      	bhi.n	92a4 <gpio_nrfx_config+0x38>
    927e:	2b06      	cmp	r3, #6
    9280:	d026      	beq.n	92d0 <gpio_nrfx_config+0x64>
    9282:	d904      	bls.n	928e <gpio_nrfx_config+0x22>
    9284:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    9288:	d109      	bne.n	929e <gpio_nrfx_config+0x32>
		drive = NRF_GPIO_PIN_H0S1;
    928a:	2401      	movs	r4, #1
    928c:	e016      	b.n	92bc <gpio_nrfx_config+0x50>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    928e:	b30b      	cbz	r3, 92d4 <gpio_nrfx_config+0x68>
    9290:	2b02      	cmp	r3, #2
    9292:	d101      	bne.n	9298 <gpio_nrfx_config+0x2c>
		drive = NRF_GPIO_PIN_D0S1;
    9294:	2404      	movs	r4, #4
    9296:	e011      	b.n	92bc <gpio_nrfx_config+0x50>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    9298:	f06f 0015 	mvn.w	r0, #21
    929c:	e048      	b.n	9330 <gpio_nrfx_config+0xc4>
    929e:	f06f 0015 	mvn.w	r0, #21
    92a2:	e045      	b.n	9330 <gpio_nrfx_config+0xc4>
    92a4:	4c30      	ldr	r4, [pc, #192]	; (9368 <gpio_nrfx_config+0xfc>)
    92a6:	42a3      	cmp	r3, r4
    92a8:	d016      	beq.n	92d8 <gpio_nrfx_config+0x6c>
    92aa:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
    92ae:	d101      	bne.n	92b4 <gpio_nrfx_config+0x48>
		drive = NRF_GPIO_PIN_H0H1;
    92b0:	2403      	movs	r4, #3
    92b2:	e003      	b.n	92bc <gpio_nrfx_config+0x50>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    92b4:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
    92b8:	d14f      	bne.n	935a <gpio_nrfx_config+0xee>
		drive = NRF_GPIO_PIN_S0H1;
    92ba:	2402      	movs	r4, #2
	if ((flags & GPIO_PULL_UP) != 0) {
    92bc:	f012 0f10 	tst.w	r2, #16
    92c0:	d10c      	bne.n	92dc <gpio_nrfx_config+0x70>
	} else if ((flags & GPIO_PULL_DOWN) != 0) {
    92c2:	f012 0f20 	tst.w	r2, #32
    92c6:	d034      	beq.n	9332 <gpio_nrfx_config+0xc6>
		pull = NRF_GPIO_PIN_PULLDOWN;
    92c8:	2501      	movs	r5, #1
    92ca:	e008      	b.n	92de <gpio_nrfx_config+0x72>
		drive = NRF_GPIO_PIN_H0D1;
    92cc:	2407      	movs	r4, #7
    92ce:	e7f5      	b.n	92bc <gpio_nrfx_config+0x50>
		drive = NRF_GPIO_PIN_S0D1;
    92d0:	2406      	movs	r4, #6
    92d2:	e7f3      	b.n	92bc <gpio_nrfx_config+0x50>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    92d4:	2400      	movs	r4, #0
    92d6:	e7f1      	b.n	92bc <gpio_nrfx_config+0x50>
		drive = NRF_GPIO_PIN_D0H1;
    92d8:	2405      	movs	r4, #5
    92da:	e7ef      	b.n	92bc <gpio_nrfx_config+0x50>
		pull = NRF_GPIO_PIN_PULLUP;
    92dc:	2503      	movs	r5, #3
	dir = ((flags & GPIO_OUTPUT) != 0)
    92de:	f3c2 2340 	ubfx	r3, r2, #9, #1
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
    92e2:	f412 7f80 	tst.w	r2, #256	; 0x100
    92e6:	bf0c      	ite	eq
    92e8:	2601      	moveq	r6, #1
    92ea:	2600      	movne	r6, #0
	if ((flags & GPIO_OUTPUT) != 0) {
    92ec:	f412 7f00 	tst.w	r2, #512	; 0x200
    92f0:	d006      	beq.n	9300 <gpio_nrfx_config+0x94>
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
    92f2:	f412 6f00 	tst.w	r2, #2048	; 0x800
    92f6:	d01e      	beq.n	9336 <gpio_nrfx_config+0xca>
			nrf_gpio_port_out_set(reg, BIT(pin));
    92f8:	2201      	movs	r2, #1
    92fa:	408a      	lsls	r2, r1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
    92fc:	f8c7 2508 	str.w	r2, [r7, #1288]	; 0x508
	return port->config_info;
    9300:	6842      	ldr	r2, [r0, #4]
	nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin),
    9302:	7a12      	ldrb	r2, [r2, #8]
    9304:	f001 011f 	and.w	r1, r1, #31
    9308:	ea41 1142 	orr.w	r1, r1, r2, lsl #5
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    930c:	2929      	cmp	r1, #41	; 0x29
    930e:	d81a      	bhi.n	9346 <gpio_nrfx_config+0xda>
    if (*p_pin < P0_PIN_NUM)
    9310:	291f      	cmp	r1, #31
    9312:	d91f      	bls.n	9354 <gpio_nrfx_config+0xe8>
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    9314:	f001 011f 	and.w	r1, r1, #31
        return NRF_P1;
    9318:	4a14      	ldr	r2, [pc, #80]	; (936c <gpio_nrfx_config+0x100>)
                               | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
    931a:	ea43 0346 	orr.w	r3, r3, r6, lsl #1
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
    931e:	ea43 0385 	orr.w	r3, r3, r5, lsl #2
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
    9322:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    9326:	f501 71e0 	add.w	r1, r1, #448	; 0x1c0
    932a:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
	return 0;
    932e:	2000      	movs	r0, #0
}
    9330:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		pull = NRF_GPIO_PIN_NOPULL;
    9332:	2500      	movs	r5, #0
    9334:	e7d3      	b.n	92de <gpio_nrfx_config+0x72>
		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
    9336:	f412 6f80 	tst.w	r2, #1024	; 0x400
    933a:	d0e1      	beq.n	9300 <gpio_nrfx_config+0x94>
			nrf_gpio_port_out_clear(reg, BIT(pin));
    933c:	2201      	movs	r2, #1
    933e:	408a      	lsls	r2, r1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
    9340:	f8c7 250c 	str.w	r2, [r7, #1292]	; 0x50c
}
    9344:	e7dc      	b.n	9300 <gpio_nrfx_config+0x94>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    9346:	4b0a      	ldr	r3, [pc, #40]	; (9370 <gpio_nrfx_config+0x104>)
    9348:	4a0a      	ldr	r2, [pc, #40]	; (9374 <gpio_nrfx_config+0x108>)
    934a:	f44f 71ed 	mov.w	r1, #474	; 0x1da
    934e:	480a      	ldr	r0, [pc, #40]	; (9378 <gpio_nrfx_config+0x10c>)
    9350:	f002 fcac 	bl	bcac <__assert_func>
        return NRF_P0;
    9354:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    9358:	e7df      	b.n	931a <gpio_nrfx_config+0xae>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    935a:	f06f 0015 	mvn.w	r0, #21
    935e:	e7e7      	b.n	9330 <gpio_nrfx_config+0xc4>
    9360:	00f00006 	.word	0x00f00006
    9364:	00100006 	.word	0x00100006
    9368:	00400002 	.word	0x00400002
    936c:	50000300 	.word	0x50000300
    9370:	00012db8 	.word	0x00012db8
    9374:	00012e48 	.word	0x00012e48
    9378:	00012dcc 	.word	0x00012dcc

0000937c <gpio_nrfx_pin_interrupt_configure>:
{
    937c:	b570      	push	{r4, r5, r6, lr}
	return port->driver_data;
    937e:	68c4      	ldr	r4, [r0, #12]
	return port->config_info;
    9380:	6845      	ldr	r5, [r0, #4]
	u32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
    9382:	7a2e      	ldrb	r6, [r5, #8]
    9384:	f001 051f 	and.w	r5, r1, #31
    9388:	ea45 1546 	orr.w	r5, r5, r6, lsl #5
	if ((mode == GPIO_INT_MODE_EDGE) &&
    938c:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
    9390:	d02d      	beq.n	93ee <gpio_nrfx_pin_interrupt_configure+0x72>
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    9392:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
    9396:	d045      	beq.n	9424 <gpio_nrfx_pin_interrupt_configure+0xa8>
    9398:	68e5      	ldr	r5, [r4, #12]
    939a:	2601      	movs	r6, #1
    939c:	408e      	lsls	r6, r1
    939e:	4335      	orrs	r5, r6
    93a0:	60e5      	str	r5, [r4, #12]
	WRITE_BIT(data->int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    93a2:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
    93a6:	d043      	beq.n	9430 <gpio_nrfx_pin_interrupt_configure+0xb4>
    93a8:	6925      	ldr	r5, [r4, #16]
    93aa:	2601      	movs	r6, #1
    93ac:	408e      	lsls	r6, r1
    93ae:	4335      	orrs	r5, r6
    93b0:	6125      	str	r5, [r4, #16]
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
    93b2:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
    93b6:	d041      	beq.n	943c <gpio_nrfx_pin_interrupt_configure+0xc0>
    93b8:	69a2      	ldr	r2, [r4, #24]
    93ba:	2501      	movs	r5, #1
    93bc:	408d      	lsls	r5, r1
    93be:	ea22 0205 	bic.w	r2, r2, r5
    93c2:	61a2      	str	r2, [r4, #24]
	WRITE_BIT(data->double_edge, pin, trig == GPIO_INT_TRIG_BOTH);
    93c4:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
    93c8:	d03d      	beq.n	9446 <gpio_nrfx_pin_interrupt_configure+0xca>
    93ca:	69e2      	ldr	r2, [r4, #28]
    93cc:	2501      	movs	r5, #1
    93ce:	408d      	lsls	r5, r1
    93d0:	ea22 0205 	bic.w	r2, r2, r5
    93d4:	61e2      	str	r2, [r4, #28]
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
    93d6:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
    93da:	d039      	beq.n	9450 <gpio_nrfx_pin_interrupt_configure+0xd4>
    93dc:	6963      	ldr	r3, [r4, #20]
    93de:	2201      	movs	r2, #1
    93e0:	408a      	lsls	r2, r1
    93e2:	ea23 0302 	bic.w	r3, r3, r2
    93e6:	6163      	str	r3, [r4, #20]
	return gpiote_pin_int_cfg(port, pin);
    93e8:	f7ff fec4 	bl	9174 <gpiote_pin_int_cfg>
}
    93ec:	bd70      	pop	{r4, r5, r6, pc}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    93ee:	2d29      	cmp	r5, #41	; 0x29
    93f0:	d80e      	bhi.n	9410 <gpio_nrfx_pin_interrupt_configure+0x94>
    if (*p_pin < P0_PIN_NUM)
    93f2:	2d1f      	cmp	r5, #31
    93f4:	d913      	bls.n	941e <gpio_nrfx_pin_interrupt_configure+0xa2>
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    93f6:	f005 051f 	and.w	r5, r5, #31
        return NRF_P1;
    93fa:	4e18      	ldr	r6, [pc, #96]	; (945c <gpio_nrfx_pin_interrupt_configure+0xe0>)
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
    93fc:	f505 75e0 	add.w	r5, r5, #448	; 0x1c0
    9400:	f856 5025 	ldr.w	r5, [r6, r5, lsl #2]
	if ((mode == GPIO_INT_MODE_EDGE) &&
    9404:	f015 0f01 	tst.w	r5, #1
    9408:	d0c3      	beq.n	9392 <gpio_nrfx_pin_interrupt_configure+0x16>
		return -ENOTSUP;
    940a:	f06f 0085 	mvn.w	r0, #133	; 0x85
    940e:	e7ed      	b.n	93ec <gpio_nrfx_pin_interrupt_configure+0x70>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    9410:	4b13      	ldr	r3, [pc, #76]	; (9460 <gpio_nrfx_pin_interrupt_configure+0xe4>)
    9412:	4a14      	ldr	r2, [pc, #80]	; (9464 <gpio_nrfx_pin_interrupt_configure+0xe8>)
    9414:	f44f 71ed 	mov.w	r1, #474	; 0x1da
    9418:	4813      	ldr	r0, [pc, #76]	; (9468 <gpio_nrfx_pin_interrupt_configure+0xec>)
    941a:	f002 fc47 	bl	bcac <__assert_func>
        return NRF_P0;
    941e:	f04f 46a0 	mov.w	r6, #1342177280	; 0x50000000
    9422:	e7eb      	b.n	93fc <gpio_nrfx_pin_interrupt_configure+0x80>
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    9424:	68e5      	ldr	r5, [r4, #12]
    9426:	2601      	movs	r6, #1
    9428:	408e      	lsls	r6, r1
    942a:	ea25 0506 	bic.w	r5, r5, r6
    942e:	e7b7      	b.n	93a0 <gpio_nrfx_pin_interrupt_configure+0x24>
	WRITE_BIT(data->int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    9430:	6925      	ldr	r5, [r4, #16]
    9432:	2601      	movs	r6, #1
    9434:	408e      	lsls	r6, r1
    9436:	ea25 0506 	bic.w	r5, r5, r6
    943a:	e7b9      	b.n	93b0 <gpio_nrfx_pin_interrupt_configure+0x34>
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
    943c:	69a2      	ldr	r2, [r4, #24]
    943e:	2501      	movs	r5, #1
    9440:	408d      	lsls	r5, r1
    9442:	432a      	orrs	r2, r5
    9444:	e7bd      	b.n	93c2 <gpio_nrfx_pin_interrupt_configure+0x46>
	WRITE_BIT(data->double_edge, pin, trig == GPIO_INT_TRIG_BOTH);
    9446:	69e2      	ldr	r2, [r4, #28]
    9448:	2501      	movs	r5, #1
    944a:	408d      	lsls	r5, r1
    944c:	432a      	orrs	r2, r5
    944e:	e7c1      	b.n	93d4 <gpio_nrfx_pin_interrupt_configure+0x58>
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
    9450:	6963      	ldr	r3, [r4, #20]
    9452:	2201      	movs	r2, #1
    9454:	408a      	lsls	r2, r1
    9456:	4313      	orrs	r3, r2
    9458:	e7c5      	b.n	93e6 <gpio_nrfx_pin_interrupt_configure+0x6a>
    945a:	bf00      	nop
    945c:	50000300 	.word	0x50000300
    9460:	00012db8 	.word	0x00012db8
    9464:	00012e48 	.word	0x00012e48
    9468:	00012dcc 	.word	0x00012dcc

0000946c <gpiote_event_handler>:
{
    946c:	b5f0      	push	{r4, r5, r6, r7, lr}
    946e:	b085      	sub	sp, #20
	u32_t fired_triggers[GPIO_COUNT] = {0};
    9470:	2300      	movs	r3, #0
    9472:	9302      	str	r3, [sp, #8]
    9474:	9303      	str	r3, [sp, #12]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    9476:	4b4a      	ldr	r3, [pc, #296]	; (95a0 <gpiote_event_handler+0x134>)
    9478:	681c      	ldr	r4, [r3, #0]
	if (port_event) {
    947a:	b90c      	cbnz	r4, 9480 <gpiote_event_handler+0x14>
{
    947c:	2100      	movs	r1, #0
    947e:	e011      	b.n	94a4 <gpiote_event_handler+0x38>
			check_level_trigger_pins(DEVICE_GET(gpio_nrfx_p0));
    9480:	4d48      	ldr	r5, [pc, #288]	; (95a4 <gpiote_event_handler+0x138>)
    9482:	4628      	mov	r0, r5
    9484:	f7ff fe32 	bl	90ec <check_level_trigger_pins>
		fired_triggers[0] =
    9488:	9002      	str	r0, [sp, #8]
			check_level_trigger_pins(DEVICE_GET(gpio_nrfx_p1));
    948a:	f105 0010 	add.w	r0, r5, #16
    948e:	f7ff fe2d 	bl	90ec <check_level_trigger_pins>
		fired_triggers[1] =
    9492:	9003      	str	r0, [sp, #12]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    9494:	4b42      	ldr	r3, [pc, #264]	; (95a0 <gpiote_event_handler+0x134>)
    9496:	2200      	movs	r2, #0
    9498:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
    949a:	681b      	ldr	r3, [r3, #0]
    949c:	9300      	str	r3, [sp, #0]
    (void)dummy;
    949e:	9b00      	ldr	r3, [sp, #0]
}
    94a0:	e7ec      	b.n	947c <gpiote_event_handler+0x10>
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    94a2:	3101      	adds	r1, #1
    94a4:	2907      	cmp	r1, #7
    94a6:	d82f      	bhi.n	9508 <gpiote_event_handler+0x9c>
		nrf_gpiote_event_t evt =
    94a8:	f101 0340 	add.w	r3, r1, #64	; 0x40
    94ac:	009b      	lsls	r3, r3, #2
    94ae:	b29a      	uxth	r2, r3
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
    94b0:	2301      	movs	r3, #1
    94b2:	408b      	lsls	r3, r1
    return p_reg->INTENSET & mask;
    94b4:	483c      	ldr	r0, [pc, #240]	; (95a8 <gpiote_event_handler+0x13c>)
    94b6:	f8d0 0304 	ldr.w	r0, [r0, #772]	; 0x304
    94ba:	4203      	tst	r3, r0
    94bc:	d0f1      	beq.n	94a2 <gpiote_event_handler+0x36>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    94be:	f102 4380 	add.w	r3, r2, #1073741824	; 0x40000000
    94c2:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
    94c6:	681b      	ldr	r3, [r3, #0]
    94c8:	2b00      	cmp	r3, #0
    94ca:	d0ea      	beq.n	94a2 <gpiote_event_handler+0x36>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    94cc:	f501 73a2 	add.w	r3, r1, #324	; 0x144
    94d0:	4835      	ldr	r0, [pc, #212]	; (95a8 <gpiote_event_handler+0x13c>)
    94d2:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
    94d6:	f3c0 3340 	ubfx	r3, r0, #13, #1
    94da:	f3c0 2004 	ubfx	r0, r0, #8, #5
    94de:	2501      	movs	r5, #1
    94e0:	fa05 f000 	lsl.w	r0, r5, r0
    94e4:	ad04      	add	r5, sp, #16
    94e6:	eb05 0383 	add.w	r3, r5, r3, lsl #2
    94ea:	f853 5c08 	ldr.w	r5, [r3, #-8]
    94ee:	4305      	orrs	r5, r0
    94f0:	f843 5c08 	str.w	r5, [r3, #-8]
    return ((uint32_t)p_reg + event);
    94f4:	f102 4380 	add.w	r3, r2, #1073741824	; 0x40000000
    94f8:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    94fc:	2200      	movs	r2, #0
    94fe:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
    9500:	681b      	ldr	r3, [r3, #0]
    9502:	9301      	str	r3, [sp, #4]
    (void)dummy;
    9504:	9b01      	ldr	r3, [sp, #4]
}
    9506:	e7cc      	b.n	94a2 <gpiote_event_handler+0x36>
	if (fired_triggers[0]) {
    9508:	9e02      	ldr	r6, [sp, #8]
    950a:	b92e      	cbnz	r6, 9518 <gpiote_event_handler+0xac>
	if (fired_triggers[1]) {
    950c:	9e03      	ldr	r6, [sp, #12]
    950e:	bb06      	cbnz	r6, 9552 <gpiote_event_handler+0xe6>
	if (port_event) {
    9510:	2c00      	cmp	r4, #0
    9512:	d13b      	bne.n	958c <gpiote_event_handler+0x120>
}
    9514:	b005      	add	sp, #20
    9516:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return port->driver_data;
    9518:	4b22      	ldr	r3, [pc, #136]	; (95a4 <gpiote_event_handler+0x138>)
    951a:	68df      	ldr	r7, [r3, #12]
	return list->head;
    951c:	6879      	ldr	r1, [r7, #4]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    951e:	b119      	cbz	r1, 9528 <gpiote_event_handler+0xbc>
    9520:	460d      	mov	r5, r1
Z_GENLIST_PEEK_NEXT(slist, snode)
    9522:	b149      	cbz	r1, 9538 <gpiote_event_handler+0xcc>
	return node->next;
    9524:	680d      	ldr	r5, [r1, #0]
    9526:	e007      	b.n	9538 <gpiote_event_handler+0xcc>
    9528:	460d      	mov	r5, r1
    952a:	e005      	b.n	9538 <gpiote_event_handler+0xcc>
    952c:	b17d      	cbz	r5, 954e <gpiote_event_handler+0xe2>
    952e:	462b      	mov	r3, r5
Z_GENLIST_PEEK_NEXT(slist, snode)
    9530:	b105      	cbz	r5, 9534 <gpiote_event_handler+0xc8>
	return node->next;
    9532:	682b      	ldr	r3, [r5, #0]
    9534:	4629      	mov	r1, r5
    9536:	461d      	mov	r5, r3
    9538:	2900      	cmp	r1, #0
    953a:	d0e7      	beq.n	950c <gpiote_event_handler+0xa0>
		if ((cb->pin_mask & pins) & data->int_en) {
    953c:	688a      	ldr	r2, [r1, #8]
    953e:	4032      	ands	r2, r6
    9540:	693b      	ldr	r3, [r7, #16]
    9542:	421a      	tst	r2, r3
    9544:	d0f2      	beq.n	952c <gpiote_event_handler+0xc0>
			cb->handler(port, cb, cb->pin_mask & pins);
    9546:	684b      	ldr	r3, [r1, #4]
    9548:	4816      	ldr	r0, [pc, #88]	; (95a4 <gpiote_event_handler+0x138>)
    954a:	4798      	blx	r3
    954c:	e7ee      	b.n	952c <gpiote_event_handler+0xc0>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    954e:	462b      	mov	r3, r5
    9550:	e7f0      	b.n	9534 <gpiote_event_handler+0xc8>
	return port->driver_data;
    9552:	4b14      	ldr	r3, [pc, #80]	; (95a4 <gpiote_event_handler+0x138>)
    9554:	69df      	ldr	r7, [r3, #28]
	return list->head;
    9556:	6879      	ldr	r1, [r7, #4]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    9558:	b119      	cbz	r1, 9562 <gpiote_event_handler+0xf6>
    955a:	460d      	mov	r5, r1
Z_GENLIST_PEEK_NEXT(slist, snode)
    955c:	b149      	cbz	r1, 9572 <gpiote_event_handler+0x106>
	return node->next;
    955e:	680d      	ldr	r5, [r1, #0]
    9560:	e007      	b.n	9572 <gpiote_event_handler+0x106>
    9562:	460d      	mov	r5, r1
    9564:	e005      	b.n	9572 <gpiote_event_handler+0x106>
    9566:	b17d      	cbz	r5, 9588 <gpiote_event_handler+0x11c>
    9568:	462b      	mov	r3, r5
Z_GENLIST_PEEK_NEXT(slist, snode)
    956a:	b105      	cbz	r5, 956e <gpiote_event_handler+0x102>
	return node->next;
    956c:	682b      	ldr	r3, [r5, #0]
    956e:	4629      	mov	r1, r5
    9570:	461d      	mov	r5, r3
    9572:	2900      	cmp	r1, #0
    9574:	d0cc      	beq.n	9510 <gpiote_event_handler+0xa4>
		if ((cb->pin_mask & pins) & data->int_en) {
    9576:	688a      	ldr	r2, [r1, #8]
    9578:	4032      	ands	r2, r6
    957a:	693b      	ldr	r3, [r7, #16]
    957c:	421a      	tst	r2, r3
    957e:	d0f2      	beq.n	9566 <gpiote_event_handler+0xfa>
			cb->handler(port, cb, cb->pin_mask & pins);
    9580:	684b      	ldr	r3, [r1, #4]
    9582:	480a      	ldr	r0, [pc, #40]	; (95ac <gpiote_event_handler+0x140>)
    9584:	4798      	blx	r3
    9586:	e7ee      	b.n	9566 <gpiote_event_handler+0xfa>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    9588:	462b      	mov	r3, r5
    958a:	e7f0      	b.n	956e <gpiote_event_handler+0x102>
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p0));
    958c:	4c05      	ldr	r4, [pc, #20]	; (95a4 <gpiote_event_handler+0x138>)
    958e:	4620      	mov	r0, r4
    9590:	f7ff fd64 	bl	905c <cfg_level_pins>
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p1));
    9594:	f104 0010 	add.w	r0, r4, #16
    9598:	f7ff fd60 	bl	905c <cfg_level_pins>
}
    959c:	e7ba      	b.n	9514 <gpiote_event_handler+0xa8>
    959e:	bf00      	nop
    95a0:	4000617c 	.word	0x4000617c
    95a4:	2000041c 	.word	0x2000041c
    95a8:	40006000 	.word	0x40006000
    95ac:	2000042c 	.word	0x2000042c

000095b0 <event_txdrdy_check>:
#endif
}

NRF_STATIC_INLINE bool nrf_uart_event_check(NRF_UART_Type const * p_reg, nrf_uart_event_t event)
{
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    95b0:	4b05      	ldr	r3, [pc, #20]	; (95c8 <event_txdrdy_check+0x18>)
    95b2:	681b      	ldr	r3, [r3, #0]

static bool event_txdrdy_check(void)
{
	return (nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_TXDRDY)
#ifdef CONFIG_UART_0_INTERRUPT_DRIVEN
		|| uart_sw_event_txdrdy
    95b4:	b923      	cbnz	r3, 95c0 <event_txdrdy_check+0x10>
    95b6:	4b05      	ldr	r3, [pc, #20]	; (95cc <event_txdrdy_check+0x1c>)
    95b8:	781b      	ldrb	r3, [r3, #0]
    95ba:	b11b      	cbz	r3, 95c4 <event_txdrdy_check+0x14>
    95bc:	2001      	movs	r0, #1
    95be:	4770      	bx	lr
    95c0:	2001      	movs	r0, #1
    95c2:	4770      	bx	lr
    95c4:	2000      	movs	r0, #0
#endif
	       );
}
    95c6:	4770      	bx	lr
    95c8:	4000211c 	.word	0x4000211c
    95cc:	20005954 	.word	0x20005954

000095d0 <event_txdrdy_clear>:

static void event_txdrdy_clear(void)
{
    95d0:	b082      	sub	sp, #8
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    95d2:	4a05      	ldr	r2, [pc, #20]	; (95e8 <event_txdrdy_clear+0x18>)
    95d4:	2300      	movs	r3, #0
    95d6:	6013      	str	r3, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    95d8:	6812      	ldr	r2, [r2, #0]
    95da:	9201      	str	r2, [sp, #4]
    (void)dummy;
    95dc:	9a01      	ldr	r2, [sp, #4]
	nrf_uart_event_clear(uart0_addr, NRF_UART_EVENT_TXDRDY);
#ifdef CONFIG_UART_0_INTERRUPT_DRIVEN
	uart_sw_event_txdrdy = 0U;
    95de:	4a03      	ldr	r2, [pc, #12]	; (95ec <event_txdrdy_clear+0x1c>)
    95e0:	7013      	strb	r3, [r2, #0]
#endif
}
    95e2:	b002      	add	sp, #8
    95e4:	4770      	bx	lr
    95e6:	bf00      	nop
    95e8:	4000211c 	.word	0x4000211c
    95ec:	20005954 	.word	0x20005954

000095f0 <baudrate_set>:

static int baudrate_set(struct device *dev, u32_t baudrate)
{
	nrf_uart_baudrate_t nrf_baudrate; /* calculated baudrate divisor */

	switch (baudrate) {
    95f0:	f5b1 4f16 	cmp.w	r1, #38400	; 0x9600
    95f4:	d06d      	beq.n	96d2 <baudrate_set+0xe2>
    95f6:	d83b      	bhi.n	9670 <baudrate_set+0x80>
    95f8:	f5b1 5f16 	cmp.w	r1, #9600	; 0x2580
    95fc:	d06b      	beq.n	96d6 <baudrate_set+0xe6>
    95fe:	d90a      	bls.n	9616 <baudrate_set+0x26>
    9600:	f5b1 4fe1 	cmp.w	r1, #28800	; 0x7080
    9604:	d072      	beq.n	96ec <baudrate_set+0xfc>
    9606:	d925      	bls.n	9654 <baudrate_set+0x64>
    9608:	f647 2312 	movw	r3, #31250	; 0x7a12
    960c:	4299      	cmp	r1, r3
    960e:	d12c      	bne.n	966a <baudrate_set+0x7a>
		break;
	case 28800:
		nrf_baudrate = NRF_UART_BAUDRATE_28800;
		break;
	case 31250:
		nrf_baudrate = NRF_UART_BAUDRATE_31250;
    9610:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    9614:	e013      	b.n	963e <baudrate_set+0x4e>
	switch (baudrate) {
    9616:	f5b1 6f96 	cmp.w	r1, #1200	; 0x4b0
    961a:	d05e      	beq.n	96da <baudrate_set+0xea>
    961c:	d907      	bls.n	962e <baudrate_set+0x3e>
    961e:	f5b1 6f16 	cmp.w	r1, #2400	; 0x960
    9622:	d060      	beq.n	96e6 <baudrate_set+0xf6>
    9624:	f5b1 5f96 	cmp.w	r1, #4800	; 0x12c0
    9628:	d111      	bne.n	964e <baudrate_set+0x5e>
		nrf_baudrate = NRF_UART_BAUDRATE_4800;
    962a:	4b3a      	ldr	r3, [pc, #232]	; (9714 <baudrate_set+0x124>)
    962c:	e007      	b.n	963e <baudrate_set+0x4e>
	switch (baudrate) {
    962e:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
    9632:	d055      	beq.n	96e0 <baudrate_set+0xf0>
    9634:	f5b1 7f16 	cmp.w	r1, #600	; 0x258
    9638:	d106      	bne.n	9648 <baudrate_set+0x58>
		nrf_baudrate = 0x00027000;
    963a:	f44f 331c 	mov.w	r3, #159744	; 0x27000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uart_baudrate_set(NRF_UART_Type * p_reg, nrf_uart_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    963e:	4a36      	ldr	r2, [pc, #216]	; (9718 <baudrate_set+0x128>)
    9640:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
		return -EINVAL;
	}

	nrf_uart_baudrate_set(uart0_addr, nrf_baudrate);

	return 0;
    9644:	2000      	movs	r0, #0
    9646:	4770      	bx	lr
	switch (baudrate) {
    9648:	f06f 0015 	mvn.w	r0, #21
    964c:	4770      	bx	lr
    964e:	f06f 0015 	mvn.w	r0, #21
    9652:	4770      	bx	lr
    9654:	f5b1 5f61 	cmp.w	r1, #14400	; 0x3840
    9658:	d04a      	beq.n	96f0 <baudrate_set+0x100>
    965a:	f5b1 4f96 	cmp.w	r1, #19200	; 0x4b00
    965e:	d101      	bne.n	9664 <baudrate_set+0x74>
		nrf_baudrate = NRF_UART_BAUDRATE_19200;
    9660:	4b2e      	ldr	r3, [pc, #184]	; (971c <baudrate_set+0x12c>)
    9662:	e7ec      	b.n	963e <baudrate_set+0x4e>
	switch (baudrate) {
    9664:	f06f 0015 	mvn.w	r0, #21
    9668:	4770      	bx	lr
    966a:	f06f 0015 	mvn.w	r0, #21
    966e:	4770      	bx	lr
    9670:	f5b1 3f61 	cmp.w	r1, #230400	; 0x38400
    9674:	d03f      	beq.n	96f6 <baudrate_set+0x106>
    9676:	d909      	bls.n	968c <baudrate_set+0x9c>
    9678:	f5b1 2f61 	cmp.w	r1, #921600	; 0xe1000
    967c:	d042      	beq.n	9704 <baudrate_set+0x114>
    967e:	d91d      	bls.n	96bc <baudrate_set+0xcc>
    9680:	4b27      	ldr	r3, [pc, #156]	; (9720 <baudrate_set+0x130>)
    9682:	4299      	cmp	r1, r3
    9684:	d143      	bne.n	970e <baudrate_set+0x11e>
		nrf_baudrate = NRF_UART_BAUDRATE_1000000;
    9686:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    968a:	e7d8      	b.n	963e <baudrate_set+0x4e>
	switch (baudrate) {
    968c:	f5b1 3f96 	cmp.w	r1, #76800	; 0x12c00
    9690:	d033      	beq.n	96fa <baudrate_set+0x10a>
    9692:	d904      	bls.n	969e <baudrate_set+0xae>
    9694:	f5b1 3fe1 	cmp.w	r1, #115200	; 0x1c200
    9698:	d10d      	bne.n	96b6 <baudrate_set+0xc6>
		nrf_baudrate = NRF_UART_BAUDRATE_115200;
    969a:	4b22      	ldr	r3, [pc, #136]	; (9724 <baudrate_set+0x134>)
    969c:	e7cf      	b.n	963e <baudrate_set+0x4e>
	switch (baudrate) {
    969e:	f64d 23c0 	movw	r3, #56000	; 0xdac0
    96a2:	4299      	cmp	r1, r3
    96a4:	d02b      	beq.n	96fe <baudrate_set+0x10e>
    96a6:	f5b1 4f61 	cmp.w	r1, #57600	; 0xe100
    96aa:	d101      	bne.n	96b0 <baudrate_set+0xc0>
		nrf_baudrate = NRF_UART_BAUDRATE_57600;
    96ac:	4b1e      	ldr	r3, [pc, #120]	; (9728 <baudrate_set+0x138>)
    96ae:	e7c6      	b.n	963e <baudrate_set+0x4e>
	switch (baudrate) {
    96b0:	f06f 0015 	mvn.w	r0, #21
    96b4:	4770      	bx	lr
    96b6:	f06f 0015 	mvn.w	r0, #21
    96ba:	4770      	bx	lr
    96bc:	4b1b      	ldr	r3, [pc, #108]	; (972c <baudrate_set+0x13c>)
    96be:	4299      	cmp	r1, r3
    96c0:	d022      	beq.n	9708 <baudrate_set+0x118>
    96c2:	f5b1 2fe1 	cmp.w	r1, #460800	; 0x70800
    96c6:	d101      	bne.n	96cc <baudrate_set+0xdc>
		nrf_baudrate = NRF_UART_BAUDRATE_460800;
    96c8:	4b19      	ldr	r3, [pc, #100]	; (9730 <baudrate_set+0x140>)
    96ca:	e7b8      	b.n	963e <baudrate_set+0x4e>
	switch (baudrate) {
    96cc:	f06f 0015 	mvn.w	r0, #21
    96d0:	4770      	bx	lr
		nrf_baudrate = NRF_UART_BAUDRATE_38400;
    96d2:	4b18      	ldr	r3, [pc, #96]	; (9734 <baudrate_set+0x144>)
    96d4:	e7b3      	b.n	963e <baudrate_set+0x4e>
		nrf_baudrate = NRF_UART_BAUDRATE_9600;
    96d6:	4b18      	ldr	r3, [pc, #96]	; (9738 <baudrate_set+0x148>)
    96d8:	e7b1      	b.n	963e <baudrate_set+0x4e>
		nrf_baudrate = NRF_UART_BAUDRATE_1200;
    96da:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
    96de:	e7ae      	b.n	963e <baudrate_set+0x4e>
	switch (baudrate) {
    96e0:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
    96e4:	e7ab      	b.n	963e <baudrate_set+0x4e>
		nrf_baudrate = NRF_UART_BAUDRATE_2400;
    96e6:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
    96ea:	e7a8      	b.n	963e <baudrate_set+0x4e>
		nrf_baudrate = NRF_UART_BAUDRATE_28800;
    96ec:	4b13      	ldr	r3, [pc, #76]	; (973c <baudrate_set+0x14c>)
    96ee:	e7a6      	b.n	963e <baudrate_set+0x4e>
		nrf_baudrate = NRF_UART_BAUDRATE_14400;
    96f0:	f44f 136c 	mov.w	r3, #3866624	; 0x3b0000
    96f4:	e7a3      	b.n	963e <baudrate_set+0x4e>
		nrf_baudrate = NRF_UART_BAUDRATE_230400;
    96f6:	4b12      	ldr	r3, [pc, #72]	; (9740 <baudrate_set+0x150>)
    96f8:	e7a1      	b.n	963e <baudrate_set+0x4e>
		nrf_baudrate = NRF_UART_BAUDRATE_76800;
    96fa:	4b12      	ldr	r3, [pc, #72]	; (9744 <baudrate_set+0x154>)
    96fc:	e79f      	b.n	963e <baudrate_set+0x4e>
		nrf_baudrate = NRF_UART_BAUDRATE_56000;
    96fe:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
    9702:	e79c      	b.n	963e <baudrate_set+0x4e>
		nrf_baudrate = NRF_UART_BAUDRATE_921600;
    9704:	4b10      	ldr	r3, [pc, #64]	; (9748 <baudrate_set+0x158>)
    9706:	e79a      	b.n	963e <baudrate_set+0x4e>
		nrf_baudrate = NRF_UART_BAUDRATE_250000;
    9708:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    970c:	e797      	b.n	963e <baudrate_set+0x4e>
	switch (baudrate) {
    970e:	f06f 0015 	mvn.w	r0, #21
}
    9712:	4770      	bx	lr
    9714:	0013b000 	.word	0x0013b000
    9718:	40002000 	.word	0x40002000
    971c:	004ea000 	.word	0x004ea000
    9720:	000f4240 	.word	0x000f4240
    9724:	01d7e000 	.word	0x01d7e000
    9728:	00ebf000 	.word	0x00ebf000
    972c:	0003d090 	.word	0x0003d090
    9730:	075f7000 	.word	0x075f7000
    9734:	009d5000 	.word	0x009d5000
    9738:	00275000 	.word	0x00275000
    973c:	0075f000 	.word	0x0075f000
    9740:	03afb000 	.word	0x03afb000
    9744:	013a9000 	.word	0x013a9000
    9748:	0ebed000 	.word	0x0ebed000

0000974c <uart_nrfx_poll_in>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    974c:	4b09      	ldr	r3, [pc, #36]	; (9774 <uart_nrfx_poll_in+0x28>)
    974e:	681b      	ldr	r3, [r3, #0]
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */

static int uart_nrfx_poll_in(struct device *dev, unsigned char *c)
{
	if (!nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_RXDRDY)) {
    9750:	b163      	cbz	r3, 976c <uart_nrfx_poll_in+0x20>
{
    9752:	b082      	sub	sp, #8
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    9754:	4b07      	ldr	r3, [pc, #28]	; (9774 <uart_nrfx_poll_in+0x28>)
    9756:	2000      	movs	r0, #0
    9758:	6018      	str	r0, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    975a:	681b      	ldr	r3, [r3, #0]
    975c:	9301      	str	r3, [sp, #4]
    (void)dummy;
    975e:	9b01      	ldr	r3, [sp, #4]
    return p_reg->RXD;
    9760:	4b05      	ldr	r3, [pc, #20]	; (9778 <uart_nrfx_poll_in+0x2c>)
    9762:	f8d3 3518 	ldr.w	r3, [r3, #1304]	; 0x518

	/* Clear the interrupt */
	nrf_uart_event_clear(uart0_addr, NRF_UART_EVENT_RXDRDY);

	/* got a character */
	*c = nrf_uart_rxd_get(uart0_addr);
    9766:	700b      	strb	r3, [r1, #0]

	return 0;
}
    9768:	b002      	add	sp, #8
    976a:	4770      	bx	lr
		return -1;
    976c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    9770:	4770      	bx	lr
    9772:	bf00      	nop
    9774:	40002108 	.word	0x40002108
    9778:	40002000 	.word	0x40002000

0000977c <uart_nrfx_err_check>:
    uint32_t errsrc_mask = p_reg->ERRORSRC;
    977c:	4b02      	ldr	r3, [pc, #8]	; (9788 <uart_nrfx_err_check+0xc>)
    977e:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
    9782:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
/** Console I/O function */
static int uart_nrfx_err_check(struct device *dev)
{
	/* register bitfields maps to the defines in uart.h */
	return nrf_uart_errorsrc_get_and_clear(uart0_addr);
}
    9786:	4770      	bx	lr
    9788:	40002000 	.word	0x40002000

0000978c <uart_nrfx_configure>:

static int uart_nrfx_configure(struct device *dev,
			       const struct uart_config *cfg)
{
    978c:	b530      	push	{r4, r5, lr}
    978e:	b083      	sub	sp, #12
    9790:	4605      	mov	r5, r0
    9792:	460c      	mov	r4, r1
	nrf_uart_config_t uart_cfg;

#if defined(UART_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
    9794:	794b      	ldrb	r3, [r1, #5]
    9796:	2b01      	cmp	r3, #1
    9798:	d006      	beq.n	97a8 <uart_nrfx_configure+0x1c>
    979a:	2b03      	cmp	r3, #3
    979c:	d011      	beq.n	97c2 <uart_nrfx_configure+0x36>
    979e:	f06f 0285 	mvn.w	r2, #133	; 0x85
	nrf_uart_configure(uart0_addr, &uart_cfg);

	get_dev_data(dev)->uart_config = *cfg;

	return 0;
}
    97a2:	4610      	mov	r0, r2
    97a4:	b003      	add	sp, #12
    97a6:	bd30      	pop	{r4, r5, pc}
		uart_cfg.stop = NRF_UART_STOP_ONE;
    97a8:	2300      	movs	r3, #0
    97aa:	f88d 3002 	strb.w	r3, [sp, #2]
	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
    97ae:	79a3      	ldrb	r3, [r4, #6]
    97b0:	2b03      	cmp	r3, #3
    97b2:	d148      	bne.n	9846 <uart_nrfx_configure+0xba>
	switch (cfg->flow_ctrl) {
    97b4:	79e3      	ldrb	r3, [r4, #7]
    97b6:	b143      	cbz	r3, 97ca <uart_nrfx_configure+0x3e>
    97b8:	2b01      	cmp	r3, #1
    97ba:	d015      	beq.n	97e8 <uart_nrfx_configure+0x5c>
    97bc:	f06f 0285 	mvn.w	r2, #133	; 0x85
    97c0:	e7ef      	b.n	97a2 <uart_nrfx_configure+0x16>
		uart_cfg.stop = NRF_UART_STOP_TWO;
    97c2:	2310      	movs	r3, #16
    97c4:	f88d 3002 	strb.w	r3, [sp, #2]
		break;
    97c8:	e7f1      	b.n	97ae <uart_nrfx_configure+0x22>
		uart_cfg.hwfc = NRF_UART_HWFC_DISABLED;
    97ca:	2300      	movs	r3, #0
    97cc:	f88d 3000 	strb.w	r3, [sp]
	uart_cfg.paritytype = NRF_UART_PARITYTYPE_EVEN;
    97d0:	2300      	movs	r3, #0
    97d2:	f8ad 3004 	strh.w	r3, [sp, #4]
	switch (cfg->parity) {
    97d6:	7923      	ldrb	r3, [r4, #4]
    97d8:	2b01      	cmp	r3, #1
    97da:	d02c      	beq.n	9836 <uart_nrfx_configure+0xaa>
    97dc:	2b02      	cmp	r3, #2
    97de:	d026      	beq.n	982e <uart_nrfx_configure+0xa2>
    97e0:	b14b      	cbz	r3, 97f6 <uart_nrfx_configure+0x6a>
    97e2:	f06f 0285 	mvn.w	r2, #133	; 0x85
    97e6:	e7dc      	b.n	97a2 <uart_nrfx_configure+0x16>
	return dev->config_info;
    97e8:	686b      	ldr	r3, [r5, #4]
		if (get_dev_config(dev)->rts_cts_pins_set) {
    97ea:	781b      	ldrb	r3, [r3, #0]
    97ec:	b373      	cbz	r3, 984c <uart_nrfx_configure+0xc0>
			uart_cfg.hwfc = NRF_UART_HWFC_ENABLED;
    97ee:	2301      	movs	r3, #1
    97f0:	f88d 3000 	strb.w	r3, [sp]
		break;
    97f4:	e7ec      	b.n	97d0 <uart_nrfx_configure+0x44>
		uart_cfg.parity = NRF_UART_PARITY_EXCLUDED;
    97f6:	f88d 3001 	strb.w	r3, [sp, #1]
	if (baudrate_set(dev, cfg->baudrate) != 0) {
    97fa:	6821      	ldr	r1, [r4, #0]
    97fc:	4628      	mov	r0, r5
    97fe:	f7ff fef7 	bl	95f0 <baudrate_set>
    9802:	4602      	mov	r2, r0
    9804:	bb28      	cbnz	r0, 9852 <uart_nrfx_configure+0xc6>
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    9806:	f89d 3001 	ldrb.w	r3, [sp, #1]
                    | (uint32_t)p_cfg->stop
    980a:	f89d 1002 	ldrb.w	r1, [sp, #2]
    980e:	430b      	orrs	r3, r1
                    | (uint32_t)p_cfg->paritytype
    9810:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    9814:	430b      	orrs	r3, r1
                    | (uint32_t)p_cfg->hwfc;
    9816:	f89d 1000 	ldrb.w	r1, [sp]
    981a:	430b      	orrs	r3, r1
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    981c:	490e      	ldr	r1, [pc, #56]	; (9858 <uart_nrfx_configure+0xcc>)
    981e:	f8c1 356c 	str.w	r3, [r1, #1388]	; 0x56c
	return dev->driver_data;
    9822:	68eb      	ldr	r3, [r5, #12]
	get_dev_data(dev)->uart_config = *cfg;
    9824:	e894 0003 	ldmia.w	r4, {r0, r1}
    9828:	e883 0003 	stmia.w	r3, {r0, r1}
	return 0;
    982c:	e7b9      	b.n	97a2 <uart_nrfx_configure+0x16>
		uart_cfg.parity = NRF_UART_PARITY_INCLUDED;
    982e:	230e      	movs	r3, #14
    9830:	f88d 3001 	strb.w	r3, [sp, #1]
		break;
    9834:	e7e1      	b.n	97fa <uart_nrfx_configure+0x6e>
		uart_cfg.parity = NRF_UART_PARITY_INCLUDED;
    9836:	230e      	movs	r3, #14
    9838:	f88d 3001 	strb.w	r3, [sp, #1]
		uart_cfg.paritytype = NRF_UART_PARITYTYPE_ODD;
    983c:	f44f 7380 	mov.w	r3, #256	; 0x100
    9840:	f8ad 3004 	strh.w	r3, [sp, #4]
		break;
    9844:	e7d9      	b.n	97fa <uart_nrfx_configure+0x6e>
		return -ENOTSUP;
    9846:	f06f 0285 	mvn.w	r2, #133	; 0x85
    984a:	e7aa      	b.n	97a2 <uart_nrfx_configure+0x16>
			return -ENOTSUP;
    984c:	f06f 0285 	mvn.w	r2, #133	; 0x85
    9850:	e7a7      	b.n	97a2 <uart_nrfx_configure+0x16>
		return -ENOTSUP;
    9852:	f06f 0285 	mvn.w	r2, #133	; 0x85
    9856:	e7a4      	b.n	97a2 <uart_nrfx_configure+0x16>
    9858:	40002000 	.word	0x40002000

0000985c <uart_nrfx_fifo_fill>:

/** Interrupt driven FIFO fill function */
static int uart_nrfx_fifo_fill(struct device *dev,
			       const u8_t *tx_data,
			       int len)
{
    985c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    985e:	460e      	mov	r6, r1
    9860:	4615      	mov	r5, r2
	u8_t num_tx = 0U;
    9862:	2400      	movs	r4, #0

	while ((len - num_tx > 0) &&
    9864:	4627      	mov	r7, r4
    9866:	1b2b      	subs	r3, r5, r4
    9868:	2b00      	cmp	r3, #0
    986a:	dd0b      	ble.n	9884 <uart_nrfx_fifo_fill+0x28>
	       event_txdrdy_check()) {
    986c:	f7ff fea0 	bl	95b0 <event_txdrdy_check>
	while ((len - num_tx > 0) &&
    9870:	b140      	cbz	r0, 9884 <uart_nrfx_fifo_fill+0x28>

		/* Clear the interrupt */
		event_txdrdy_clear();
    9872:	f7ff fead 	bl	95d0 <event_txdrdy_clear>

		/* Send a character */
		nrf_uart_txd_set(uart0_addr, (u8_t)tx_data[num_tx++]);
    9876:	1c63      	adds	r3, r4, #1
    9878:	5d34      	ldrb	r4, [r6, r4]
    p_reg->TXD = txd;
    987a:	4803      	ldr	r0, [pc, #12]	; (9888 <uart_nrfx_fifo_fill+0x2c>)
    987c:	f8c0 451c 	str.w	r4, [r0, #1308]	; 0x51c
    9880:	b2dc      	uxtb	r4, r3
}
    9882:	e7ef      	b.n	9864 <uart_nrfx_fifo_fill+0x8>
	}

	return (int)num_tx;
}
    9884:	4638      	mov	r0, r7
    9886:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9888:	40002000 	.word	0x40002000

0000988c <uart_nrfx_fifo_read>:

/** Interrupt driven FIFO read function */
static int uart_nrfx_fifo_read(struct device *dev,
			       u8_t *rx_data,
			       const int size)
{
    988c:	b410      	push	{r4}
    988e:	b083      	sub	sp, #12
	u8_t num_rx = 0U;
    9890:	2300      	movs	r3, #0

	while ((size - num_rx > 0) &&
    9892:	4618      	mov	r0, r3
    9894:	1ad4      	subs	r4, r2, r3
    9896:	2c00      	cmp	r4, #0
    9898:	dd0f      	ble.n	98ba <uart_nrfx_fifo_read+0x2e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    989a:	4c09      	ldr	r4, [pc, #36]	; (98c0 <uart_nrfx_fifo_read+0x34>)
    989c:	6824      	ldr	r4, [r4, #0]
    989e:	b164      	cbz	r4, 98ba <uart_nrfx_fifo_read+0x2e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    98a0:	4807      	ldr	r0, [pc, #28]	; (98c0 <uart_nrfx_fifo_read+0x34>)
    98a2:	2400      	movs	r4, #0
    98a4:	6004      	str	r4, [r0, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    98a6:	6800      	ldr	r0, [r0, #0]
    98a8:	9001      	str	r0, [sp, #4]
    (void)dummy;
    98aa:	9801      	ldr	r0, [sp, #4]
	       nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_RXDRDY)) {
		/* Clear the interrupt */
		nrf_uart_event_clear(uart0_addr, NRF_UART_EVENT_RXDRDY);

		/* Receive a character */
		rx_data[num_rx++] = (u8_t)nrf_uart_rxd_get(uart0_addr);
    98ac:	1c58      	adds	r0, r3, #1
    return p_reg->RXD;
    98ae:	4c05      	ldr	r4, [pc, #20]	; (98c4 <uart_nrfx_fifo_read+0x38>)
    98b0:	f8d4 4518 	ldr.w	r4, [r4, #1304]	; 0x518
    98b4:	54cc      	strb	r4, [r1, r3]
    98b6:	b2c3      	uxtb	r3, r0
    98b8:	e7eb      	b.n	9892 <uart_nrfx_fifo_read+0x6>
	}

	return num_rx;
}
    98ba:	b003      	add	sp, #12
    98bc:	bc10      	pop	{r4}
    98be:	4770      	bx	lr
    98c0:	40002108 	.word	0x40002108
    98c4:	40002000 	.word	0x40002000

000098c8 <uart_nrfx_irq_rx_enable>:
    p_reg->INTENSET = mask;
    98c8:	4b02      	ldr	r3, [pc, #8]	; (98d4 <uart_nrfx_irq_rx_enable+0xc>)
    98ca:	2204      	movs	r2, #4
    98cc:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

/** Interrupt driven receiver enabling function */
static void uart_nrfx_irq_rx_enable(struct device *dev)
{
	nrf_uart_int_enable(uart0_addr, NRF_UART_INT_MASK_RXDRDY);
}
    98d0:	4770      	bx	lr
    98d2:	bf00      	nop
    98d4:	40002000 	.word	0x40002000

000098d8 <uart_nrfx_irq_rx_disable>:
    p_reg->INTENCLR = mask;
    98d8:	4b02      	ldr	r3, [pc, #8]	; (98e4 <uart_nrfx_irq_rx_disable+0xc>)
    98da:	2204      	movs	r2, #4
    98dc:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

/** Interrupt driven receiver disabling function */
static void uart_nrfx_irq_rx_disable(struct device *dev)
{
	nrf_uart_int_disable(uart0_addr, NRF_UART_INT_MASK_RXDRDY);
}
    98e0:	4770      	bx	lr
    98e2:	bf00      	nop
    98e4:	40002000 	.word	0x40002000

000098e8 <uart_nrfx_irq_rx_ready>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    98e8:	4b02      	ldr	r3, [pc, #8]	; (98f4 <uart_nrfx_irq_rx_ready+0xc>)
    98ea:	6818      	ldr	r0, [r3, #0]

/** Interrupt driven receiver ready function */
static int uart_nrfx_irq_rx_ready(struct device *dev)
{
	return nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_RXDRDY);
}
    98ec:	3800      	subs	r0, #0
    98ee:	bf18      	it	ne
    98f0:	2001      	movne	r0, #1
    98f2:	4770      	bx	lr
    98f4:	40002108 	.word	0x40002108

000098f8 <uart_nrfx_irq_err_enable>:
    p_reg->INTENSET = mask;
    98f8:	4b02      	ldr	r3, [pc, #8]	; (9904 <uart_nrfx_irq_err_enable+0xc>)
    98fa:	f44f 7200 	mov.w	r2, #512	; 0x200
    98fe:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

/** Interrupt driven error enabling function */
static void uart_nrfx_irq_err_enable(struct device *dev)
{
	nrf_uart_int_enable(uart0_addr, NRF_UART_INT_MASK_ERROR);
}
    9902:	4770      	bx	lr
    9904:	40002000 	.word	0x40002000

00009908 <uart_nrfx_irq_err_disable>:
    p_reg->INTENCLR = mask;
    9908:	4b02      	ldr	r3, [pc, #8]	; (9914 <uart_nrfx_irq_err_disable+0xc>)
    990a:	f44f 7200 	mov.w	r2, #512	; 0x200
    990e:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

/** Interrupt driven error disabling function */
static void uart_nrfx_irq_err_disable(struct device *dev)
{
	nrf_uart_int_disable(uart0_addr, NRF_UART_INT_MASK_ERROR);
}
    9912:	4770      	bx	lr
    9914:	40002000 	.word	0x40002000

00009918 <uart_nrfx_irq_is_pending>:

/** Interrupt driven pending status function */
static int uart_nrfx_irq_is_pending(struct device *dev)
{
    9918:	b510      	push	{r4, lr}
    991a:	4604      	mov	r4, r0
    return p_reg->INTENSET & mask;
    991c:	4b0d      	ldr	r3, [pc, #52]	; (9954 <uart_nrfx_irq_is_pending+0x3c>)
    991e:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
	return ((nrf_uart_int_enable_check(uart0_addr,
					   NRF_UART_INT_MASK_TXDRDY) &&
		 event_txdrdy_check())
		||
    9922:	f013 0f80 	tst.w	r3, #128	; 0x80
    9926:	d107      	bne.n	9938 <uart_nrfx_irq_is_pending+0x20>
    9928:	4b0a      	ldr	r3, [pc, #40]	; (9954 <uart_nrfx_irq_is_pending+0x3c>)
    992a:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
    992e:	f013 0f04 	tst.w	r3, #4
    9932:	d107      	bne.n	9944 <uart_nrfx_irq_is_pending+0x2c>
    9934:	2000      	movs	r0, #0
		(nrf_uart_int_enable_check(uart0_addr,
					   NRF_UART_INT_MASK_RXDRDY) &&
		 uart_nrfx_irq_rx_ready(dev)));
}
    9936:	bd10      	pop	{r4, pc}
		 event_txdrdy_check())
    9938:	f7ff fe3a 	bl	95b0 <event_txdrdy_check>
					   NRF_UART_INT_MASK_TXDRDY) &&
    993c:	2800      	cmp	r0, #0
    993e:	d0f3      	beq.n	9928 <uart_nrfx_irq_is_pending+0x10>
		||
    9940:	2001      	movs	r0, #1
    9942:	e7f8      	b.n	9936 <uart_nrfx_irq_is_pending+0x1e>
		 uart_nrfx_irq_rx_ready(dev)));
    9944:	4620      	mov	r0, r4
    9946:	f7ff ffcf 	bl	98e8 <uart_nrfx_irq_rx_ready>
					   NRF_UART_INT_MASK_RXDRDY) &&
    994a:	2800      	cmp	r0, #0
    994c:	d0f3      	beq.n	9936 <uart_nrfx_irq_is_pending+0x1e>
		||
    994e:	2001      	movs	r0, #1
    9950:	e7f1      	b.n	9936 <uart_nrfx_irq_is_pending+0x1e>
    9952:	bf00      	nop
    9954:	40002000 	.word	0x40002000

00009958 <uart_nrfx_irq_callback_set>:
static void uart_nrfx_irq_callback_set(struct device *dev,
				       uart_irq_callback_user_data_t cb,
				       void *cb_data)
{
	(void)dev;
	irq_callback = cb;
    9958:	4b02      	ldr	r3, [pc, #8]	; (9964 <uart_nrfx_irq_callback_set+0xc>)
    995a:	6019      	str	r1, [r3, #0]
	irq_cb_data = cb_data;
    995c:	4b02      	ldr	r3, [pc, #8]	; (9968 <uart_nrfx_irq_callback_set+0x10>)
    995e:	601a      	str	r2, [r3, #0]
}
    9960:	4770      	bx	lr
    9962:	bf00      	nop
    9964:	20004dac 	.word	0x20004dac
    9968:	20004db0 	.word	0x20004db0

0000996c <uart_nrfx_isr>:
 * @param arg Argument to ISR.
 *
 * @return N/A
 */
static void uart_nrfx_isr(void *arg)
{
    996c:	b500      	push	{lr}
    996e:	b083      	sub	sp, #12
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    9970:	4b08      	ldr	r3, [pc, #32]	; (9994 <uart_nrfx_isr+0x28>)
    9972:	681b      	ldr	r3, [r3, #0]
	ARG_UNUSED(arg);

	if (nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_ERROR)) {
    9974:	b12b      	cbz	r3, 9982 <uart_nrfx_isr+0x16>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    9976:	4b07      	ldr	r3, [pc, #28]	; (9994 <uart_nrfx_isr+0x28>)
    9978:	2200      	movs	r2, #0
    997a:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    997c:	681b      	ldr	r3, [r3, #0]
    997e:	9301      	str	r3, [sp, #4]
    (void)dummy;
    9980:	9b01      	ldr	r3, [sp, #4]
		nrf_uart_event_clear(uart0_addr, NRF_UART_EVENT_ERROR);
	}

	if (irq_callback) {
    9982:	4b05      	ldr	r3, [pc, #20]	; (9998 <uart_nrfx_isr+0x2c>)
    9984:	681b      	ldr	r3, [r3, #0]
    9986:	b113      	cbz	r3, 998e <uart_nrfx_isr+0x22>
		irq_callback(irq_cb_data);
    9988:	4a04      	ldr	r2, [pc, #16]	; (999c <uart_nrfx_isr+0x30>)
    998a:	6810      	ldr	r0, [r2, #0]
    998c:	4798      	blx	r3
	}
}
    998e:	b003      	add	sp, #12
    9990:	f85d fb04 	ldr.w	pc, [sp], #4
    9994:	40002124 	.word	0x40002124
    9998:	20004dac 	.word	0x20004dac
    999c:	20004db0 	.word	0x20004db0

000099a0 <uart_nrfx_irq_tx_disable>:
{
    99a0:	b508      	push	{r3, lr}
    p_reg->INTENCLR = mask;
    99a2:	4b05      	ldr	r3, [pc, #20]	; (99b8 <uart_nrfx_irq_tx_disable+0x18>)
    99a4:	2280      	movs	r2, #128	; 0x80
    99a6:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    99aa:	330c      	adds	r3, #12
    99ac:	2201      	movs	r2, #1
    99ae:	601a      	str	r2, [r3, #0]
	device_busy_clear(dev);
    99b0:	f006 f8eb 	bl	fb8a <device_busy_clear>
}
    99b4:	bd08      	pop	{r3, pc}
    99b6:	bf00      	nop
    99b8:	40002000 	.word	0x40002000

000099bc <uart_nrfx_irq_tx_enable>:
{
    99bc:	b508      	push	{r3, lr}
	device_busy_set(dev);
    99be:	f006 f8e3 	bl	fb88 <device_busy_set>
    99c2:	4b0d      	ldr	r3, [pc, #52]	; (99f8 <uart_nrfx_irq_tx_enable+0x3c>)
    99c4:	2201      	movs	r2, #1
    99c6:	601a      	str	r2, [r3, #0]
    p_reg->INTENSET = mask;
    99c8:	3b08      	subs	r3, #8
    99ca:	2280      	movs	r2, #128	; 0x80
    99cc:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	__asm__ volatile(
    99d0:	f04f 0220 	mov.w	r2, #32
    99d4:	f3ef 8311 	mrs	r3, BASEPRI
    99d8:	f382 8811 	msr	BASEPRI, r2
    99dc:	f3bf 8f6f 	isb	sy
	if (uart_sw_event_txdrdy) {
    99e0:	4a06      	ldr	r2, [pc, #24]	; (99fc <uart_nrfx_irq_tx_enable+0x40>)
    99e2:	7812      	ldrb	r2, [r2, #0]
    99e4:	b11a      	cbz	r2, 99ee <uart_nrfx_irq_tx_enable+0x32>
    99e6:	4a06      	ldr	r2, [pc, #24]	; (9a00 <uart_nrfx_irq_tx_enable+0x44>)
    99e8:	2104      	movs	r1, #4
    99ea:	f8c2 1100 	str.w	r1, [r2, #256]	; 0x100
	__asm__ volatile(
    99ee:	f383 8811 	msr	BASEPRI, r3
    99f2:	f3bf 8f6f 	isb	sy
}
    99f6:	bd08      	pop	{r3, pc}
    99f8:	40002008 	.word	0x40002008
    99fc:	20005954 	.word	0x20005954
    9a00:	e000e100 	.word	0xe000e100

00009a04 <uart_nrfx_poll_out>:
{
    9a04:	b538      	push	{r3, r4, r5, lr}
    9a06:	460c      	mov	r4, r1
	if (!k_is_in_isr()) {
    9a08:	f006 fc56 	bl	102b8 <k_is_in_isr>
    9a0c:	b9c0      	cbnz	r0, 9a40 <uart_nrfx_poll_out+0x3c>
		u8_t safety_cnt = 100;
    9a0e:	2564      	movs	r5, #100	; 0x64
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    9a10:	4b19      	ldr	r3, [pc, #100]	; (9a78 <uart_nrfx_poll_out+0x74>)
    9a12:	2201      	movs	r2, #1
    9a14:	f3bf 8f5b 	dmb	ish
    9a18:	e853 1f00 	ldrex	r1, [r3]
    9a1c:	2900      	cmp	r1, #0
    9a1e:	d103      	bne.n	9a28 <uart_nrfx_poll_out+0x24>
    9a20:	e843 2000 	strex	r0, r2, [r3]
    9a24:	2800      	cmp	r0, #0
    9a26:	d1f7      	bne.n	9a18 <uart_nrfx_poll_out+0x14>
    9a28:	f3bf 8f5b 	dmb	ish
		while (atomic_cas((atomic_t *) lock,
    9a2c:	d00b      	beq.n	9a46 <uart_nrfx_poll_out+0x42>
	return z_impl_k_sleep(timeout);
    9a2e:	2021      	movs	r0, #33	; 0x21
    9a30:	2100      	movs	r1, #0
    9a32:	f001 fc31 	bl	b298 <z_impl_k_sleep>
			if (--safety_cnt == 0) {
    9a36:	3d01      	subs	r5, #1
    9a38:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
    9a3c:	d1e8      	bne.n	9a10 <uart_nrfx_poll_out+0xc>
    9a3e:	e01a      	b.n	9a76 <uart_nrfx_poll_out+0x72>
		*lock = 1;
    9a40:	4b0d      	ldr	r3, [pc, #52]	; (9a78 <uart_nrfx_poll_out+0x74>)
    9a42:	2201      	movs	r2, #1
    9a44:	601a      	str	r2, [r3, #0]
	event_txdrdy_clear();
    9a46:	f7ff fdc3 	bl	95d0 <event_txdrdy_clear>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    9a4a:	4b0c      	ldr	r3, [pc, #48]	; (9a7c <uart_nrfx_poll_out+0x78>)
    9a4c:	2201      	movs	r2, #1
    9a4e:	601a      	str	r2, [r3, #0]
    p_reg->TXD = txd;
    9a50:	3b08      	subs	r3, #8
    9a52:	f8c3 451c 	str.w	r4, [r3, #1308]	; 0x51c
	NRFX_WAIT_FOR(event_txdrdy_check(), 1000, 1, res);
    9a56:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
    9a5a:	f7ff fda9 	bl	95b0 <event_txdrdy_check>
    9a5e:	b920      	cbnz	r0, 9a6a <uart_nrfx_poll_out+0x66>
    9a60:	2001      	movs	r0, #1
    9a62:	f006 f88d 	bl	fb80 <nrfx_busy_wait>
    9a66:	3c01      	subs	r4, #1
    9a68:	d1f7      	bne.n	9a5a <uart_nrfx_poll_out+0x56>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    9a6a:	4b05      	ldr	r3, [pc, #20]	; (9a80 <uart_nrfx_poll_out+0x7c>)
    9a6c:	2201      	movs	r2, #1
    9a6e:	601a      	str	r2, [r3, #0]
	*lock = 0;
    9a70:	4b01      	ldr	r3, [pc, #4]	; (9a78 <uart_nrfx_poll_out+0x74>)
    9a72:	2200      	movs	r2, #0
    9a74:	601a      	str	r2, [r3, #0]
}
    9a76:	bd38      	pop	{r3, r4, r5, pc}
    9a78:	20004db4 	.word	0x20004db4
    9a7c:	40002008 	.word	0x40002008
    9a80:	4000200c 	.word	0x4000200c

00009a84 <uart_nrfx_init>:
 * @param dev UART device struct
 *
 * @return 0 on success
 */
static int uart_nrfx_init(struct device *dev)
{
    9a84:	b530      	push	{r4, r5, lr}
    9a86:	b083      	sub	sp, #12
    p_reg->OUTSET = set_mask;
    9a88:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    9a8c:	2240      	movs	r2, #64	; 0x40
    9a8e:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    9a92:	2403      	movs	r4, #3
    9a94:	f8c3 4718 	str.w	r4, [r3, #1816]	; 0x718
    9a98:	2100      	movs	r1, #0
    9a9a:	f8c3 1720 	str.w	r1, [r3, #1824]	; 0x720
    p_reg->PSEL.RXD = pselrxd;
    9a9e:	4a18      	ldr	r2, [pc, #96]	; (9b00 <uart_nrfx_init+0x7c>)
    9aa0:	2508      	movs	r5, #8
    9aa2:	f8c2 5514 	str.w	r5, [r2, #1300]	; 0x514
    p_reg->PSEL.TXD = pseltxd;
    9aa6:	2506      	movs	r5, #6
    9aa8:	f8c2 550c 	str.w	r5, [r2, #1292]	; 0x50c
    p_reg->OUTSET = set_mask;
    9aac:	2520      	movs	r5, #32
    9aae:	f8c3 5508 	str.w	r5, [r3, #1288]	; 0x508
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    9ab2:	f8c3 4714 	str.w	r4, [r3, #1812]	; 0x714
    9ab6:	f8c3 171c 	str.w	r1, [r3, #1820]	; 0x71c
    p_reg->PSEL.RTS = pselrts;
    9aba:	2305      	movs	r3, #5
    9abc:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    p_reg->PSEL.CTS = pselcts;
    9ac0:	2307      	movs	r3, #7
    9ac2:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510

	nrf_uart_hwfc_pins_set(uart0_addr, RTS_PIN, CTS_PIN);
#endif

	/* Set initial configuration */
	err = uart_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
    9ac6:	68c1      	ldr	r1, [r0, #12]
    9ac8:	f7ff fe60 	bl	978c <uart_nrfx_configure>
	if (err) {
    9acc:	4604      	mov	r4, r0
    9ace:	b110      	cbz	r0, 9ad6 <uart_nrfx_init+0x52>
#if	HW_FLOW_CONTROL
	k_delayed_work_init(&uart0_cb.tx_timeout_work, tx_timeout);
#endif
#endif
	return 0;
}
    9ad0:	4620      	mov	r0, r4
    9ad2:	b003      	add	sp, #12
    9ad4:	bd30      	pop	{r4, r5, pc}
    p_reg->ENABLE = UART_ENABLE_ENABLE_Enabled;
    9ad6:	4b0a      	ldr	r3, [pc, #40]	; (9b00 <uart_nrfx_init+0x7c>)
    9ad8:	2204      	movs	r2, #4
    9ada:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    9ade:	4909      	ldr	r1, [pc, #36]	; (9b04 <uart_nrfx_init+0x80>)
    9ae0:	2200      	movs	r2, #0
    9ae2:	600a      	str	r2, [r1, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    9ae4:	6809      	ldr	r1, [r1, #0]
    9ae6:	9101      	str	r1, [sp, #4]
    (void)dummy;
    9ae8:	9901      	ldr	r1, [sp, #4]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    9aea:	2101      	movs	r1, #1
    9aec:	6019      	str	r1, [r3, #0]
	uart_sw_event_txdrdy = 1U;
    9aee:	4b06      	ldr	r3, [pc, #24]	; (9b08 <uart_nrfx_init+0x84>)
    9af0:	7019      	strb	r1, [r3, #0]
	IRQ_CONNECT(IRQN,
    9af2:	2002      	movs	r0, #2
    9af4:	f7f8 fee4 	bl	28c0 <z_arm_irq_priority_set>
	irq_enable(IRQN);
    9af8:	2002      	movs	r0, #2
    9afa:	f7f8 feaf 	bl	285c <arch_irq_enable>
	return 0;
    9afe:	e7e7      	b.n	9ad0 <uart_nrfx_init+0x4c>
    9b00:	40002000 	.word	0x40002000
    9b04:	40002108 	.word	0x40002108
    9b08:	20005954 	.word	0x20005954

00009b0c <baudrate_set>:
	return dev->driver_data;
}

static inline const struct uarte_nrfx_config *get_dev_config(struct device *dev)
{
	return dev->config_info;
    9b0c:	6843      	ldr	r3, [r0, #4]

static inline NRF_UARTE_Type *get_uarte_instance(struct device *dev)
{
	const struct uarte_nrfx_config *config = get_dev_config(dev);

	return config->uarte_regs;
    9b0e:	681a      	ldr	r2, [r3, #0]
static int baudrate_set(struct device *dev, u32_t baudrate)
{
	nrf_uarte_baudrate_t nrf_baudrate; /* calculated baudrate divisor */
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);

	switch (baudrate) {
    9b10:	f5b1 4f16 	cmp.w	r1, #38400	; 0x9600
    9b14:	d06f      	beq.n	9bf6 <baudrate_set+0xea>
    9b16:	d83a      	bhi.n	9b8e <baudrate_set+0x82>
    9b18:	f5b1 5f16 	cmp.w	r1, #9600	; 0x2580
    9b1c:	d06e      	beq.n	9bfc <baudrate_set+0xf0>
    9b1e:	d90a      	bls.n	9b36 <baudrate_set+0x2a>
    9b20:	f5b1 4fe1 	cmp.w	r1, #28800	; 0x7080
    9b24:	d075      	beq.n	9c12 <baudrate_set+0x106>
    9b26:	d924      	bls.n	9b72 <baudrate_set+0x66>
    9b28:	f647 2312 	movw	r3, #31250	; 0x7a12
    9b2c:	4299      	cmp	r1, r3
    9b2e:	d12b      	bne.n	9b88 <baudrate_set+0x7c>
		break;
	case 28800:
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
		break;
	case 31250:
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
    9b30:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    9b34:	e013      	b.n	9b5e <baudrate_set+0x52>
	switch (baudrate) {
    9b36:	f5b1 6f96 	cmp.w	r1, #1200	; 0x4b0
    9b3a:	d061      	beq.n	9c00 <baudrate_set+0xf4>
    9b3c:	d907      	bls.n	9b4e <baudrate_set+0x42>
    9b3e:	f5b1 6f16 	cmp.w	r1, #2400	; 0x960
    9b42:	d063      	beq.n	9c0c <baudrate_set+0x100>
    9b44:	f5b1 5f96 	cmp.w	r1, #4800	; 0x12c0
    9b48:	d110      	bne.n	9b6c <baudrate_set+0x60>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
    9b4a:	4b3c      	ldr	r3, [pc, #240]	; (9c3c <baudrate_set+0x130>)
    9b4c:	e007      	b.n	9b5e <baudrate_set+0x52>
	switch (baudrate) {
    9b4e:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
    9b52:	d058      	beq.n	9c06 <baudrate_set+0xfa>
    9b54:	f5b1 7f16 	cmp.w	r1, #600	; 0x258
    9b58:	d105      	bne.n	9b66 <baudrate_set+0x5a>
		nrf_baudrate = 0x00027000;
    9b5a:	f44f 331c 	mov.w	r3, #159744	; 0x27000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    9b5e:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
		return -EINVAL;
	}

	nrf_uarte_baudrate_set(uarte, nrf_baudrate);

	return 0;
    9b62:	2000      	movs	r0, #0
    9b64:	4770      	bx	lr
	switch (baudrate) {
    9b66:	f06f 0015 	mvn.w	r0, #21
    9b6a:	4770      	bx	lr
    9b6c:	f06f 0015 	mvn.w	r0, #21
    9b70:	4770      	bx	lr
    9b72:	f5b1 5f61 	cmp.w	r1, #14400	; 0x3840
    9b76:	d04e      	beq.n	9c16 <baudrate_set+0x10a>
    9b78:	f5b1 4f96 	cmp.w	r1, #19200	; 0x4b00
    9b7c:	d101      	bne.n	9b82 <baudrate_set+0x76>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
    9b7e:	4b30      	ldr	r3, [pc, #192]	; (9c40 <baudrate_set+0x134>)
    9b80:	e7ed      	b.n	9b5e <baudrate_set+0x52>
	switch (baudrate) {
    9b82:	f06f 0015 	mvn.w	r0, #21
    9b86:	4770      	bx	lr
    9b88:	f06f 0015 	mvn.w	r0, #21
    9b8c:	4770      	bx	lr
    9b8e:	f5b1 3f61 	cmp.w	r1, #230400	; 0x38400
    9b92:	d042      	beq.n	9c1a <baudrate_set+0x10e>
    9b94:	d909      	bls.n	9baa <baudrate_set+0x9e>
    9b96:	f5b1 2f61 	cmp.w	r1, #921600	; 0xe1000
    9b9a:	d046      	beq.n	9c2a <baudrate_set+0x11e>
    9b9c:	d91f      	bls.n	9bde <baudrate_set+0xd2>
    9b9e:	4b29      	ldr	r3, [pc, #164]	; (9c44 <baudrate_set+0x138>)
    9ba0:	4299      	cmp	r1, r3
    9ba2:	d148      	bne.n	9c36 <baudrate_set+0x12a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
    9ba4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    9ba8:	e7d9      	b.n	9b5e <baudrate_set+0x52>
	switch (baudrate) {
    9baa:	f5b1 3f96 	cmp.w	r1, #76800	; 0x12c00
    9bae:	d037      	beq.n	9c20 <baudrate_set+0x114>
    9bb0:	d905      	bls.n	9bbe <baudrate_set+0xb2>
    9bb2:	f5b1 3fe1 	cmp.w	r1, #115200	; 0x1c200
    9bb6:	d10f      	bne.n	9bd8 <baudrate_set+0xcc>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
    9bb8:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
    9bbc:	e7cf      	b.n	9b5e <baudrate_set+0x52>
	switch (baudrate) {
    9bbe:	f64d 23c0 	movw	r3, #56000	; 0xdac0
    9bc2:	4299      	cmp	r1, r3
    9bc4:	d02e      	beq.n	9c24 <baudrate_set+0x118>
    9bc6:	f5b1 4f61 	cmp.w	r1, #57600	; 0xe100
    9bca:	d102      	bne.n	9bd2 <baudrate_set+0xc6>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
    9bcc:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
    9bd0:	e7c5      	b.n	9b5e <baudrate_set+0x52>
	switch (baudrate) {
    9bd2:	f06f 0015 	mvn.w	r0, #21
    9bd6:	4770      	bx	lr
    9bd8:	f06f 0015 	mvn.w	r0, #21
    9bdc:	4770      	bx	lr
    9bde:	4b1a      	ldr	r3, [pc, #104]	; (9c48 <baudrate_set+0x13c>)
    9be0:	4299      	cmp	r1, r3
    9be2:	d025      	beq.n	9c30 <baudrate_set+0x124>
    9be4:	f5b1 2fe1 	cmp.w	r1, #460800	; 0x70800
    9be8:	d102      	bne.n	9bf0 <baudrate_set+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
    9bea:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
    9bee:	e7b6      	b.n	9b5e <baudrate_set+0x52>
	switch (baudrate) {
    9bf0:	f06f 0015 	mvn.w	r0, #21
    9bf4:	4770      	bx	lr
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
    9bf6:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
    9bfa:	e7b0      	b.n	9b5e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
    9bfc:	4b13      	ldr	r3, [pc, #76]	; (9c4c <baudrate_set+0x140>)
    9bfe:	e7ae      	b.n	9b5e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
    9c00:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
    9c04:	e7ab      	b.n	9b5e <baudrate_set+0x52>
	switch (baudrate) {
    9c06:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
    9c0a:	e7a8      	b.n	9b5e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
    9c0c:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
    9c10:	e7a5      	b.n	9b5e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
    9c12:	4b0f      	ldr	r3, [pc, #60]	; (9c50 <baudrate_set+0x144>)
    9c14:	e7a3      	b.n	9b5e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
    9c16:	4b0f      	ldr	r3, [pc, #60]	; (9c54 <baudrate_set+0x148>)
    9c18:	e7a1      	b.n	9b5e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
    9c1a:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
    9c1e:	e79e      	b.n	9b5e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
    9c20:	4b0d      	ldr	r3, [pc, #52]	; (9c58 <baudrate_set+0x14c>)
    9c22:	e79c      	b.n	9b5e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
    9c24:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
    9c28:	e799      	b.n	9b5e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
    9c2a:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    9c2e:	e796      	b.n	9b5e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
    9c30:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    9c34:	e793      	b.n	9b5e <baudrate_set+0x52>
	switch (baudrate) {
    9c36:	f06f 0015 	mvn.w	r0, #21
}
    9c3a:	4770      	bx	lr
    9c3c:	0013b000 	.word	0x0013b000
    9c40:	004ea000 	.word	0x004ea000
    9c44:	000f4240 	.word	0x000f4240
    9c48:	0003d090 	.word	0x0003d090
    9c4c:	00275000 	.word	0x00275000
    9c50:	0075c000 	.word	0x0075c000
    9c54:	003af000 	.word	0x003af000
    9c58:	013a9000 	.word	0x013a9000

00009c5c <uarte_instance_init>:
};

static int uarte_instance_init(struct device *dev,
			       const struct uarte_init_config *config,
			       u8_t interrupts_active)
{
    9c5c:	b5f0      	push	{r4, r5, r6, r7, lr}
    9c5e:	b083      	sub	sp, #12
	return dev->config_info;
    9c60:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    9c62:	681d      	ldr	r5, [r3, #0]
	return dev->driver_data;
    9c64:	68c7      	ldr	r7, [r0, #12]
	int err;
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
	struct uarte_nrfx_data *data = get_dev_data(dev);

	nrf_gpio_pin_write(config->pseltxd, 1);
    9c66:	680b      	ldr	r3, [r1, #0]
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    9c68:	2b29      	cmp	r3, #41	; 0x29
    9c6a:	d851      	bhi.n	9d10 <uarte_instance_init+0xb4>
    9c6c:	460c      	mov	r4, r1
    9c6e:	4616      	mov	r6, r2
    if (*p_pin < P0_PIN_NUM)
    9c70:	2b1f      	cmp	r3, #31
    9c72:	d954      	bls.n	9d1e <uarte_instance_init+0xc2>
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    9c74:	f003 031f 	and.w	r3, r3, #31
        return NRF_P1;
    9c78:	4960      	ldr	r1, [pc, #384]	; (9dfc <uarte_instance_init+0x1a0>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    9c7a:	2201      	movs	r2, #1
    9c7c:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->OUTSET = set_mask;
    9c80:	f8c1 3508 	str.w	r3, [r1, #1288]	; 0x508
	nrf_gpio_cfg_output(config->pseltxd);
    9c84:	6823      	ldr	r3, [r4, #0]
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    9c86:	2b29      	cmp	r3, #41	; 0x29
    9c88:	d84c      	bhi.n	9d24 <uarte_instance_init+0xc8>
    if (*p_pin < P0_PIN_NUM)
    9c8a:	2b1f      	cmp	r3, #31
    9c8c:	d951      	bls.n	9d32 <uarte_instance_init+0xd6>
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    9c8e:	f003 031f 	and.w	r3, r3, #31
        return NRF_P1;
    9c92:	495a      	ldr	r1, [pc, #360]	; (9dfc <uarte_instance_init+0x1a0>)
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    9c94:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    9c98:	2203      	movs	r2, #3
    9c9a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

	if (config->pselrxd !=  NRF_UARTE_PSEL_DISCONNECTED) {
    9c9e:	6863      	ldr	r3, [r4, #4]
    9ca0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    9ca4:	d148      	bne.n	9d38 <uarte_instance_init+0xdc>
		nrf_gpio_cfg_input(config->pselrxd, NRF_GPIO_PIN_NOPULL);
	}

	nrf_uarte_txrx_pins_set(uarte, config->pseltxd, config->pselrxd);
    9ca6:	6822      	ldr	r2, [r4, #0]
    9ca8:	6863      	ldr	r3, [r4, #4]
    p_reg->PSEL.TXD = pseltxd;
    9caa:	f8c5 250c 	str.w	r2, [r5, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
    9cae:	f8c5 3514 	str.w	r3, [r5, #1300]	; 0x514

	if (config->pselcts != NRF_UARTE_PSEL_DISCONNECTED &&
    9cb2:	68a3      	ldr	r3, [r4, #8]
    9cb4:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    9cb8:	d003      	beq.n	9cc2 <uarte_instance_init+0x66>
	    config->pselrts != NRF_UARTE_PSEL_DISCONNECTED) {
    9cba:	68e3      	ldr	r3, [r4, #12]
	if (config->pselcts != NRF_UARTE_PSEL_DISCONNECTED &&
    9cbc:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    9cc0:	d151      	bne.n	9d66 <uarte_instance_init+0x10a>
		nrf_uarte_hwfc_pins_set(uarte,
					config->pselrts,
					config->pselcts);
	}

	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
    9cc2:	68c1      	ldr	r1, [r0, #12]
    9cc4:	f005 fdc0 	bl	f848 <uarte_nrfx_configure>
	if (err) {
    9cc8:	bb00      	cbnz	r0, 9d0c <uarte_instance_init+0xb0>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
    9cca:	2308      	movs	r3, #8
    9ccc:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
	}
#endif
	/* Enable receiver and transmitter */
	nrf_uarte_enable(uarte);

	if (config->pselrxd != NRF_UARTE_PSEL_DISCONNECTED) {
    9cd0:	6863      	ldr	r3, [r4, #4]
    9cd2:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    9cd6:	d00e      	beq.n	9cf6 <uarte_instance_init+0x9a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    9cd8:	2300      	movs	r3, #0
    9cda:	f8c5 3110 	str.w	r3, [r5, #272]	; 0x110
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    9cde:	f8d5 3110 	ldr.w	r3, [r5, #272]	; 0x110
    9ce2:	9301      	str	r3, [sp, #4]
    (void)dummy;
    9ce4:	9b01      	ldr	r3, [sp, #4]
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDRX);

		nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
    9ce6:	f107 0310 	add.w	r3, r7, #16

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    9cea:	f8c5 3534 	str.w	r3, [r5, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
    9cee:	2301      	movs	r3, #1
    9cf0:	f8c5 3538 	str.w	r3, [r5, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    9cf4:	602b      	str	r3, [r5, #0]
		nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STARTRX);
	}

#ifdef UARTE_INTERRUPT_DRIVEN
	if (interrupts_active) {
    9cf6:	b14e      	cbz	r6, 9d0c <uarte_instance_init+0xb0>
		/* Set ENDTX event by requesting fake (zero-length) transfer.
		 * Pointer to RAM variable (data->tx_buffer) is set because
		 * otherwise such operation may result in HardFault or RAM
		 * corruption.
		 */
		nrf_uarte_tx_buffer_set(uarte, data->int_driven->tx_buffer, 0);
    9cf8:	68bb      	ldr	r3, [r7, #8]
    9cfa:	689b      	ldr	r3, [r3, #8]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    9cfc:	f8c5 3544 	str.w	r3, [r5, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    9d00:	2300      	movs	r3, #0
    9d02:	f8c5 3548 	str.w	r3, [r5, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    9d06:	2301      	movs	r3, #1
    9d08:	60ab      	str	r3, [r5, #8]
    9d0a:	60eb      	str	r3, [r5, #12]
		/* switch off transmitter to save an energy */
		nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STOPTX);
	}
#endif
	return 0;
}
    9d0c:	b003      	add	sp, #12
    9d0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    9d10:	4b3b      	ldr	r3, [pc, #236]	; (9e00 <uarte_instance_init+0x1a4>)
    9d12:	4a3c      	ldr	r2, [pc, #240]	; (9e04 <uarte_instance_init+0x1a8>)
    9d14:	f44f 71ed 	mov.w	r1, #474	; 0x1da
    9d18:	483b      	ldr	r0, [pc, #236]	; (9e08 <uarte_instance_init+0x1ac>)
    9d1a:	f001 ffc7 	bl	bcac <__assert_func>
        return NRF_P0;
    9d1e:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
    9d22:	e7aa      	b.n	9c7a <uarte_instance_init+0x1e>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    9d24:	4b36      	ldr	r3, [pc, #216]	; (9e00 <uarte_instance_init+0x1a4>)
    9d26:	4a37      	ldr	r2, [pc, #220]	; (9e04 <uarte_instance_init+0x1a8>)
    9d28:	f44f 71ed 	mov.w	r1, #474	; 0x1da
    9d2c:	4836      	ldr	r0, [pc, #216]	; (9e08 <uarte_instance_init+0x1ac>)
    9d2e:	f001 ffbd 	bl	bcac <__assert_func>
        return NRF_P0;
    9d32:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
    9d36:	e7ad      	b.n	9c94 <uarte_instance_init+0x38>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    9d38:	2b29      	cmp	r3, #41	; 0x29
    9d3a:	d80a      	bhi.n	9d52 <uarte_instance_init+0xf6>
    if (*p_pin < P0_PIN_NUM)
    9d3c:	2b1f      	cmp	r3, #31
    9d3e:	d90f      	bls.n	9d60 <uarte_instance_init+0x104>
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    9d40:	f003 031f 	and.w	r3, r3, #31
        return NRF_P1;
    9d44:	4a2d      	ldr	r2, [pc, #180]	; (9dfc <uarte_instance_init+0x1a0>)
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    9d46:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    9d4a:	2100      	movs	r1, #0
    9d4c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
}
    9d50:	e7a9      	b.n	9ca6 <uarte_instance_init+0x4a>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    9d52:	4b2b      	ldr	r3, [pc, #172]	; (9e00 <uarte_instance_init+0x1a4>)
    9d54:	4a2b      	ldr	r2, [pc, #172]	; (9e04 <uarte_instance_init+0x1a8>)
    9d56:	f44f 71ed 	mov.w	r1, #474	; 0x1da
    9d5a:	482b      	ldr	r0, [pc, #172]	; (9e08 <uarte_instance_init+0x1ac>)
    9d5c:	f001 ffa6 	bl	bcac <__assert_func>
        return NRF_P0;
    9d60:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    9d64:	e7ef      	b.n	9d46 <uarte_instance_init+0xea>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    9d66:	2b29      	cmp	r3, #41	; 0x29
    9d68:	d81f      	bhi.n	9daa <uarte_instance_init+0x14e>
    if (*p_pin < P0_PIN_NUM)
    9d6a:	2b1f      	cmp	r3, #31
    9d6c:	d924      	bls.n	9db8 <uarte_instance_init+0x15c>
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    9d6e:	f003 031f 	and.w	r3, r3, #31
        return NRF_P1;
    9d72:	4922      	ldr	r1, [pc, #136]	; (9dfc <uarte_instance_init+0x1a0>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    9d74:	2201      	movs	r2, #1
    9d76:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->OUTSET = set_mask;
    9d7a:	f8c1 3508 	str.w	r3, [r1, #1288]	; 0x508
		nrf_gpio_cfg_output(config->pselrts);
    9d7e:	68e3      	ldr	r3, [r4, #12]
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    9d80:	2b29      	cmp	r3, #41	; 0x29
    9d82:	d81c      	bhi.n	9dbe <uarte_instance_init+0x162>
    if (*p_pin < P0_PIN_NUM)
    9d84:	2b1f      	cmp	r3, #31
    9d86:	d921      	bls.n	9dcc <uarte_instance_init+0x170>
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    9d88:	f003 031f 	and.w	r3, r3, #31
        return NRF_P1;
    9d8c:	4a1b      	ldr	r2, [pc, #108]	; (9dfc <uarte_instance_init+0x1a0>)
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    9d8e:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    9d92:	2103      	movs	r1, #3
    9d94:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		nrf_gpio_cfg_input(config->pselcts, NRF_GPIO_PIN_NOPULL);
    9d98:	68a3      	ldr	r3, [r4, #8]
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    9d9a:	2b29      	cmp	r3, #41	; 0x29
    9d9c:	d819      	bhi.n	9dd2 <uarte_instance_init+0x176>
    if (*p_pin < P0_PIN_NUM)
    9d9e:	2b1f      	cmp	r3, #31
    9da0:	d91e      	bls.n	9de0 <uarte_instance_init+0x184>
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    9da2:	f003 031f 	and.w	r3, r3, #31
        return NRF_P1;
    9da6:	4a15      	ldr	r2, [pc, #84]	; (9dfc <uarte_instance_init+0x1a0>)
    9da8:	e01c      	b.n	9de4 <uarte_instance_init+0x188>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    9daa:	4b15      	ldr	r3, [pc, #84]	; (9e00 <uarte_instance_init+0x1a4>)
    9dac:	4a15      	ldr	r2, [pc, #84]	; (9e04 <uarte_instance_init+0x1a8>)
    9dae:	f44f 71ed 	mov.w	r1, #474	; 0x1da
    9db2:	4815      	ldr	r0, [pc, #84]	; (9e08 <uarte_instance_init+0x1ac>)
    9db4:	f001 ff7a 	bl	bcac <__assert_func>
        return NRF_P0;
    9db8:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
    9dbc:	e7da      	b.n	9d74 <uarte_instance_init+0x118>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    9dbe:	4b10      	ldr	r3, [pc, #64]	; (9e00 <uarte_instance_init+0x1a4>)
    9dc0:	4a10      	ldr	r2, [pc, #64]	; (9e04 <uarte_instance_init+0x1a8>)
    9dc2:	f44f 71ed 	mov.w	r1, #474	; 0x1da
    9dc6:	4810      	ldr	r0, [pc, #64]	; (9e08 <uarte_instance_init+0x1ac>)
    9dc8:	f001 ff70 	bl	bcac <__assert_func>
        return NRF_P0;
    9dcc:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    9dd0:	e7dd      	b.n	9d8e <uarte_instance_init+0x132>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    9dd2:	4b0b      	ldr	r3, [pc, #44]	; (9e00 <uarte_instance_init+0x1a4>)
    9dd4:	4a0b      	ldr	r2, [pc, #44]	; (9e04 <uarte_instance_init+0x1a8>)
    9dd6:	f44f 71ed 	mov.w	r1, #474	; 0x1da
    9dda:	480b      	ldr	r0, [pc, #44]	; (9e08 <uarte_instance_init+0x1ac>)
    9ddc:	f001 ff66 	bl	bcac <__assert_func>
        return NRF_P0;
    9de0:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    9de4:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    9de8:	2100      	movs	r1, #0
    9dea:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		nrf_uarte_hwfc_pins_set(uarte,
    9dee:	68e2      	ldr	r2, [r4, #12]
    9df0:	68a3      	ldr	r3, [r4, #8]
    p_reg->PSEL.RTS = pselrts;
    9df2:	f8c5 2508 	str.w	r2, [r5, #1288]	; 0x508
    p_reg->PSEL.CTS = pselcts;
    9df6:	f8c5 3510 	str.w	r3, [r5, #1296]	; 0x510
}
    9dfa:	e762      	b.n	9cc2 <uarte_instance_init+0x66>
    9dfc:	50000300 	.word	0x50000300
    9e00:	00012db8 	.word	0x00012db8
    9e04:	00012f10 	.word	0x00012f10
    9e08:	00012dcc 	.word	0x00012dcc

00009e0c <uarte_1_init>:
#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
#endif

#ifdef CONFIG_UART_1_NRF_UARTE
UART_NRF_UARTE_DEVICE(1);
    9e0c:	b530      	push	{r4, r5, lr}
    9e0e:	b085      	sub	sp, #20
    9e10:	4605      	mov	r5, r0
    9e12:	4b0a      	ldr	r3, [pc, #40]	; (9e3c <uarte_1_init+0x30>)
    9e14:	466c      	mov	r4, sp
    9e16:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    9e18:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    9e1c:	2200      	movs	r2, #0
    9e1e:	2101      	movs	r1, #1
    9e20:	2028      	movs	r0, #40	; 0x28
    9e22:	f7f8 fd4d 	bl	28c0 <z_arm_irq_priority_set>
    9e26:	2028      	movs	r0, #40	; 0x28
    9e28:	f7f8 fd18 	bl	285c <arch_irq_enable>
    9e2c:	2201      	movs	r2, #1
    9e2e:	4621      	mov	r1, r4
    9e30:	4628      	mov	r0, r5
    9e32:	f7ff ff13 	bl	9c5c <uarte_instance_init>
    9e36:	b005      	add	sp, #20
    9e38:	bd30      	pop	{r4, r5, pc}
    9e3a:	bf00      	nop
    9e3c:	00010d40 	.word	0x00010d40

00009e40 <random_byte_get>:
	__asm__ volatile(
    9e40:	f04f 0320 	mov.w	r3, #32
    9e44:	f3ef 8211 	mrs	r2, BASEPRI
    9e48:	f383 8811 	msr	BASEPRI, r3
    9e4c:	f3bf 8f6f 	isb	sy
#endif
}

NRF_STATIC_INLINE bool nrf_rng_event_check(NRF_RNG_Type const * p_reg, nrf_rng_event_t rng_event)
{
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
    9e50:	4b0d      	ldr	r3, [pc, #52]	; (9e88 <random_byte_get+0x48>)
    9e52:	681b      	ldr	r3, [r3, #0]
	int retval = -EAGAIN;
	unsigned int key;

	key = irq_lock();

	if (nrf_rng_event_check(NRF_RNG, NRF_RNG_EVENT_VALRDY)) {
    9e54:	b18b      	cbz	r3, 9e7a <random_byte_get+0x3a>
{
    9e56:	b082      	sub	sp, #8
     p_reg->SHORTS &= ~mask;
}

NRF_STATIC_INLINE uint8_t nrf_rng_random_value_get(NRF_RNG_Type const * p_reg)
{
    return (uint8_t)(p_reg->VALUE & RNG_VALUE_VALUE_Msk);
    9e58:	4b0c      	ldr	r3, [pc, #48]	; (9e8c <random_byte_get+0x4c>)
    9e5a:	f8d3 0508 	ldr.w	r0, [r3, #1288]	; 0x508
		retval = nrf_rng_random_value_get(NRF_RNG);
    9e5e:	b2c0      	uxtb	r0, r0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
    9e60:	f503 7380 	add.w	r3, r3, #256	; 0x100
    9e64:	2100      	movs	r1, #0
    9e66:	6019      	str	r1, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
    9e68:	681b      	ldr	r3, [r3, #0]
    9e6a:	9301      	str	r3, [sp, #4]
    (void)dummy;
    9e6c:	9b01      	ldr	r3, [sp, #4]
	__asm__ volatile(
    9e6e:	f382 8811 	msr	BASEPRI, r2
    9e72:	f3bf 8f6f 	isb	sy
	}

	irq_unlock(key);

	return retval;
}
    9e76:	b002      	add	sp, #8
    9e78:	4770      	bx	lr
	int retval = -EAGAIN;
    9e7a:	f06f 000a 	mvn.w	r0, #10
    9e7e:	f382 8811 	msr	BASEPRI, r2
    9e82:	f3bf 8f6f 	isb	sy
}
    9e86:	4770      	bx	lr
    9e88:	4000d100 	.word	0x4000d100
    9e8c:	4000d000 	.word	0x4000d000

00009e90 <rng_pool_get>:
#pragma GCC push_options
#if defined(CONFIG_BT_CTLR_FAST_ENC)
#pragma GCC optimize ("Ofast")
#endif
static u16_t rng_pool_get(struct rng_pool *rngp, u8_t *buf, u16_t len)
{
    9e90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9e94:	4606      	mov	r6, r0
	u32_t last  = rngp->last;
    9e96:	f890 c002 	ldrb.w	ip, [r0, #2]
	u32_t mask  = rngp->mask;
    9e9a:	78c5      	ldrb	r5, [r0, #3]
    9e9c:	462f      	mov	r7, r5
	__asm__ volatile(
    9e9e:	f04f 0320 	mov.w	r3, #32
    9ea2:	f3ef 8811 	mrs	r8, BASEPRI
    9ea6:	f383 8811 	msr	BASEPRI, r3
    9eaa:	f3bf 8f6f 	isb	sy
	u32_t first, available;
	u32_t other_read_in_progress;
	unsigned int key;

	key = irq_lock();
	first = rngp->first_alloc;
    9eae:	7800      	ldrb	r0, [r0, #0]
    9eb0:	4604      	mov	r4, r0
	/*
	 * The other_read_in_progress is non-zero if rngp->first_read != first,
	 * which means that lower-priority code (which was interrupted by this
	 * call) already allocated area for read.
	 */
	other_read_in_progress = (rngp->first_read ^ first);
    9eb2:	f896 e001 	ldrb.w	lr, [r6, #1]

	available = (last - first) & mask;
    9eb6:	ebac 0c00 	sub.w	ip, ip, r0
    9eba:	ea0c 0c05 	and.w	ip, ip, r5
	if (available < len) {
    9ebe:	4562      	cmp	r2, ip
    9ec0:	d901      	bls.n	9ec6 <rng_pool_get+0x36>
		len = available;
    9ec2:	fa1f f28c 	uxth.w	r2, ip

	/*
	 * Move alloc index forward to signal, that part of the buffer is
	 * now reserved for this call.
	 */
	rngp->first_alloc = (first + len) & mask;
    9ec6:	1883      	adds	r3, r0, r2
    9ec8:	402b      	ands	r3, r5
    9eca:	7033      	strb	r3, [r6, #0]
	__asm__ volatile(
    9ecc:	f388 8811 	msr	BASEPRI, r8
    9ed0:	f3bf 8f6f 	isb	sy
	u8_t *dst   = buf;
    9ed4:	460b      	mov	r3, r1
}
    9ed6:	e006      	b.n	9ee6 <rng_pool_get+0x56>
	irq_unlock(key);

	while (likely(len--)) {
		*dst++ = rngp->buffer[first];
    9ed8:	1932      	adds	r2, r6, r4
    9eda:	7952      	ldrb	r2, [r2, #5]
    9edc:	f803 2b01 	strb.w	r2, [r3], #1
		first = (first + 1) & mask;
    9ee0:	3401      	adds	r4, #1
    9ee2:	403c      	ands	r4, r7
	while (likely(len--)) {
    9ee4:	462a      	mov	r2, r5
    9ee6:	1e55      	subs	r5, r2, #1
    9ee8:	b2ad      	uxth	r5, r5
    9eea:	2a00      	cmp	r2, #0
    9eec:	d1f4      	bne.n	9ed8 <rng_pool_get+0x48>
	/*
	 * If this call is the last one accessing the pool, move read index
	 * to signal that all allocated regions are now read and could be
	 * overwritten.
	 */
	if (likely(!other_read_in_progress)) {
    9eee:	4570      	cmp	r0, lr
    9ef0:	d10d      	bne.n	9f0e <rng_pool_get+0x7e>
	__asm__ volatile(
    9ef2:	f04f 0020 	mov.w	r0, #32
    9ef6:	f3ef 8211 	mrs	r2, BASEPRI
    9efa:	f380 8811 	msr	BASEPRI, r0
    9efe:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		rngp->first_read = rngp->first_alloc;
    9f02:	7830      	ldrb	r0, [r6, #0]
    9f04:	7070      	strb	r0, [r6, #1]
	__asm__ volatile(
    9f06:	f382 8811 	msr	BASEPRI, r2
    9f0a:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}

	len = dst - buf;
    9f0e:	1a5b      	subs	r3, r3, r1
    9f10:	b298      	uxth	r0, r3
	available = available - len;
    9f12:	ebac 0c00 	sub.w	ip, ip, r0
	if (available <= rngp->threshold) {
    9f16:	7933      	ldrb	r3, [r6, #4]
    9f18:	4563      	cmp	r3, ip
    9f1a:	d302      	bcc.n	9f22 <rng_pool_get+0x92>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
    9f1c:	4b02      	ldr	r3, [pc, #8]	; (9f28 <rng_pool_get+0x98>)
    9f1e:	2201      	movs	r2, #1
    9f20:	601a      	str	r2, [r3, #0]
		nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);
	}

	return len;
}
    9f22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9f26:	bf00      	nop
    9f28:	4000d000 	.word	0x4000d000

00009f2c <entropy_nrf5_get_entropy_isr>:
	return 0;
}

static int entropy_nrf5_get_entropy_isr(struct device *dev, u8_t *buf, u16_t len,
					u32_t flags)
{
    9f2c:	b5f0      	push	{r4, r5, r6, r7, lr}
    9f2e:	b083      	sub	sp, #12
    9f30:	460d      	mov	r5, r1
    9f32:	4614      	mov	r4, r2
	u16_t cnt = len;

	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == DEV_DATA(dev));

	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
    9f34:	f013 0f01 	tst.w	r3, #1
    9f38:	d104      	bne.n	9f44 <entropy_nrf5_get_entropy_isr+0x18>
		return rng_pool_get((struct rng_pool *)(entropy_nrf5_data.isr),
    9f3a:	4820      	ldr	r0, [pc, #128]	; (9fbc <entropy_nrf5_get_entropy_isr+0x90>)
    9f3c:	f7ff ffa8 	bl	9e90 <rng_pool_get>
			irq_enable(IRQN);
		}
	}

	return cnt;
}
    9f40:	b003      	add	sp, #12
    9f42:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (len) {
    9f44:	b90a      	cbnz	r2, 9f4a <entropy_nrf5_get_entropy_isr+0x1e>
	return cnt;
    9f46:	4620      	mov	r0, r4
    9f48:	e7fa      	b.n	9f40 <entropy_nrf5_get_entropy_isr+0x14>
	__asm__ volatile(
    9f4a:	f04f 0320 	mov.w	r3, #32
    9f4e:	f3ef 8611 	mrs	r6, BASEPRI
    9f52:	f383 8811 	msr	BASEPRI, r3
    9f56:	f3bf 8f6f 	isb	sy
		irq_enabled = irq_is_enabled(IRQN);
    9f5a:	200d      	movs	r0, #13
    9f5c:	f7f8 fca2 	bl	28a4 <arch_irq_is_enabled>
    9f60:	4607      	mov	r7, r0
		irq_disable(IRQN);
    9f62:	200d      	movs	r0, #13
    9f64:	f7f8 fc8a 	bl	287c <arch_irq_disable>
	__asm__ volatile(
    9f68:	f386 8811 	msr	BASEPRI, r6
    9f6c:	f3bf 8f6f 	isb	sy
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
    9f70:	4b13      	ldr	r3, [pc, #76]	; (9fc0 <entropy_nrf5_get_entropy_isr+0x94>)
    9f72:	2200      	movs	r2, #0
    9f74:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
    9f76:	681b      	ldr	r3, [r3, #0]
    9f78:	9301      	str	r3, [sp, #4]
    (void)dummy;
    9f7a:	9b01      	ldr	r3, [sp, #4]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
    9f7c:	4b11      	ldr	r3, [pc, #68]	; (9fc4 <entropy_nrf5_get_entropy_isr+0x98>)
    9f7e:	2201      	movs	r2, #1
    9f80:	601a      	str	r2, [r3, #0]
}
    9f82:	4626      	mov	r6, r4
    9f84:	e002      	b.n	9f8c <entropy_nrf5_get_entropy_isr+0x60>
				__WFE();
    9f86:	bf20      	wfe
				__SEV();
    9f88:	bf40      	sev
				__WFE();
    9f8a:	bf20      	wfe
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
    9f8c:	4b0c      	ldr	r3, [pc, #48]	; (9fc0 <entropy_nrf5_get_entropy_isr+0x94>)
    9f8e:	681b      	ldr	r3, [r3, #0]
			while (!nrf_rng_event_check(NRF_RNG,
    9f90:	2b00      	cmp	r3, #0
    9f92:	d0f8      	beq.n	9f86 <entropy_nrf5_get_entropy_isr+0x5a>
			byte = random_byte_get();
    9f94:	f7ff ff54 	bl	9e40 <random_byte_get>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    9f98:	4b0b      	ldr	r3, [pc, #44]	; (9fc8 <entropy_nrf5_get_entropy_isr+0x9c>)
    9f9a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    9f9e:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
			if (byte < 0) {
    9fa2:	2800      	cmp	r0, #0
    9fa4:	db02      	blt.n	9fac <entropy_nrf5_get_entropy_isr+0x80>
			buf[--len] = byte;
    9fa6:	3e01      	subs	r6, #1
    9fa8:	b2b6      	uxth	r6, r6
    9faa:	55a8      	strb	r0, [r5, r6]
		} while (len);
    9fac:	2e00      	cmp	r6, #0
    9fae:	d1ed      	bne.n	9f8c <entropy_nrf5_get_entropy_isr+0x60>
		if (irq_enabled) {
    9fb0:	2f00      	cmp	r7, #0
    9fb2:	d0c8      	beq.n	9f46 <entropy_nrf5_get_entropy_isr+0x1a>
			irq_enable(IRQN);
    9fb4:	200d      	movs	r0, #13
    9fb6:	f7f8 fc51 	bl	285c <arch_irq_enable>
    9fba:	e7c4      	b.n	9f46 <entropy_nrf5_get_entropy_isr+0x1a>
    9fbc:	20004e08 	.word	0x20004e08
    9fc0:	4000d100 	.word	0x4000d100
    9fc4:	4000d000 	.word	0x4000d000
    9fc8:	e000e100 	.word	0xe000e100

00009fcc <isr>:
{
    9fcc:	b510      	push	{r4, lr}
	byte = random_byte_get();
    9fce:	f7ff ff37 	bl	9e40 <random_byte_get>
	if (byte < 0) {
    9fd2:	2800      	cmp	r0, #0
    9fd4:	db06      	blt.n	9fe4 <isr+0x18>
	ret = rng_pool_put((struct rng_pool *)(entropy_nrf5_data.isr), byte);
    9fd6:	b2c4      	uxtb	r4, r0
    9fd8:	4621      	mov	r1, r4
    9fda:	480a      	ldr	r0, [pc, #40]	; (a004 <isr+0x38>)
    9fdc:	f005 fdb4 	bl	fb48 <rng_pool_put>
	if (ret < 0) {
    9fe0:	2800      	cmp	r0, #0
    9fe2:	db00      	blt.n	9fe6 <isr+0x1a>
}
    9fe4:	bd10      	pop	{r4, pc}
		ret = rng_pool_put((struct rng_pool *)(entropy_nrf5_data.thr),
    9fe6:	4621      	mov	r1, r4
    9fe8:	4807      	ldr	r0, [pc, #28]	; (a008 <isr+0x3c>)
    9fea:	f005 fdad 	bl	fb48 <rng_pool_put>
		if (ret < 0) {
    9fee:	2800      	cmp	r0, #0
    9ff0:	db03      	blt.n	9ffa <isr+0x2e>
	z_impl_k_sem_give(sem);
    9ff2:	4806      	ldr	r0, [pc, #24]	; (a00c <isr+0x40>)
    9ff4:	f001 f982 	bl	b2fc <z_impl_k_sem_give>
}
    9ff8:	e7f4      	b.n	9fe4 <isr+0x18>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
    9ffa:	4b05      	ldr	r3, [pc, #20]	; (a010 <isr+0x44>)
    9ffc:	2201      	movs	r2, #1
    9ffe:	601a      	str	r2, [r3, #0]
}
    a000:	e7f7      	b.n	9ff2 <isr+0x26>
    a002:	bf00      	nop
    a004:	20004e08 	.word	0x20004e08
    a008:	20004e1d 	.word	0x20004e1d
    a00c:	20004df0 	.word	0x20004df0
    a010:	4000d004 	.word	0x4000d004

0000a014 <entropy_nrf5_get_entropy>:
{
    a014:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a016:	460f      	mov	r7, r1
    a018:	4614      	mov	r4, r2
	while (len) {
    a01a:	e002      	b.n	a022 <entropy_nrf5_get_entropy+0xe>
		len -= bytes;
    a01c:	1b64      	subs	r4, r4, r5
    a01e:	b2a4      	uxth	r4, r4
		buf += bytes;
    a020:	442f      	add	r7, r5
	while (len) {
    a022:	b1e4      	cbz	r4, a05e <entropy_nrf5_get_entropy+0x4a>
	return z_impl_k_sem_take(sem, timeout);
    a024:	4e0f      	ldr	r6, [pc, #60]	; (a064 <entropy_nrf5_get_entropy+0x50>)
    a026:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    a02a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    a02e:	4630      	mov	r0, r6
    a030:	f001 f98c 	bl	b34c <z_impl_k_sem_take>
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
    a034:	4622      	mov	r2, r4
    a036:	4639      	mov	r1, r7
    a038:	f106 0045 	add.w	r0, r6, #69	; 0x45
    a03c:	f7ff ff28 	bl	9e90 <rng_pool_get>
    a040:	4605      	mov	r5, r0
	z_impl_k_sem_give(sem);
    a042:	4630      	mov	r0, r6
    a044:	f001 f95a 	bl	b2fc <z_impl_k_sem_give>
		if (bytes == 0U) {
    a048:	2d00      	cmp	r5, #0
    a04a:	d1e7      	bne.n	a01c <entropy_nrf5_get_entropy+0x8>
	return z_impl_k_sem_take(sem, timeout);
    a04c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    a050:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    a054:	f106 0018 	add.w	r0, r6, #24
    a058:	f001 f978 	bl	b34c <z_impl_k_sem_take>
			continue;
    a05c:	e7e1      	b.n	a022 <entropy_nrf5_get_entropy+0xe>
}
    a05e:	2000      	movs	r0, #0
    a060:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a062:	bf00      	nop
    a064:	20004dd8 	.word	0x20004dd8

0000a068 <entropy_nrf5_init>:
		    entropy_nrf5_init, &entropy_nrf5_data, NULL,
		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &entropy_nrf5_api_funcs);

static int entropy_nrf5_init(struct device *device)
{
    a068:	b510      	push	{r4, lr}
    a06a:	b082      	sub	sp, #8
	return z_impl_k_sem_init(sem, initial_count, limit);
    a06c:	4c19      	ldr	r4, [pc, #100]	; (a0d4 <entropy_nrf5_init+0x6c>)
    a06e:	2201      	movs	r2, #1
    a070:	4611      	mov	r1, r2
    a072:	4620      	mov	r0, r4
    a074:	f006 f90d 	bl	10292 <z_impl_k_sem_init>
    a078:	2201      	movs	r2, #1
    a07a:	2100      	movs	r1, #0
    a07c:	f104 0018 	add.w	r0, r4, #24
    a080:	f006 f907 	bl	10292 <z_impl_k_sem_init>
	k_sem_init(&entropy_nrf5_data.sem_lock, 1, 1);

	/* Synching semaphore */
	k_sem_init(&entropy_nrf5_data.sem_sync, 0, 1);

	rng_pool_init((struct rng_pool *)(entropy_nrf5_data.thr),
    a084:	2204      	movs	r2, #4
    a086:	2108      	movs	r1, #8
    a088:	f104 0045 	add.w	r0, r4, #69	; 0x45
    a08c:	f005 fd70 	bl	fb70 <rng_pool_init>
		      CONFIG_ENTROPY_NRF5_THR_POOL_SIZE,
		      CONFIG_ENTROPY_NRF5_THR_THRESHOLD);
	rng_pool_init((struct rng_pool *)(entropy_nrf5_data.isr),
    a090:	220c      	movs	r2, #12
    a092:	2110      	movs	r1, #16
    a094:	f104 0030 	add.w	r0, r4, #48	; 0x30
    a098:	f005 fd6a 	bl	fb70 <rng_pool_init>
}

NRF_STATIC_INLINE void nrf_rng_error_correction_enable(NRF_RNG_Type * p_reg)
{
    p_reg->CONFIG |= RNG_CONFIG_DERCEN_Msk;
    a09c:	4b0e      	ldr	r3, [pc, #56]	; (a0d8 <entropy_nrf5_init+0x70>)
    a09e:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
    a0a2:	f042 0201 	orr.w	r2, r2, #1
    a0a6:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
    a0aa:	4a0c      	ldr	r2, [pc, #48]	; (a0dc <entropy_nrf5_init+0x74>)
    a0ac:	2400      	movs	r4, #0
    a0ae:	6014      	str	r4, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
    a0b0:	6812      	ldr	r2, [r2, #0]
    a0b2:	9201      	str	r2, [sp, #4]
    (void)dummy;
    a0b4:	9a01      	ldr	r2, [sp, #4]
    p_reg->INTENSET = mask;
    a0b6:	2101      	movs	r1, #1
    a0b8:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
    a0bc:	6019      	str	r1, [r3, #0]

	nrf_rng_event_clear(NRF_RNG, NRF_RNG_EVENT_VALRDY);
	nrf_rng_int_enable(NRF_RNG, NRF_RNG_INT_VALRDY_MASK);
	nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);

	IRQ_CONNECT(IRQN, IRQ_PRIO, isr, &entropy_nrf5_data, 0);
    a0be:	4622      	mov	r2, r4
    a0c0:	200d      	movs	r0, #13
    a0c2:	f7f8 fbfd 	bl	28c0 <z_arm_irq_priority_set>
	irq_enable(IRQN);
    a0c6:	200d      	movs	r0, #13
    a0c8:	f7f8 fbc8 	bl	285c <arch_irq_enable>

	return 0;
}
    a0cc:	4620      	mov	r0, r4
    a0ce:	b002      	add	sp, #8
    a0d0:	bd10      	pop	{r4, pc}
    a0d2:	bf00      	nop
    a0d4:	20004dd8 	.word	0x20004dd8
    a0d8:	4000d000 	.word	0x4000d000
    a0dc:	4000d100 	.word	0x4000d100

0000a0e0 <errata_36>:
    return false;
}

static bool errata_36(void)
{
    uint32_t var1 = *(uint32_t *)0x10000130ul;
    a0e0:	4b03      	ldr	r3, [pc, #12]	; (a0f0 <errata_36+0x10>)
    a0e2:	681b      	ldr	r3, [r3, #0]
    uint32_t var2 = *(uint32_t *)0x10000134ul;

    switch(var1)
    a0e4:	2b0d      	cmp	r3, #13
    a0e6:	d001      	beq.n	a0ec <errata_36+0xc>
            }
        break;

    }

    return false;
    a0e8:	2000      	movs	r0, #0
    a0ea:	4770      	bx	lr
                    return true;
    a0ec:	2001      	movs	r0, #1
}
    a0ee:	4770      	bx	lr
    a0f0:	10000130 	.word	0x10000130

0000a0f4 <errata_66>:
    return false;
}

static bool errata_66(void)
{
    uint32_t var1 = *(uint32_t *)0x10000130ul;
    a0f4:	4b03      	ldr	r3, [pc, #12]	; (a104 <errata_66+0x10>)
    a0f6:	681b      	ldr	r3, [r3, #0]
    uint32_t var2 = *(uint32_t *)0x10000134ul;

    switch(var1)
    a0f8:	2b0d      	cmp	r3, #13
    a0fa:	d001      	beq.n	a100 <errata_66+0xc>
            }
        break;

    }

    return false;
    a0fc:	2000      	movs	r0, #0
    a0fe:	4770      	bx	lr
                    return true;
    a100:	2001      	movs	r0, #1
}
    a102:	4770      	bx	lr
    a104:	10000130 	.word	0x10000130

0000a108 <errata_136>:
    return false;
}

static bool errata_136(void)
{
    uint32_t var1 = *(uint32_t *)0x10000130ul;
    a108:	4b03      	ldr	r3, [pc, #12]	; (a118 <errata_136+0x10>)
    a10a:	681b      	ldr	r3, [r3, #0]
    uint32_t var2 = *(uint32_t *)0x10000134ul;

    switch(var1)
    a10c:	2b0d      	cmp	r3, #13
    a10e:	d001      	beq.n	a114 <errata_136+0xc>
            }
        break;

    }

    return false;
    a110:	2000      	movs	r0, #0
    a112:	4770      	bx	lr
                    return true;
    a114:	2001      	movs	r0, #1
}
    a116:	4770      	bx	lr
    a118:	10000130 	.word	0x10000130

0000a11c <SystemCoreClockUpdate>:
    uint32_t SystemCoreClock __attribute__((used)) = __SYSTEM_CLOCK_64M;
#endif

void SystemCoreClockUpdate(void)
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
    a11c:	4b01      	ldr	r3, [pc, #4]	; (a124 <SystemCoreClockUpdate+0x8>)
    a11e:	4a02      	ldr	r2, [pc, #8]	; (a128 <SystemCoreClockUpdate+0xc>)
    a120:	601a      	str	r2, [r3, #0]
}
    a122:	4770      	bx	lr
    a124:	20000358 	.word	0x20000358
    a128:	03d09000 	.word	0x03d09000

0000a12c <SystemInit>:

void SystemInit(void)
{
    a12c:	b508      	push	{r3, lr}
        NRF_P1->PIN_CNF[9]  = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
    #endif
    
    /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_36()){
    a12e:	f7ff ffd7 	bl	a0e0 <errata_36>
    a132:	b140      	cbz	r0, a146 <SystemInit+0x1a>
        NRF_CLOCK->EVENTS_DONE = 0;
    a134:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    a138:	2200      	movs	r2, #0
    a13a:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
        NRF_CLOCK->EVENTS_CTTO = 0;
    a13e:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
        NRF_CLOCK->CTIV = 0;
    a142:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    }   

    /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_66()){
    a146:	f7ff ffd5 	bl	a0f4 <errata_66>
    a14a:	2800      	cmp	r0, #0
    a14c:	d046      	beq.n	a1dc <SystemInit+0xb0>
        NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
    a14e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    a152:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
    a156:	4b4a      	ldr	r3, [pc, #296]	; (a280 <SystemInit+0x154>)
    a158:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
        NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
    a15c:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
    a160:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
        NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
    a164:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
    a168:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
        NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
    a16c:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
    a170:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
        NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
    a174:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
    a178:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
        NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
    a17c:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
    a180:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
        NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
    a184:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
    a188:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
        NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
    a18c:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
    a190:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
        NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
    a194:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
    a198:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
        NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
    a19c:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
    a1a0:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
        NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
    a1a4:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
    a1a8:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
        NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
    a1ac:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
    a1b0:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
        NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
    a1b4:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
    a1b8:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
        NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
    a1bc:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
    a1c0:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
        NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
    a1c4:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
    a1c8:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
        NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
    a1cc:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
    a1d0:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
        NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
    a1d4:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
    a1d8:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    }
    
    /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_136()){
    a1dc:	f7ff ff94 	bl	a108 <errata_136>
    a1e0:	b160      	cbz	r0, a1fc <SystemInit+0xd0>
        if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
    a1e2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    a1e6:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    a1ea:	f013 0f01 	tst.w	r3, #1
    a1ee:	d005      	beq.n	a1fc <SystemInit+0xd0>
            NRF_POWER->RESETREAS = ~POWER_RESETREAS_RESETPIN_Msk;
    a1f0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    a1f4:	f06f 0201 	mvn.w	r2, #1
    a1f8:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400

    /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
      defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
      reserved for PinReset and not available as normal GPIO. */
    #if defined (CONFIG_GPIO_AS_PINRESET)
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    a1fc:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    a200:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    a204:	2b00      	cmp	r3, #0
    a206:	db08      	blt.n	a21a <SystemInit+0xee>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
    a208:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    a20c:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    a210:	2b00      	cmp	r3, #0
    a212:	db02      	blt.n	a21a <SystemInit+0xee>
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
            NVIC_SystemReset();
        }
    #endif

    SystemCoreClockUpdate();
    a214:	f7ff ff82 	bl	a11c <SystemCoreClockUpdate>
}
    a218:	bd08      	pop	{r3, pc}
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
    a21a:	4b1a      	ldr	r3, [pc, #104]	; (a284 <SystemInit+0x158>)
    a21c:	2201      	movs	r2, #1
    a21e:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    a222:	4b18      	ldr	r3, [pc, #96]	; (a284 <SystemInit+0x158>)
    a224:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    a228:	2b00      	cmp	r3, #0
    a22a:	d0fa      	beq.n	a222 <SystemInit+0xf6>
            NRF_UICR->PSELRESET[0] = 18;
    a22c:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    a230:	2212      	movs	r2, #18
    a232:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    a236:	4b13      	ldr	r3, [pc, #76]	; (a284 <SystemInit+0x158>)
    a238:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    a23c:	2b00      	cmp	r3, #0
    a23e:	d0fa      	beq.n	a236 <SystemInit+0x10a>
            NRF_UICR->PSELRESET[1] = 18;
    a240:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    a244:	2212      	movs	r2, #18
    a246:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    a24a:	4b0e      	ldr	r3, [pc, #56]	; (a284 <SystemInit+0x158>)
    a24c:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    a250:	2b00      	cmp	r3, #0
    a252:	d0fa      	beq.n	a24a <SystemInit+0x11e>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
    a254:	4b0b      	ldr	r3, [pc, #44]	; (a284 <SystemInit+0x158>)
    a256:	2200      	movs	r2, #0
    a258:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    a25c:	4b09      	ldr	r3, [pc, #36]	; (a284 <SystemInit+0x158>)
    a25e:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    a262:	2b00      	cmp	r3, #0
    a264:	d0fa      	beq.n	a25c <SystemInit+0x130>
  __ASM volatile ("dsb 0xF":::"memory");
    a266:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    a26a:	4907      	ldr	r1, [pc, #28]	; (a288 <SystemInit+0x15c>)
    a26c:	68ca      	ldr	r2, [r1, #12]
    a26e:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    a272:	4b06      	ldr	r3, [pc, #24]	; (a28c <SystemInit+0x160>)
    a274:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    a276:	60cb      	str	r3, [r1, #12]
    a278:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    a27c:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    a27e:	e7fd      	b.n	a27c <SystemInit+0x150>
    a280:	4000c000 	.word	0x4000c000
    a284:	4001e000 	.word	0x4001e000
    a288:	e000ed00 	.word	0xe000ed00
    a28c:	05fa0004 	.word	0x05fa0004

0000a290 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(s32_t level)
{
    a290:	b570      	push	{r4, r5, r6, lr}
    a292:	4606      	mov	r6, r0
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    a294:	4b0b      	ldr	r3, [pc, #44]	; (a2c4 <z_sys_init_run_level+0x34>)
    a296:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
    a29a:	e000      	b.n	a29e <z_sys_init_run_level+0xe>
    a29c:	3408      	adds	r4, #8
    a29e:	1c73      	adds	r3, r6, #1
    a2a0:	4a08      	ldr	r2, [pc, #32]	; (a2c4 <z_sys_init_run_level+0x34>)
    a2a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a2a6:	42a3      	cmp	r3, r4
    a2a8:	d90a      	bls.n	a2c0 <z_sys_init_run_level+0x30>
		struct device *dev = entry->dev;
    a2aa:	6865      	ldr	r5, [r4, #4]

		if (dev != NULL) {
			z_object_init(dev);
		}

		retval = entry->init(dev);
    a2ac:	6823      	ldr	r3, [r4, #0]
    a2ae:	4628      	mov	r0, r5
    a2b0:	4798      	blx	r3
		if (retval != 0) {
    a2b2:	2800      	cmp	r0, #0
    a2b4:	d0f2      	beq.n	a29c <z_sys_init_run_level+0xc>
			if (dev) {
    a2b6:	2d00      	cmp	r5, #0
    a2b8:	d0f0      	beq.n	a29c <z_sys_init_run_level+0xc>
				/* Initialization failed. Clear the API struct
				 * so that device_get_binding() will not succeed
				 * for it.
				 */
				dev->driver_api = NULL;
    a2ba:	2300      	movs	r3, #0
    a2bc:	60ab      	str	r3, [r5, #8]
    a2be:	e7ed      	b.n	a29c <z_sys_init_run_level+0xc>
			}
		}
	}
}
    a2c0:	bd70      	pop	{r4, r5, r6, pc}
    a2c2:	bf00      	nop
    a2c4:	00012f88 	.word	0x00012f88

0000a2c8 <z_impl_device_get_binding>:

struct device *z_impl_device_get_binding(const char *name)
{
    a2c8:	b538      	push	{r3, r4, r5, lr}
    a2ca:	4605      	mov	r5, r0
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed. Reserve string comparisons for a fallback.
	 */
	for (dev = __device_start; dev != __device_end; dev++) {
    a2cc:	4c0f      	ldr	r4, [pc, #60]	; (a30c <z_impl_device_get_binding+0x44>)
    a2ce:	e000      	b.n	a2d2 <z_impl_device_get_binding+0xa>
    a2d0:	3410      	adds	r4, #16
    a2d2:	4b0f      	ldr	r3, [pc, #60]	; (a310 <z_impl_device_get_binding+0x48>)
    a2d4:	429c      	cmp	r4, r3
    a2d6:	d006      	beq.n	a2e6 <z_impl_device_get_binding+0x1e>
		if ((dev->driver_api != NULL) &&
    a2d8:	68a3      	ldr	r3, [r4, #8]
    a2da:	2b00      	cmp	r3, #0
    a2dc:	d0f8      	beq.n	a2d0 <z_impl_device_get_binding+0x8>
		    (dev->name == name)) {
    a2de:	6823      	ldr	r3, [r4, #0]
		if ((dev->driver_api != NULL) &&
    a2e0:	42ab      	cmp	r3, r5
    a2e2:	d1f5      	bne.n	a2d0 <z_impl_device_get_binding+0x8>
    a2e4:	e010      	b.n	a308 <z_impl_device_get_binding+0x40>
			return dev;
		}
	}

	for (dev = __device_start; dev != __device_end; dev++) {
    a2e6:	4c09      	ldr	r4, [pc, #36]	; (a30c <z_impl_device_get_binding+0x44>)
    a2e8:	e000      	b.n	a2ec <z_impl_device_get_binding+0x24>
    a2ea:	3410      	adds	r4, #16
    a2ec:	4b08      	ldr	r3, [pc, #32]	; (a310 <z_impl_device_get_binding+0x48>)
    a2ee:	429c      	cmp	r4, r3
    a2f0:	d009      	beq.n	a306 <z_impl_device_get_binding+0x3e>
		if ((dev->driver_api != NULL) &&
    a2f2:	68a3      	ldr	r3, [r4, #8]
    a2f4:	2b00      	cmp	r3, #0
    a2f6:	d0f8      	beq.n	a2ea <z_impl_device_get_binding+0x22>
		    (strcmp(name, dev->name) == 0)) {
    a2f8:	6821      	ldr	r1, [r4, #0]
    a2fa:	4628      	mov	r0, r5
    a2fc:	f7f6 fa00 	bl	700 <strcmp>
		if ((dev->driver_api != NULL) &&
    a300:	2800      	cmp	r0, #0
    a302:	d1f2      	bne.n	a2ea <z_impl_device_get_binding+0x22>
    a304:	e000      	b.n	a308 <z_impl_device_get_binding+0x40>
			return dev;
		}
	}

	return NULL;
    a306:	2400      	movs	r4, #0
}
    a308:	4620      	mov	r0, r4
    a30a:	bd38      	pop	{r3, r4, r5, pc}
    a30c:	200003cc 	.word	0x200003cc
    a310:	2000043c 	.word	0x2000043c

0000a314 <reason_to_str>:
	return thread_name;
}

static const char *reason_to_str(unsigned int reason)
{
	switch (reason) {
    a314:	2804      	cmp	r0, #4
    a316:	d80c      	bhi.n	a332 <reason_to_str+0x1e>
    a318:	e8df f000 	tbb	[pc, r0]
    a31c:	07050d03 	.word	0x07050d03
    a320:	09          	.byte	0x09
    a321:	00          	.byte	0x00
	case K_ERR_STACK_CHK_FAIL:
		return "Stack overflow";
	case K_ERR_KERNEL_OOPS:
		return "Kernel oops";
	case K_ERR_KERNEL_PANIC:
		return "Kernel panic";
    a322:	4806      	ldr	r0, [pc, #24]	; (a33c <reason_to_str+0x28>)
    a324:	4770      	bx	lr
		return "Stack overflow";
    a326:	4806      	ldr	r0, [pc, #24]	; (a340 <reason_to_str+0x2c>)
    a328:	4770      	bx	lr
		return "Kernel oops";
    a32a:	4806      	ldr	r0, [pc, #24]	; (a344 <reason_to_str+0x30>)
    a32c:	4770      	bx	lr
		return "Kernel panic";
    a32e:	4806      	ldr	r0, [pc, #24]	; (a348 <reason_to_str+0x34>)
    a330:	4770      	bx	lr
	default:
		return "Unknown error";
    a332:	4806      	ldr	r0, [pc, #24]	; (a34c <reason_to_str+0x38>)
    a334:	4770      	bx	lr
		return "Unhandled interrupt";
    a336:	4806      	ldr	r0, [pc, #24]	; (a350 <reason_to_str+0x3c>)
	}
}
    a338:	4770      	bx	lr
    a33a:	bf00      	nop
    a33c:	00012ff0 	.word	0x00012ff0
    a340:	00012fc4 	.word	0x00012fc4
    a344:	00012fd4 	.word	0x00012fd4
    a348:	00012fe0 	.word	0x00012fe0
    a34c:	00012fa0 	.word	0x00012fa0
    a350:	00012fb0 	.word	0x00012fb0

0000a354 <thread_name_get>:
{
    a354:	b508      	push	{r3, lr}
	const char *thread_name = k_thread_name_get(thread);
    a356:	f005 ffbc 	bl	102d2 <k_thread_name_get>
	if (thread_name == NULL || thread_name[0] == '\0') {
    a35a:	b120      	cbz	r0, a366 <thread_name_get+0x12>
    a35c:	4603      	mov	r3, r0
    a35e:	7802      	ldrb	r2, [r0, #0]
    a360:	b11a      	cbz	r2, a36a <thread_name_get+0x16>
}
    a362:	4618      	mov	r0, r3
    a364:	bd08      	pop	{r3, pc}
		thread_name = "unknown";
    a366:	4b02      	ldr	r3, [pc, #8]	; (a370 <thread_name_get+0x1c>)
    a368:	e7fb      	b.n	a362 <thread_name_get+0xe>
    a36a:	4b01      	ldr	r3, [pc, #4]	; (a370 <thread_name_get+0x1c>)
	return thread_name;
    a36c:	e7f9      	b.n	a362 <thread_name_get+0xe>
    a36e:	bf00      	nop
    a370:	00011df0 	.word	0x00011df0

0000a374 <k_sys_fatal_error_handler>:
{
    a374:	b510      	push	{r4, lr}
    a376:	4604      	mov	r4, r0
	z_impl_log_panic();
    a378:	f7f7 fade 	bl	1938 <z_impl_log_panic>
	LOG_ERR("Halting system");
    a37c:	f04f 0100 	mov.w	r1, #0
    a380:	2301      	movs	r3, #1
    a382:	f363 0102 	bfi	r1, r3, #0, #3
    a386:	f36f 01c5 	bfc	r1, #3, #3
    a38a:	4b06      	ldr	r3, [pc, #24]	; (a3a4 <k_sys_fatal_error_handler+0x30>)
    a38c:	4a06      	ldr	r2, [pc, #24]	; (a3a8 <k_sys_fatal_error_handler+0x34>)
    a38e:	1a9b      	subs	r3, r3, r2
    a390:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    a394:	f363 118f 	bfi	r1, r3, #6, #10
    a398:	4804      	ldr	r0, [pc, #16]	; (a3ac <k_sys_fatal_error_handler+0x38>)
    a39a:	f7f7 fc81 	bl	1ca0 <log_0>
	arch_system_halt(reason);
    a39e:	4620      	mov	r0, r4
    a3a0:	f005 fbf4 	bl	fb8c <arch_system_halt>
    a3a4:	00010cb8 	.word	0x00010cb8
    a3a8:	00010c18 	.word	0x00010c18
    a3ac:	00013000 	.word	0x00013000

0000a3b0 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    a3b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a3b4:	b082      	sub	sp, #8
    a3b6:	4605      	mov	r5, r0
    a3b8:	460e      	mov	r6, r1
	__asm__ volatile(
    a3ba:	f04f 0320 	mov.w	r3, #32
    a3be:	f3ef 8711 	mrs	r7, BASEPRI
    a3c2:	f383 8811 	msr	BASEPRI, r3
    a3c6:	f3bf 8f6f 	isb	sy
	return z_impl_k_current_get();
    a3ca:	f000 ff91 	bl	b2f0 <z_impl_k_current_get>
    a3ce:	4604      	mov	r4, r0
	struct k_thread *thread = k_current_get();

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
    a3d0:	f04f 0800 	mov.w	r8, #0
    a3d4:	2301      	movs	r3, #1
    a3d6:	f363 0802 	bfi	r8, r3, #0, #3
    a3da:	f36f 08c5 	bfc	r8, #3, #3
    a3de:	4b28      	ldr	r3, [pc, #160]	; (a480 <z_fatal_error+0xd0>)
    a3e0:	4a28      	ldr	r2, [pc, #160]	; (a484 <z_fatal_error+0xd4>)
    a3e2:	1a9b      	subs	r3, r3, r2
    a3e4:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    a3e8:	f363 188f 	bfi	r8, r3, #6, #10
    a3ec:	4628      	mov	r0, r5
    a3ee:	f7ff ff91 	bl	a314 <reason_to_str>
    a3f2:	4602      	mov	r2, r0
    a3f4:	f8ad 8000 	strh.w	r8, [sp]
    a3f8:	2300      	movs	r3, #0
    a3fa:	4629      	mov	r1, r5
    a3fc:	4822      	ldr	r0, [pc, #136]	; (a488 <z_fatal_error+0xd8>)
    a3fe:	f7f7 fa13 	bl	1828 <log_3>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
    a402:	b11e      	cbz	r6, a40c <z_fatal_error+0x5c>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
    a404:	69f3      	ldr	r3, [r6, #28]
    a406:	f3c3 0308 	ubfx	r3, r3, #0, #9
    a40a:	bb33      	cbnz	r3, a45a <z_fatal_error+0xaa>
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
    a40c:	f04f 0800 	mov.w	r8, #0
    a410:	2301      	movs	r3, #1
    a412:	f363 0802 	bfi	r8, r3, #0, #3
    a416:	f36f 08c5 	bfc	r8, #3, #3
    a41a:	4b19      	ldr	r3, [pc, #100]	; (a480 <z_fatal_error+0xd0>)
    a41c:	4a19      	ldr	r2, [pc, #100]	; (a484 <z_fatal_error+0xd4>)
    a41e:	1a9b      	subs	r3, r3, r2
    a420:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    a424:	f363 188f 	bfi	r8, r3, #6, #10
    a428:	4620      	mov	r0, r4
    a42a:	f7ff ff93 	bl	a354 <thread_name_get>
    a42e:	f7f7 f8f7 	bl	1620 <log_strdup>
    a432:	4602      	mov	r2, r0
    a434:	4643      	mov	r3, r8
    a436:	4621      	mov	r1, r4
    a438:	4814      	ldr	r0, [pc, #80]	; (a48c <z_fatal_error+0xdc>)
    a43a:	f7f7 fb41 	bl	1ac0 <log_2>
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
    a43e:	4631      	mov	r1, r6
    a440:	4628      	mov	r0, r5
    a442:	f7ff ff97 	bl	a374 <k_sys_fatal_error_handler>
	__asm__ volatile(
    a446:	f387 8811 	msr	BASEPRI, r7
    a44a:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
    a44e:	4620      	mov	r0, r4
    a450:	f7f8 ff0a 	bl	3268 <z_impl_k_thread_abort>
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	arch_irq_unlock(key);
	k_thread_abort(thread);
}
    a454:	b002      	add	sp, #8
    a456:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LOG_ERR("Fault during interrupt handling\n");
    a45a:	f04f 0100 	mov.w	r1, #0
    a45e:	2301      	movs	r3, #1
    a460:	f363 0102 	bfi	r1, r3, #0, #3
    a464:	f36f 01c5 	bfc	r1, #3, #3
    a468:	4b05      	ldr	r3, [pc, #20]	; (a480 <z_fatal_error+0xd0>)
    a46a:	4a06      	ldr	r2, [pc, #24]	; (a484 <z_fatal_error+0xd4>)
    a46c:	1a9b      	subs	r3, r3, r2
    a46e:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    a472:	f363 118f 	bfi	r1, r3, #6, #10
    a476:	4806      	ldr	r0, [pc, #24]	; (a490 <z_fatal_error+0xe0>)
    a478:	f7f7 fc12 	bl	1ca0 <log_0>
    a47c:	e7c6      	b.n	a40c <z_fatal_error+0x5c>
    a47e:	bf00      	nop
    a480:	00010cb8 	.word	0x00010cb8
    a484:	00010c18 	.word	0x00010c18
    a488:	00013010 	.word	0x00013010
    a48c:	0001305c 	.word	0x0001305c
    a490:	00013038 	.word	0x00013038

0000a494 <set_kernel_idle_time_in_ticks>:
 */
#if !SMP_FALLBACK
static void set_kernel_idle_time_in_ticks(s32_t ticks)
{
#ifdef CONFIG_SYS_POWER_MANAGEMENT
	_kernel.idle = ticks;
    a494:	4b01      	ldr	r3, [pc, #4]	; (a49c <set_kernel_idle_time_in_ticks+0x8>)
    a496:	6218      	str	r0, [r3, #32]
#endif
}
    a498:	4770      	bx	lr
    a49a:	bf00      	nop
    a49c:	20005874 	.word	0x20005874

0000a4a0 <init_idle_thread>:

/* LCOV_EXCL_STOP */

#if defined(CONFIG_MULTITHREADING)
static void init_idle_thread(int i)
{
    a4a0:	b510      	push	{r4, lr}
    a4a2:	b086      	sub	sp, #24
	struct k_thread *thread = &z_idle_threads[i];
    a4a4:	4b0e      	ldr	r3, [pc, #56]	; (a4e0 <init_idle_thread+0x40>)
    a4a6:	2474      	movs	r4, #116	; 0x74
    a4a8:	fb04 3400 	mla	r4, r4, r0, r3
	k_thread_stack_t *stack = z_idle_stacks[i];
    a4ac:	eb00 0080 	add.w	r0, r0, r0, lsl #2
	snprintk(tname, 8, "idle %02d", i);
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
    a4b0:	2300      	movs	r3, #0
    a4b2:	9305      	str	r3, [sp, #20]
    a4b4:	2201      	movs	r2, #1
    a4b6:	9204      	str	r2, [sp, #16]
    a4b8:	220f      	movs	r2, #15
    a4ba:	9203      	str	r2, [sp, #12]
    a4bc:	9302      	str	r3, [sp, #8]
    a4be:	9301      	str	r3, [sp, #4]
    a4c0:	9300      	str	r3, [sp, #0]
    a4c2:	4b08      	ldr	r3, [pc, #32]	; (a4e4 <init_idle_thread+0x44>)
    a4c4:	f44f 72a0 	mov.w	r2, #320	; 0x140
    a4c8:	4907      	ldr	r1, [pc, #28]	; (a4e8 <init_idle_thread+0x48>)
    a4ca:	eb01 1180 	add.w	r1, r1, r0, lsl #6
    a4ce:	4620      	mov	r0, r4
    a4d0:	f000 ff90 	bl	b3f4 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    a4d4:	7b63      	ldrb	r3, [r4, #13]
    a4d6:	f023 0304 	bic.w	r3, r3, #4
    a4da:	7363      	strb	r3, [r4, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    a4dc:	b006      	add	sp, #24
    a4de:	bd10      	pop	{r4, pc}
    a4e0:	20004e2c 	.word	0x20004e2c
    a4e4:	0000fbc9 	.word	0x0000fbc9
    a4e8:	20006ca0 	.word	0x20006ca0

0000a4ec <prepare_multithreading>:
 *
 * @return N/A
 */
#ifdef CONFIG_MULTITHREADING
static void prepare_multithreading(void)
{
    a4ec:	b530      	push	{r4, r5, lr}
    a4ee:	b087      	sub	sp, #28
	/* _kernel.ready_q is all zeroes */
	z_sched_init();
    a4f0:	f000 fe30 	bl	b154 <z_sched_init>
	 * - the main thread will be the one to run first
	 * - no other thread is initialized yet and thus their priority fields
	 *   contain garbage, which would prevent the cache loading algorithm
	 *   to work as intended
	 */
	_kernel.ready_q.cache = &z_main_thread;
    a4f4:	4d1c      	ldr	r5, [pc, #112]	; (a568 <prepare_multithreading+0x7c>)
    a4f6:	4b1d      	ldr	r3, [pc, #116]	; (a56c <prepare_multithreading+0x80>)
    a4f8:	625d      	str	r5, [r3, #36]	; 0x24
#endif

	z_setup_new_thread(&z_main_thread, z_main_stack,
    a4fa:	4b1d      	ldr	r3, [pc, #116]	; (a570 <prepare_multithreading+0x84>)
    a4fc:	9305      	str	r3, [sp, #20]
    a4fe:	2301      	movs	r3, #1
    a500:	9304      	str	r3, [sp, #16]
    a502:	2400      	movs	r4, #0
    a504:	9403      	str	r4, [sp, #12]
    a506:	9402      	str	r4, [sp, #8]
    a508:	9401      	str	r4, [sp, #4]
    a50a:	9400      	str	r4, [sp, #0]
    a50c:	4b19      	ldr	r3, [pc, #100]	; (a574 <prepare_multithreading+0x88>)
    a50e:	f44f 6200 	mov.w	r2, #2048	; 0x800
    a512:	4919      	ldr	r1, [pc, #100]	; (a578 <prepare_multithreading+0x8c>)
    a514:	4628      	mov	r0, r5
    a516:	f000 ff6d 	bl	b3f4 <z_setup_new_thread>
    a51a:	7b6b      	ldrb	r3, [r5, #13]
    a51c:	f023 0304 	bic.w	r3, r3, #4
    a520:	736b      	strb	r3, [r5, #13]
			   CONFIG_MAIN_STACK_SIZE, bg_thread_main,
			   NULL, NULL, NULL,
			   CONFIG_MAIN_THREAD_PRIORITY, K_ESSENTIAL, "main");
	z_mark_thread_as_started(&z_main_thread);
	z_ready_thread(&z_main_thread);
    a522:	4628      	mov	r0, r5
    a524:	f005 fdc1 	bl	100aa <z_ready_thread>

	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
    a528:	2c00      	cmp	r4, #0
    a52a:	dd06      	ble.n	a53a <prepare_multithreading+0x4e>
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    a52c:	4b0f      	ldr	r3, [pc, #60]	; (a56c <prepare_multithreading+0x80>)
    a52e:	f103 0218 	add.w	r2, r3, #24
    a532:	619a      	str	r2, [r3, #24]
	list->tail = (sys_dnode_t *)list;
    a534:	61da      	str	r2, [r3, #28]
			(Z_THREAD_STACK_BUFFER(z_interrupt_stacks[i]) +
			 K_THREAD_STACK_SIZEOF(z_interrupt_stacks[i]));
	}

	initialize_timeouts();
}
    a536:	b007      	add	sp, #28
    a538:	bd30      	pop	{r4, r5, pc}
		init_idle_thread(i);
    a53a:	4620      	mov	r0, r4
    a53c:	f7ff ffb0 	bl	a4a0 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    a540:	4b0e      	ldr	r3, [pc, #56]	; (a57c <prepare_multithreading+0x90>)
    a542:	2274      	movs	r2, #116	; 0x74
    a544:	fb02 3204 	mla	r2, r2, r4, r3
    a548:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    a54c:	00d9      	lsls	r1, r3, #3
    a54e:	4b07      	ldr	r3, [pc, #28]	; (a56c <prepare_multithreading+0x80>)
    a550:	440b      	add	r3, r1
    a552:	60da      	str	r2, [r3, #12]
		_kernel.cpus[i].id = i;
    a554:	751c      	strb	r4, [r3, #20]
			(Z_THREAD_STACK_BUFFER(z_interrupt_stacks[i]) +
    a556:	4a0a      	ldr	r2, [pc, #40]	; (a580 <prepare_multithreading+0x94>)
    a558:	eb02 22c4 	add.w	r2, r2, r4, lsl #11
    a55c:	f502 6200 	add.w	r2, r2, #2048	; 0x800
		_kernel.cpus[i].irq_stack =
    a560:	605a      	str	r2, [r3, #4]
	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
    a562:	3401      	adds	r4, #1
    a564:	e7e0      	b.n	a528 <prepare_multithreading+0x3c>
    a566:	bf00      	nop
    a568:	20004ea0 	.word	0x20004ea0
    a56c:	20005874 	.word	0x20005874
    a570:	00013074 	.word	0x00013074
    a574:	0000a5ed 	.word	0x0000a5ed
    a578:	200064a0 	.word	0x200064a0
    a57c:	20004e2c 	.word	0x20004e2c
    a580:	20006de0 	.word	0x20006de0

0000a584 <switch_to_main_thread>:

static FUNC_NORETURN void switch_to_main_thread(void)
{
    a584:	b508      	push	{r3, lr}
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
    a586:	4b03      	ldr	r3, [pc, #12]	; (a594 <switch_to_main_thread+0x10>)
    a588:	f44f 6200 	mov.w	r2, #2048	; 0x800
    a58c:	4902      	ldr	r1, [pc, #8]	; (a598 <switch_to_main_thread+0x14>)
    a58e:	4803      	ldr	r0, [pc, #12]	; (a59c <switch_to_main_thread+0x18>)
    a590:	f7f8 f9d8 	bl	2944 <arch_switch_to_main_thread>
	 * current fake thread is not on a wait queue or ready queue, so it
	 * will never be rescheduled in.
	 */
	z_swap_unlocked();
#endif
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    a594:	0000a5ed 	.word	0x0000a5ed
    a598:	200064a0 	.word	0x200064a0
    a59c:	20004ea0 	.word	0x20004ea0

0000a5a0 <z_bss_zero>:
{
    a5a0:	b508      	push	{r3, lr}
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
    a5a2:	4803      	ldr	r0, [pc, #12]	; (a5b0 <z_bss_zero+0x10>)
__ssp_bos_icheck3(memset, void *, int)
    a5a4:	4a03      	ldr	r2, [pc, #12]	; (a5b4 <z_bss_zero+0x14>)
    a5a6:	1a12      	subs	r2, r2, r0
    a5a8:	2100      	movs	r1, #0
    a5aa:	f006 f808 	bl	105be <memset>
}
    a5ae:	bd08      	pop	{r3, pc}
    a5b0:	20000578 	.word	0x20000578
    a5b4:	2000595c 	.word	0x2000595c

0000a5b8 <z_data_copy>:
{
    a5b8:	b508      	push	{r3, lr}
	(void)memcpy(&__data_ram_start, &__data_rom_start,
    a5ba:	4806      	ldr	r0, [pc, #24]	; (a5d4 <z_data_copy+0x1c>)
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    a5bc:	4a06      	ldr	r2, [pc, #24]	; (a5d8 <z_data_copy+0x20>)
    a5be:	1a12      	subs	r2, r2, r0
    a5c0:	4906      	ldr	r1, [pc, #24]	; (a5dc <z_data_copy+0x24>)
    a5c2:	f005 ffee 	bl	105a2 <memcpy>
    a5c6:	4a06      	ldr	r2, [pc, #24]	; (a5e0 <z_data_copy+0x28>)
    a5c8:	4906      	ldr	r1, [pc, #24]	; (a5e4 <z_data_copy+0x2c>)
    a5ca:	4807      	ldr	r0, [pc, #28]	; (a5e8 <z_data_copy+0x30>)
    a5cc:	f005 ffe9 	bl	105a2 <memcpy>
}
    a5d0:	bd08      	pop	{r3, pc}
    a5d2:	bf00      	nop
    a5d4:	20000000 	.word	0x20000000
    a5d8:	20000578 	.word	0x20000578
    a5dc:	000132a4 	.word	0x000132a4
    a5e0:	00000000 	.word	0x00000000
    a5e4:	000132a4 	.word	0x000132a4
    a5e8:	20000000 	.word	0x20000000

0000a5ec <bg_thread_main>:
{
    a5ec:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
    a5ee:	4b0c      	ldr	r3, [pc, #48]	; (a620 <bg_thread_main+0x34>)
    a5f0:	2201      	movs	r2, #1
    a5f2:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    a5f4:	2002      	movs	r0, #2
    a5f6:	f7ff fe4b 	bl	a290 <z_sys_init_run_level>
	printk("*** Booting Zephyr OS version %s %s ***\n",
    a5fa:	4a0a      	ldr	r2, [pc, #40]	; (a624 <bg_thread_main+0x38>)
    a5fc:	490a      	ldr	r1, [pc, #40]	; (a628 <bg_thread_main+0x3c>)
    a5fe:	480b      	ldr	r0, [pc, #44]	; (a62c <bg_thread_main+0x40>)
    a600:	f002 fd15 	bl	d02e <printk>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    a604:	2003      	movs	r0, #3
    a606:	f7ff fe43 	bl	a290 <z_sys_init_run_level>
	z_init_static_threads();
    a60a:	f000 ff27 	bl	b45c <z_init_static_threads>
	main();
    a60e:	f7f6 f937 	bl	880 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    a612:	4a07      	ldr	r2, [pc, #28]	; (a630 <bg_thread_main+0x44>)
    a614:	7b13      	ldrb	r3, [r2, #12]
    a616:	f023 0301 	bic.w	r3, r3, #1
    a61a:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    a61c:	bd08      	pop	{r3, pc}
    a61e:	bf00      	nop
    a620:	20005955 	.word	0x20005955
    a624:	00011320 	.word	0x00011320
    a628:	0001307c 	.word	0x0001307c
    a62c:	00013088 	.word	0x00013088
    a630:	20004ea0 	.word	0x20004ea0

0000a634 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
    a634:	b500      	push	{lr}
    a636:	b09f      	sub	sp, #124	; 0x7c
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
    a638:	f7f6 ff2a 	bl	1490 <log_core_init>
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(z_interrupt_stacks[0])) +
    a63c:	4b17      	ldr	r3, [pc, #92]	; (a69c <z_cstart+0x68>)
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    a63e:	f383 8808 	msr	MSP, r3
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
    a642:	4c17      	ldr	r4, [pc, #92]	; (a6a0 <z_cstart+0x6c>)
    a644:	6963      	ldr	r3, [r4, #20]
    a646:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    a64a:	6163      	str	r3, [r4, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    a64c:	23e0      	movs	r3, #224	; 0xe0
    a64e:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
    a652:	2500      	movs	r5, #0
    a654:	77e5      	strb	r5, [r4, #31]
    a656:	7625      	strb	r5, [r4, #24]
    a658:	7665      	strb	r5, [r4, #25]
    a65a:	76a5      	strb	r5, [r4, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
    a65c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    a65e:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    a662:	6263      	str	r3, [r4, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
    a664:	f7f8 fdd0 	bl	3208 <z_arm_fault_init>
	z_arm_cpu_idle_init();
    a668:	f7f8 f988 	bl	297c <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
    a66c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    a670:	62a3      	str	r3, [r4, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
    a672:	62e3      	str	r3, [r4, #44]	; 0x2c
 *
 * The memory of the dummy thread can be completely uninitialized.
 */
static inline void z_dummy_thread_init(struct k_thread *dummy_thread)
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
    a674:	2401      	movs	r4, #1
    a676:	f88d 4011 	strb.w	r4, [sp, #17]
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
    a67a:	f88d 4010 	strb.w	r4, [sp, #16]
#ifdef CONFIG_THREAD_STACK_INFO
	dummy_thread->stack_info.start = 0U;
    a67e:	9519      	str	r5, [sp, #100]	; 0x64
	dummy_thread->stack_info.size = 0U;
    a680:	951a      	str	r5, [sp, #104]	; 0x68
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = 0;
#endif

	_current_cpu->current = dummy_thread;
    a682:	4b08      	ldr	r3, [pc, #32]	; (a6a4 <z_cstart+0x70>)
    a684:	aa01      	add	r2, sp, #4
    a686:	609a      	str	r2, [r3, #8]

	z_dummy_thread_init(&dummy_thread);
#endif

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    a688:	4628      	mov	r0, r5
    a68a:	f7ff fe01 	bl	a290 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    a68e:	4620      	mov	r0, r4
    a690:	f7ff fdfe 	bl	a290 <z_sys_init_run_level>
	__stack_chk_guard = stack_guard;
	__stack_chk_guard <<= 8;
#endif	/* CONFIG_STACK_CANARIES */

#ifdef CONFIG_MULTITHREADING
	prepare_multithreading();
    a694:	f7ff ff2a 	bl	a4ec <prepare_multithreading>
	switch_to_main_thread();
    a698:	f7ff ff74 	bl	a584 <switch_to_main_thread>
    a69c:	200075e0 	.word	0x200075e0
    a6a0:	e000ed00 	.word	0xe000ed00
    a6a4:	20005874 	.word	0x20005874

0000a6a8 <statics_init>:
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
}

static int statics_init(struct device *unused)
{
    a6a8:	b510      	push	{r4, lr}
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    a6aa:	4c06      	ldr	r4, [pc, #24]	; (a6c4 <statics_init+0x1c>)
    a6ac:	4b06      	ldr	r3, [pc, #24]	; (a6c8 <statics_init+0x20>)
    a6ae:	429c      	cmp	r4, r3
    a6b0:	d206      	bcs.n	a6c0 <statics_init+0x18>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    a6b2:	68a2      	ldr	r2, [r4, #8]
    a6b4:	6861      	ldr	r1, [r4, #4]
    a6b6:	4620      	mov	r0, r4
    a6b8:	f005 fa92 	bl	fbe0 <k_heap_init>
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    a6bc:	3414      	adds	r4, #20
    a6be:	e7f5      	b.n	a6ac <statics_init+0x4>
	}
	return 0;
}
    a6c0:	2000      	movs	r0, #0
    a6c2:	bd10      	pop	{r4, pc}
    a6c4:	2000043c 	.word	0x2000043c
    a6c8:	20000450 	.word	0x20000450

0000a6cc <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(struct device *dev)
{
    a6cc:	b510      	push	{r4, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    a6ce:	4c06      	ldr	r4, [pc, #24]	; (a6e8 <init_mem_slab_module+0x1c>)
	int rc = 0;
    a6d0:	2000      	movs	r0, #0
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    a6d2:	4b06      	ldr	r3, [pc, #24]	; (a6ec <init_mem_slab_module+0x20>)
    a6d4:	429c      	cmp	r4, r3
    a6d6:	d206      	bcs.n	a6e6 <init_mem_slab_module+0x1a>
		rc = create_free_list(slab);
    a6d8:	4620      	mov	r0, r4
    a6da:	f005 fb07 	bl	fcec <create_free_list>
		if (rc < 0) {
    a6de:	2800      	cmp	r0, #0
    a6e0:	db01      	blt.n	a6e6 <init_mem_slab_module+0x1a>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    a6e2:	341c      	adds	r4, #28
    a6e4:	e7f5      	b.n	a6d2 <init_mem_slab_module+0x6>
		z_object_init(slab);
	}

out:
	return rc;
}
    a6e6:	bd10      	pop	{r4, pc}
    a6e8:	2000043c 	.word	0x2000043c
    a6ec:	2000043c 	.word	0x2000043c

0000a6f0 <k_mem_slab_alloc>:
out:
	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
    a6f0:	b5d0      	push	{r4, r6, r7, lr}
    a6f2:	b082      	sub	sp, #8
    a6f4:	460c      	mov	r4, r1
    a6f6:	461f      	mov	r7, r3
	__asm__ volatile(
    a6f8:	f04f 0320 	mov.w	r3, #32
    a6fc:	f3ef 8111 	mrs	r1, BASEPRI
    a700:	f383 8811 	msr	BASEPRI, r3
    a704:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
    a708:	6943      	ldr	r3, [r0, #20]
    a70a:	b16b      	cbz	r3, a728 <k_mem_slab_alloc+0x38>
		/* take a free block */
		*mem = slab->free_list;
    a70c:	6023      	str	r3, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
    a70e:	6943      	ldr	r3, [r0, #20]
    a710:	681b      	ldr	r3, [r3, #0]
    a712:	6143      	str	r3, [r0, #20]
		slab->num_used++;
    a714:	6983      	ldr	r3, [r0, #24]
    a716:	3301      	adds	r3, #1
    a718:	6183      	str	r3, [r0, #24]
		result = 0;
    a71a:	2000      	movs	r0, #0
	__asm__ volatile(
    a71c:	f381 8811 	msr	BASEPRI, r1
    a720:	f3bf 8f6f 	isb	sy
	}

	k_spin_unlock(&lock, key);

	return result;
}
    a724:	b002      	add	sp, #8
    a726:	bdd0      	pop	{r4, r6, r7, pc}
    a728:	4616      	mov	r6, r2
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    a72a:	ea56 0307 	orrs.w	r3, r6, r7
    a72e:	d104      	bne.n	a73a <k_mem_slab_alloc+0x4a>
		*mem = NULL;
    a730:	2300      	movs	r3, #0
    a732:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
    a734:	f06f 000b 	mvn.w	r0, #11
    a738:	e7f0      	b.n	a71c <k_mem_slab_alloc+0x2c>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
    a73a:	e9cd 6700 	strd	r6, r7, [sp]
    a73e:	4602      	mov	r2, r0
    a740:	4804      	ldr	r0, [pc, #16]	; (a754 <k_mem_slab_alloc+0x64>)
    a742:	f000 fc9b 	bl	b07c <z_pend_curr>
		if (result == 0) {
    a746:	2800      	cmp	r0, #0
    a748:	d1ec      	bne.n	a724 <k_mem_slab_alloc+0x34>
			*mem = _current->base.swap_data;
    a74a:	4b03      	ldr	r3, [pc, #12]	; (a758 <k_mem_slab_alloc+0x68>)
    a74c:	689b      	ldr	r3, [r3, #8]
    a74e:	695b      	ldr	r3, [r3, #20]
    a750:	6023      	str	r3, [r4, #0]
		return result;
    a752:	e7e7      	b.n	a724 <k_mem_slab_alloc+0x34>
    a754:	20004f14 	.word	0x20004f14
    a758:	20005874 	.word	0x20005874

0000a75c <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
    a75c:	b570      	push	{r4, r5, r6, lr}
    a75e:	4604      	mov	r4, r0
    a760:	460d      	mov	r5, r1
	__asm__ volatile(
    a762:	f04f 0320 	mov.w	r3, #32
    a766:	f3ef 8611 	mrs	r6, BASEPRI
    a76a:	f383 8811 	msr	BASEPRI, r3
    a76e:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
    a772:	f005 fd42 	bl	101fa <z_unpend_first_thread>

	if (pending_thread != NULL) {
    a776:	b150      	cbz	r0, a78e <k_mem_slab_free+0x32>
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
    a778:	682a      	ldr	r2, [r5, #0]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
    a77a:	2100      	movs	r1, #0
    a77c:	6701      	str	r1, [r0, #112]	; 0x70
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
    a77e:	6142      	str	r2, [r0, #20]
		z_ready_thread(pending_thread);
    a780:	f005 fc93 	bl	100aa <z_ready_thread>
		z_reschedule(&lock, key);
    a784:	4631      	mov	r1, r6
    a786:	4808      	ldr	r0, [pc, #32]	; (a7a8 <k_mem_slab_free+0x4c>)
    a788:	f005 fc44 	bl	10014 <z_reschedule>
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
    a78c:	bd70      	pop	{r4, r5, r6, pc}
		**(char ***)mem = slab->free_list;
    a78e:	682b      	ldr	r3, [r5, #0]
    a790:	6962      	ldr	r2, [r4, #20]
    a792:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
    a794:	682b      	ldr	r3, [r5, #0]
    a796:	6163      	str	r3, [r4, #20]
		slab->num_used--;
    a798:	69a3      	ldr	r3, [r4, #24]
    a79a:	3b01      	subs	r3, #1
    a79c:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
    a79e:	f386 8811 	msr	BASEPRI, r6
    a7a2:	f3bf 8f6f 	isb	sy
}
    a7a6:	e7f1      	b.n	a78c <k_mem_slab_free+0x30>
    a7a8:	20004f14 	.word	0x20004f14

0000a7ac <z_thread_malloc>:
#else
#define _HEAP_MEM_POOL	NULL
#endif

void *z_thread_malloc(size_t size)
{
    a7ac:	b510      	push	{r4, lr}
    a7ae:	4604      	mov	r4, r0
	void *ret;
	struct k_mem_pool *pool;

	if (k_is_in_isr()) {
    a7b0:	f005 fd82 	bl	102b8 <k_is_in_isr>
    a7b4:	b938      	cbnz	r0, a7c6 <z_thread_malloc+0x1a>
		pool = _HEAP_MEM_POOL;
	} else {
		pool = _current->resource_pool;
    a7b6:	4b05      	ldr	r3, [pc, #20]	; (a7cc <z_thread_malloc+0x20>)
    a7b8:	689b      	ldr	r3, [r3, #8]
    a7ba:	6e98      	ldr	r0, [r3, #104]	; 0x68
	}

	if (pool) {
    a7bc:	b110      	cbz	r0, a7c4 <z_thread_malloc+0x18>
		ret = k_mem_pool_malloc(pool, size);
    a7be:	4621      	mov	r1, r4
    a7c0:	f005 fab9 	bl	fd36 <k_mem_pool_malloc>
	} else {
		ret = NULL;
	}

	return ret;
}
    a7c4:	bd10      	pop	{r4, pc}
		pool = _HEAP_MEM_POOL;
    a7c6:	4802      	ldr	r0, [pc, #8]	; (a7d0 <z_thread_malloc+0x24>)
    a7c8:	e7f8      	b.n	a7bc <z_thread_malloc+0x10>
    a7ca:	bf00      	nop
    a7cc:	20005874 	.word	0x20005874
    a7d0:	2000035c 	.word	0x2000035c

0000a7d4 <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
    a7d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a7d8:	b082      	sub	sp, #8
    a7da:	4604      	mov	r4, r0
    a7dc:	460d      	mov	r5, r1
    a7de:	4610      	mov	r0, r2
    a7e0:	4619      	mov	r1, r3

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
    a7e2:	f104 0708 	add.w	r7, r4, #8
	__asm__ volatile(
    a7e6:	f04f 0320 	mov.w	r3, #32
    a7ea:	f3ef 8611 	mrs	r6, BASEPRI
    a7ee:	f383 8811 	msr	BASEPRI, r3
    a7f2:	f3bf 8f6f 	isb	sy

	if (msgq->used_msgs < msgq->max_msgs) {
    a7f6:	6a22      	ldr	r2, [r4, #32]
    a7f8:	68e3      	ldr	r3, [r4, #12]
    a7fa:	429a      	cmp	r2, r3
    a7fc:	d30b      	bcc.n	a816 <z_impl_k_msgq_put+0x42>
				msgq->write_ptr = msgq->buffer_start;
			}
			msgq->used_msgs++;
		}
		result = 0;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    a7fe:	ea50 0301 	orrs.w	r3, r0, r1
    a802:	d132      	bne.n	a86a <z_impl_k_msgq_put+0x96>
		/* don't wait for message space to become available */
		result = -ENOMSG;
    a804:	f06f 0022 	mvn.w	r0, #34	; 0x22
	__asm__ volatile(
    a808:	f386 8811 	msr	BASEPRI, r6
    a80c:	f3bf 8f6f 	isb	sy
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
    a810:	b002      	add	sp, #8
    a812:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
    a816:	4620      	mov	r0, r4
    a818:	f005 fcef 	bl	101fa <z_unpend_first_thread>
		if (pending_thread != NULL) {
    a81c:	4680      	mov	r8, r0
    a81e:	b180      	cbz	r0, a842 <z_impl_k_msgq_put+0x6e>
    a820:	68a2      	ldr	r2, [r4, #8]
    a822:	4629      	mov	r1, r5
    a824:	6940      	ldr	r0, [r0, #20]
    a826:	f005 febc 	bl	105a2 <memcpy>
    a82a:	2400      	movs	r4, #0
    a82c:	f8c8 4070 	str.w	r4, [r8, #112]	; 0x70
			z_ready_thread(pending_thread);
    a830:	4640      	mov	r0, r8
    a832:	f005 fc3a 	bl	100aa <z_ready_thread>
			z_reschedule(&msgq->lock, key);
    a836:	4631      	mov	r1, r6
    a838:	4638      	mov	r0, r7
    a83a:	f005 fbeb 	bl	10014 <z_reschedule>
			return 0;
    a83e:	4620      	mov	r0, r4
    a840:	e7e6      	b.n	a810 <z_impl_k_msgq_put+0x3c>
    a842:	68a2      	ldr	r2, [r4, #8]
    a844:	4629      	mov	r1, r5
    a846:	69e0      	ldr	r0, [r4, #28]
    a848:	f005 feab 	bl	105a2 <memcpy>
			msgq->write_ptr += msgq->msg_size;
    a84c:	68a2      	ldr	r2, [r4, #8]
    a84e:	69e3      	ldr	r3, [r4, #28]
    a850:	4413      	add	r3, r2
    a852:	61e3      	str	r3, [r4, #28]
			if (msgq->write_ptr == msgq->buffer_end) {
    a854:	6962      	ldr	r2, [r4, #20]
    a856:	4293      	cmp	r3, r2
    a858:	d004      	beq.n	a864 <z_impl_k_msgq_put+0x90>
			msgq->used_msgs++;
    a85a:	6a23      	ldr	r3, [r4, #32]
    a85c:	3301      	adds	r3, #1
    a85e:	6223      	str	r3, [r4, #32]
		result = 0;
    a860:	2000      	movs	r0, #0
    a862:	e7d1      	b.n	a808 <z_impl_k_msgq_put+0x34>
				msgq->write_ptr = msgq->buffer_start;
    a864:	6923      	ldr	r3, [r4, #16]
    a866:	61e3      	str	r3, [r4, #28]
    a868:	e7f7      	b.n	a85a <z_impl_k_msgq_put+0x86>
		_current->base.swap_data = data;
    a86a:	4b05      	ldr	r3, [pc, #20]	; (a880 <z_impl_k_msgq_put+0xac>)
    a86c:	689b      	ldr	r3, [r3, #8]
    a86e:	615d      	str	r5, [r3, #20]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    a870:	e9cd 0100 	strd	r0, r1, [sp]
    a874:	4622      	mov	r2, r4
    a876:	4631      	mov	r1, r6
    a878:	4638      	mov	r0, r7
    a87a:	f000 fbff 	bl	b07c <z_pend_curr>
    a87e:	e7c7      	b.n	a810 <z_impl_k_msgq_put+0x3c>
    a880:	20005874 	.word	0x20005874

0000a884 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
    a884:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a888:	b082      	sub	sp, #8
    a88a:	4604      	mov	r4, r0
    a88c:	4608      	mov	r0, r1
    a88e:	461f      	mov	r7, r3

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
    a890:	f104 0808 	add.w	r8, r4, #8
	__asm__ volatile(
    a894:	f04f 0320 	mov.w	r3, #32
    a898:	f3ef 8511 	mrs	r5, BASEPRI
    a89c:	f383 8811 	msr	BASEPRI, r3
    a8a0:	f3bf 8f6f 	isb	sy

	if (msgq->used_msgs > 0) {
    a8a4:	6a23      	ldr	r3, [r4, #32]
    a8a6:	2b00      	cmp	r3, #0
    a8a8:	d033      	beq.n	a912 <z_impl_k_msgq_get+0x8e>
    a8aa:	68a2      	ldr	r2, [r4, #8]
    a8ac:	69a1      	ldr	r1, [r4, #24]
    a8ae:	f005 fe78 	bl	105a2 <memcpy>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		msgq->read_ptr += msgq->msg_size;
    a8b2:	68a2      	ldr	r2, [r4, #8]
    a8b4:	69a3      	ldr	r3, [r4, #24]
    a8b6:	4413      	add	r3, r2
    a8b8:	61a3      	str	r3, [r4, #24]
		if (msgq->read_ptr == msgq->buffer_end) {
    a8ba:	6962      	ldr	r2, [r4, #20]
    a8bc:	4293      	cmp	r3, r2
    a8be:	d022      	beq.n	a906 <z_impl_k_msgq_get+0x82>
			msgq->read_ptr = msgq->buffer_start;
		}
		msgq->used_msgs--;
    a8c0:	6a23      	ldr	r3, [r4, #32]
    a8c2:	3b01      	subs	r3, #1
    a8c4:	6223      	str	r3, [r4, #32]

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
    a8c6:	4620      	mov	r0, r4
    a8c8:	f005 fc97 	bl	101fa <z_unpend_first_thread>
		if (pending_thread != NULL) {
    a8cc:	4606      	mov	r6, r0
    a8ce:	2800      	cmp	r0, #0
    a8d0:	d037      	beq.n	a942 <z_impl_k_msgq_get+0xbe>
    a8d2:	68a2      	ldr	r2, [r4, #8]
    a8d4:	6941      	ldr	r1, [r0, #20]
    a8d6:	69e0      	ldr	r0, [r4, #28]
    a8d8:	f005 fe63 	bl	105a2 <memcpy>
			/* add thread's message to queue */
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
    a8dc:	68a2      	ldr	r2, [r4, #8]
    a8de:	69e3      	ldr	r3, [r4, #28]
    a8e0:	4413      	add	r3, r2
    a8e2:	61e3      	str	r3, [r4, #28]
			if (msgq->write_ptr == msgq->buffer_end) {
    a8e4:	6962      	ldr	r2, [r4, #20]
    a8e6:	4293      	cmp	r3, r2
    a8e8:	d010      	beq.n	a90c <z_impl_k_msgq_get+0x88>
				msgq->write_ptr = msgq->buffer_start;
			}
			msgq->used_msgs++;
    a8ea:	6a23      	ldr	r3, [r4, #32]
    a8ec:	3301      	adds	r3, #1
    a8ee:	6223      	str	r3, [r4, #32]
    a8f0:	2400      	movs	r4, #0
    a8f2:	6734      	str	r4, [r6, #112]	; 0x70

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
    a8f4:	4630      	mov	r0, r6
    a8f6:	f005 fbd8 	bl	100aa <z_ready_thread>
			z_reschedule(&msgq->lock, key);
    a8fa:	4629      	mov	r1, r5
    a8fc:	4640      	mov	r0, r8
    a8fe:	f005 fb89 	bl	10014 <z_reschedule>
			return 0;
    a902:	4620      	mov	r0, r4
    a904:	e00f      	b.n	a926 <z_impl_k_msgq_get+0xa2>
			msgq->read_ptr = msgq->buffer_start;
    a906:	6923      	ldr	r3, [r4, #16]
    a908:	61a3      	str	r3, [r4, #24]
    a90a:	e7d9      	b.n	a8c0 <z_impl_k_msgq_get+0x3c>
				msgq->write_ptr = msgq->buffer_start;
    a90c:	6923      	ldr	r3, [r4, #16]
    a90e:	61e3      	str	r3, [r4, #28]
    a910:	e7eb      	b.n	a8ea <z_impl_k_msgq_get+0x66>
    a912:	4616      	mov	r6, r2
		}
		result = 0;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    a914:	ea56 0307 	orrs.w	r3, r6, r7
    a918:	d108      	bne.n	a92c <z_impl_k_msgq_get+0xa8>
		/* don't wait for a message to become available */
		result = -ENOMSG;
    a91a:	f06f 0022 	mvn.w	r0, #34	; 0x22
	__asm__ volatile(
    a91e:	f385 8811 	msr	BASEPRI, r5
    a922:	f3bf 8f6f 	isb	sy
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
    a926:	b002      	add	sp, #8
    a928:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		_current->base.swap_data = data;
    a92c:	4b06      	ldr	r3, [pc, #24]	; (a948 <z_impl_k_msgq_get+0xc4>)
    a92e:	689b      	ldr	r3, [r3, #8]
    a930:	6159      	str	r1, [r3, #20]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    a932:	e9cd 6700 	strd	r6, r7, [sp]
    a936:	4622      	mov	r2, r4
    a938:	4629      	mov	r1, r5
    a93a:	4640      	mov	r0, r8
    a93c:	f000 fb9e 	bl	b07c <z_pend_curr>
    a940:	e7f1      	b.n	a926 <z_impl_k_msgq_get+0xa2>
		result = 0;
    a942:	2000      	movs	r0, #0
    a944:	e7eb      	b.n	a91e <z_impl_k_msgq_get+0x9a>
    a946:	bf00      	nop
    a948:	20005874 	.word	0x20005874

0000a94c <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
    a94c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    a950:	b083      	sub	sp, #12
    a952:	4604      	mov	r4, r0
    a954:	461d      	mov	r5, r3
	__asm__ volatile(
    a956:	f04f 0320 	mov.w	r3, #32
    a95a:	f3ef 8711 	mrs	r7, BASEPRI
    a95e:	f383 8811 	msr	BASEPRI, r3
    a962:	f3bf 8f6f 	isb	sy
	bool resched = false;

	sys_trace_void(SYS_TRACE_ID_MUTEX_LOCK);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    a966:	68c1      	ldr	r1, [r0, #12]
    a968:	b999      	cbnz	r1, a992 <z_impl_k_mutex_lock+0x46>

		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
					_current->base.prio :
    a96a:	2900      	cmp	r1, #0
    a96c:	d14f      	bne.n	aa0e <z_impl_k_mutex_lock+0xc2>
    a96e:	4b3a      	ldr	r3, [pc, #232]	; (aa58 <z_impl_k_mutex_lock+0x10c>)
    a970:	689b      	ldr	r3, [r3, #8]
    a972:	f993 300e 	ldrsb.w	r3, [r3, #14]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    a976:	6123      	str	r3, [r4, #16]
					mutex->owner_orig_prio;

		mutex->lock_count++;
    a978:	3101      	adds	r1, #1
    a97a:	60e1      	str	r1, [r4, #12]
		mutex->owner = _current;
    a97c:	4b36      	ldr	r3, [pc, #216]	; (aa58 <z_impl_k_mutex_lock+0x10c>)
    a97e:	689b      	ldr	r3, [r3, #8]
    a980:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
    a982:	f387 8811 	msr	BASEPRI, r7
    a986:	f3bf 8f6f 	isb	sy
			mutex->owner_orig_prio);

		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
    a98a:	2000      	movs	r0, #0
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
    a98c:	b003      	add	sp, #12
    a98e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    a992:	4616      	mov	r6, r2
	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    a994:	6882      	ldr	r2, [r0, #8]
    a996:	4b30      	ldr	r3, [pc, #192]	; (aa58 <z_impl_k_mutex_lock+0x10c>)
    a998:	689b      	ldr	r3, [r3, #8]
    a99a:	429a      	cmp	r2, r3
    a99c:	d0e5      	beq.n	a96a <z_impl_k_mutex_lock+0x1e>
	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
    a99e:	ea55 0106 	orrs.w	r1, r5, r6
    a9a2:	bf0c      	ite	eq
    a9a4:	f04f 0801 	moveq.w	r8, #1
    a9a8:	f04f 0800 	movne.w	r8, #0
    a9ac:	d031      	beq.n	aa12 <z_impl_k_mutex_lock+0xc6>
					    mutex->owner->base.prio);
    a9ae:	f992 900e 	ldrsb.w	r9, [r2, #14]
	new_prio = new_prio_for_inheritance(_current->base.prio,
    a9b2:	4649      	mov	r1, r9
    a9b4:	f993 000e 	ldrsb.w	r0, [r3, #14]
    a9b8:	f005 f9ff 	bl	fdba <new_prio_for_inheritance>
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
    a9bc:	4581      	cmp	r9, r0
    a9be:	dc2f      	bgt.n	aa20 <z_impl_k_mutex_lock+0xd4>
	bool resched = false;
    a9c0:	f04f 0900 	mov.w	r9, #0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
    a9c4:	9600      	str	r6, [sp, #0]
    a9c6:	9501      	str	r5, [sp, #4]
    a9c8:	4622      	mov	r2, r4
    a9ca:	4639      	mov	r1, r7
    a9cc:	4823      	ldr	r0, [pc, #140]	; (aa5c <z_impl_k_mutex_lock+0x110>)
    a9ce:	f000 fb55 	bl	b07c <z_pend_curr>
	if (got_mutex == 0) {
    a9d2:	2800      	cmp	r0, #0
    a9d4:	d0da      	beq.n	a98c <z_impl_k_mutex_lock+0x40>
	__asm__ volatile(
    a9d6:	f04f 0320 	mov.w	r3, #32
    a9da:	f3ef 8511 	mrs	r5, BASEPRI
    a9de:	f383 8811 	msr	BASEPRI, r3
    a9e2:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
    a9e6:	6823      	ldr	r3, [r4, #0]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
    a9e8:	429c      	cmp	r4, r3
    a9ea:	d01f      	beq.n	aa2c <z_impl_k_mutex_lock+0xe0>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
    a9ec:	b1f3      	cbz	r3, aa2c <z_impl_k_mutex_lock+0xe0>
    a9ee:	6921      	ldr	r1, [r4, #16]
    a9f0:	f993 000e 	ldrsb.w	r0, [r3, #14]
    a9f4:	f005 f9e1 	bl	fdba <new_prio_for_inheritance>
    a9f8:	4601      	mov	r1, r0
	resched = adjust_owner_prio(mutex, new_prio) || resched;
    a9fa:	4620      	mov	r0, r4
    a9fc:	f005 f9e6 	bl	fdcc <adjust_owner_prio>
    aa00:	b9b0      	cbnz	r0, aa30 <z_impl_k_mutex_lock+0xe4>
    aa02:	f1b9 0f00 	cmp.w	r9, #0
    aa06:	d015      	beq.n	aa34 <z_impl_k_mutex_lock+0xe8>
    aa08:	f04f 0801 	mov.w	r8, #1
    aa0c:	e012      	b.n	aa34 <z_impl_k_mutex_lock+0xe8>
					_current->base.prio :
    aa0e:	6923      	ldr	r3, [r4, #16]
    aa10:	e7b1      	b.n	a976 <z_impl_k_mutex_lock+0x2a>
	__asm__ volatile(
    aa12:	f387 8811 	msr	BASEPRI, r7
    aa16:	f3bf 8f6f 	isb	sy
		return -EBUSY;
    aa1a:	f06f 000f 	mvn.w	r0, #15
    aa1e:	e7b5      	b.n	a98c <z_impl_k_mutex_lock+0x40>
		resched = adjust_owner_prio(mutex, new_prio);
    aa20:	4601      	mov	r1, r0
    aa22:	4620      	mov	r0, r4
    aa24:	f005 f9d2 	bl	fdcc <adjust_owner_prio>
    aa28:	4681      	mov	r9, r0
    aa2a:	e7cb      	b.n	a9c4 <z_impl_k_mutex_lock+0x78>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
    aa2c:	6921      	ldr	r1, [r4, #16]
    aa2e:	e7e4      	b.n	a9fa <z_impl_k_mutex_lock+0xae>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
    aa30:	f04f 0801 	mov.w	r8, #1
	if (resched) {
    aa34:	f1b8 0f00 	cmp.w	r8, #0
    aa38:	d106      	bne.n	aa48 <z_impl_k_mutex_lock+0xfc>
    aa3a:	f385 8811 	msr	BASEPRI, r5
    aa3e:	f3bf 8f6f 	isb	sy
	return -EAGAIN;
    aa42:	f06f 000a 	mvn.w	r0, #10
    aa46:	e7a1      	b.n	a98c <z_impl_k_mutex_lock+0x40>
		z_reschedule(&lock, key);
    aa48:	4629      	mov	r1, r5
    aa4a:	4804      	ldr	r0, [pc, #16]	; (aa5c <z_impl_k_mutex_lock+0x110>)
    aa4c:	f005 fae2 	bl	10014 <z_reschedule>
	return -EAGAIN;
    aa50:	f06f 000a 	mvn.w	r0, #10
    aa54:	e79a      	b.n	a98c <z_impl_k_mutex_lock+0x40>
    aa56:	bf00      	nop
    aa58:	20005874 	.word	0x20005874
    aa5c:	20005874 	.word	0x20005874

0000aa60 <z_impl_k_mutex_unlock>:

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
	struct k_thread *new_owner;

	CHECKIF(mutex->owner == NULL) {
    aa60:	6882      	ldr	r2, [r0, #8]
    aa62:	2a00      	cmp	r2, #0
    aa64:	d034      	beq.n	aad0 <z_impl_k_mutex_unlock+0x70>
{
    aa66:	b538      	push	{r3, r4, r5, lr}
    aa68:	4604      	mov	r4, r0
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
    aa6a:	4b1c      	ldr	r3, [pc, #112]	; (aadc <z_impl_k_mutex_unlock+0x7c>)
    aa6c:	689b      	ldr	r3, [r3, #8]
    aa6e:	429a      	cmp	r2, r3
    aa70:	d131      	bne.n	aad6 <z_impl_k_mutex_unlock+0x76>
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
    aa72:	7bda      	ldrb	r2, [r3, #15]
    aa74:	3a01      	subs	r2, #1
    aa76:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count - 1U != 0U) {
    aa78:	68c3      	ldr	r3, [r0, #12]
    aa7a:	2b01      	cmp	r3, #1
    aa7c:	d005      	beq.n	aa8a <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
    aa7e:	3b01      	subs	r3, #1
    aa80:	60c3      	str	r3, [r0, #12]
		k_spin_unlock(&lock, key);
	}


k_mutex_unlock_return:
	k_sched_unlock();
    aa82:	f000 f91f 	bl	acc4 <k_sched_unlock>
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);

	return 0;
    aa86:	2000      	movs	r0, #0
}
    aa88:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
    aa8a:	f04f 0320 	mov.w	r3, #32
    aa8e:	f3ef 8511 	mrs	r5, BASEPRI
    aa92:	f383 8811 	msr	BASEPRI, r3
    aa96:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
    aa9a:	6901      	ldr	r1, [r0, #16]
    aa9c:	f005 f996 	bl	fdcc <adjust_owner_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
    aaa0:	4620      	mov	r0, r4
    aaa2:	f005 fbaa 	bl	101fa <z_unpend_first_thread>
	mutex->owner = new_owner;
    aaa6:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
    aaa8:	b158      	cbz	r0, aac2 <z_impl_k_mutex_unlock+0x62>
		mutex->owner_orig_prio = new_owner->base.prio;
    aaaa:	f990 300e 	ldrsb.w	r3, [r0, #14]
    aaae:	6123      	str	r3, [r4, #16]
    aab0:	2300      	movs	r3, #0
    aab2:	6703      	str	r3, [r0, #112]	; 0x70
		z_ready_thread(new_owner);
    aab4:	f005 faf9 	bl	100aa <z_ready_thread>
		z_reschedule(&lock, key);
    aab8:	4629      	mov	r1, r5
    aaba:	4809      	ldr	r0, [pc, #36]	; (aae0 <z_impl_k_mutex_unlock+0x80>)
    aabc:	f005 faaa 	bl	10014 <z_reschedule>
    aac0:	e7df      	b.n	aa82 <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
    aac2:	2300      	movs	r3, #0
    aac4:	60e3      	str	r3, [r4, #12]
	__asm__ volatile(
    aac6:	f385 8811 	msr	BASEPRI, r5
    aaca:	f3bf 8f6f 	isb	sy
    aace:	e7d8      	b.n	aa82 <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
    aad0:	f06f 0015 	mvn.w	r0, #21
}
    aad4:	4770      	bx	lr
		return -EPERM;
    aad6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    aada:	e7d5      	b.n	aa88 <z_impl_k_mutex_unlock+0x28>
    aadc:	20005874 	.word	0x20005874
    aae0:	20005874 	.word	0x20005874

0000aae4 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
    aae4:	b5d0      	push	{r4, r6, r7, lr}
    aae6:	b082      	sub	sp, #8
    aae8:	4601      	mov	r1, r0
    aaea:	4616      	mov	r6, r2
    aaec:	461f      	mov	r7, r3
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
    aaee:	4602      	mov	r2, r0
	__asm__ volatile(
    aaf0:	f04f 0320 	mov.w	r3, #32
    aaf4:	f3ef 8411 	mrs	r4, BASEPRI
    aaf8:	f383 8811 	msr	BASEPRI, r3
    aafc:	f3bf 8f6f 	isb	sy
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_head(sys_sflist_t *list)
{
	return list->head;
    ab00:	f852 0b08 	ldr.w	r0, [r2], #8
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
    ab04:	b188      	cbz	r0, ab2a <z_impl_k_queue_get+0x46>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
    ab06:	6803      	ldr	r3, [r0, #0]
    ab08:	f023 0303 	bic.w	r3, r3, #3
	list->head = node;
    ab0c:	600b      	str	r3, [r1, #0]
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_tail(sys_sflist_t *list)
{
	return list->tail;
    ab0e:	684a      	ldr	r2, [r1, #4]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
    ab10:	4290      	cmp	r0, r2
    ab12:	d008      	beq.n	ab26 <z_impl_k_queue_get+0x42>
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
    ab14:	2101      	movs	r1, #1
    ab16:	f005 f9d6 	bl	fec6 <z_queue_node_peek>
	__asm__ volatile(
    ab1a:	f384 8811 	msr	BASEPRI, r4
    ab1e:	f3bf 8f6f 	isb	sy
	}

	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
    ab22:	b002      	add	sp, #8
    ab24:	bdd0      	pop	{r4, r6, r7, pc}
	list->tail = node;
    ab26:	604b      	str	r3, [r1, #4]
}
    ab28:	e7f4      	b.n	ab14 <z_impl_k_queue_get+0x30>
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    ab2a:	ea56 0307 	orrs.w	r3, r6, r7
    ab2e:	d00a      	beq.n	ab46 <z_impl_k_queue_get+0x62>
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
    ab30:	e9cd 6700 	strd	r6, r7, [sp]
    ab34:	4621      	mov	r1, r4
    ab36:	4610      	mov	r0, r2
    ab38:	f000 faa0 	bl	b07c <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
    ab3c:	b948      	cbnz	r0, ab52 <z_impl_k_queue_get+0x6e>
    ab3e:	4b06      	ldr	r3, [pc, #24]	; (ab58 <z_impl_k_queue_get+0x74>)
    ab40:	689b      	ldr	r3, [r3, #8]
    ab42:	6958      	ldr	r0, [r3, #20]
    ab44:	e7ed      	b.n	ab22 <z_impl_k_queue_get+0x3e>
    ab46:	f384 8811 	msr	BASEPRI, r4
    ab4a:	f3bf 8f6f 	isb	sy
		return NULL;
    ab4e:	2000      	movs	r0, #0
    ab50:	e7e7      	b.n	ab22 <z_impl_k_queue_get+0x3e>
	return (ret != 0) ? NULL : _current->base.swap_data;
    ab52:	2000      	movs	r0, #0
    ab54:	e7e5      	b.n	ab22 <z_impl_k_queue_get+0x3e>
    ab56:	bf00      	nop
    ab58:	20005874 	.word	0x20005874

0000ab5c <add_thread_timeout>:
		z_priq_wait_add(&wait_q->waitq, thread);
	}
}

static void add_thread_timeout(struct k_thread *thread, k_timeout_t timeout)
{
    ab5c:	b538      	push	{r3, r4, r5, lr}
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    ab5e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    ab62:	bf08      	it	eq
    ab64:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
    ab68:	d100      	bne.n	ab6c <add_thread_timeout+0x10>
#ifdef CONFIG_LEGACY_TIMEOUT_API
		timeout = _TICK_ALIGN + k_ms_to_ticks_ceil32(timeout);
#endif
		z_add_thread_timeout(thread, timeout);
	}
}
    ab6a:	bd38      	pop	{r3, r4, r5, pc}

extern void z_thread_timeout(struct _timeout *to);

static inline void z_add_thread_timeout(struct k_thread *th, k_timeout_t ticks)
{
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
    ab6c:	4902      	ldr	r1, [pc, #8]	; (ab78 <add_thread_timeout+0x1c>)
    ab6e:	3018      	adds	r0, #24
    ab70:	f000 fd1a 	bl	b5a8 <z_add_timeout>
    ab74:	e7f9      	b.n	ab6a <add_thread_timeout+0xe>
    ab76:	bf00      	nop
    ab78:	000100d7 	.word	0x000100d7

0000ab7c <z_reset_time_slice>:
{
    ab7c:	b508      	push	{r3, lr}
	if (slice_time != 0) {
    ab7e:	4b08      	ldr	r3, [pc, #32]	; (aba0 <z_reset_time_slice+0x24>)
    ab80:	681b      	ldr	r3, [r3, #0]
    ab82:	b903      	cbnz	r3, ab86 <z_reset_time_slice+0xa>
}
    ab84:	bd08      	pop	{r3, pc}
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
    ab86:	f7f7 fd49 	bl	261c <z_clock_elapsed>
    ab8a:	4603      	mov	r3, r0
    ab8c:	4a04      	ldr	r2, [pc, #16]	; (aba0 <z_reset_time_slice+0x24>)
    ab8e:	6810      	ldr	r0, [r2, #0]
    ab90:	4403      	add	r3, r0
    ab92:	4a04      	ldr	r2, [pc, #16]	; (aba4 <z_reset_time_slice+0x28>)
    ab94:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
    ab96:	2100      	movs	r1, #0
    ab98:	f005 fc11 	bl	103be <z_set_timeout_expiry>
}
    ab9c:	e7f2      	b.n	ab84 <z_reset_time_slice+0x8>
    ab9e:	bf00      	nop
    aba0:	200058ac 	.word	0x200058ac
    aba4:	20005874 	.word	0x20005874

0000aba8 <k_sched_time_slice_set>:
{
    aba8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    abac:	4606      	mov	r6, r0
    abae:	4688      	mov	r8, r1
	LOCKED(&sched_spinlock) {
    abb0:	2300      	movs	r3, #0
	__asm__ volatile(
    abb2:	f04f 0220 	mov.w	r2, #32
    abb6:	f3ef 8711 	mrs	r7, BASEPRI
    abba:	f382 8811 	msr	BASEPRI, r2
    abbe:	f3bf 8f6f 	isb	sy
    abc2:	b9eb      	cbnz	r3, ac00 <k_sched_time_slice_set+0x58>
		_current_cpu->slice_ticks = 0;
    abc4:	2300      	movs	r3, #0
    abc6:	4a0f      	ldr	r2, [pc, #60]	; (ac04 <k_sched_time_slice_set+0x5c>)
    abc8:	6113      	str	r3, [r2, #16]
		} else {
			return t * (to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
    abca:	0c75      	lsrs	r5, r6, #17
    abcc:	03f4      	lsls	r4, r6, #15
    abce:	f240 30e7 	movw	r0, #999	; 0x3e7
    abd2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    abd6:	2300      	movs	r3, #0
    abd8:	1820      	adds	r0, r4, r0
    abda:	f04f 0100 	mov.w	r1, #0
    abde:	eb45 0101 	adc.w	r1, r5, r1
    abe2:	f7f5 fc11 	bl	408 <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
    abe6:	4b08      	ldr	r3, [pc, #32]	; (ac08 <k_sched_time_slice_set+0x60>)
    abe8:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
    abea:	4b08      	ldr	r3, [pc, #32]	; (ac0c <k_sched_time_slice_set+0x64>)
    abec:	f8c3 8000 	str.w	r8, [r3]
		z_reset_time_slice();
    abf0:	f7ff ffc4 	bl	ab7c <z_reset_time_slice>
	__asm__ volatile(
    abf4:	f387 8811 	msr	BASEPRI, r7
    abf8:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    abfc:	2301      	movs	r3, #1
    abfe:	e7e0      	b.n	abc2 <k_sched_time_slice_set+0x1a>
}
    ac00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ac04:	20005874 	.word	0x20005874
    ac08:	200058ac 	.word	0x200058ac
    ac0c:	200058a8 	.word	0x200058a8

0000ac10 <k_sched_lock>:
	}
}

void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
    ac10:	2300      	movs	r3, #0
	__asm__ volatile(
    ac12:	f04f 0220 	mov.w	r2, #32
    ac16:	f3ef 8111 	mrs	r1, BASEPRI
    ac1a:	f382 8811 	msr	BASEPRI, r2
    ac1e:	f3bf 8f6f 	isb	sy
    ac22:	b953      	cbnz	r3, ac3a <k_sched_lock+0x2a>
    ac24:	4b05      	ldr	r3, [pc, #20]	; (ac3c <k_sched_lock+0x2c>)
    ac26:	689a      	ldr	r2, [r3, #8]
    ac28:	7bd3      	ldrb	r3, [r2, #15]
    ac2a:	3b01      	subs	r3, #1
    ac2c:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
    ac2e:	f381 8811 	msr	BASEPRI, r1
    ac32:	f3bf 8f6f 	isb	sy
    ac36:	2301      	movs	r3, #1
    ac38:	e7f3      	b.n	ac22 <k_sched_lock+0x12>
		z_sched_lock();
	}
}
    ac3a:	4770      	bx	lr
    ac3c:	20005874 	.word	0x20005874

0000ac40 <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
    ac40:	4b0a      	ldr	r3, [pc, #40]	; (ac6c <z_priq_dumb_remove+0x2c>)
    ac42:	4283      	cmp	r3, r0
    ac44:	d008      	beq.n	ac58 <z_priq_dumb_remove+0x18>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
    ac46:	684a      	ldr	r2, [r1, #4]
    ac48:	680b      	ldr	r3, [r1, #0]
    ac4a:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
    ac4c:	684a      	ldr	r2, [r1, #4]
    ac4e:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    ac50:	2300      	movs	r3, #0
    ac52:	600b      	str	r3, [r1, #0]
	node->prev = NULL;
    ac54:	604b      	str	r3, [r1, #4]
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
    ac56:	4770      	bx	lr
	if (pq == &_kernel.ready_q.runq && thread == _current &&
    ac58:	3b28      	subs	r3, #40	; 0x28
    ac5a:	689b      	ldr	r3, [r3, #8]
    ac5c:	428b      	cmp	r3, r1
    ac5e:	d1f2      	bne.n	ac46 <z_priq_dumb_remove+0x6>
	u8_t state = thread->base.thread_state;
    ac60:	7b4b      	ldrb	r3, [r1, #13]
    ac62:	f013 0f1f 	tst.w	r3, #31
    ac66:	d0ee      	beq.n	ac46 <z_priq_dumb_remove+0x6>
    ac68:	e7f5      	b.n	ac56 <z_priq_dumb_remove+0x16>
    ac6a:	bf00      	nop
    ac6c:	2000589c 	.word	0x2000589c

0000ac70 <update_cache>:
{
    ac70:	b570      	push	{r4, r5, r6, lr}
    ac72:	4605      	mov	r5, r0
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
    ac74:	4e12      	ldr	r6, [pc, #72]	; (acc0 <update_cache+0x50>)
    ac76:	f106 0028 	add.w	r0, r6, #40	; 0x28
    ac7a:	f005 fa0f 	bl	1009c <z_priq_dumb_best>
    ac7e:	4604      	mov	r4, r0
	if (_current->base.thread_state & _THREAD_ABORTING) {
    ac80:	68b3      	ldr	r3, [r6, #8]
    ac82:	7b5a      	ldrb	r2, [r3, #13]
    ac84:	f012 0f20 	tst.w	r2, #32
    ac88:	d002      	beq.n	ac90 <update_cache+0x20>
		_current->base.thread_state |= _THREAD_DEAD;
    ac8a:	f042 0208 	orr.w	r2, r2, #8
    ac8e:	735a      	strb	r2, [r3, #13]
	return thread ? thread : _current_cpu->idle_thread;
    ac90:	b164      	cbz	r4, acac <update_cache+0x3c>
	if (preempt_ok != 0) {
    ac92:	b975      	cbnz	r5, acb2 <update_cache+0x42>
    ac94:	7b5a      	ldrb	r2, [r3, #13]
	if (z_is_thread_prevented_from_running(_current)) {
    ac96:	f012 0f1f 	tst.w	r2, #31
    ac9a:	d10a      	bne.n	acb2 <update_cache+0x42>
	return node->next != NULL;
    ac9c:	69a2      	ldr	r2, [r4, #24]
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
    ac9e:	b942      	cbnz	r2, acb2 <update_cache+0x42>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    aca0:	89da      	ldrh	r2, [r3, #14]
	if (is_preempt(_current) || is_metairq(thread)) {
    aca2:	2a7f      	cmp	r2, #127	; 0x7f
    aca4:	d905      	bls.n	acb2 <update_cache+0x42>
		_kernel.ready_q.cache = _current;
    aca6:	4a06      	ldr	r2, [pc, #24]	; (acc0 <update_cache+0x50>)
    aca8:	6253      	str	r3, [r2, #36]	; 0x24
    acaa:	e008      	b.n	acbe <update_cache+0x4e>
	return thread ? thread : _current_cpu->idle_thread;
    acac:	4a04      	ldr	r2, [pc, #16]	; (acc0 <update_cache+0x50>)
    acae:	68d4      	ldr	r4, [r2, #12]
    acb0:	e7ef      	b.n	ac92 <update_cache+0x22>
		if (thread != _current) {
    acb2:	42a3      	cmp	r3, r4
    acb4:	d001      	beq.n	acba <update_cache+0x4a>
			z_reset_time_slice();
    acb6:	f7ff ff61 	bl	ab7c <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    acba:	4b01      	ldr	r3, [pc, #4]	; (acc0 <update_cache+0x50>)
    acbc:	625c      	str	r4, [r3, #36]	; 0x24
}
    acbe:	bd70      	pop	{r4, r5, r6, pc}
    acc0:	20005874 	.word	0x20005874

0000acc4 <k_sched_unlock>:
{
    acc4:	b510      	push	{r4, lr}
	LOCKED(&sched_spinlock) {
    acc6:	2300      	movs	r3, #0
	__asm__ volatile(
    acc8:	f04f 0220 	mov.w	r2, #32
    accc:	f3ef 8411 	mrs	r4, BASEPRI
    acd0:	f382 8811 	msr	BASEPRI, r2
    acd4:	f3bf 8f6f 	isb	sy
    acd8:	b96b      	cbnz	r3, acf6 <k_sched_unlock+0x32>
		++_current->base.sched_locked;
    acda:	4b0c      	ldr	r3, [pc, #48]	; (ad0c <k_sched_unlock+0x48>)
    acdc:	689a      	ldr	r2, [r3, #8]
    acde:	7bd3      	ldrb	r3, [r2, #15]
    ace0:	3301      	adds	r3, #1
    ace2:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
    ace4:	2000      	movs	r0, #0
    ace6:	f7ff ffc3 	bl	ac70 <update_cache>
	__asm__ volatile(
    acea:	f384 8811 	msr	BASEPRI, r4
    acee:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    acf2:	2301      	movs	r3, #1
    acf4:	e7f0      	b.n	acd8 <k_sched_unlock+0x14>
	__asm__ volatile(
    acf6:	f04f 0320 	mov.w	r3, #32
    acfa:	f3ef 8011 	mrs	r0, BASEPRI
    acfe:	f383 8811 	msr	BASEPRI, r3
    ad02:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
    ad06:	f005 f998 	bl	1003a <z_reschedule_irqlock>
}
    ad0a:	bd10      	pop	{r4, pc}
    ad0c:	20005874 	.word	0x20005874

0000ad10 <ready_thread>:
{
    ad10:	b538      	push	{r3, r4, r5, lr}
    ad12:	4605      	mov	r5, r0
	u8_t state = thread->base.thread_state;
    ad14:	7b43      	ldrb	r3, [r0, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    ad16:	f013 0f1f 	tst.w	r3, #31
    ad1a:	d105      	bne.n	ad28 <ready_thread+0x18>
    ad1c:	6983      	ldr	r3, [r0, #24]
    ad1e:	b10b      	cbz	r3, ad24 <ready_thread+0x14>
    ad20:	2300      	movs	r3, #0
    ad22:	e002      	b.n	ad2a <ready_thread+0x1a>
    ad24:	2301      	movs	r3, #1
    ad26:	e000      	b.n	ad2a <ready_thread+0x1a>
    ad28:	2300      	movs	r3, #0
	if (z_is_thread_ready(thread)) {
    ad2a:	b30b      	cbz	r3, ad70 <ready_thread+0x60>
	return list->head == list;
    ad2c:	4b15      	ldr	r3, [pc, #84]	; (ad84 <ready_thread+0x74>)
    ad2e:	f853 4f28 	ldr.w	r4, [r3, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    ad32:	429c      	cmp	r4, r3
    ad34:	d024      	beq.n	ad80 <ready_thread+0x70>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    ad36:	b164      	cbz	r4, ad52 <ready_thread+0x42>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
    ad38:	4621      	mov	r1, r4
    ad3a:	4628      	mov	r0, r5
    ad3c:	f005 f92a 	bl	ff94 <z_is_t1_higher_prio_than_t2>
    ad40:	b9b8      	cbnz	r0, ad72 <ready_thread+0x62>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    ad42:	b134      	cbz	r4, ad52 <ready_thread+0x42>
	return (node == list->tail) ? NULL : node->next;
    ad44:	4b0f      	ldr	r3, [pc, #60]	; (ad84 <ready_thread+0x74>)
    ad46:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    ad48:	429c      	cmp	r4, r3
    ad4a:	d002      	beq.n	ad52 <ready_thread+0x42>
    ad4c:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    ad4e:	2c00      	cmp	r4, #0
    ad50:	d1f1      	bne.n	ad36 <ready_thread+0x26>
	node->next = list;
    ad52:	4b0c      	ldr	r3, [pc, #48]	; (ad84 <ready_thread+0x74>)
    ad54:	f103 0228 	add.w	r2, r3, #40	; 0x28
    ad58:	602a      	str	r2, [r5, #0]
	node->prev = list->tail;
    ad5a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    ad5c:	606a      	str	r2, [r5, #4]
	list->tail->next = node;
    ad5e:	6015      	str	r5, [r2, #0]
	list->tail = node;
    ad60:	62dd      	str	r5, [r3, #44]	; 0x2c
	thread->base.thread_state |= states;
    ad62:	7b6b      	ldrb	r3, [r5, #13]
    ad64:	f063 037f 	orn	r3, r3, #127	; 0x7f
    ad68:	736b      	strb	r3, [r5, #13]
		update_cache(0);
    ad6a:	2000      	movs	r0, #0
    ad6c:	f7ff ff80 	bl	ac70 <update_cache>
}
    ad70:	bd38      	pop	{r3, r4, r5, pc}
	node->prev = successor->prev;
    ad72:	6863      	ldr	r3, [r4, #4]
    ad74:	606b      	str	r3, [r5, #4]
	node->next = successor;
    ad76:	602c      	str	r4, [r5, #0]
	successor->prev->next = node;
    ad78:	6863      	ldr	r3, [r4, #4]
    ad7a:	601d      	str	r5, [r3, #0]
	successor->prev = node;
    ad7c:	6065      	str	r5, [r4, #4]
}
    ad7e:	e7f0      	b.n	ad62 <ready_thread+0x52>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    ad80:	2400      	movs	r4, #0
    ad82:	e7d8      	b.n	ad36 <ready_thread+0x26>
    ad84:	20005874 	.word	0x20005874

0000ad88 <z_sched_start>:
{
    ad88:	b510      	push	{r4, lr}
    ad8a:	f04f 0320 	mov.w	r3, #32
    ad8e:	f3ef 8411 	mrs	r4, BASEPRI
    ad92:	f383 8811 	msr	BASEPRI, r3
    ad96:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
    ad9a:	7b43      	ldrb	r3, [r0, #13]
	if (z_has_thread_started(thread)) {
    ad9c:	f013 0f04 	tst.w	r3, #4
    ada0:	d104      	bne.n	adac <z_sched_start+0x24>
	__asm__ volatile(
    ada2:	f384 8811 	msr	BASEPRI, r4
    ada6:	f3bf 8f6f 	isb	sy
}
    adaa:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
    adac:	f023 0304 	bic.w	r3, r3, #4
    adb0:	7343      	strb	r3, [r0, #13]
	ready_thread(thread);
    adb2:	f7ff ffad 	bl	ad10 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    adb6:	4621      	mov	r1, r4
    adb8:	4801      	ldr	r0, [pc, #4]	; (adc0 <z_sched_start+0x38>)
    adba:	f005 f92b 	bl	10014 <z_reschedule>
    adbe:	e7f4      	b.n	adaa <z_sched_start+0x22>
    adc0:	200058a8 	.word	0x200058a8

0000adc4 <z_move_thread_to_end_of_prio_q>:
{
    adc4:	b570      	push	{r4, r5, r6, lr}
    adc6:	4605      	mov	r5, r0
	LOCKED(&sched_spinlock) {
    adc8:	2300      	movs	r3, #0
	__asm__ volatile(
    adca:	f04f 0220 	mov.w	r2, #32
    adce:	f3ef 8611 	mrs	r6, BASEPRI
    add2:	f382 8811 	msr	BASEPRI, r2
    add6:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    adda:	e026      	b.n	ae2a <z_move_thread_to_end_of_prio_q+0x66>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    addc:	4629      	mov	r1, r5
    adde:	4821      	ldr	r0, [pc, #132]	; (ae64 <z_move_thread_to_end_of_prio_q+0xa0>)
    ade0:	f7ff ff2e 	bl	ac40 <z_priq_dumb_remove>
    ade4:	e026      	b.n	ae34 <z_move_thread_to_end_of_prio_q+0x70>
	node->prev = successor->prev;
    ade6:	6863      	ldr	r3, [r4, #4]
    ade8:	606b      	str	r3, [r5, #4]
	node->next = successor;
    adea:	602c      	str	r4, [r5, #0]
	successor->prev->next = node;
    adec:	6863      	ldr	r3, [r4, #4]
    adee:	601d      	str	r5, [r3, #0]
	successor->prev = node;
    adf0:	6065      	str	r5, [r4, #4]
}
    adf2:	e009      	b.n	ae08 <z_move_thread_to_end_of_prio_q+0x44>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    adf4:	2400      	movs	r4, #0
    adf6:	e022      	b.n	ae3e <z_move_thread_to_end_of_prio_q+0x7a>
	node->next = list;
    adf8:	4b1b      	ldr	r3, [pc, #108]	; (ae68 <z_move_thread_to_end_of_prio_q+0xa4>)
    adfa:	f103 0228 	add.w	r2, r3, #40	; 0x28
    adfe:	602a      	str	r2, [r5, #0]
	node->prev = list->tail;
    ae00:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    ae02:	606a      	str	r2, [r5, #4]
	list->tail->next = node;
    ae04:	6015      	str	r5, [r2, #0]
	list->tail = node;
    ae06:	62dd      	str	r5, [r3, #44]	; 0x2c
	thread->base.thread_state |= states;
    ae08:	7b6b      	ldrb	r3, [r5, #13]
    ae0a:	f063 037f 	orn	r3, r3, #127	; 0x7f
    ae0e:	736b      	strb	r3, [r5, #13]
		update_cache(thread == _current);
    ae10:	4b15      	ldr	r3, [pc, #84]	; (ae68 <z_move_thread_to_end_of_prio_q+0xa4>)
    ae12:	6898      	ldr	r0, [r3, #8]
    ae14:	42a8      	cmp	r0, r5
    ae16:	bf14      	ite	ne
    ae18:	2000      	movne	r0, #0
    ae1a:	2001      	moveq	r0, #1
    ae1c:	f7ff ff28 	bl	ac70 <update_cache>
	__asm__ volatile(
    ae20:	f386 8811 	msr	BASEPRI, r6
    ae24:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    ae28:	2301      	movs	r3, #1
    ae2a:	b9d3      	cbnz	r3, ae62 <z_move_thread_to_end_of_prio_q+0x9e>
		if (z_is_thread_queued(thread)) {
    ae2c:	f995 300d 	ldrsb.w	r3, [r5, #13]
    ae30:	2b00      	cmp	r3, #0
    ae32:	dbd3      	blt.n	addc <z_move_thread_to_end_of_prio_q+0x18>
	return list->head == list;
    ae34:	4b0c      	ldr	r3, [pc, #48]	; (ae68 <z_move_thread_to_end_of_prio_q+0xa4>)
    ae36:	f853 4f28 	ldr.w	r4, [r3, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    ae3a:	429c      	cmp	r4, r3
    ae3c:	d0da      	beq.n	adf4 <z_move_thread_to_end_of_prio_q+0x30>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    ae3e:	2c00      	cmp	r4, #0
    ae40:	d0da      	beq.n	adf8 <z_move_thread_to_end_of_prio_q+0x34>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
    ae42:	4621      	mov	r1, r4
    ae44:	4628      	mov	r0, r5
    ae46:	f005 f8a5 	bl	ff94 <z_is_t1_higher_prio_than_t2>
    ae4a:	2800      	cmp	r0, #0
    ae4c:	d1cb      	bne.n	ade6 <z_move_thread_to_end_of_prio_q+0x22>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    ae4e:	2c00      	cmp	r4, #0
    ae50:	d0d2      	beq.n	adf8 <z_move_thread_to_end_of_prio_q+0x34>
	return (node == list->tail) ? NULL : node->next;
    ae52:	4b05      	ldr	r3, [pc, #20]	; (ae68 <z_move_thread_to_end_of_prio_q+0xa4>)
    ae54:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    ae56:	429c      	cmp	r4, r3
    ae58:	d0ce      	beq.n	adf8 <z_move_thread_to_end_of_prio_q+0x34>
    ae5a:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    ae5c:	2c00      	cmp	r4, #0
    ae5e:	d1ee      	bne.n	ae3e <z_move_thread_to_end_of_prio_q+0x7a>
    ae60:	e7ca      	b.n	adf8 <z_move_thread_to_end_of_prio_q+0x34>
}
    ae62:	bd70      	pop	{r4, r5, r6, pc}
    ae64:	2000589c 	.word	0x2000589c
    ae68:	20005874 	.word	0x20005874

0000ae6c <z_time_slice>:
{
    ae6c:	b508      	push	{r3, lr}
	if (pending_current == _current) {
    ae6e:	4b17      	ldr	r3, [pc, #92]	; (aecc <z_time_slice+0x60>)
    ae70:	689b      	ldr	r3, [r3, #8]
    ae72:	4a17      	ldr	r2, [pc, #92]	; (aed0 <z_time_slice+0x64>)
    ae74:	6812      	ldr	r2, [r2, #0]
    ae76:	4293      	cmp	r3, r2
    ae78:	d017      	beq.n	aeaa <z_time_slice+0x3e>
	pending_current = NULL;
    ae7a:	4a15      	ldr	r2, [pc, #84]	; (aed0 <z_time_slice+0x64>)
    ae7c:	2100      	movs	r1, #0
    ae7e:	6011      	str	r1, [r2, #0]
	if (slice_time && sliceable(_current)) {
    ae80:	4a14      	ldr	r2, [pc, #80]	; (aed4 <z_time_slice+0x68>)
    ae82:	6812      	ldr	r2, [r2, #0]
    ae84:	b16a      	cbz	r2, aea2 <z_time_slice+0x36>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    ae86:	89da      	ldrh	r2, [r3, #14]
		&& !z_is_thread_timeout_active(thread);
    ae88:	2a7f      	cmp	r2, #127	; 0x7f
    ae8a:	d80a      	bhi.n	aea2 <z_time_slice+0x36>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    ae8c:	f993 100e 	ldrsb.w	r1, [r3, #14]
    ae90:	4a11      	ldr	r2, [pc, #68]	; (aed8 <z_time_slice+0x6c>)
    ae92:	6812      	ldr	r2, [r2, #0]
    ae94:	4291      	cmp	r1, r2
    ae96:	db04      	blt.n	aea2 <z_time_slice+0x36>
		&& !z_is_idle_thread_object(thread)
    ae98:	4a10      	ldr	r2, [pc, #64]	; (aedc <z_time_slice+0x70>)
    ae9a:	4293      	cmp	r3, r2
    ae9c:	d001      	beq.n	aea2 <z_time_slice+0x36>
	return node->next != NULL;
    ae9e:	699a      	ldr	r2, [r3, #24]
		&& !z_is_thread_timeout_active(thread);
    aea0:	b132      	cbz	r2, aeb0 <z_time_slice+0x44>
		_current_cpu->slice_ticks = 0;
    aea2:	4b0a      	ldr	r3, [pc, #40]	; (aecc <z_time_slice+0x60>)
    aea4:	2200      	movs	r2, #0
    aea6:	611a      	str	r2, [r3, #16]
}
    aea8:	bd08      	pop	{r3, pc}
		z_reset_time_slice();
    aeaa:	f7ff fe67 	bl	ab7c <z_reset_time_slice>
		return;
    aeae:	e7fb      	b.n	aea8 <z_time_slice+0x3c>
		if (ticks >= _current_cpu->slice_ticks) {
    aeb0:	4a06      	ldr	r2, [pc, #24]	; (aecc <z_time_slice+0x60>)
    aeb2:	6912      	ldr	r2, [r2, #16]
    aeb4:	4282      	cmp	r2, r0
    aeb6:	dd03      	ble.n	aec0 <z_time_slice+0x54>
			_current_cpu->slice_ticks -= ticks;
    aeb8:	1a10      	subs	r0, r2, r0
    aeba:	4b04      	ldr	r3, [pc, #16]	; (aecc <z_time_slice+0x60>)
    aebc:	6118      	str	r0, [r3, #16]
    aebe:	e7f3      	b.n	aea8 <z_time_slice+0x3c>
			z_move_thread_to_end_of_prio_q(_current);
    aec0:	4618      	mov	r0, r3
    aec2:	f7ff ff7f 	bl	adc4 <z_move_thread_to_end_of_prio_q>
			z_reset_time_slice();
    aec6:	f7ff fe59 	bl	ab7c <z_reset_time_slice>
    aeca:	e7ed      	b.n	aea8 <z_time_slice+0x3c>
    aecc:	20005874 	.word	0x20005874
    aed0:	200058a4 	.word	0x200058a4
    aed4:	200058ac 	.word	0x200058ac
    aed8:	200058a8 	.word	0x200058a8
    aedc:	20004e2c 	.word	0x20004e2c

0000aee0 <z_impl_k_thread_suspend>:
{
    aee0:	b538      	push	{r3, r4, r5, lr}
    aee2:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    aee4:	3018      	adds	r0, #24
    aee6:	f005 fa36 	bl	10356 <z_abort_timeout>
	LOCKED(&sched_spinlock) {
    aeea:	2300      	movs	r3, #0
	__asm__ volatile(
    aeec:	f04f 0220 	mov.w	r2, #32
    aef0:	f3ef 8511 	mrs	r5, BASEPRI
    aef4:	f382 8811 	msr	BASEPRI, r2
    aef8:	f3bf 8f6f 	isb	sy
    aefc:	e010      	b.n	af20 <z_impl_k_thread_suspend+0x40>
	thread->base.thread_state |= _THREAD_SUSPENDED;
    aefe:	7b63      	ldrb	r3, [r4, #13]
    af00:	f043 0310 	orr.w	r3, r3, #16
    af04:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
    af06:	4b15      	ldr	r3, [pc, #84]	; (af5c <z_impl_k_thread_suspend+0x7c>)
    af08:	6898      	ldr	r0, [r3, #8]
    af0a:	42a0      	cmp	r0, r4
    af0c:	bf14      	ite	ne
    af0e:	2000      	movne	r0, #0
    af10:	2001      	moveq	r0, #1
    af12:	f7ff fead 	bl	ac70 <update_cache>
	__asm__ volatile(
    af16:	f385 8811 	msr	BASEPRI, r5
    af1a:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    af1e:	2301      	movs	r3, #1
    af20:	b963      	cbnz	r3, af3c <z_impl_k_thread_suspend+0x5c>
		if (z_is_thread_queued(thread)) {
    af22:	f994 300d 	ldrsb.w	r3, [r4, #13]
    af26:	2b00      	cmp	r3, #0
    af28:	dae9      	bge.n	aefe <z_impl_k_thread_suspend+0x1e>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    af2a:	4621      	mov	r1, r4
    af2c:	480c      	ldr	r0, [pc, #48]	; (af60 <z_impl_k_thread_suspend+0x80>)
    af2e:	f7ff fe87 	bl	ac40 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    af32:	7b63      	ldrb	r3, [r4, #13]
    af34:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    af38:	7363      	strb	r3, [r4, #13]
}
    af3a:	e7e0      	b.n	aefe <z_impl_k_thread_suspend+0x1e>
	if (thread == _current) {
    af3c:	4b07      	ldr	r3, [pc, #28]	; (af5c <z_impl_k_thread_suspend+0x7c>)
    af3e:	689b      	ldr	r3, [r3, #8]
    af40:	42a3      	cmp	r3, r4
    af42:	d000      	beq.n	af46 <z_impl_k_thread_suspend+0x66>
}
    af44:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
    af46:	f04f 0320 	mov.w	r3, #32
    af4a:	f3ef 8011 	mrs	r0, BASEPRI
    af4e:	f383 8811 	msr	BASEPRI, r3
    af52:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
    af56:	f005 f870 	bl	1003a <z_reschedule_irqlock>
    af5a:	e7f3      	b.n	af44 <z_impl_k_thread_suspend+0x64>
    af5c:	20005874 	.word	0x20005874
    af60:	2000589c 	.word	0x2000589c

0000af64 <z_thread_single_abort>:
{
    af64:	b570      	push	{r4, r5, r6, lr}
    af66:	4605      	mov	r5, r0
	if (thread->fn_abort != NULL) {
    af68:	6d83      	ldr	r3, [r0, #88]	; 0x58
    af6a:	b103      	cbz	r3, af6e <z_thread_single_abort+0xa>
		thread->fn_abort();
    af6c:	4798      	blx	r3
    af6e:	f105 0018 	add.w	r0, r5, #24
    af72:	f005 f9f0 	bl	10356 <z_abort_timeout>
	LOCKED(&sched_spinlock) {
    af76:	2300      	movs	r3, #0
    af78:	f04f 0220 	mov.w	r2, #32
    af7c:	f3ef 8611 	mrs	r6, BASEPRI
    af80:	f382 8811 	msr	BASEPRI, r2
    af84:	f3bf 8f6f 	isb	sy
    af88:	e01f      	b.n	afca <z_thread_single_abort+0x66>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    af8a:	2201      	movs	r2, #1
    af8c:	e027      	b.n	afde <z_thread_single_abort+0x7a>
				_priq_run_remove(&_kernel.ready_q.runq,
    af8e:	4629      	mov	r1, r5
    af90:	482a      	ldr	r0, [pc, #168]	; (b03c <z_thread_single_abort+0xd8>)
    af92:	f7ff fe55 	bl	ac40 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    af96:	7b6b      	ldrb	r3, [r5, #13]
    af98:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    af9c:	736b      	strb	r3, [r5, #13]
}
    af9e:	e024      	b.n	afea <z_thread_single_abort+0x86>
			if (z_is_thread_pending(thread)) {
    afa0:	f013 0f02 	tst.w	r3, #2
    afa4:	d029      	beq.n	affa <z_thread_single_abort+0x96>
				_priq_wait_remove(&pended_on(thread)->waitq,
    afa6:	4628      	mov	r0, r5
    afa8:	f004 fff2 	bl	ff90 <pended_on>
    afac:	4629      	mov	r1, r5
    afae:	f7ff fe47 	bl	ac40 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    afb2:	7b6b      	ldrb	r3, [r5, #13]
    afb4:	f023 0302 	bic.w	r3, r3, #2
    afb8:	736b      	strb	r3, [r5, #13]
				thread->base.pended_on = NULL;
    afba:	2300      	movs	r3, #0
    afbc:	60ab      	str	r3, [r5, #8]
    afbe:	e01c      	b.n	affa <z_thread_single_abort+0x96>
	__asm__ volatile(
    afc0:	f386 8811 	msr	BASEPRI, r6
    afc4:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    afc8:	2301      	movs	r3, #1
    afca:	461a      	mov	r2, r3
    afcc:	2b00      	cmp	r3, #0
    afce:	d134      	bne.n	b03a <z_thread_single_abort+0xd6>
	u8_t state = thread->base.thread_state;
    afd0:	7b6b      	ldrb	r3, [r5, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    afd2:	f013 0f1f 	tst.w	r3, #31
    afd6:	d102      	bne.n	afde <z_thread_single_abort+0x7a>
    afd8:	69a9      	ldr	r1, [r5, #24]
    afda:	2900      	cmp	r1, #0
    afdc:	d0d5      	beq.n	af8a <z_thread_single_abort+0x26>
		if (z_is_thread_ready(thread)) {
    afde:	f012 0f01 	tst.w	r2, #1
    afe2:	d0dd      	beq.n	afa0 <z_thread_single_abort+0x3c>
			if (z_is_thread_queued(thread)) {
    afe4:	f013 0f80 	tst.w	r3, #128	; 0x80
    afe8:	d1d1      	bne.n	af8e <z_thread_single_abort+0x2a>
			update_cache(thread == _current);
    afea:	4b15      	ldr	r3, [pc, #84]	; (b040 <z_thread_single_abort+0xdc>)
    afec:	6898      	ldr	r0, [r3, #8]
    afee:	42a8      	cmp	r0, r5
    aff0:	bf14      	ite	ne
    aff2:	2000      	movne	r0, #0
    aff4:	2001      	moveq	r0, #1
    aff6:	f7ff fe3b 	bl	ac70 <update_cache>
		thread->base.thread_state |= mask;
    affa:	7b6b      	ldrb	r3, [r5, #13]
    affc:	f043 0308 	orr.w	r3, r3, #8
    b000:	736b      	strb	r3, [r5, #13]
	sys_dlist_init(&w->waitq);
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    b002:	f105 0328 	add.w	r3, r5, #40	; 0x28
	return list->head == list;
    b006:	6aac      	ldr	r4, [r5, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
    b008:	42a3      	cmp	r3, r4
    b00a:	d0d9      	beq.n	afc0 <z_thread_single_abort+0x5c>
		while ((waiter = z_waitq_head(&thread->base.join_waiters)) !=
    b00c:	2c00      	cmp	r4, #0
    b00e:	d0d7      	beq.n	afc0 <z_thread_single_abort+0x5c>
    b010:	f104 0018 	add.w	r0, r4, #24
    b014:	f005 f99f 	bl	10356 <z_abort_timeout>
			_priq_wait_remove(&pended_on(waiter)->waitq, waiter);
    b018:	4620      	mov	r0, r4
    b01a:	f004 ffb9 	bl	ff90 <pended_on>
    b01e:	4621      	mov	r1, r4
    b020:	f7ff fe0e 	bl	ac40 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    b024:	7b63      	ldrb	r3, [r4, #13]
    b026:	f023 0302 	bic.w	r3, r3, #2
    b02a:	7363      	strb	r3, [r4, #13]
			waiter->base.pended_on = NULL;
    b02c:	2300      	movs	r3, #0
    b02e:	60a3      	str	r3, [r4, #8]
    b030:	6723      	str	r3, [r4, #112]	; 0x70
			ready_thread(waiter);
    b032:	4620      	mov	r0, r4
    b034:	f7ff fe6c 	bl	ad10 <ready_thread>
    b038:	e7e3      	b.n	b002 <z_thread_single_abort+0x9e>
}
    b03a:	bd70      	pop	{r4, r5, r6, pc}
    b03c:	2000589c 	.word	0x2000589c
    b040:	20005874 	.word	0x20005874

0000b044 <unready_thread>:
{
    b044:	b510      	push	{r4, lr}
    b046:	4604      	mov	r4, r0
	if (z_is_thread_queued(thread)) {
    b048:	f990 300d 	ldrsb.w	r3, [r0, #13]
    b04c:	2b00      	cmp	r3, #0
    b04e:	db08      	blt.n	b062 <unready_thread+0x1e>
	update_cache(thread == _current);
    b050:	4b08      	ldr	r3, [pc, #32]	; (b074 <unready_thread+0x30>)
    b052:	6898      	ldr	r0, [r3, #8]
    b054:	42a0      	cmp	r0, r4
    b056:	bf14      	ite	ne
    b058:	2000      	movne	r0, #0
    b05a:	2001      	moveq	r0, #1
    b05c:	f7ff fe08 	bl	ac70 <update_cache>
}
    b060:	bd10      	pop	{r4, pc}
		_priq_run_remove(&_kernel.ready_q.runq, thread);
    b062:	4601      	mov	r1, r0
    b064:	4804      	ldr	r0, [pc, #16]	; (b078 <unready_thread+0x34>)
    b066:	f7ff fdeb 	bl	ac40 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    b06a:	7b63      	ldrb	r3, [r4, #13]
    b06c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    b070:	7363      	strb	r3, [r4, #13]
}
    b072:	e7ed      	b.n	b050 <unready_thread+0xc>
    b074:	20005874 	.word	0x20005874
    b078:	2000589c 	.word	0x2000589c

0000b07c <z_pend_curr>:
{
    b07c:	b510      	push	{r4, lr}
    b07e:	460c      	mov	r4, r1
    b080:	4611      	mov	r1, r2
	pending_current = _current;
    b082:	4b06      	ldr	r3, [pc, #24]	; (b09c <z_pend_curr+0x20>)
    b084:	6898      	ldr	r0, [r3, #8]
    b086:	4b06      	ldr	r3, [pc, #24]	; (b0a0 <z_pend_curr+0x24>)
    b088:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
    b08a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    b08e:	f005 f893 	bl	101b8 <pend>
	ret = arch_swap(key);
    b092:	4620      	mov	r0, r4
    b094:	f7f7 fb94 	bl	27c0 <arch_swap>
}
    b098:	bd10      	pop	{r4, pc}
    b09a:	bf00      	nop
    b09c:	20005874 	.word	0x20005874
    b0a0:	200058a4 	.word	0x200058a4

0000b0a4 <z_set_prio>:
{
    b0a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    b0a8:	4604      	mov	r4, r0
    b0aa:	460f      	mov	r7, r1
	LOCKED(&sched_spinlock) {
    b0ac:	2300      	movs	r3, #0
	__asm__ volatile(
    b0ae:	f04f 0220 	mov.w	r2, #32
    b0b2:	f3ef 8611 	mrs	r6, BASEPRI
    b0b6:	f382 8811 	msr	BASEPRI, r2
    b0ba:	f3bf 8f6f 	isb	sy
	bool need_sched = 0;
    b0be:	4698      	mov	r8, r3
    b0c0:	e008      	b.n	b0d4 <z_set_prio+0x30>
		if (need_sched) {
    b0c2:	f012 0801 	ands.w	r8, r2, #1
    b0c6:	d111      	bne.n	b0ec <z_set_prio+0x48>
			thread->base.prio = prio;
    b0c8:	73a7      	strb	r7, [r4, #14]
	__asm__ volatile(
    b0ca:	f386 8811 	msr	BASEPRI, r6
    b0ce:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    b0d2:	2301      	movs	r3, #1
    b0d4:	461a      	mov	r2, r3
    b0d6:	2b00      	cmp	r3, #0
    b0d8:	d136      	bne.n	b148 <z_set_prio+0xa4>
	u8_t state = thread->base.thread_state;
    b0da:	7b63      	ldrb	r3, [r4, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    b0dc:	f013 0f1f 	tst.w	r3, #31
    b0e0:	d1ef      	bne.n	b0c2 <z_set_prio+0x1e>
	return node->next != NULL;
    b0e2:	69a3      	ldr	r3, [r4, #24]
    b0e4:	2b00      	cmp	r3, #0
    b0e6:	d1ec      	bne.n	b0c2 <z_set_prio+0x1e>
    b0e8:	2201      	movs	r2, #1
    b0ea:	e7ea      	b.n	b0c2 <z_set_prio+0x1e>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
    b0ec:	4d18      	ldr	r5, [pc, #96]	; (b150 <z_set_prio+0xac>)
    b0ee:	f105 0928 	add.w	r9, r5, #40	; 0x28
    b0f2:	4621      	mov	r1, r4
    b0f4:	4648      	mov	r0, r9
    b0f6:	f7ff fda3 	bl	ac40 <z_priq_dumb_remove>
				thread->base.prio = prio;
    b0fa:	73a7      	strb	r7, [r4, #14]
	return list->head == list;
    b0fc:	6aad      	ldr	r5, [r5, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
    b0fe:	454d      	cmp	r5, r9
    b100:	d020      	beq.n	b144 <z_set_prio+0xa0>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    b102:	b165      	cbz	r5, b11e <z_set_prio+0x7a>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
    b104:	4629      	mov	r1, r5
    b106:	4620      	mov	r0, r4
    b108:	f004 ff44 	bl	ff94 <z_is_t1_higher_prio_than_t2>
    b10c:	b998      	cbnz	r0, b136 <z_set_prio+0x92>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    b10e:	b135      	cbz	r5, b11e <z_set_prio+0x7a>
	return (node == list->tail) ? NULL : node->next;
    b110:	4b0f      	ldr	r3, [pc, #60]	; (b150 <z_set_prio+0xac>)
    b112:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    b114:	429d      	cmp	r5, r3
    b116:	d002      	beq.n	b11e <z_set_prio+0x7a>
    b118:	682d      	ldr	r5, [r5, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    b11a:	2d00      	cmp	r5, #0
    b11c:	d1f1      	bne.n	b102 <z_set_prio+0x5e>
	node->next = list;
    b11e:	4b0c      	ldr	r3, [pc, #48]	; (b150 <z_set_prio+0xac>)
    b120:	f103 0228 	add.w	r2, r3, #40	; 0x28
    b124:	6022      	str	r2, [r4, #0]
	node->prev = list->tail;
    b126:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    b128:	6062      	str	r2, [r4, #4]
	list->tail->next = node;
    b12a:	6014      	str	r4, [r2, #0]
	list->tail = node;
    b12c:	62dc      	str	r4, [r3, #44]	; 0x2c
			update_cache(1);
    b12e:	2001      	movs	r0, #1
    b130:	f7ff fd9e 	bl	ac70 <update_cache>
    b134:	e7c9      	b.n	b0ca <z_set_prio+0x26>
	node->prev = successor->prev;
    b136:	686b      	ldr	r3, [r5, #4]
    b138:	6063      	str	r3, [r4, #4]
	node->next = successor;
    b13a:	6025      	str	r5, [r4, #0]
	successor->prev->next = node;
    b13c:	686b      	ldr	r3, [r5, #4]
    b13e:	601c      	str	r4, [r3, #0]
	successor->prev = node;
    b140:	606c      	str	r4, [r5, #4]
}
    b142:	e7f4      	b.n	b12e <z_set_prio+0x8a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    b144:	2500      	movs	r5, #0
    b146:	e7dc      	b.n	b102 <z_set_prio+0x5e>
}
    b148:	4640      	mov	r0, r8
    b14a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    b14e:	bf00      	nop
    b150:	20005874 	.word	0x20005874

0000b154 <z_sched_init>:

	return need_sched;
}

void z_sched_init(void)
{
    b154:	b508      	push	{r3, lr}
	list->head = (sys_dnode_t *)list;
    b156:	4b05      	ldr	r3, [pc, #20]	; (b16c <z_sched_init+0x18>)
    b158:	f103 0228 	add.w	r2, r3, #40	; 0x28
    b15c:	629a      	str	r2, [r3, #40]	; 0x28
	list->tail = (sys_dnode_t *)list;
    b15e:	62da      	str	r2, [r3, #44]	; 0x2c
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    b160:	2100      	movs	r1, #0
    b162:	4608      	mov	r0, r1
    b164:	f7ff fd20 	bl	aba8 <k_sched_time_slice_set>
		CONFIG_TIMESLICE_PRIORITY);
#endif
}
    b168:	bd08      	pop	{r3, pc}
    b16a:	bf00      	nop
    b16c:	20005874 	.word	0x20005874

0000b170 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
    b170:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__ASSERT(!arch_is_in_isr(), "");

	if (!z_is_idle_thread_object(_current)) {
    b172:	4b2b      	ldr	r3, [pc, #172]	; (b220 <z_impl_k_yield+0xb0>)
    b174:	689a      	ldr	r2, [r3, #8]
    b176:	4b2b      	ldr	r3, [pc, #172]	; (b224 <z_impl_k_yield+0xb4>)
    b178:	429a      	cmp	r2, r3
    b17a:	d046      	beq.n	b20a <z_impl_k_yield+0x9a>
		LOCKED(&sched_spinlock) {
    b17c:	2300      	movs	r3, #0
	__asm__ volatile(
    b17e:	f04f 0220 	mov.w	r2, #32
    b182:	f3ef 8611 	mrs	r6, BASEPRI
    b186:	f382 8811 	msr	BASEPRI, r2
    b18a:	f3bf 8f6f 	isb	sy
    b18e:	e01e      	b.n	b1ce <z_impl_k_yield+0x5e>
	node->prev = successor->prev;
    b190:	6863      	ldr	r3, [r4, #4]
    b192:	606b      	str	r3, [r5, #4]
	node->next = successor;
    b194:	602c      	str	r4, [r5, #0]
	successor->prev->next = node;
    b196:	6863      	ldr	r3, [r4, #4]
    b198:	601d      	str	r5, [r3, #0]
	successor->prev = node;
    b19a:	6065      	str	r5, [r4, #4]
}
    b19c:	e009      	b.n	b1b2 <z_impl_k_yield+0x42>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    b19e:	2400      	movs	r4, #0
    b1a0:	e021      	b.n	b1e6 <z_impl_k_yield+0x76>
	node->next = list;
    b1a2:	4b1f      	ldr	r3, [pc, #124]	; (b220 <z_impl_k_yield+0xb0>)
    b1a4:	f103 0228 	add.w	r2, r3, #40	; 0x28
    b1a8:	602a      	str	r2, [r5, #0]
	node->prev = list->tail;
    b1aa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    b1ac:	606a      	str	r2, [r5, #4]
	list->tail->next = node;
    b1ae:	6015      	str	r5, [r2, #0]
	list->tail = node;
    b1b0:	62dd      	str	r5, [r3, #44]	; 0x2c
			    z_is_thread_queued(_current)) {
				_priq_run_remove(&_kernel.ready_q.runq,
						 _current);
			}
			_priq_run_add(&_kernel.ready_q.runq, _current);
			z_mark_thread_as_queued(_current);
    b1b2:	4b1b      	ldr	r3, [pc, #108]	; (b220 <z_impl_k_yield+0xb0>)
    b1b4:	689a      	ldr	r2, [r3, #8]
	thread->base.thread_state |= states;
    b1b6:	7b53      	ldrb	r3, [r2, #13]
    b1b8:	f063 037f 	orn	r3, r3, #127	; 0x7f
    b1bc:	7353      	strb	r3, [r2, #13]
			update_cache(1);
    b1be:	2001      	movs	r0, #1
    b1c0:	f7ff fd56 	bl	ac70 <update_cache>
	__asm__ volatile(
    b1c4:	f386 8811 	msr	BASEPRI, r6
    b1c8:	f3bf 8f6f 	isb	sy
		LOCKED(&sched_spinlock) {
    b1cc:	2301      	movs	r3, #1
    b1ce:	b9e3      	cbnz	r3, b20a <z_impl_k_yield+0x9a>
				_priq_run_remove(&_kernel.ready_q.runq,
    b1d0:	4c13      	ldr	r4, [pc, #76]	; (b220 <z_impl_k_yield+0xb0>)
    b1d2:	f104 0728 	add.w	r7, r4, #40	; 0x28
    b1d6:	68a1      	ldr	r1, [r4, #8]
    b1d8:	4638      	mov	r0, r7
    b1da:	f7ff fd31 	bl	ac40 <z_priq_dumb_remove>
			_priq_run_add(&_kernel.ready_q.runq, _current);
    b1de:	68a5      	ldr	r5, [r4, #8]
	return list->head == list;
    b1e0:	6aa4      	ldr	r4, [r4, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
    b1e2:	42bc      	cmp	r4, r7
    b1e4:	d0db      	beq.n	b19e <z_impl_k_yield+0x2e>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    b1e6:	2c00      	cmp	r4, #0
    b1e8:	d0db      	beq.n	b1a2 <z_impl_k_yield+0x32>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
    b1ea:	4621      	mov	r1, r4
    b1ec:	4628      	mov	r0, r5
    b1ee:	f004 fed1 	bl	ff94 <z_is_t1_higher_prio_than_t2>
    b1f2:	2800      	cmp	r0, #0
    b1f4:	d1cc      	bne.n	b190 <z_impl_k_yield+0x20>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    b1f6:	2c00      	cmp	r4, #0
    b1f8:	d0d3      	beq.n	b1a2 <z_impl_k_yield+0x32>
	return (node == list->tail) ? NULL : node->next;
    b1fa:	4b09      	ldr	r3, [pc, #36]	; (b220 <z_impl_k_yield+0xb0>)
    b1fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    b1fe:	429c      	cmp	r4, r3
    b200:	d0cf      	beq.n	b1a2 <z_impl_k_yield+0x32>
    b202:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    b204:	2c00      	cmp	r4, #0
    b206:	d1ee      	bne.n	b1e6 <z_impl_k_yield+0x76>
    b208:	e7cb      	b.n	b1a2 <z_impl_k_yield+0x32>
	__asm__ volatile(
    b20a:	f04f 0320 	mov.w	r3, #32
    b20e:	f3ef 8011 	mrs	r0, BASEPRI
    b212:	f383 8811 	msr	BASEPRI, r3
    b216:	f3bf 8f6f 	isb	sy
    b21a:	f7f7 fad1 	bl	27c0 <arch_swap>
		}
	}
	z_swap_unlocked();
}
    b21e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    b220:	20005874 	.word	0x20005874
    b224:	20004e2c 	.word	0x20004e2c

0000b228 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static s32_t z_tick_sleep(s32_t ticks)
{
    b228:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT(!arch_is_in_isr(), "");

	K_DEBUG("thread %p for %d ticks\n", _current, ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
    b22c:	4604      	mov	r4, r0
    b22e:	b348      	cbz	r0, b284 <z_tick_sleep+0x5c>
	}

	k_timeout_t timeout;

#ifndef CONFIG_LEGACY_TIMEOUT_API
	timeout = Z_TIMEOUT_TICKS(ticks);
    b230:	4606      	mov	r6, r0
    b232:	17c7      	asrs	r7, r0, #31
#else
	ticks += _TICK_ALIGN;
	timeout = (k_ticks_t) ticks;
#endif

	expected_wakeup_time = ticks + z_tick_get_32();
    b234:	f005 f8ec 	bl	10410 <z_tick_get_32>
    b238:	4404      	add	r4, r0
    b23a:	f04f 0320 	mov.w	r3, #32
    b23e:	f3ef 8811 	mrs	r8, BASEPRI
    b242:	f383 8811 	msr	BASEPRI, r3
    b246:	f3bf 8f6f 	isb	sy
	 */
	struct k_spinlock local_lock = {};
	k_spinlock_key_t key = k_spin_lock(&local_lock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
    b24a:	4d10      	ldr	r5, [pc, #64]	; (b28c <z_tick_sleep+0x64>)
    b24c:	68a8      	ldr	r0, [r5, #8]
    b24e:	4b10      	ldr	r3, [pc, #64]	; (b290 <z_tick_sleep+0x68>)
    b250:	6018      	str	r0, [r3, #0]
#endif
	z_remove_thread_from_ready_q(_current);
    b252:	f004 ff71 	bl	10138 <z_remove_thread_from_ready_q>
	z_add_thread_timeout(_current, timeout);
    b256:	68a8      	ldr	r0, [r5, #8]
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
    b258:	4632      	mov	r2, r6
    b25a:	463b      	mov	r3, r7
    b25c:	490d      	ldr	r1, [pc, #52]	; (b294 <z_tick_sleep+0x6c>)
    b25e:	3018      	adds	r0, #24
    b260:	f000 f9a2 	bl	b5a8 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
    b264:	68aa      	ldr	r2, [r5, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
    b266:	7b53      	ldrb	r3, [r2, #13]
    b268:	f043 0310 	orr.w	r3, r3, #16
    b26c:	7353      	strb	r3, [r2, #13]
    b26e:	4640      	mov	r0, r8
    b270:	f7f7 faa6 	bl	27c0 <arch_swap>

	(void)z_swap(&local_lock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = expected_wakeup_time - z_tick_get_32();
    b274:	f005 f8cc 	bl	10410 <z_tick_get_32>
    b278:	1a20      	subs	r0, r4, r0
	if (ticks > 0) {
    b27a:	2800      	cmp	r0, #0
    b27c:	dc00      	bgt.n	b280 <z_tick_sleep+0x58>
		return ticks;
	}
#endif

	return 0;
    b27e:	2000      	movs	r0, #0
}
    b280:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	z_impl_k_yield();
    b284:	f7ff ff74 	bl	b170 <z_impl_k_yield>
		return 0;
    b288:	4620      	mov	r0, r4
    b28a:	e7f9      	b.n	b280 <z_tick_sleep+0x58>
    b28c:	20005874 	.word	0x20005874
    b290:	200058a4 	.word	0x200058a4
    b294:	000100d7 	.word	0x000100d7

0000b298 <z_impl_k_sleep>:

s32_t z_impl_k_sleep(k_timeout_t timeout)
{
    b298:	b538      	push	{r3, r4, r5, lr}
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    b29a:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
    b29e:	bf08      	it	eq
    b2a0:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
    b2a4:	d01a      	beq.n	b2dc <z_impl_k_sleep+0x44>
	ticks = k_ms_to_ticks_ceil32(timeout);
#else
	ticks = timeout.ticks;
#endif

	ticks = z_tick_sleep(ticks);
    b2a6:	f7ff ffbf 	bl	b228 <z_tick_sleep>
	return k_ticks_to_ms_floor64(ticks);
    b2aa:	4604      	mov	r4, r0
    b2ac:	17c5      	asrs	r5, r0, #31
		} else {
			return (t * to_hz + off) / from_hz;
    b2ae:	0169      	lsls	r1, r5, #5
    b2b0:	0143      	lsls	r3, r0, #5
    b2b2:	ea41 62d0 	orr.w	r2, r1, r0, lsr #27
    b2b6:	1a18      	subs	r0, r3, r0
    b2b8:	eb62 0305 	sbc.w	r3, r2, r5
    b2bc:	009a      	lsls	r2, r3, #2
    b2be:	ea42 7290 	orr.w	r2, r2, r0, lsr #30
    b2c2:	0081      	lsls	r1, r0, #2
    b2c4:	4613      	mov	r3, r2
    b2c6:	1908      	adds	r0, r1, r4
    b2c8:	eb45 0303 	adc.w	r3, r5, r3
    b2cc:	00da      	lsls	r2, r3, #3
    b2ce:	ea42 7250 	orr.w	r2, r2, r0, lsr #29
    b2d2:	00c1      	lsls	r1, r0, #3
    b2d4:	0bc8      	lsrs	r0, r1, #15
    b2d6:	ea40 4042 	orr.w	r0, r0, r2, lsl #17
}
    b2da:	bd38      	pop	{r3, r4, r5, pc}
		k_thread_suspend(_current);
    b2dc:	4b03      	ldr	r3, [pc, #12]	; (b2ec <z_impl_k_sleep+0x54>)
    b2de:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
    b2e0:	f7ff fdfe 	bl	aee0 <z_impl_k_thread_suspend>
		return (s32_t) K_TICKS_FOREVER;
    b2e4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    b2e8:	e7f7      	b.n	b2da <z_impl_k_sleep+0x42>
    b2ea:	bf00      	nop
    b2ec:	20005874 	.word	0x20005874

0000b2f0 <z_impl_k_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
    b2f0:	4b01      	ldr	r3, [pc, #4]	; (b2f8 <z_impl_k_current_get+0x8>)
    b2f2:	6898      	ldr	r0, [r3, #8]
    b2f4:	4770      	bx	lr
    b2f6:	bf00      	nop
    b2f8:	20005874 	.word	0x20005874

0000b2fc <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    b2fc:	b538      	push	{r3, r4, r5, lr}
    b2fe:	4604      	mov	r4, r0
    b300:	f04f 0320 	mov.w	r3, #32
    b304:	f3ef 8511 	mrs	r5, BASEPRI
    b308:	f383 8811 	msr	BASEPRI, r3
    b30c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
    b310:	f004 ff73 	bl	101fa <z_unpend_first_thread>

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);

	if (thread != NULL) {
    b314:	b140      	cbz	r0, b328 <z_impl_k_sem_give+0x2c>
    b316:	2200      	movs	r2, #0
    b318:	6702      	str	r2, [r0, #112]	; 0x70
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
    b31a:	f004 fec6 	bl	100aa <z_ready_thread>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
    b31e:	4629      	mov	r1, r5
    b320:	4809      	ldr	r0, [pc, #36]	; (b348 <z_impl_k_sem_give+0x4c>)
    b322:	f004 fe77 	bl	10014 <z_reschedule>
}
    b326:	bd38      	pop	{r3, r4, r5, pc}
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    b328:	68a3      	ldr	r3, [r4, #8]
    b32a:	68e2      	ldr	r2, [r4, #12]
    b32c:	4293      	cmp	r3, r2
    b32e:	d008      	beq.n	b342 <z_impl_k_sem_give+0x46>
    b330:	2201      	movs	r2, #1
    b332:	4413      	add	r3, r2
    b334:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
    b336:	2102      	movs	r1, #2
    b338:	f104 0010 	add.w	r0, r4, #16
    b33c:	f005 f912 	bl	10564 <z_handle_obj_poll_events>
}
    b340:	e7ed      	b.n	b31e <z_impl_k_sem_give+0x22>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    b342:	2200      	movs	r2, #0
    b344:	e7f5      	b.n	b332 <z_impl_k_sem_give+0x36>
    b346:	bf00      	nop
    b348:	200058b0 	.word	0x200058b0

0000b34c <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
    b34c:	b530      	push	{r4, r5, lr}
    b34e:	b083      	sub	sp, #12
    b350:	461d      	mov	r5, r3
    b352:	f04f 0320 	mov.w	r3, #32
    b356:	f3ef 8111 	mrs	r1, BASEPRI
    b35a:	f383 8811 	msr	BASEPRI, r3
    b35e:	f3bf 8f6f 	isb	sy
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
    b362:	6883      	ldr	r3, [r0, #8]
    b364:	b143      	cbz	r3, b378 <z_impl_k_sem_take+0x2c>
		sem->count--;
    b366:	3b01      	subs	r3, #1
    b368:	6083      	str	r3, [r0, #8]
	__asm__ volatile(
    b36a:	f381 8811 	msr	BASEPRI, r1
    b36e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
    b372:	2000      	movs	r0, #0
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
}
    b374:	b003      	add	sp, #12
    b376:	bd30      	pop	{r4, r5, pc}
    b378:	4614      	mov	r4, r2
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    b37a:	ea54 0305 	orrs.w	r3, r4, r5
    b37e:	d006      	beq.n	b38e <z_impl_k_sem_take+0x42>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    b380:	e9cd 4500 	strd	r4, r5, [sp]
    b384:	4602      	mov	r2, r0
    b386:	4805      	ldr	r0, [pc, #20]	; (b39c <z_impl_k_sem_take+0x50>)
    b388:	f7ff fe78 	bl	b07c <z_pend_curr>
	return ret;
    b38c:	e7f2      	b.n	b374 <z_impl_k_sem_take+0x28>
    b38e:	f381 8811 	msr	BASEPRI, r1
    b392:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
    b396:	f06f 000f 	mvn.w	r0, #15
    b39a:	e7eb      	b.n	b374 <z_impl_k_sem_take+0x28>
    b39c:	200058b0 	.word	0x200058b0

0000b3a0 <k_sys_work_q_init>:
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
    b3a0:	b510      	push	{r4, lr}
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
    b3a2:	4c08      	ldr	r4, [pc, #32]	; (b3c4 <k_sys_work_q_init+0x24>)
    b3a4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    b3a8:	f44f 6200 	mov.w	r2, #2048	; 0x800
    b3ac:	4906      	ldr	r1, [pc, #24]	; (b3c8 <k_sys_work_q_init+0x28>)
    b3ae:	4620      	mov	r0, r4
    b3b0:	f000 f89a 	bl	b4e8 <k_work_q_start>
	return z_impl_k_thread_name_set(thread_id, value);
    b3b4:	4905      	ldr	r1, [pc, #20]	; (b3cc <k_sys_work_q_init+0x2c>)
    b3b6:	f104 0018 	add.w	r0, r4, #24
    b3ba:	f004 ff87 	bl	102cc <z_impl_k_thread_name_set>
		       K_THREAD_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
    b3be:	2000      	movs	r0, #0
    b3c0:	bd10      	pop	{r4, pc}
    b3c2:	bf00      	nop
    b3c4:	200058b0 	.word	0x200058b0
    b3c8:	200075e0 	.word	0x200075e0
    b3cc:	000130b8 	.word	0x000130b8

0000b3d0 <schedule_new_thread>:
#endif
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, k_timeout_t delay)
{
    b3d0:	b538      	push	{r3, r4, r5, lr}
    b3d2:	4614      	mov	r4, r2
    b3d4:	461d      	mov	r5, r3
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    b3d6:	ea54 0305 	orrs.w	r3, r4, r5
    b3da:	d102      	bne.n	b3e2 <schedule_new_thread+0x12>
	z_impl_k_thread_start(thread);
    b3dc:	f004 ff7b 	bl	102d6 <z_impl_k_thread_start>
	}
#else
	ARG_UNUSED(delay);
	k_thread_start(thread);
#endif
}
    b3e0:	bd38      	pop	{r3, r4, r5, pc}
    b3e2:	462b      	mov	r3, r5
    b3e4:	4902      	ldr	r1, [pc, #8]	; (b3f0 <schedule_new_thread+0x20>)
    b3e6:	3018      	adds	r0, #24
    b3e8:	f000 f8de 	bl	b5a8 <z_add_timeout>
    b3ec:	e7f8      	b.n	b3e0 <schedule_new_thread+0x10>
    b3ee:	bf00      	nop
    b3f0:	000100d7 	.word	0x000100d7

0000b3f4 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
    b3f4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    b3f8:	b087      	sub	sp, #28
    b3fa:	4604      	mov	r4, r0
    b3fc:	460d      	mov	r5, r1
    b3fe:	4616      	mov	r6, r2
    b400:	461f      	mov	r7, r3
    b402:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
    b406:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
	sys_dlist_init(&w->waitq);
    b40a:	f100 0328 	add.w	r3, r0, #40	; 0x28
	list->head = (sys_dnode_t *)list;
    b40e:	6283      	str	r3, [r0, #40]	; 0x28
	list->tail = (sys_dnode_t *)list;
    b410:	62c3      	str	r3, [r0, #44]	; 0x2c
	stack_size = Z_STACK_PTR_ALIGN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif
	/* Initialize various struct k_thread members */
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    b412:	464b      	mov	r3, r9
    b414:	2204      	movs	r2, #4
    b416:	4641      	mov	r1, r8
    b418:	f004 ff61 	bl	102de <z_init_thread_base>

	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    b41c:	f8cd 9010 	str.w	r9, [sp, #16]
    b420:	f8cd 800c 	str.w	r8, [sp, #12]
    b424:	9b10      	ldr	r3, [sp, #64]	; 0x40
    b426:	9302      	str	r3, [sp, #8]
    b428:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    b42a:	9301      	str	r3, [sp, #4]
    b42c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    b42e:	9300      	str	r3, [sp, #0]
    b430:	463b      	mov	r3, r7
    b432:	4632      	mov	r2, r6
    b434:	4629      	mov	r1, r5
    b436:	4620      	mov	r0, r4
    b438:	f7f7 fa66 	bl	2908 <arch_new_thread>
			  prio, options);
	/* static threads overwrite it afterwards with real value */
	new_thread->init_data = NULL;
    b43c:	2300      	movs	r3, #0
    b43e:	6563      	str	r3, [r4, #84]	; 0x54
	new_thread->fn_abort = NULL;
    b440:	65a3      	str	r3, [r4, #88]	; 0x58
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
    b442:	4b05      	ldr	r3, [pc, #20]	; (b458 <z_setup_new_thread+0x64>)
    b444:	689b      	ldr	r3, [r3, #8]
    b446:	b123      	cbz	r3, b452 <z_setup_new_thread+0x5e>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
    b448:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    b44a:	66a3      	str	r3, [r4, #104]	; 0x68
	sys_trace_thread_create(new_thread);
}
    b44c:	b007      	add	sp, #28
    b44e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		new_thread->resource_pool = NULL;
    b452:	66a3      	str	r3, [r4, #104]	; 0x68
		return;
    b454:	e7fa      	b.n	b44c <z_setup_new_thread+0x58>
    b456:	bf00      	nop
    b458:	20005874 	.word	0x20005874

0000b45c <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
    b45c:	b5f0      	push	{r4, r5, r6, r7, lr}
    b45e:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
    b460:	4c1f      	ldr	r4, [pc, #124]	; (b4e0 <z_init_static_threads+0x84>)
    b462:	4b20      	ldr	r3, [pc, #128]	; (b4e4 <z_init_static_threads+0x88>)
    b464:	429c      	cmp	r4, r3
    b466:	d215      	bcs.n	b494 <z_init_static_threads+0x38>
		z_setup_new_thread(
    b468:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    b46a:	9305      	str	r3, [sp, #20]
    b46c:	6a23      	ldr	r3, [r4, #32]
    b46e:	9304      	str	r3, [sp, #16]
    b470:	69e3      	ldr	r3, [r4, #28]
    b472:	9303      	str	r3, [sp, #12]
    b474:	69a3      	ldr	r3, [r4, #24]
    b476:	9302      	str	r3, [sp, #8]
    b478:	6963      	ldr	r3, [r4, #20]
    b47a:	9301      	str	r3, [sp, #4]
    b47c:	6923      	ldr	r3, [r4, #16]
    b47e:	9300      	str	r3, [sp, #0]
    b480:	68e3      	ldr	r3, [r4, #12]
    b482:	68a2      	ldr	r2, [r4, #8]
    b484:	6861      	ldr	r1, [r4, #4]
    b486:	6820      	ldr	r0, [r4, #0]
    b488:	f7ff ffb4 	bl	b3f4 <z_setup_new_thread>
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options,
			thread_data->init_name);

		thread_data->init_thread->init_data = thread_data;
    b48c:	6823      	ldr	r3, [r4, #0]
    b48e:	655c      	str	r4, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
    b490:	3430      	adds	r4, #48	; 0x30
    b492:	e7e6      	b.n	b462 <z_init_static_threads+0x6>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
    b494:	f7ff fbbc 	bl	ac10 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    b498:	4c11      	ldr	r4, [pc, #68]	; (b4e0 <z_init_static_threads+0x84>)
    b49a:	e015      	b.n	b4c8 <z_init_static_threads+0x6c>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
			schedule_new_thread(thread_data->init_thread,
    b49c:	6827      	ldr	r7, [r4, #0]
					    K_MSEC(thread_data->init_delay));
    b49e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 * @return The converted time value
 */
static TIME_CONSTEXPR inline u32_t k_ms_to_ticks_ceil32(u32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
    b4a2:	2500      	movs	r5, #0
			return (u32_t)((t * to_hz + off) / from_hz);
    b4a4:	0c59      	lsrs	r1, r3, #17
    b4a6:	03d8      	lsls	r0, r3, #15
    b4a8:	f240 36e7 	movw	r6, #999	; 0x3e7
    b4ac:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    b4b0:	2300      	movs	r3, #0
    b4b2:	1980      	adds	r0, r0, r6
    b4b4:	eb45 0101 	adc.w	r1, r5, r1
    b4b8:	f7f4 ffa6 	bl	408 <__aeabi_uldivmod>
    b4bc:	4602      	mov	r2, r0
			schedule_new_thread(thread_data->init_thread,
    b4be:	462b      	mov	r3, r5
    b4c0:	4638      	mov	r0, r7
    b4c2:	f7ff ff85 	bl	b3d0 <schedule_new_thread>
	_FOREACH_STATIC_THREAD(thread_data) {
    b4c6:	3430      	adds	r4, #48	; 0x30
    b4c8:	4b06      	ldr	r3, [pc, #24]	; (b4e4 <z_init_static_threads+0x88>)
    b4ca:	429c      	cmp	r4, r3
    b4cc:	d204      	bcs.n	b4d8 <z_init_static_threads+0x7c>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    b4ce:	6a63      	ldr	r3, [r4, #36]	; 0x24
    b4d0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    b4d4:	d0f7      	beq.n	b4c6 <z_init_static_threads+0x6a>
    b4d6:	e7e1      	b.n	b49c <z_init_static_threads+0x40>
		}
	}
	k_sched_unlock();
    b4d8:	f7ff fbf4 	bl	acc4 <k_sched_unlock>
}
    b4dc:	b007      	add	sp, #28
    b4de:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b4e0:	2000043c 	.word	0x2000043c
    b4e4:	2000043c 	.word	0x2000043c

0000b4e8 <k_work_q_start>:

extern void z_work_q_main(void *work_q_ptr, void *p2, void *p3);

void k_work_q_start(struct k_work_q *work_q, k_thread_stack_t *stack,
		    size_t stack_size, int prio)
{
    b4e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b4ec:	b088      	sub	sp, #32
    b4ee:	4604      	mov	r4, r0
    b4f0:	460d      	mov	r5, r1
    b4f2:	4616      	mov	r6, r2
    b4f4:	461f      	mov	r7, r3
	z_impl_k_queue_init(queue);
    b4f6:	f004 fcf5 	bl	fee4 <z_impl_k_queue_init>
	k_queue_init(&work_q->queue);
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
    b4fa:	f104 0818 	add.w	r8, r4, #24
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    b4fe:	2200      	movs	r2, #0
    b500:	2300      	movs	r3, #0
    b502:	e9cd 2306 	strd	r2, r3, [sp, #24]
    b506:	9204      	str	r2, [sp, #16]
    b508:	9703      	str	r7, [sp, #12]
    b50a:	9202      	str	r2, [sp, #8]
    b50c:	9201      	str	r2, [sp, #4]
    b50e:	9400      	str	r4, [sp, #0]
    b510:	4b06      	ldr	r3, [pc, #24]	; (b52c <k_work_q_start+0x44>)
    b512:	4632      	mov	r2, r6
    b514:	4629      	mov	r1, r5
    b516:	4640      	mov	r0, r8
    b518:	f004 fee9 	bl	102ee <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    b51c:	4904      	ldr	r1, [pc, #16]	; (b530 <k_work_q_start+0x48>)
    b51e:	4640      	mov	r0, r8
    b520:	f004 fed4 	bl	102cc <z_impl_k_thread_name_set>
			work_q, NULL, NULL, prio, 0, K_NO_WAIT);

	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}
    b524:	b008      	add	sp, #32
    b526:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b52a:	bf00      	nop
    b52c:	0000d0a5 	.word	0x0000d0a5
    b530:	000130c4 	.word	0x000130c4

0000b534 <first>:
	return list->head == list;
    b534:	4b03      	ldr	r3, [pc, #12]	; (b544 <first+0x10>)
    b536:	6818      	ldr	r0, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    b538:	4298      	cmp	r0, r3
    b53a:	d000      	beq.n	b53e <first+0xa>
static struct _timeout *first(void)
{
	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);

	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
}
    b53c:	4770      	bx	lr
    b53e:	2000      	movs	r0, #0
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
    b540:	e7fc      	b.n	b53c <first+0x8>
    b542:	bf00      	nop
    b544:	20000360 	.word	0x20000360

0000b548 <next>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    b548:	b130      	cbz	r0, b558 <next+0x10>
	return (node == list->tail) ? NULL : node->next;
    b54a:	4a04      	ldr	r2, [pc, #16]	; (b55c <next+0x14>)
    b54c:	6852      	ldr	r2, [r2, #4]
    b54e:	4290      	cmp	r0, r2
    b550:	d001      	beq.n	b556 <next+0xe>
    b552:	6800      	ldr	r0, [r0, #0]
    b554:	4770      	bx	lr
    b556:	2000      	movs	r0, #0
static struct _timeout *next(struct _timeout *t)
{
	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);

	return n == NULL ? NULL : CONTAINER_OF(n, struct _timeout, node);
}
    b558:	4770      	bx	lr
    b55a:	bf00      	nop
    b55c:	20000360 	.word	0x20000360

0000b560 <elapsed>:

	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
    b560:	b508      	push	{r3, lr}
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
    b562:	4b04      	ldr	r3, [pc, #16]	; (b574 <elapsed+0x14>)
    b564:	681b      	ldr	r3, [r3, #0]
    b566:	b10b      	cbz	r3, b56c <elapsed+0xc>
    b568:	2000      	movs	r0, #0
}
    b56a:	bd08      	pop	{r3, pc}
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
    b56c:	f7f7 f856 	bl	261c <z_clock_elapsed>
    b570:	e7fb      	b.n	b56a <elapsed+0xa>
    b572:	bf00      	nop
    b574:	2000593c 	.word	0x2000593c

0000b578 <next_timeout>:

static s32_t next_timeout(void)
{
    b578:	b510      	push	{r4, lr}
	struct _timeout *to = first();
    b57a:	f7ff ffdb 	bl	b534 <first>
    b57e:	4604      	mov	r4, r0
	s32_t ticks_elapsed = elapsed();
    b580:	f7ff ffee 	bl	b560 <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
    b584:	b154      	cbz	r4, b59c <next_timeout+0x24>
    b586:	68a3      	ldr	r3, [r4, #8]
    b588:	1a18      	subs	r0, r3, r0
    b58a:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    b58e:	4b05      	ldr	r3, [pc, #20]	; (b5a4 <next_timeout+0x2c>)
    b590:	691b      	ldr	r3, [r3, #16]
    b592:	b113      	cbz	r3, b59a <next_timeout+0x22>
    b594:	4283      	cmp	r3, r0
    b596:	da00      	bge.n	b59a <next_timeout+0x22>
		ret = _current_cpu->slice_ticks;
    b598:	4618      	mov	r0, r3
	}
#endif
	return ret;
}
    b59a:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
    b59c:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    b5a0:	e7f5      	b.n	b58e <next_timeout+0x16>
    b5a2:	bf00      	nop
    b5a4:	20005874 	.word	0x20005874

0000b5a8 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
    b5a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    b5ac:	4604      	mov	r4, r0
    b5ae:	460d      	mov	r5, r1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    b5b0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    b5b4:	bf08      	it	eq
    b5b6:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
    b5ba:	d066      	beq.n	b68a <z_add_timeout+0xe2>
	}

#ifdef CONFIG_LEGACY_TIMEOUT_API
	k_ticks_t ticks = timeout;
#else
	k_ticks_t ticks = timeout.ticks + 1;
    b5bc:	f112 0801 	adds.w	r8, r2, #1
    b5c0:	f143 0900 	adc.w	r9, r3, #0

	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
    b5c4:	f06f 0301 	mvn.w	r3, #1
    b5c8:	ebb3 0608 	subs.w	r6, r3, r8
    b5cc:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
    b5d0:	eb6a 0709 	sbc.w	r7, sl, r9
    b5d4:	2e00      	cmp	r6, #0
    b5d6:	f177 0300 	sbcs.w	r3, r7, #0
    b5da:	da10      	bge.n	b5fe <z_add_timeout+0x56>
		ticks = Z_TICK_ABS(ticks) - (curr_tick + elapsed());
	}
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    b5dc:	60e5      	str	r5, [r4, #12]
	ticks = MAX(1, ticks);
    b5de:	4646      	mov	r6, r8
    b5e0:	f1b8 0f01 	cmp.w	r8, #1
    b5e4:	f179 0300 	sbcs.w	r3, r9, #0
    b5e8:	db1c      	blt.n	b624 <z_add_timeout+0x7c>

	LOCKED(&timeout_lock) {
    b5ea:	2300      	movs	r3, #0
	__asm__ volatile(
    b5ec:	f04f 0220 	mov.w	r2, #32
    b5f0:	f3ef 8511 	mrs	r5, BASEPRI
    b5f4:	f382 8811 	msr	BASEPRI, r2
    b5f8:	f3bf 8f6f 	isb	sy
    b5fc:	e026      	b.n	b64c <z_add_timeout+0xa4>
		ticks = Z_TICK_ABS(ticks) - (curr_tick + elapsed());
    b5fe:	f7ff ffaf 	bl	b560 <elapsed>
    b602:	4b23      	ldr	r3, [pc, #140]	; (b690 <z_add_timeout+0xe8>)
    b604:	e9d3 2300 	ldrd	r2, r3, [r3]
    b608:	1812      	adds	r2, r2, r0
    b60a:	eb43 73e0 	adc.w	r3, r3, r0, asr #31
    b60e:	eb18 0202 	adds.w	r2, r8, r2
    b612:	eb49 0103 	adc.w	r1, r9, r3
    b616:	f06f 0301 	mvn.w	r3, #1
    b61a:	ebb3 0802 	subs.w	r8, r3, r2
    b61e:	eb6a 0901 	sbc.w	r9, sl, r1
    b622:	e7db      	b.n	b5dc <z_add_timeout+0x34>
	ticks = MAX(1, ticks);
    b624:	2601      	movs	r6, #1
    b626:	e7e0      	b.n	b5ea <z_add_timeout+0x42>
		to->dticks = ticks + elapsed();
		for (t = first(); t != NULL; t = next(t)) {
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
    b628:	1ad3      	subs	r3, r2, r3
    b62a:	6083      	str	r3, [r0, #8]
	node->prev = successor->prev;
    b62c:	6843      	ldr	r3, [r0, #4]
    b62e:	6063      	str	r3, [r4, #4]
	node->next = successor;
    b630:	6020      	str	r0, [r4, #0]
	successor->prev->next = node;
    b632:	6843      	ldr	r3, [r0, #4]
    b634:	601c      	str	r4, [r3, #0]
	successor->prev = node;
    b636:	6044      	str	r4, [r0, #4]
				break;
			}
			to->dticks -= t->dticks;
		}

		if (t == NULL) {
    b638:	b1d0      	cbz	r0, b670 <z_add_timeout+0xc8>
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    b63a:	f7ff ff7b 	bl	b534 <first>
    b63e:	4284      	cmp	r4, r0
    b640:	d01d      	beq.n	b67e <z_add_timeout+0xd6>
	__asm__ volatile(
    b642:	f385 8811 	msr	BASEPRI, r5
    b646:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    b64a:	2301      	movs	r3, #1
    b64c:	b9eb      	cbnz	r3, b68a <z_add_timeout+0xe2>
		to->dticks = ticks + elapsed();
    b64e:	f7ff ff87 	bl	b560 <elapsed>
    b652:	4430      	add	r0, r6
    b654:	60a0      	str	r0, [r4, #8]
		for (t = first(); t != NULL; t = next(t)) {
    b656:	f7ff ff6d 	bl	b534 <first>
    b65a:	2800      	cmp	r0, #0
    b65c:	d0ec      	beq.n	b638 <z_add_timeout+0x90>
			if (t->dticks > to->dticks) {
    b65e:	6882      	ldr	r2, [r0, #8]
    b660:	68a3      	ldr	r3, [r4, #8]
    b662:	429a      	cmp	r2, r3
    b664:	dce0      	bgt.n	b628 <z_add_timeout+0x80>
			to->dticks -= t->dticks;
    b666:	1a9b      	subs	r3, r3, r2
    b668:	60a3      	str	r3, [r4, #8]
		for (t = first(); t != NULL; t = next(t)) {
    b66a:	f7ff ff6d 	bl	b548 <next>
    b66e:	e7f4      	b.n	b65a <z_add_timeout+0xb2>
	node->next = list;
    b670:	4b08      	ldr	r3, [pc, #32]	; (b694 <z_add_timeout+0xec>)
    b672:	6023      	str	r3, [r4, #0]
	node->prev = list->tail;
    b674:	685a      	ldr	r2, [r3, #4]
    b676:	6062      	str	r2, [r4, #4]
	list->tail->next = node;
    b678:	6014      	str	r4, [r2, #0]
	list->tail = node;
    b67a:	605c      	str	r4, [r3, #4]
}
    b67c:	e7dd      	b.n	b63a <z_add_timeout+0x92>
			z_clock_set_timeout(next_timeout(), false);
    b67e:	f7ff ff7b 	bl	b578 <next_timeout>
    b682:	2100      	movs	r1, #0
    b684:	f7f6 ff9c 	bl	25c0 <z_clock_set_timeout>
    b688:	e7db      	b.n	b642 <z_add_timeout+0x9a>
		}
	}
}
    b68a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b68e:	bf00      	nop
    b690:	200005a8 	.word	0x200005a8
    b694:	20000360 	.word	0x20000360

0000b698 <z_clock_announce>:
		}
	}
}

void z_clock_announce(s32_t ticks)
{
    b698:	b570      	push	{r4, r5, r6, lr}
    b69a:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    b69c:	f7ff fbe6 	bl	ae6c <z_time_slice>
	__asm__ volatile(
    b6a0:	f04f 0320 	mov.w	r3, #32
    b6a4:	f3ef 8511 	mrs	r5, BASEPRI
    b6a8:	f383 8811 	msr	BASEPRI, r3
    b6ac:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    b6b0:	4b23      	ldr	r3, [pc, #140]	; (b740 <z_clock_announce+0xa8>)
    b6b2:	601c      	str	r4, [r3, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
    b6b4:	f7ff ff3e 	bl	b534 <first>
    b6b8:	4604      	mov	r4, r0
    b6ba:	b320      	cbz	r0, b706 <z_clock_announce+0x6e>
    b6bc:	6882      	ldr	r2, [r0, #8]
    b6be:	4b20      	ldr	r3, [pc, #128]	; (b740 <z_clock_announce+0xa8>)
    b6c0:	681b      	ldr	r3, [r3, #0]
    b6c2:	429a      	cmp	r2, r3
    b6c4:	dc1f      	bgt.n	b706 <z_clock_announce+0x6e>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
    b6c6:	4e1f      	ldr	r6, [pc, #124]	; (b744 <z_clock_announce+0xac>)
    b6c8:	e9d6 0100 	ldrd	r0, r1, [r6]
    b6cc:	1880      	adds	r0, r0, r2
    b6ce:	eb41 71e2 	adc.w	r1, r1, r2, asr #31
    b6d2:	e9c6 0100 	strd	r0, r1, [r6]
		announce_remaining -= dt;
    b6d6:	1a9b      	subs	r3, r3, r2
    b6d8:	4a19      	ldr	r2, [pc, #100]	; (b740 <z_clock_announce+0xa8>)
    b6da:	6013      	str	r3, [r2, #0]
		t->dticks = 0;
    b6dc:	2300      	movs	r3, #0
    b6de:	60a3      	str	r3, [r4, #8]
		remove_timeout(t);
    b6e0:	4620      	mov	r0, r4
    b6e2:	f004 fe26 	bl	10332 <remove_timeout>
	__asm__ volatile(
    b6e6:	f385 8811 	msr	BASEPRI, r5
    b6ea:	f3bf 8f6f 	isb	sy

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
    b6ee:	68e3      	ldr	r3, [r4, #12]
    b6f0:	4620      	mov	r0, r4
    b6f2:	4798      	blx	r3
	__asm__ volatile(
    b6f4:	f04f 0320 	mov.w	r3, #32
    b6f8:	f3ef 8511 	mrs	r5, BASEPRI
    b6fc:	f383 8811 	msr	BASEPRI, r3
    b700:	f3bf 8f6f 	isb	sy
    b704:	e7d6      	b.n	b6b4 <z_clock_announce+0x1c>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
    b706:	b124      	cbz	r4, b712 <z_clock_announce+0x7a>
		first()->dticks -= announce_remaining;
    b708:	68a3      	ldr	r3, [r4, #8]
    b70a:	4a0d      	ldr	r2, [pc, #52]	; (b740 <z_clock_announce+0xa8>)
    b70c:	6812      	ldr	r2, [r2, #0]
    b70e:	1a9b      	subs	r3, r3, r2
    b710:	60a3      	str	r3, [r4, #8]
	}

	curr_tick += announce_remaining;
    b712:	480c      	ldr	r0, [pc, #48]	; (b744 <z_clock_announce+0xac>)
    b714:	490a      	ldr	r1, [pc, #40]	; (b740 <z_clock_announce+0xa8>)
    b716:	680c      	ldr	r4, [r1, #0]
    b718:	e9d0 2300 	ldrd	r2, r3, [r0]
    b71c:	1912      	adds	r2, r2, r4
    b71e:	eb43 73e4 	adc.w	r3, r3, r4, asr #31
    b722:	e9c0 2300 	strd	r2, r3, [r0]
	announce_remaining = 0;
    b726:	2400      	movs	r4, #0
    b728:	600c      	str	r4, [r1, #0]

	z_clock_set_timeout(next_timeout(), false);
    b72a:	f7ff ff25 	bl	b578 <next_timeout>
    b72e:	4621      	mov	r1, r4
    b730:	f7f6 ff46 	bl	25c0 <z_clock_set_timeout>
	__asm__ volatile(
    b734:	f385 8811 	msr	BASEPRI, r5
    b738:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
    b73c:	bd70      	pop	{r4, r5, r6, pc}
    b73e:	bf00      	nop
    b740:	2000593c 	.word	0x2000593c
    b744:	200005a8 	.word	0x200005a8

0000b748 <z_tick_get>:

s64_t z_tick_get(void)
{
    b748:	b510      	push	{r4, lr}
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
    b74a:	2100      	movs	r1, #0
	__asm__ volatile(
    b74c:	f04f 0320 	mov.w	r3, #32
    b750:	f3ef 8411 	mrs	r4, BASEPRI
    b754:	f383 8811 	msr	BASEPRI, r3
    b758:	f3bf 8f6f 	isb	sy
	u64_t t = 0U;
    b75c:	2200      	movs	r2, #0
    b75e:	2300      	movs	r3, #0
	LOCKED(&timeout_lock) {
    b760:	b969      	cbnz	r1, b77e <z_tick_get+0x36>
		t = curr_tick + z_clock_elapsed();
    b762:	f7f6 ff5b 	bl	261c <z_clock_elapsed>
    b766:	4b07      	ldr	r3, [pc, #28]	; (b784 <z_tick_get+0x3c>)
    b768:	e9d3 2300 	ldrd	r2, r3, [r3]
    b76c:	1812      	adds	r2, r2, r0
    b76e:	f143 0300 	adc.w	r3, r3, #0
	__asm__ volatile(
    b772:	f384 8811 	msr	BASEPRI, r4
    b776:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    b77a:	2101      	movs	r1, #1
    b77c:	e7f0      	b.n	b760 <z_tick_get+0x18>
	}
	return t;
}
    b77e:	4610      	mov	r0, r2
    b780:	4619      	mov	r1, r3
    b782:	bd10      	pop	{r4, pc}
    b784:	200005a8 	.word	0x200005a8

0000b788 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
    b788:	b510      	push	{r4, lr}
    b78a:	4604      	mov	r4, r0

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
    b78c:	e9d0 2308 	ldrd	r2, r3, [r0, #32]
    b790:	ea52 0103 	orrs.w	r1, r2, r3
    b794:	d005      	beq.n	b7a2 <z_timer_expiration_handler+0x1a>
    b796:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    b79a:	bf08      	it	eq
    b79c:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
    b7a0:	d115      	bne.n	b7ce <z_timer_expiration_handler+0x46>
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
    b7a2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    b7a4:	3301      	adds	r3, #1
    b7a6:	62a3      	str	r3, [r4, #40]	; 0x28

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
    b7a8:	69a3      	ldr	r3, [r4, #24]
    b7aa:	b10b      	cbz	r3, b7b0 <z_timer_expiration_handler+0x28>
		timer->expiry_fn(timer);
    b7ac:	4620      	mov	r0, r4
    b7ae:	4798      	blx	r3
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    b7b0:	f104 0310 	add.w	r3, r4, #16
	return list->head == list;
    b7b4:	6924      	ldr	r4, [r4, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    b7b6:	42a3      	cmp	r3, r4
    b7b8:	d008      	beq.n	b7cc <z_timer_expiration_handler+0x44>
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
    b7ba:	b13c      	cbz	r4, b7cc <z_timer_expiration_handler+0x44>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
    b7bc:	4620      	mov	r0, r4
    b7be:	f004 fc0a 	bl	ffd6 <z_unpend_thread_no_timeout>

	z_ready_thread(thread);
    b7c2:	4620      	mov	r0, r4
    b7c4:	f004 fc71 	bl	100aa <z_ready_thread>
    b7c8:	2300      	movs	r3, #0
    b7ca:	6723      	str	r3, [r4, #112]	; 0x70

	arch_thread_return_value_set(thread, 0);
}
    b7cc:	bd10      	pop	{r4, pc}
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    b7ce:	4902      	ldr	r1, [pc, #8]	; (b7d8 <z_timer_expiration_handler+0x50>)
    b7d0:	f7ff feea 	bl	b5a8 <z_add_timeout>
    b7d4:	e7e5      	b.n	b7a2 <z_timer_expiration_handler+0x1a>
    b7d6:	bf00      	nop
    b7d8:	0000b789 	.word	0x0000b789

0000b7dc <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
    b7dc:	e92d 4df0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, fp, lr}
    b7e0:	b086      	sub	sp, #24
    b7e2:	4605      	mov	r5, r0
    b7e4:	4614      	mov	r4, r2
    b7e6:	4698      	mov	r8, r3
    b7e8:	e9dd 670e 	ldrd	r6, r7, [sp, #56]	; 0x38
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (period.ticks != 0 && Z_TICK_ABS(period.ticks) < 0) {
    b7ec:	ea56 0307 	orrs.w	r3, r6, r7
    b7f0:	d00e      	beq.n	b810 <z_impl_k_timer_start+0x34>
    b7f2:	f06f 0201 	mvn.w	r2, #1
    b7f6:	1b92      	subs	r2, r2, r6
    b7f8:	9200      	str	r2, [sp, #0]
    b7fa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    b7fe:	eb63 0207 	sbc.w	r2, r3, r7
    b802:	9201      	str	r2, [sp, #4]
    b804:	e9dd 2300 	ldrd	r2, r3, [sp]
    b808:	2a00      	cmp	r2, #0
    b80a:	f173 0300 	sbcs.w	r3, r3, #0
    b80e:	db1c      	blt.n	b84a <z_impl_k_timer_start+0x6e>
		period.ticks = MAX(period.ticks - 1, 1);
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
    b810:	f06f 0301 	mvn.w	r3, #1
    b814:	ebb3 0a04 	subs.w	sl, r3, r4
    b818:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    b81c:	eb63 0b08 	sbc.w	fp, r3, r8
    b820:	f1ba 0f00 	cmp.w	sl, #0
    b824:	f17b 0300 	sbcs.w	r3, fp, #0
    b828:	db23      	blt.n	b872 <z_impl_k_timer_start+0x96>
		duration.ticks = MAX(duration.ticks - 1, 0);
	}
#endif

	(void)z_abort_timeout(&timer->timeout);
    b82a:	4628      	mov	r0, r5
    b82c:	f004 fd93 	bl	10356 <z_abort_timeout>
	timer->period = period;
    b830:	e9c5 6708 	strd	r6, r7, [r5, #32]
	timer->status = 0U;
    b834:	2300      	movs	r3, #0
    b836:	62ab      	str	r3, [r5, #40]	; 0x28

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    b838:	4622      	mov	r2, r4
    b83a:	4643      	mov	r3, r8
    b83c:	4915      	ldr	r1, [pc, #84]	; (b894 <z_impl_k_timer_start+0xb8>)
    b83e:	4628      	mov	r0, r5
    b840:	f7ff feb2 	bl	b5a8 <z_add_timeout>
		     duration);
}
    b844:	b006      	add	sp, #24
    b846:	e8bd 8df0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, fp, pc}
		period.ticks = MAX(period.ticks - 1, 1);
    b84a:	f116 33ff 	adds.w	r3, r6, #4294967295	; 0xffffffff
    b84e:	9304      	str	r3, [sp, #16]
    b850:	f147 33ff 	adc.w	r3, r7, #4294967295	; 0xffffffff
    b854:	9305      	str	r3, [sp, #20]
    b856:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    b85a:	4602      	mov	r2, r0
    b85c:	460b      	mov	r3, r1
    b85e:	2801      	cmp	r0, #1
    b860:	f171 0100 	sbcs.w	r1, r1, #0
    b864:	db02      	blt.n	b86c <z_impl_k_timer_start+0x90>
    b866:	4616      	mov	r6, r2
    b868:	461f      	mov	r7, r3
    b86a:	e7d1      	b.n	b810 <z_impl_k_timer_start+0x34>
    b86c:	2201      	movs	r2, #1
    b86e:	2300      	movs	r3, #0
    b870:	e7f9      	b.n	b866 <z_impl_k_timer_start+0x8a>
		duration.ticks = MAX(duration.ticks - 1, 0);
    b872:	f114 33ff 	adds.w	r3, r4, #4294967295	; 0xffffffff
    b876:	9302      	str	r3, [sp, #8]
    b878:	f148 33ff 	adc.w	r3, r8, #4294967295	; 0xffffffff
    b87c:	9303      	str	r3, [sp, #12]
    b87e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    b882:	4614      	mov	r4, r2
    b884:	4698      	mov	r8, r3
    b886:	2a00      	cmp	r2, #0
    b888:	f173 0300 	sbcs.w	r3, r3, #0
    b88c:	dacd      	bge.n	b82a <z_impl_k_timer_start+0x4e>
    b88e:	2400      	movs	r4, #0
    b890:	46a0      	mov	r8, r4
    b892:	e7ca      	b.n	b82a <z_impl_k_timer_start+0x4e>
    b894:	0000b789 	.word	0x0000b789

0000b898 <z_impl_k_poll>:
	return 0;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events,
		  k_timeout_t timeout)
{
    b898:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b89c:	b08f      	sub	sp, #60	; 0x3c
    b89e:	4605      	mov	r5, r0
    b8a0:	9106      	str	r1, [sp, #24]
    b8a2:	4690      	mov	r8, r2
    b8a4:	4699      	mov	r9, r3
	int events_registered;
	k_spinlock_key_t key;
	struct _poller poller = { .is_polling = true,
    b8a6:	2301      	movs	r3, #1
    b8a8:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
				  .thread     = _current,
    b8ac:	4b9d      	ldr	r3, [pc, #628]	; (bb24 <z_impl_k_poll+0x28c>)
    b8ae:	689b      	ldr	r3, [r3, #8]
	struct _poller poller = { .is_polling = true,
    b8b0:	930c      	str	r3, [sp, #48]	; 0x30
    b8b2:	4b9d      	ldr	r3, [pc, #628]	; (bb28 <z_impl_k_poll+0x290>)
    b8b4:	930d      	str	r3, [sp, #52]	; 0x34

	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(events != NULL, "NULL events\n");
	__ASSERT(num_events >= 0, "<0 events\n");

	events_registered = register_events(events, num_events, &poller,
    b8b6:	ea59 0302 	orrs.w	r3, r9, r2
    b8ba:	bf0c      	ite	eq
    b8bc:	2301      	moveq	r3, #1
    b8be:	2300      	movne	r3, #0
    b8c0:	9303      	str	r3, [sp, #12]
	for (int ii = 0; ii < num_events; ii++) {
    b8c2:	2700      	movs	r7, #0
	int events_registered = 0;
    b8c4:	463e      	mov	r6, r7
    b8c6:	e9cd 8904 	strd	r8, r9, [sp, #16]
	for (int ii = 0; ii < num_events; ii++) {
    b8ca:	e01e      	b.n	b90a <z_impl_k_poll+0x72>
		if (k_sem_count_get(event->sem) > 0) {
    b8cc:	6923      	ldr	r3, [r4, #16]
/**
 * @internal
 */
static inline unsigned int z_impl_k_sem_count_get(struct k_sem *sem)
{
	return sem->count;
    b8ce:	689b      	ldr	r3, [r3, #8]
    b8d0:	2b00      	cmp	r3, #0
    b8d2:	d036      	beq.n	b942 <z_impl_k_poll+0xaa>
			*state = K_POLL_STATE_SEM_AVAILABLE;
    b8d4:	2302      	movs	r3, #2
    b8d6:	9302      	str	r3, [sp, #8]
			return true;
    b8d8:	2301      	movs	r3, #1
    b8da:	e032      	b.n	b942 <z_impl_k_poll+0xaa>
		if (!k_queue_is_empty(event->queue)) {
    b8dc:	6923      	ldr	r3, [r4, #16]
	return list->head;
    b8de:	681b      	ldr	r3, [r3, #0]
    b8e0:	b37b      	cbz	r3, b942 <z_impl_k_poll+0xaa>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
    b8e2:	2304      	movs	r3, #4
    b8e4:	9302      	str	r3, [sp, #8]
			return true;
    b8e6:	2301      	movs	r3, #1
    b8e8:	e02b      	b.n	b942 <z_impl_k_poll+0xaa>
		if (event->signal->signaled != 0U) {
    b8ea:	6923      	ldr	r3, [r4, #16]
    b8ec:	689b      	ldr	r3, [r3, #8]
    b8ee:	b343      	cbz	r3, b942 <z_impl_k_poll+0xaa>
			*state = K_POLL_STATE_SIGNALED;
    b8f0:	2301      	movs	r3, #1
    b8f2:	9302      	str	r3, [sp, #8]
    b8f4:	e025      	b.n	b942 <z_impl_k_poll+0xaa>
		} else if (!just_check && poller->is_polling) {
    b8f6:	9b03      	ldr	r3, [sp, #12]
    b8f8:	b913      	cbnz	r3, b900 <z_impl_k_poll+0x68>
    b8fa:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    b8fe:	bb7b      	cbnz	r3, b960 <z_impl_k_poll+0xc8>
    b900:	f38a 8811 	msr	BASEPRI, sl
    b904:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
    b908:	3701      	adds	r7, #1
    b90a:	9b06      	ldr	r3, [sp, #24]
    b90c:	42bb      	cmp	r3, r7
    b90e:	f340 8135 	ble.w	bb7c <z_impl_k_poll+0x2e4>
	__asm__ volatile(
    b912:	f04f 0320 	mov.w	r3, #32
    b916:	f3ef 8a11 	mrs	sl, BASEPRI
    b91a:	f383 8811 	msr	BASEPRI, r3
    b91e:	f3bf 8f6f 	isb	sy
		if (is_condition_met(&events[ii], &state)) {
    b922:	eb07 0487 	add.w	r4, r7, r7, lsl #2
    b926:	ea4f 0984 	mov.w	r9, r4, lsl #2
    b92a:	eb05 0484 	add.w	r4, r5, r4, lsl #2
	switch (event->type) {
    b92e:	7b63      	ldrb	r3, [r4, #13]
    b930:	f003 030f 	and.w	r3, r3, #15
    b934:	2b02      	cmp	r3, #2
    b936:	d0c9      	beq.n	b8cc <z_impl_k_poll+0x34>
    b938:	2b04      	cmp	r3, #4
    b93a:	d0cf      	beq.n	b8dc <z_impl_k_poll+0x44>
    b93c:	2b01      	cmp	r3, #1
    b93e:	d0d4      	beq.n	b8ea <z_impl_k_poll+0x52>
    b940:	2300      	movs	r3, #0
		if (is_condition_met(&events[ii], &state)) {
    b942:	2b00      	cmp	r3, #0
    b944:	d0d7      	beq.n	b8f6 <z_impl_k_poll+0x5e>
	event->poller = NULL;
    b946:	2100      	movs	r1, #0
    b948:	60a1      	str	r1, [r4, #8]
	event->state |= state;
    b94a:	68e3      	ldr	r3, [r4, #12]
    b94c:	f3c3 3204 	ubfx	r2, r3, #12, #5
    b950:	9802      	ldr	r0, [sp, #8]
    b952:	4302      	orrs	r2, r0
    b954:	f362 3310 	bfi	r3, r2, #12, #5
    b958:	60e3      	str	r3, [r4, #12]
			poller->is_polling = false;
    b95a:	f88d 102c 	strb.w	r1, [sp, #44]	; 0x2c
    b95e:	e7cf      	b.n	b900 <z_impl_k_poll+0x68>
	switch (event->type) {
    b960:	7b63      	ldrb	r3, [r4, #13]
    b962:	f003 030f 	and.w	r3, r3, #15
    b966:	2b02      	cmp	r3, #2
    b968:	d008      	beq.n	b97c <z_impl_k_poll+0xe4>
    b96a:	2b04      	cmp	r3, #4
    b96c:	d05d      	beq.n	ba2a <z_impl_k_poll+0x192>
    b96e:	2b01      	cmp	r3, #1
    b970:	f000 80b2 	beq.w	bad8 <z_impl_k_poll+0x240>
	event->poller = poller;
    b974:	ab0b      	add	r3, sp, #44	; 0x2c
    b976:	60a3      	str	r3, [r4, #8]
				events_registered += 1;
    b978:	3601      	adds	r6, #1
    b97a:	e7c1      	b.n	b900 <z_impl_k_poll+0x68>
		add_event(&event->sem->poll_events, event, poller);
    b97c:	f8d4 b010 	ldr.w	fp, [r4, #16]
    b980:	f10b 0210 	add.w	r2, fp, #16
    b984:	9207      	str	r2, [sp, #28]
	return list->head == list;
    b986:	f8db 3010 	ldr.w	r3, [fp, #16]
	return sys_dlist_is_empty(list) ? NULL : list->tail;
    b98a:	429a      	cmp	r2, r3
    b98c:	d023      	beq.n	b9d6 <z_impl_k_poll+0x13e>
    b98e:	f8db 3014 	ldr.w	r3, [fp, #20]
	if ((pending == NULL) ||
    b992:	b303      	cbz	r3, b9d6 <z_impl_k_poll+0x13e>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
    b994:	689b      	ldr	r3, [r3, #8]
    b996:	990c      	ldr	r1, [sp, #48]	; 0x30
    b998:	6858      	ldr	r0, [r3, #4]
    b99a:	f004 fafb 	bl	ff94 <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
    b99e:	b9d0      	cbnz	r0, b9d6 <z_impl_k_poll+0x13e>
	return list->head == list;
    b9a0:	f8db b010 	ldr.w	fp, [fp, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    b9a4:	9b07      	ldr	r3, [sp, #28]
    b9a6:	455b      	cmp	r3, fp
    b9a8:	d02a      	beq.n	ba00 <z_impl_k_poll+0x168>
    b9aa:	f8dd 801c 	ldr.w	r8, [sp, #28]
    b9ae:	465b      	mov	r3, fp
    b9b0:	46a3      	mov	fp, r4
    b9b2:	461c      	mov	r4, r3
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
    b9b4:	b364      	cbz	r4, ba10 <z_impl_k_poll+0x178>
						pending->poller->thread)) {
    b9b6:	68a3      	ldr	r3, [r4, #8]
		if (z_is_t1_higher_prio_than_t2(poller->thread,
    b9b8:	6859      	ldr	r1, [r3, #4]
    b9ba:	980c      	ldr	r0, [sp, #48]	; 0x30
    b9bc:	f004 faea 	bl	ff94 <z_is_t1_higher_prio_than_t2>
    b9c0:	b988      	cbnz	r0, b9e6 <z_impl_k_poll+0x14e>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    b9c2:	b33c      	cbz	r4, ba14 <z_impl_k_poll+0x17c>
	return (node == list->tail) ? NULL : node->next;
    b9c4:	f8d8 3004 	ldr.w	r3, [r8, #4]
    b9c8:	429c      	cmp	r4, r3
    b9ca:	d02c      	beq.n	ba26 <z_impl_k_poll+0x18e>
    b9cc:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
    b9ce:	2c00      	cmp	r4, #0
    b9d0:	d1f0      	bne.n	b9b4 <z_impl_k_poll+0x11c>
    b9d2:	465c      	mov	r4, fp
    b9d4:	e01f      	b.n	ba16 <z_impl_k_poll+0x17e>
	node->next = list;
    b9d6:	9a07      	ldr	r2, [sp, #28]
    b9d8:	f845 2009 	str.w	r2, [r5, r9]
	node->prev = list->tail;
    b9dc:	6853      	ldr	r3, [r2, #4]
    b9de:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
    b9e0:	601c      	str	r4, [r3, #0]
	list->tail = node;
    b9e2:	6054      	str	r4, [r2, #4]
		return;
    b9e4:	e7c6      	b.n	b974 <z_impl_k_poll+0xdc>
    b9e6:	4623      	mov	r3, r4
    b9e8:	465c      	mov	r4, fp
    b9ea:	469b      	mov	fp, r3
	node->prev = successor->prev;
    b9ec:	685b      	ldr	r3, [r3, #4]
    b9ee:	6063      	str	r3, [r4, #4]
	node->next = successor;
    b9f0:	f845 b009 	str.w	fp, [r5, r9]
	successor->prev->next = node;
    b9f4:	f8db 3004 	ldr.w	r3, [fp, #4]
    b9f8:	601c      	str	r4, [r3, #0]
	successor->prev = node;
    b9fa:	f8cb 4004 	str.w	r4, [fp, #4]
			return;
    b9fe:	e7b9      	b.n	b974 <z_impl_k_poll+0xdc>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
    ba00:	f04f 0b00 	mov.w	fp, #0
    ba04:	f8dd 801c 	ldr.w	r8, [sp, #28]
    ba08:	465b      	mov	r3, fp
    ba0a:	46a3      	mov	fp, r4
    ba0c:	461c      	mov	r4, r3
    ba0e:	e7d1      	b.n	b9b4 <z_impl_k_poll+0x11c>
    ba10:	465c      	mov	r4, fp
    ba12:	e000      	b.n	ba16 <z_impl_k_poll+0x17e>
    ba14:	465c      	mov	r4, fp
	node->next = list;
    ba16:	9a07      	ldr	r2, [sp, #28]
    ba18:	f845 2009 	str.w	r2, [r5, r9]
	node->prev = list->tail;
    ba1c:	6853      	ldr	r3, [r2, #4]
    ba1e:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
    ba20:	601c      	str	r4, [r3, #0]
	list->tail = node;
    ba22:	6054      	str	r4, [r2, #4]
}
    ba24:	e7a6      	b.n	b974 <z_impl_k_poll+0xdc>
    ba26:	465c      	mov	r4, fp
    ba28:	e7f5      	b.n	ba16 <z_impl_k_poll+0x17e>
		add_event(&event->queue->poll_events, event, poller);
    ba2a:	f8d4 b010 	ldr.w	fp, [r4, #16]
    ba2e:	f10b 0210 	add.w	r2, fp, #16
    ba32:	9207      	str	r2, [sp, #28]
	return list->head == list;
    ba34:	f8db 3010 	ldr.w	r3, [fp, #16]
	return sys_dlist_is_empty(list) ? NULL : list->tail;
    ba38:	429a      	cmp	r2, r3
    ba3a:	d023      	beq.n	ba84 <z_impl_k_poll+0x1ec>
    ba3c:	f8db 3014 	ldr.w	r3, [fp, #20]
	if ((pending == NULL) ||
    ba40:	b303      	cbz	r3, ba84 <z_impl_k_poll+0x1ec>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
    ba42:	689b      	ldr	r3, [r3, #8]
    ba44:	990c      	ldr	r1, [sp, #48]	; 0x30
    ba46:	6858      	ldr	r0, [r3, #4]
    ba48:	f004 faa4 	bl	ff94 <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
    ba4c:	b9d0      	cbnz	r0, ba84 <z_impl_k_poll+0x1ec>
	return list->head == list;
    ba4e:	f8db b010 	ldr.w	fp, [fp, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    ba52:	9b07      	ldr	r3, [sp, #28]
    ba54:	455b      	cmp	r3, fp
    ba56:	d02a      	beq.n	baae <z_impl_k_poll+0x216>
    ba58:	f8dd 801c 	ldr.w	r8, [sp, #28]
    ba5c:	465b      	mov	r3, fp
    ba5e:	46a3      	mov	fp, r4
    ba60:	461c      	mov	r4, r3
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
    ba62:	b364      	cbz	r4, babe <z_impl_k_poll+0x226>
						pending->poller->thread)) {
    ba64:	68a3      	ldr	r3, [r4, #8]
		if (z_is_t1_higher_prio_than_t2(poller->thread,
    ba66:	6859      	ldr	r1, [r3, #4]
    ba68:	980c      	ldr	r0, [sp, #48]	; 0x30
    ba6a:	f004 fa93 	bl	ff94 <z_is_t1_higher_prio_than_t2>
    ba6e:	b988      	cbnz	r0, ba94 <z_impl_k_poll+0x1fc>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    ba70:	b33c      	cbz	r4, bac2 <z_impl_k_poll+0x22a>
	return (node == list->tail) ? NULL : node->next;
    ba72:	f8d8 3004 	ldr.w	r3, [r8, #4]
    ba76:	429c      	cmp	r4, r3
    ba78:	d02c      	beq.n	bad4 <z_impl_k_poll+0x23c>
    ba7a:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
    ba7c:	2c00      	cmp	r4, #0
    ba7e:	d1f0      	bne.n	ba62 <z_impl_k_poll+0x1ca>
    ba80:	465c      	mov	r4, fp
    ba82:	e01f      	b.n	bac4 <z_impl_k_poll+0x22c>
	node->next = list;
    ba84:	9a07      	ldr	r2, [sp, #28]
    ba86:	f845 2009 	str.w	r2, [r5, r9]
	node->prev = list->tail;
    ba8a:	6853      	ldr	r3, [r2, #4]
    ba8c:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
    ba8e:	601c      	str	r4, [r3, #0]
	list->tail = node;
    ba90:	6054      	str	r4, [r2, #4]
		return;
    ba92:	e76f      	b.n	b974 <z_impl_k_poll+0xdc>
    ba94:	4623      	mov	r3, r4
    ba96:	465c      	mov	r4, fp
    ba98:	469b      	mov	fp, r3
	node->prev = successor->prev;
    ba9a:	685b      	ldr	r3, [r3, #4]
    ba9c:	6063      	str	r3, [r4, #4]
	node->next = successor;
    ba9e:	f845 b009 	str.w	fp, [r5, r9]
	successor->prev->next = node;
    baa2:	f8db 3004 	ldr.w	r3, [fp, #4]
    baa6:	601c      	str	r4, [r3, #0]
	successor->prev = node;
    baa8:	f8cb 4004 	str.w	r4, [fp, #4]
			return;
    baac:	e762      	b.n	b974 <z_impl_k_poll+0xdc>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
    baae:	f04f 0b00 	mov.w	fp, #0
    bab2:	f8dd 801c 	ldr.w	r8, [sp, #28]
    bab6:	465b      	mov	r3, fp
    bab8:	46a3      	mov	fp, r4
    baba:	461c      	mov	r4, r3
    babc:	e7d1      	b.n	ba62 <z_impl_k_poll+0x1ca>
    babe:	465c      	mov	r4, fp
    bac0:	e000      	b.n	bac4 <z_impl_k_poll+0x22c>
    bac2:	465c      	mov	r4, fp
	node->next = list;
    bac4:	9a07      	ldr	r2, [sp, #28]
    bac6:	f845 2009 	str.w	r2, [r5, r9]
	node->prev = list->tail;
    baca:	6853      	ldr	r3, [r2, #4]
    bacc:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
    bace:	601c      	str	r4, [r3, #0]
	list->tail = node;
    bad0:	6054      	str	r4, [r2, #4]
}
    bad2:	e74f      	b.n	b974 <z_impl_k_poll+0xdc>
    bad4:	465c      	mov	r4, fp
    bad6:	e7f5      	b.n	bac4 <z_impl_k_poll+0x22c>
		add_event(&event->signal->poll_events, event, poller);
    bad8:	f8d4 b010 	ldr.w	fp, [r4, #16]
	return list->head == list;
    badc:	f8db 3000 	ldr.w	r3, [fp]
	return sys_dlist_is_empty(list) ? NULL : list->tail;
    bae0:	459b      	cmp	fp, r3
    bae2:	d023      	beq.n	bb2c <z_impl_k_poll+0x294>
    bae4:	f8db 3004 	ldr.w	r3, [fp, #4]
	if ((pending == NULL) ||
    bae8:	b303      	cbz	r3, bb2c <z_impl_k_poll+0x294>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
    baea:	689b      	ldr	r3, [r3, #8]
    baec:	990c      	ldr	r1, [sp, #48]	; 0x30
    baee:	6858      	ldr	r0, [r3, #4]
    baf0:	f004 fa50 	bl	ff94 <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
    baf4:	b9d0      	cbnz	r0, bb2c <z_impl_k_poll+0x294>
	return list->head == list;
    baf6:	f8db 3000 	ldr.w	r3, [fp]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    bafa:	459b      	cmp	fp, r3
    bafc:	d02c      	beq.n	bb58 <z_impl_k_poll+0x2c0>
    bafe:	46a0      	mov	r8, r4
    bb00:	461c      	mov	r4, r3
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
    bb02:	b36c      	cbz	r4, bb60 <z_impl_k_poll+0x2c8>
						pending->poller->thread)) {
    bb04:	68a3      	ldr	r3, [r4, #8]
		if (z_is_t1_higher_prio_than_t2(poller->thread,
    bb06:	6859      	ldr	r1, [r3, #4]
    bb08:	980c      	ldr	r0, [sp, #48]	; 0x30
    bb0a:	f004 fa43 	bl	ff94 <z_is_t1_higher_prio_than_t2>
    bb0e:	b9b0      	cbnz	r0, bb3e <z_impl_k_poll+0x2a6>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    bb10:	b344      	cbz	r4, bb64 <z_impl_k_poll+0x2cc>
	return (node == list->tail) ? NULL : node->next;
    bb12:	f8db 3004 	ldr.w	r3, [fp, #4]
    bb16:	429c      	cmp	r4, r3
    bb18:	d02e      	beq.n	bb78 <z_impl_k_poll+0x2e0>
    bb1a:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
    bb1c:	2c00      	cmp	r4, #0
    bb1e:	d1f0      	bne.n	bb02 <z_impl_k_poll+0x26a>
    bb20:	4644      	mov	r4, r8
    bb22:	e020      	b.n	bb66 <z_impl_k_poll+0x2ce>
    bb24:	20005874 	.word	0x20005874
    bb28:	00010509 	.word	0x00010509
	node->next = list;
    bb2c:	f845 b009 	str.w	fp, [r5, r9]
	node->prev = list->tail;
    bb30:	f8db 3004 	ldr.w	r3, [fp, #4]
    bb34:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
    bb36:	601c      	str	r4, [r3, #0]
	list->tail = node;
    bb38:	f8cb 4004 	str.w	r4, [fp, #4]
		return;
    bb3c:	e71a      	b.n	b974 <z_impl_k_poll+0xdc>
    bb3e:	4622      	mov	r2, r4
    bb40:	4644      	mov	r4, r8
	node->prev = successor->prev;
    bb42:	6853      	ldr	r3, [r2, #4]
    bb44:	f8c8 3004 	str.w	r3, [r8, #4]
	node->next = successor;
    bb48:	f845 2009 	str.w	r2, [r5, r9]
	successor->prev->next = node;
    bb4c:	6853      	ldr	r3, [r2, #4]
    bb4e:	f8c3 8000 	str.w	r8, [r3]
	successor->prev = node;
    bb52:	f8c2 8004 	str.w	r8, [r2, #4]
			return;
    bb56:	e70d      	b.n	b974 <z_impl_k_poll+0xdc>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
    bb58:	2300      	movs	r3, #0
    bb5a:	46a0      	mov	r8, r4
    bb5c:	461c      	mov	r4, r3
    bb5e:	e7d0      	b.n	bb02 <z_impl_k_poll+0x26a>
    bb60:	4644      	mov	r4, r8
    bb62:	e000      	b.n	bb66 <z_impl_k_poll+0x2ce>
    bb64:	4644      	mov	r4, r8
	node->next = list;
    bb66:	f845 b009 	str.w	fp, [r5, r9]
	node->prev = list->tail;
    bb6a:	f8db 3004 	ldr.w	r3, [fp, #4]
    bb6e:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
    bb70:	601c      	str	r4, [r3, #0]
	list->tail = node;
    bb72:	f8cb 4004 	str.w	r4, [fp, #4]
}
    bb76:	e6fd      	b.n	b974 <z_impl_k_poll+0xdc>
    bb78:	4644      	mov	r4, r8
    bb7a:	e7f4      	b.n	bb66 <z_impl_k_poll+0x2ce>
    bb7c:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
    bb80:	f04f 0320 	mov.w	r3, #32
    bb84:	f3ef 8111 	mrs	r1, BASEPRI
    bb88:	f383 8811 	msr	BASEPRI, r3
    bb8c:	f3bf 8f6f 	isb	sy
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller.is_polling) {
    bb90:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    bb94:	b1bb      	cbz	r3, bbc6 <z_impl_k_poll+0x32e>
		clear_event_registrations(events, events_registered, key);
		k_spin_unlock(&lock, key);
		return 0;
	}

	poller.is_polling = false;
    bb96:	2300      	movs	r3, #0
    bb98:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    bb9c:	ea58 0309 	orrs.w	r3, r8, r9
    bba0:	d045      	beq.n	bc2e <z_impl_k_poll+0x396>
		k_spin_unlock(&lock, key);
		return -EAGAIN;
	}

	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
    bba2:	aa09      	add	r2, sp, #36	; 0x24
    bba4:	9209      	str	r2, [sp, #36]	; 0x24
    bba6:	920a      	str	r2, [sp, #40]	; 0x28

	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
    bba8:	e9cd 8900 	strd	r8, r9, [sp]
    bbac:	483e      	ldr	r0, [pc, #248]	; (bca8 <z_impl_k_poll+0x410>)
    bbae:	f7ff fa65 	bl	b07c <z_pend_curr>
    bbb2:	f04f 0320 	mov.w	r3, #32
    bbb6:	f3ef 8711 	mrs	r7, BASEPRI
    bbba:	f383 8811 	msr	BASEPRI, r3
    bbbe:	f3bf 8f6f 	isb	sy
    bbc2:	4639      	mov	r1, r7
	while (num_events--) {
    bbc4:	e049      	b.n	bc5a <z_impl_k_poll+0x3c2>
		clear_event_registrations(events, events_registered, key);
    bbc6:	460c      	mov	r4, r1
	while (num_events--) {
    bbc8:	e00e      	b.n	bbe8 <z_impl_k_poll+0x350>
	switch (event->type) {
    bbca:	b240      	sxtb	r0, r0
    bbcc:	b9f0      	cbnz	r0, bc0c <z_impl_k_poll+0x374>
	__asm__ volatile(
    bbce:	f384 8811 	msr	BASEPRI, r4
    bbd2:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
    bbd6:	f04f 0320 	mov.w	r3, #32
    bbda:	f3ef 8411 	mrs	r4, BASEPRI
    bbde:	f383 8811 	msr	BASEPRI, r3
    bbe2:	f3bf 8f6f 	isb	sy
	while (num_events--) {
    bbe6:	463e      	mov	r6, r7
    bbe8:	1e77      	subs	r7, r6, #1
    bbea:	b1d6      	cbz	r6, bc22 <z_impl_k_poll+0x38a>
		clear_event_registration(&events[num_events]);
    bbec:	eb07 0387 	add.w	r3, r7, r7, lsl #2
    bbf0:	009e      	lsls	r6, r3, #2
    bbf2:	eb05 0383 	add.w	r3, r5, r3, lsl #2
	event->poller = NULL;
    bbf6:	2200      	movs	r2, #0
    bbf8:	609a      	str	r2, [r3, #8]
	switch (event->type) {
    bbfa:	7b5a      	ldrb	r2, [r3, #13]
    bbfc:	f3c2 0003 	ubfx	r0, r2, #0, #4
    bc00:	f002 020f 	and.w	r2, r2, #15
    bc04:	2a02      	cmp	r2, #2
    bc06:	d9e0      	bls.n	bbca <z_impl_k_poll+0x332>
    bc08:	2a04      	cmp	r2, #4
    bc0a:	d1e0      	bne.n	bbce <z_impl_k_poll+0x336>
	return node->next != NULL;
    bc0c:	59aa      	ldr	r2, [r5, r6]
	if (remove && sys_dnode_is_linked(&event->_node)) {
    bc0e:	2a00      	cmp	r2, #0
    bc10:	d0dd      	beq.n	bbce <z_impl_k_poll+0x336>
	node->prev->next = node->next;
    bc12:	6858      	ldr	r0, [r3, #4]
    bc14:	6002      	str	r2, [r0, #0]
	node->next->prev = node->prev;
    bc16:	6858      	ldr	r0, [r3, #4]
    bc18:	6050      	str	r0, [r2, #4]
	node->next = NULL;
    bc1a:	2200      	movs	r2, #0
    bc1c:	51aa      	str	r2, [r5, r6]
	node->prev = NULL;
    bc1e:	605a      	str	r2, [r3, #4]
	sys_dnode_init(node);
}
    bc20:	e7d5      	b.n	bbce <z_impl_k_poll+0x336>
	__asm__ volatile(
    bc22:	f381 8811 	msr	BASEPRI, r1
    bc26:	f3bf 8f6f 	isb	sy
		return 0;
    bc2a:	4630      	mov	r0, r6
    bc2c:	e039      	b.n	bca2 <z_impl_k_poll+0x40a>
    bc2e:	f381 8811 	msr	BASEPRI, r1
    bc32:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
    bc36:	f06f 000a 	mvn.w	r0, #10
    bc3a:	e032      	b.n	bca2 <z_impl_k_poll+0x40a>
	switch (event->type) {
    bc3c:	b276      	sxtb	r6, r6
    bc3e:	b9fe      	cbnz	r6, bc80 <z_impl_k_poll+0x3e8>
    bc40:	f381 8811 	msr	BASEPRI, r1
    bc44:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
    bc48:	f04f 0320 	mov.w	r3, #32
    bc4c:	f3ef 8111 	mrs	r1, BASEPRI
    bc50:	f383 8811 	msr	BASEPRI, r3
    bc54:	f3bf 8f6f 	isb	sy
	while (num_events--) {
    bc58:	4626      	mov	r6, r4
    bc5a:	1e74      	subs	r4, r6, #1
    bc5c:	b1ee      	cbz	r6, bc9a <z_impl_k_poll+0x402>
		clear_event_registration(&events[num_events]);
    bc5e:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    bc62:	ea4f 0c83 	mov.w	ip, r3, lsl #2
    bc66:	eb05 0383 	add.w	r3, r5, r3, lsl #2
	event->poller = NULL;
    bc6a:	2200      	movs	r2, #0
    bc6c:	609a      	str	r2, [r3, #8]
	switch (event->type) {
    bc6e:	7b5a      	ldrb	r2, [r3, #13]
    bc70:	f3c2 0603 	ubfx	r6, r2, #0, #4
    bc74:	f002 020f 	and.w	r2, r2, #15
    bc78:	2a02      	cmp	r2, #2
    bc7a:	d9df      	bls.n	bc3c <z_impl_k_poll+0x3a4>
    bc7c:	2a04      	cmp	r2, #4
    bc7e:	d1df      	bne.n	bc40 <z_impl_k_poll+0x3a8>
	return node->next != NULL;
    bc80:	f855 200c 	ldr.w	r2, [r5, ip]
	if (remove && sys_dnode_is_linked(&event->_node)) {
    bc84:	2a00      	cmp	r2, #0
    bc86:	d0db      	beq.n	bc40 <z_impl_k_poll+0x3a8>
	node->prev->next = node->next;
    bc88:	685e      	ldr	r6, [r3, #4]
    bc8a:	6032      	str	r2, [r6, #0]
	node->next->prev = node->prev;
    bc8c:	685e      	ldr	r6, [r3, #4]
    bc8e:	6056      	str	r6, [r2, #4]
	node->next = NULL;
    bc90:	2200      	movs	r2, #0
    bc92:	f845 200c 	str.w	r2, [r5, ip]
	node->prev = NULL;
    bc96:	605a      	str	r2, [r3, #4]
}
    bc98:	e7d2      	b.n	bc40 <z_impl_k_poll+0x3a8>
	__asm__ volatile(
    bc9a:	f387 8811 	msr	BASEPRI, r7
    bc9e:	f3bf 8f6f 	isb	sy
	key = k_spin_lock(&lock);
	clear_event_registrations(events, events_registered, key);
	k_spin_unlock(&lock, key);

	return swap_rc;
}
    bca2:	b00f      	add	sp, #60	; 0x3c
    bca4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bca8:	20005940 	.word	0x20005940

0000bcac <__assert_func>:
    bcac:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    bcae:	4614      	mov	r4, r2
    bcb0:	461a      	mov	r2, r3
    bcb2:	4b09      	ldr	r3, [pc, #36]	; (bcd8 <__assert_func+0x2c>)
    bcb4:	681b      	ldr	r3, [r3, #0]
    bcb6:	4605      	mov	r5, r0
    bcb8:	68d8      	ldr	r0, [r3, #12]
    bcba:	b14c      	cbz	r4, bcd0 <__assert_func+0x24>
    bcbc:	4b07      	ldr	r3, [pc, #28]	; (bcdc <__assert_func+0x30>)
    bcbe:	9100      	str	r1, [sp, #0]
    bcc0:	e9cd 3401 	strd	r3, r4, [sp, #4]
    bcc4:	4906      	ldr	r1, [pc, #24]	; (bce0 <__assert_func+0x34>)
    bcc6:	462b      	mov	r3, r5
    bcc8:	f000 f80e 	bl	bce8 <fiprintf>
    bccc:	f004 fd26 	bl	1071c <abort>
    bcd0:	4b04      	ldr	r3, [pc, #16]	; (bce4 <__assert_func+0x38>)
    bcd2:	461c      	mov	r4, r3
    bcd4:	e7f3      	b.n	bcbe <__assert_func+0x12>
    bcd6:	bf00      	nop
    bcd8:	20000368 	.word	0x20000368
    bcdc:	00013134 	.word	0x00013134
    bce0:	00013141 	.word	0x00013141
    bce4:	0001316f 	.word	0x0001316f

0000bce8 <fiprintf>:
    bce8:	b40e      	push	{r1, r2, r3}
    bcea:	b503      	push	{r0, r1, lr}
    bcec:	4601      	mov	r1, r0
    bcee:	ab03      	add	r3, sp, #12
    bcf0:	4805      	ldr	r0, [pc, #20]	; (bd08 <fiprintf+0x20>)
    bcf2:	f853 2b04 	ldr.w	r2, [r3], #4
    bcf6:	6800      	ldr	r0, [r0, #0]
    bcf8:	9301      	str	r3, [sp, #4]
    bcfa:	f000 f807 	bl	bd0c <_vfiprintf_r>
    bcfe:	b002      	add	sp, #8
    bd00:	f85d eb04 	ldr.w	lr, [sp], #4
    bd04:	b003      	add	sp, #12
    bd06:	4770      	bx	lr
    bd08:	20000368 	.word	0x20000368

0000bd0c <_vfiprintf_r>:
    bd0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bd10:	460d      	mov	r5, r1
    bd12:	b09d      	sub	sp, #116	; 0x74
    bd14:	4614      	mov	r4, r2
    bd16:	4698      	mov	r8, r3
    bd18:	4606      	mov	r6, r0
    bd1a:	b118      	cbz	r0, bd24 <_vfiprintf_r+0x18>
    bd1c:	6983      	ldr	r3, [r0, #24]
    bd1e:	b90b      	cbnz	r3, bd24 <_vfiprintf_r+0x18>
    bd20:	f000 fbf2 	bl	c508 <__sinit>
    bd24:	4b7c      	ldr	r3, [pc, #496]	; (bf18 <_vfiprintf_r+0x20c>)
    bd26:	429d      	cmp	r5, r3
    bd28:	d161      	bne.n	bdee <_vfiprintf_r+0xe2>
    bd2a:	6875      	ldr	r5, [r6, #4]
    bd2c:	89ab      	ldrh	r3, [r5, #12]
    bd2e:	071b      	lsls	r3, r3, #28
    bd30:	d567      	bpl.n	be02 <_vfiprintf_r+0xf6>
    bd32:	692b      	ldr	r3, [r5, #16]
    bd34:	2b00      	cmp	r3, #0
    bd36:	d064      	beq.n	be02 <_vfiprintf_r+0xf6>
    bd38:	2300      	movs	r3, #0
    bd3a:	9309      	str	r3, [sp, #36]	; 0x24
    bd3c:	2320      	movs	r3, #32
    bd3e:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    bd42:	f8cd 800c 	str.w	r8, [sp, #12]
    bd46:	2330      	movs	r3, #48	; 0x30
    bd48:	f8df 81d0 	ldr.w	r8, [pc, #464]	; bf1c <_vfiprintf_r+0x210>
    bd4c:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    bd50:	f04f 0901 	mov.w	r9, #1
    bd54:	4623      	mov	r3, r4
    bd56:	469a      	mov	sl, r3
    bd58:	f813 2b01 	ldrb.w	r2, [r3], #1
    bd5c:	b10a      	cbz	r2, bd62 <_vfiprintf_r+0x56>
    bd5e:	2a25      	cmp	r2, #37	; 0x25
    bd60:	d1f9      	bne.n	bd56 <_vfiprintf_r+0x4a>
    bd62:	ebba 0b04 	subs.w	fp, sl, r4
    bd66:	d00b      	beq.n	bd80 <_vfiprintf_r+0x74>
    bd68:	465b      	mov	r3, fp
    bd6a:	4622      	mov	r2, r4
    bd6c:	4629      	mov	r1, r5
    bd6e:	4630      	mov	r0, r6
    bd70:	f004 fc42 	bl	105f8 <__sfputs_r>
    bd74:	3001      	adds	r0, #1
    bd76:	f000 80c0 	beq.w	befa <_vfiprintf_r+0x1ee>
    bd7a:	9a09      	ldr	r2, [sp, #36]	; 0x24
    bd7c:	445a      	add	r2, fp
    bd7e:	9209      	str	r2, [sp, #36]	; 0x24
    bd80:	f89a 3000 	ldrb.w	r3, [sl]
    bd84:	2b00      	cmp	r3, #0
    bd86:	f000 80b8 	beq.w	befa <_vfiprintf_r+0x1ee>
    bd8a:	2300      	movs	r3, #0
    bd8c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    bd90:	e9cd 2305 	strd	r2, r3, [sp, #20]
    bd94:	f10a 0a01 	add.w	sl, sl, #1
    bd98:	9304      	str	r3, [sp, #16]
    bd9a:	9307      	str	r3, [sp, #28]
    bd9c:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    bda0:	931a      	str	r3, [sp, #104]	; 0x68
    bda2:	4654      	mov	r4, sl
    bda4:	2205      	movs	r2, #5
    bda6:	f814 1b01 	ldrb.w	r1, [r4], #1
    bdaa:	485c      	ldr	r0, [pc, #368]	; (bf1c <_vfiprintf_r+0x210>)
    bdac:	f7f4 f9a8 	bl	100 <memchr>
    bdb0:	9a04      	ldr	r2, [sp, #16]
    bdb2:	2800      	cmp	r0, #0
    bdb4:	d130      	bne.n	be18 <_vfiprintf_r+0x10c>
    bdb6:	06d0      	lsls	r0, r2, #27
    bdb8:	bf44      	itt	mi
    bdba:	2320      	movmi	r3, #32
    bdbc:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
    bdc0:	0711      	lsls	r1, r2, #28
    bdc2:	bf44      	itt	mi
    bdc4:	232b      	movmi	r3, #43	; 0x2b
    bdc6:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
    bdca:	f89a 3000 	ldrb.w	r3, [sl]
    bdce:	2b2a      	cmp	r3, #42	; 0x2a
    bdd0:	d02a      	beq.n	be28 <_vfiprintf_r+0x11c>
    bdd2:	9a07      	ldr	r2, [sp, #28]
    bdd4:	4654      	mov	r4, sl
    bdd6:	2000      	movs	r0, #0
    bdd8:	f04f 0c0a 	mov.w	ip, #10
    bddc:	4621      	mov	r1, r4
    bdde:	f811 3b01 	ldrb.w	r3, [r1], #1
    bde2:	3b30      	subs	r3, #48	; 0x30
    bde4:	2b09      	cmp	r3, #9
    bde6:	d963      	bls.n	beb0 <_vfiprintf_r+0x1a4>
    bde8:	b358      	cbz	r0, be42 <_vfiprintf_r+0x136>
    bdea:	9207      	str	r2, [sp, #28]
    bdec:	e029      	b.n	be42 <_vfiprintf_r+0x136>
    bdee:	4b4c      	ldr	r3, [pc, #304]	; (bf20 <_vfiprintf_r+0x214>)
    bdf0:	429d      	cmp	r5, r3
    bdf2:	d101      	bne.n	bdf8 <_vfiprintf_r+0xec>
    bdf4:	68b5      	ldr	r5, [r6, #8]
    bdf6:	e799      	b.n	bd2c <_vfiprintf_r+0x20>
    bdf8:	4b4a      	ldr	r3, [pc, #296]	; (bf24 <_vfiprintf_r+0x218>)
    bdfa:	429d      	cmp	r5, r3
    bdfc:	bf08      	it	eq
    bdfe:	68f5      	ldreq	r5, [r6, #12]
    be00:	e794      	b.n	bd2c <_vfiprintf_r+0x20>
    be02:	4629      	mov	r1, r5
    be04:	4630      	mov	r0, r6
    be06:	f000 fa2f 	bl	c268 <__swsetup_r>
    be0a:	2800      	cmp	r0, #0
    be0c:	d094      	beq.n	bd38 <_vfiprintf_r+0x2c>
    be0e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    be12:	b01d      	add	sp, #116	; 0x74
    be14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    be18:	eba0 0308 	sub.w	r3, r0, r8
    be1c:	fa09 f303 	lsl.w	r3, r9, r3
    be20:	4313      	orrs	r3, r2
    be22:	9304      	str	r3, [sp, #16]
    be24:	46a2      	mov	sl, r4
    be26:	e7bc      	b.n	bda2 <_vfiprintf_r+0x96>
    be28:	9b03      	ldr	r3, [sp, #12]
    be2a:	1d19      	adds	r1, r3, #4
    be2c:	681b      	ldr	r3, [r3, #0]
    be2e:	9103      	str	r1, [sp, #12]
    be30:	2b00      	cmp	r3, #0
    be32:	bfbb      	ittet	lt
    be34:	425b      	neglt	r3, r3
    be36:	f042 0202 	orrlt.w	r2, r2, #2
    be3a:	9307      	strge	r3, [sp, #28]
    be3c:	9307      	strlt	r3, [sp, #28]
    be3e:	bfb8      	it	lt
    be40:	9204      	strlt	r2, [sp, #16]
    be42:	7823      	ldrb	r3, [r4, #0]
    be44:	2b2e      	cmp	r3, #46	; 0x2e
    be46:	d10c      	bne.n	be62 <_vfiprintf_r+0x156>
    be48:	7863      	ldrb	r3, [r4, #1]
    be4a:	2b2a      	cmp	r3, #42	; 0x2a
    be4c:	d135      	bne.n	beba <_vfiprintf_r+0x1ae>
    be4e:	9b03      	ldr	r3, [sp, #12]
    be50:	1d1a      	adds	r2, r3, #4
    be52:	681b      	ldr	r3, [r3, #0]
    be54:	9203      	str	r2, [sp, #12]
    be56:	2b00      	cmp	r3, #0
    be58:	bfb8      	it	lt
    be5a:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
    be5e:	3402      	adds	r4, #2
    be60:	9305      	str	r3, [sp, #20]
    be62:	f8df a0d0 	ldr.w	sl, [pc, #208]	; bf34 <_vfiprintf_r+0x228>
    be66:	7821      	ldrb	r1, [r4, #0]
    be68:	2203      	movs	r2, #3
    be6a:	4650      	mov	r0, sl
    be6c:	f7f4 f948 	bl	100 <memchr>
    be70:	b140      	cbz	r0, be84 <_vfiprintf_r+0x178>
    be72:	2340      	movs	r3, #64	; 0x40
    be74:	eba0 000a 	sub.w	r0, r0, sl
    be78:	fa03 f000 	lsl.w	r0, r3, r0
    be7c:	9b04      	ldr	r3, [sp, #16]
    be7e:	4303      	orrs	r3, r0
    be80:	3401      	adds	r4, #1
    be82:	9304      	str	r3, [sp, #16]
    be84:	f814 1b01 	ldrb.w	r1, [r4], #1
    be88:	4827      	ldr	r0, [pc, #156]	; (bf28 <_vfiprintf_r+0x21c>)
    be8a:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
    be8e:	2206      	movs	r2, #6
    be90:	f7f4 f936 	bl	100 <memchr>
    be94:	2800      	cmp	r0, #0
    be96:	d035      	beq.n	bf04 <_vfiprintf_r+0x1f8>
    be98:	4b24      	ldr	r3, [pc, #144]	; (bf2c <_vfiprintf_r+0x220>)
    be9a:	bb1b      	cbnz	r3, bee4 <_vfiprintf_r+0x1d8>
    be9c:	9b03      	ldr	r3, [sp, #12]
    be9e:	3307      	adds	r3, #7
    bea0:	f023 0307 	bic.w	r3, r3, #7
    bea4:	3308      	adds	r3, #8
    bea6:	9303      	str	r3, [sp, #12]
    bea8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    beaa:	443b      	add	r3, r7
    beac:	9309      	str	r3, [sp, #36]	; 0x24
    beae:	e751      	b.n	bd54 <_vfiprintf_r+0x48>
    beb0:	fb0c 3202 	mla	r2, ip, r2, r3
    beb4:	460c      	mov	r4, r1
    beb6:	2001      	movs	r0, #1
    beb8:	e790      	b.n	bddc <_vfiprintf_r+0xd0>
    beba:	2300      	movs	r3, #0
    bebc:	3401      	adds	r4, #1
    bebe:	9305      	str	r3, [sp, #20]
    bec0:	4619      	mov	r1, r3
    bec2:	f04f 0c0a 	mov.w	ip, #10
    bec6:	4620      	mov	r0, r4
    bec8:	f810 2b01 	ldrb.w	r2, [r0], #1
    becc:	3a30      	subs	r2, #48	; 0x30
    bece:	2a09      	cmp	r2, #9
    bed0:	d903      	bls.n	beda <_vfiprintf_r+0x1ce>
    bed2:	2b00      	cmp	r3, #0
    bed4:	d0c5      	beq.n	be62 <_vfiprintf_r+0x156>
    bed6:	9105      	str	r1, [sp, #20]
    bed8:	e7c3      	b.n	be62 <_vfiprintf_r+0x156>
    beda:	fb0c 2101 	mla	r1, ip, r1, r2
    bede:	4604      	mov	r4, r0
    bee0:	2301      	movs	r3, #1
    bee2:	e7f0      	b.n	bec6 <_vfiprintf_r+0x1ba>
    bee4:	ab03      	add	r3, sp, #12
    bee6:	9300      	str	r3, [sp, #0]
    bee8:	462a      	mov	r2, r5
    beea:	4b11      	ldr	r3, [pc, #68]	; (bf30 <_vfiprintf_r+0x224>)
    beec:	a904      	add	r1, sp, #16
    beee:	4630      	mov	r0, r6
    bef0:	f3af 8000 	nop.w
    bef4:	1c42      	adds	r2, r0, #1
    bef6:	4607      	mov	r7, r0
    bef8:	d1d6      	bne.n	bea8 <_vfiprintf_r+0x19c>
    befa:	89ab      	ldrh	r3, [r5, #12]
    befc:	065b      	lsls	r3, r3, #25
    befe:	d486      	bmi.n	be0e <_vfiprintf_r+0x102>
    bf00:	9809      	ldr	r0, [sp, #36]	; 0x24
    bf02:	e786      	b.n	be12 <_vfiprintf_r+0x106>
    bf04:	ab03      	add	r3, sp, #12
    bf06:	9300      	str	r3, [sp, #0]
    bf08:	462a      	mov	r2, r5
    bf0a:	4b09      	ldr	r3, [pc, #36]	; (bf30 <_vfiprintf_r+0x224>)
    bf0c:	a904      	add	r1, sp, #16
    bf0e:	4630      	mov	r0, r6
    bf10:	f000 f812 	bl	bf38 <_printf_i>
    bf14:	e7ee      	b.n	bef4 <_vfiprintf_r+0x1e8>
    bf16:	bf00      	nop
    bf18:	000130f4 	.word	0x000130f4
    bf1c:	00013271 	.word	0x00013271
    bf20:	00013114 	.word	0x00013114
    bf24:	000130d4 	.word	0x000130d4
    bf28:	0001327b 	.word	0x0001327b
    bf2c:	00000000 	.word	0x00000000
    bf30:	000105f9 	.word	0x000105f9
    bf34:	00013277 	.word	0x00013277

0000bf38 <_printf_i>:
    bf38:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    bf3c:	460c      	mov	r4, r1
    bf3e:	4691      	mov	r9, r2
    bf40:	7e27      	ldrb	r7, [r4, #24]
    bf42:	990c      	ldr	r1, [sp, #48]	; 0x30
    bf44:	2f78      	cmp	r7, #120	; 0x78
    bf46:	4680      	mov	r8, r0
    bf48:	469a      	mov	sl, r3
    bf4a:	f104 0243 	add.w	r2, r4, #67	; 0x43
    bf4e:	d807      	bhi.n	bf60 <_printf_i+0x28>
    bf50:	2f62      	cmp	r7, #98	; 0x62
    bf52:	d80a      	bhi.n	bf6a <_printf_i+0x32>
    bf54:	2f00      	cmp	r7, #0
    bf56:	f000 80d8 	beq.w	c10a <_printf_i+0x1d2>
    bf5a:	2f58      	cmp	r7, #88	; 0x58
    bf5c:	f000 80a3 	beq.w	c0a6 <_printf_i+0x16e>
    bf60:	f104 0642 	add.w	r6, r4, #66	; 0x42
    bf64:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
    bf68:	e03a      	b.n	bfe0 <_printf_i+0xa8>
    bf6a:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
    bf6e:	2b15      	cmp	r3, #21
    bf70:	d8f6      	bhi.n	bf60 <_printf_i+0x28>
    bf72:	a001      	add	r0, pc, #4	; (adr r0, bf78 <_printf_i+0x40>)
    bf74:	f850 f023 	ldr.w	pc, [r0, r3, lsl #2]
    bf78:	0000bfd1 	.word	0x0000bfd1
    bf7c:	0000bfe5 	.word	0x0000bfe5
    bf80:	0000bf61 	.word	0x0000bf61
    bf84:	0000bf61 	.word	0x0000bf61
    bf88:	0000bf61 	.word	0x0000bf61
    bf8c:	0000bf61 	.word	0x0000bf61
    bf90:	0000bfe5 	.word	0x0000bfe5
    bf94:	0000bf61 	.word	0x0000bf61
    bf98:	0000bf61 	.word	0x0000bf61
    bf9c:	0000bf61 	.word	0x0000bf61
    bfa0:	0000bf61 	.word	0x0000bf61
    bfa4:	0000c0f1 	.word	0x0000c0f1
    bfa8:	0000c015 	.word	0x0000c015
    bfac:	0000c0d3 	.word	0x0000c0d3
    bfb0:	0000bf61 	.word	0x0000bf61
    bfb4:	0000bf61 	.word	0x0000bf61
    bfb8:	0000c113 	.word	0x0000c113
    bfbc:	0000bf61 	.word	0x0000bf61
    bfc0:	0000c015 	.word	0x0000c015
    bfc4:	0000bf61 	.word	0x0000bf61
    bfc8:	0000bf61 	.word	0x0000bf61
    bfcc:	0000c0db 	.word	0x0000c0db
    bfd0:	680b      	ldr	r3, [r1, #0]
    bfd2:	1d1a      	adds	r2, r3, #4
    bfd4:	681b      	ldr	r3, [r3, #0]
    bfd6:	600a      	str	r2, [r1, #0]
    bfd8:	f104 0642 	add.w	r6, r4, #66	; 0x42
    bfdc:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    bfe0:	2301      	movs	r3, #1
    bfe2:	e0a3      	b.n	c12c <_printf_i+0x1f4>
    bfe4:	6825      	ldr	r5, [r4, #0]
    bfe6:	6808      	ldr	r0, [r1, #0]
    bfe8:	062e      	lsls	r6, r5, #24
    bfea:	f100 0304 	add.w	r3, r0, #4
    bfee:	d50a      	bpl.n	c006 <_printf_i+0xce>
    bff0:	6805      	ldr	r5, [r0, #0]
    bff2:	600b      	str	r3, [r1, #0]
    bff4:	2d00      	cmp	r5, #0
    bff6:	da03      	bge.n	c000 <_printf_i+0xc8>
    bff8:	232d      	movs	r3, #45	; 0x2d
    bffa:	426d      	negs	r5, r5
    bffc:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    c000:	485e      	ldr	r0, [pc, #376]	; (c17c <_printf_i+0x244>)
    c002:	230a      	movs	r3, #10
    c004:	e019      	b.n	c03a <_printf_i+0x102>
    c006:	f015 0f40 	tst.w	r5, #64	; 0x40
    c00a:	6805      	ldr	r5, [r0, #0]
    c00c:	600b      	str	r3, [r1, #0]
    c00e:	bf18      	it	ne
    c010:	b22d      	sxthne	r5, r5
    c012:	e7ef      	b.n	bff4 <_printf_i+0xbc>
    c014:	680b      	ldr	r3, [r1, #0]
    c016:	6825      	ldr	r5, [r4, #0]
    c018:	1d18      	adds	r0, r3, #4
    c01a:	6008      	str	r0, [r1, #0]
    c01c:	0628      	lsls	r0, r5, #24
    c01e:	d501      	bpl.n	c024 <_printf_i+0xec>
    c020:	681d      	ldr	r5, [r3, #0]
    c022:	e002      	b.n	c02a <_printf_i+0xf2>
    c024:	0669      	lsls	r1, r5, #25
    c026:	d5fb      	bpl.n	c020 <_printf_i+0xe8>
    c028:	881d      	ldrh	r5, [r3, #0]
    c02a:	4854      	ldr	r0, [pc, #336]	; (c17c <_printf_i+0x244>)
    c02c:	2f6f      	cmp	r7, #111	; 0x6f
    c02e:	bf0c      	ite	eq
    c030:	2308      	moveq	r3, #8
    c032:	230a      	movne	r3, #10
    c034:	2100      	movs	r1, #0
    c036:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
    c03a:	6866      	ldr	r6, [r4, #4]
    c03c:	60a6      	str	r6, [r4, #8]
    c03e:	2e00      	cmp	r6, #0
    c040:	bfa2      	ittt	ge
    c042:	6821      	ldrge	r1, [r4, #0]
    c044:	f021 0104 	bicge.w	r1, r1, #4
    c048:	6021      	strge	r1, [r4, #0]
    c04a:	b90d      	cbnz	r5, c050 <_printf_i+0x118>
    c04c:	2e00      	cmp	r6, #0
    c04e:	d04d      	beq.n	c0ec <_printf_i+0x1b4>
    c050:	4616      	mov	r6, r2
    c052:	fbb5 f1f3 	udiv	r1, r5, r3
    c056:	fb03 5711 	mls	r7, r3, r1, r5
    c05a:	5dc7      	ldrb	r7, [r0, r7]
    c05c:	f806 7d01 	strb.w	r7, [r6, #-1]!
    c060:	462f      	mov	r7, r5
    c062:	42bb      	cmp	r3, r7
    c064:	460d      	mov	r5, r1
    c066:	d9f4      	bls.n	c052 <_printf_i+0x11a>
    c068:	2b08      	cmp	r3, #8
    c06a:	d10b      	bne.n	c084 <_printf_i+0x14c>
    c06c:	6823      	ldr	r3, [r4, #0]
    c06e:	07df      	lsls	r7, r3, #31
    c070:	d508      	bpl.n	c084 <_printf_i+0x14c>
    c072:	6923      	ldr	r3, [r4, #16]
    c074:	6861      	ldr	r1, [r4, #4]
    c076:	4299      	cmp	r1, r3
    c078:	bfde      	ittt	le
    c07a:	2330      	movle	r3, #48	; 0x30
    c07c:	f806 3c01 	strble.w	r3, [r6, #-1]
    c080:	f106 36ff 	addle.w	r6, r6, #4294967295	; 0xffffffff
    c084:	1b92      	subs	r2, r2, r6
    c086:	6122      	str	r2, [r4, #16]
    c088:	f8cd a000 	str.w	sl, [sp]
    c08c:	464b      	mov	r3, r9
    c08e:	aa03      	add	r2, sp, #12
    c090:	4621      	mov	r1, r4
    c092:	4640      	mov	r0, r8
    c094:	f004 fac2 	bl	1061c <_printf_common>
    c098:	3001      	adds	r0, #1
    c09a:	d14c      	bne.n	c136 <_printf_i+0x1fe>
    c09c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    c0a0:	b004      	add	sp, #16
    c0a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    c0a6:	4835      	ldr	r0, [pc, #212]	; (c17c <_printf_i+0x244>)
    c0a8:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
    c0ac:	6823      	ldr	r3, [r4, #0]
    c0ae:	680e      	ldr	r6, [r1, #0]
    c0b0:	061f      	lsls	r7, r3, #24
    c0b2:	f856 5b04 	ldr.w	r5, [r6], #4
    c0b6:	600e      	str	r6, [r1, #0]
    c0b8:	d514      	bpl.n	c0e4 <_printf_i+0x1ac>
    c0ba:	07d9      	lsls	r1, r3, #31
    c0bc:	bf44      	itt	mi
    c0be:	f043 0320 	orrmi.w	r3, r3, #32
    c0c2:	6023      	strmi	r3, [r4, #0]
    c0c4:	b91d      	cbnz	r5, c0ce <_printf_i+0x196>
    c0c6:	6823      	ldr	r3, [r4, #0]
    c0c8:	f023 0320 	bic.w	r3, r3, #32
    c0cc:	6023      	str	r3, [r4, #0]
    c0ce:	2310      	movs	r3, #16
    c0d0:	e7b0      	b.n	c034 <_printf_i+0xfc>
    c0d2:	6823      	ldr	r3, [r4, #0]
    c0d4:	f043 0320 	orr.w	r3, r3, #32
    c0d8:	6023      	str	r3, [r4, #0]
    c0da:	2378      	movs	r3, #120	; 0x78
    c0dc:	4828      	ldr	r0, [pc, #160]	; (c180 <_printf_i+0x248>)
    c0de:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    c0e2:	e7e3      	b.n	c0ac <_printf_i+0x174>
    c0e4:	065e      	lsls	r6, r3, #25
    c0e6:	bf48      	it	mi
    c0e8:	b2ad      	uxthmi	r5, r5
    c0ea:	e7e6      	b.n	c0ba <_printf_i+0x182>
    c0ec:	4616      	mov	r6, r2
    c0ee:	e7bb      	b.n	c068 <_printf_i+0x130>
    c0f0:	680b      	ldr	r3, [r1, #0]
    c0f2:	6826      	ldr	r6, [r4, #0]
    c0f4:	6960      	ldr	r0, [r4, #20]
    c0f6:	1d1d      	adds	r5, r3, #4
    c0f8:	600d      	str	r5, [r1, #0]
    c0fa:	0635      	lsls	r5, r6, #24
    c0fc:	681b      	ldr	r3, [r3, #0]
    c0fe:	d501      	bpl.n	c104 <_printf_i+0x1cc>
    c100:	6018      	str	r0, [r3, #0]
    c102:	e002      	b.n	c10a <_printf_i+0x1d2>
    c104:	0671      	lsls	r1, r6, #25
    c106:	d5fb      	bpl.n	c100 <_printf_i+0x1c8>
    c108:	8018      	strh	r0, [r3, #0]
    c10a:	2300      	movs	r3, #0
    c10c:	6123      	str	r3, [r4, #16]
    c10e:	4616      	mov	r6, r2
    c110:	e7ba      	b.n	c088 <_printf_i+0x150>
    c112:	680b      	ldr	r3, [r1, #0]
    c114:	1d1a      	adds	r2, r3, #4
    c116:	600a      	str	r2, [r1, #0]
    c118:	681e      	ldr	r6, [r3, #0]
    c11a:	6862      	ldr	r2, [r4, #4]
    c11c:	2100      	movs	r1, #0
    c11e:	4630      	mov	r0, r6
    c120:	f7f3 ffee 	bl	100 <memchr>
    c124:	b108      	cbz	r0, c12a <_printf_i+0x1f2>
    c126:	1b80      	subs	r0, r0, r6
    c128:	6060      	str	r0, [r4, #4]
    c12a:	6863      	ldr	r3, [r4, #4]
    c12c:	6123      	str	r3, [r4, #16]
    c12e:	2300      	movs	r3, #0
    c130:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    c134:	e7a8      	b.n	c088 <_printf_i+0x150>
    c136:	6923      	ldr	r3, [r4, #16]
    c138:	4632      	mov	r2, r6
    c13a:	4649      	mov	r1, r9
    c13c:	4640      	mov	r0, r8
    c13e:	47d0      	blx	sl
    c140:	3001      	adds	r0, #1
    c142:	d0ab      	beq.n	c09c <_printf_i+0x164>
    c144:	6823      	ldr	r3, [r4, #0]
    c146:	079b      	lsls	r3, r3, #30
    c148:	d413      	bmi.n	c172 <_printf_i+0x23a>
    c14a:	68e0      	ldr	r0, [r4, #12]
    c14c:	9b03      	ldr	r3, [sp, #12]
    c14e:	4298      	cmp	r0, r3
    c150:	bfb8      	it	lt
    c152:	4618      	movlt	r0, r3
    c154:	e7a4      	b.n	c0a0 <_printf_i+0x168>
    c156:	2301      	movs	r3, #1
    c158:	4632      	mov	r2, r6
    c15a:	4649      	mov	r1, r9
    c15c:	4640      	mov	r0, r8
    c15e:	47d0      	blx	sl
    c160:	3001      	adds	r0, #1
    c162:	d09b      	beq.n	c09c <_printf_i+0x164>
    c164:	3501      	adds	r5, #1
    c166:	68e3      	ldr	r3, [r4, #12]
    c168:	9903      	ldr	r1, [sp, #12]
    c16a:	1a5b      	subs	r3, r3, r1
    c16c:	42ab      	cmp	r3, r5
    c16e:	dcf2      	bgt.n	c156 <_printf_i+0x21e>
    c170:	e7eb      	b.n	c14a <_printf_i+0x212>
    c172:	2500      	movs	r5, #0
    c174:	f104 0619 	add.w	r6, r4, #25
    c178:	e7f5      	b.n	c166 <_printf_i+0x22e>
    c17a:	bf00      	nop
    c17c:	00013282 	.word	0x00013282
    c180:	00013293 	.word	0x00013293

0000c184 <siprintf>:
    c184:	b40e      	push	{r1, r2, r3}
    c186:	b500      	push	{lr}
    c188:	b09a      	sub	sp, #104	; 0x68
    c18a:	ab1b      	add	r3, sp, #108	; 0x6c
    c18c:	9001      	str	r0, [sp, #4]
    c18e:	9005      	str	r0, [sp, #20]
    c190:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    c194:	4809      	ldr	r0, [pc, #36]	; (c1bc <siprintf+0x38>)
    c196:	9106      	str	r1, [sp, #24]
    c198:	9103      	str	r1, [sp, #12]
    c19a:	4909      	ldr	r1, [pc, #36]	; (c1c0 <siprintf+0x3c>)
    c19c:	f853 2b04 	ldr.w	r2, [r3], #4
    c1a0:	9104      	str	r1, [sp, #16]
    c1a2:	6800      	ldr	r0, [r0, #0]
    c1a4:	9300      	str	r3, [sp, #0]
    c1a6:	a901      	add	r1, sp, #4
    c1a8:	f000 fb02 	bl	c7b0 <_svfiprintf_r>
    c1ac:	9b01      	ldr	r3, [sp, #4]
    c1ae:	2200      	movs	r2, #0
    c1b0:	701a      	strb	r2, [r3, #0]
    c1b2:	b01a      	add	sp, #104	; 0x68
    c1b4:	f85d eb04 	ldr.w	lr, [sp], #4
    c1b8:	b003      	add	sp, #12
    c1ba:	4770      	bx	lr
    c1bc:	20000368 	.word	0x20000368
    c1c0:	ffff0208 	.word	0xffff0208

0000c1c4 <__swbuf_r>:
    c1c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c1c6:	460e      	mov	r6, r1
    c1c8:	4614      	mov	r4, r2
    c1ca:	4605      	mov	r5, r0
    c1cc:	b118      	cbz	r0, c1d6 <__swbuf_r+0x12>
    c1ce:	6983      	ldr	r3, [r0, #24]
    c1d0:	b90b      	cbnz	r3, c1d6 <__swbuf_r+0x12>
    c1d2:	f000 f999 	bl	c508 <__sinit>
    c1d6:	4b21      	ldr	r3, [pc, #132]	; (c25c <__swbuf_r+0x98>)
    c1d8:	429c      	cmp	r4, r3
    c1da:	d12b      	bne.n	c234 <__swbuf_r+0x70>
    c1dc:	686c      	ldr	r4, [r5, #4]
    c1de:	69a3      	ldr	r3, [r4, #24]
    c1e0:	60a3      	str	r3, [r4, #8]
    c1e2:	89a3      	ldrh	r3, [r4, #12]
    c1e4:	071a      	lsls	r2, r3, #28
    c1e6:	d52f      	bpl.n	c248 <__swbuf_r+0x84>
    c1e8:	6923      	ldr	r3, [r4, #16]
    c1ea:	b36b      	cbz	r3, c248 <__swbuf_r+0x84>
    c1ec:	6923      	ldr	r3, [r4, #16]
    c1ee:	6820      	ldr	r0, [r4, #0]
    c1f0:	1ac0      	subs	r0, r0, r3
    c1f2:	6963      	ldr	r3, [r4, #20]
    c1f4:	b2f6      	uxtb	r6, r6
    c1f6:	4283      	cmp	r3, r0
    c1f8:	4637      	mov	r7, r6
    c1fa:	dc04      	bgt.n	c206 <__swbuf_r+0x42>
    c1fc:	4621      	mov	r1, r4
    c1fe:	4628      	mov	r0, r5
    c200:	f000 f92e 	bl	c460 <_fflush_r>
    c204:	bb30      	cbnz	r0, c254 <__swbuf_r+0x90>
    c206:	68a3      	ldr	r3, [r4, #8]
    c208:	3b01      	subs	r3, #1
    c20a:	60a3      	str	r3, [r4, #8]
    c20c:	6823      	ldr	r3, [r4, #0]
    c20e:	1c5a      	adds	r2, r3, #1
    c210:	6022      	str	r2, [r4, #0]
    c212:	701e      	strb	r6, [r3, #0]
    c214:	6963      	ldr	r3, [r4, #20]
    c216:	3001      	adds	r0, #1
    c218:	4283      	cmp	r3, r0
    c21a:	d004      	beq.n	c226 <__swbuf_r+0x62>
    c21c:	89a3      	ldrh	r3, [r4, #12]
    c21e:	07db      	lsls	r3, r3, #31
    c220:	d506      	bpl.n	c230 <__swbuf_r+0x6c>
    c222:	2e0a      	cmp	r6, #10
    c224:	d104      	bne.n	c230 <__swbuf_r+0x6c>
    c226:	4621      	mov	r1, r4
    c228:	4628      	mov	r0, r5
    c22a:	f000 f919 	bl	c460 <_fflush_r>
    c22e:	b988      	cbnz	r0, c254 <__swbuf_r+0x90>
    c230:	4638      	mov	r0, r7
    c232:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c234:	4b0a      	ldr	r3, [pc, #40]	; (c260 <__swbuf_r+0x9c>)
    c236:	429c      	cmp	r4, r3
    c238:	d101      	bne.n	c23e <__swbuf_r+0x7a>
    c23a:	68ac      	ldr	r4, [r5, #8]
    c23c:	e7cf      	b.n	c1de <__swbuf_r+0x1a>
    c23e:	4b09      	ldr	r3, [pc, #36]	; (c264 <__swbuf_r+0xa0>)
    c240:	429c      	cmp	r4, r3
    c242:	bf08      	it	eq
    c244:	68ec      	ldreq	r4, [r5, #12]
    c246:	e7ca      	b.n	c1de <__swbuf_r+0x1a>
    c248:	4621      	mov	r1, r4
    c24a:	4628      	mov	r0, r5
    c24c:	f000 f80c 	bl	c268 <__swsetup_r>
    c250:	2800      	cmp	r0, #0
    c252:	d0cb      	beq.n	c1ec <__swbuf_r+0x28>
    c254:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    c258:	e7ea      	b.n	c230 <__swbuf_r+0x6c>
    c25a:	bf00      	nop
    c25c:	000130f4 	.word	0x000130f4
    c260:	00013114 	.word	0x00013114
    c264:	000130d4 	.word	0x000130d4

0000c268 <__swsetup_r>:
    c268:	4b32      	ldr	r3, [pc, #200]	; (c334 <__swsetup_r+0xcc>)
    c26a:	b570      	push	{r4, r5, r6, lr}
    c26c:	681d      	ldr	r5, [r3, #0]
    c26e:	4606      	mov	r6, r0
    c270:	460c      	mov	r4, r1
    c272:	b125      	cbz	r5, c27e <__swsetup_r+0x16>
    c274:	69ab      	ldr	r3, [r5, #24]
    c276:	b913      	cbnz	r3, c27e <__swsetup_r+0x16>
    c278:	4628      	mov	r0, r5
    c27a:	f000 f945 	bl	c508 <__sinit>
    c27e:	4b2e      	ldr	r3, [pc, #184]	; (c338 <__swsetup_r+0xd0>)
    c280:	429c      	cmp	r4, r3
    c282:	d10f      	bne.n	c2a4 <__swsetup_r+0x3c>
    c284:	686c      	ldr	r4, [r5, #4]
    c286:	89a3      	ldrh	r3, [r4, #12]
    c288:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    c28c:	0719      	lsls	r1, r3, #28
    c28e:	d42c      	bmi.n	c2ea <__swsetup_r+0x82>
    c290:	06dd      	lsls	r5, r3, #27
    c292:	d411      	bmi.n	c2b8 <__swsetup_r+0x50>
    c294:	2309      	movs	r3, #9
    c296:	6033      	str	r3, [r6, #0]
    c298:	f042 0340 	orr.w	r3, r2, #64	; 0x40
    c29c:	81a3      	strh	r3, [r4, #12]
    c29e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    c2a2:	e03e      	b.n	c322 <__swsetup_r+0xba>
    c2a4:	4b25      	ldr	r3, [pc, #148]	; (c33c <__swsetup_r+0xd4>)
    c2a6:	429c      	cmp	r4, r3
    c2a8:	d101      	bne.n	c2ae <__swsetup_r+0x46>
    c2aa:	68ac      	ldr	r4, [r5, #8]
    c2ac:	e7eb      	b.n	c286 <__swsetup_r+0x1e>
    c2ae:	4b24      	ldr	r3, [pc, #144]	; (c340 <__swsetup_r+0xd8>)
    c2b0:	429c      	cmp	r4, r3
    c2b2:	bf08      	it	eq
    c2b4:	68ec      	ldreq	r4, [r5, #12]
    c2b6:	e7e6      	b.n	c286 <__swsetup_r+0x1e>
    c2b8:	0758      	lsls	r0, r3, #29
    c2ba:	d512      	bpl.n	c2e2 <__swsetup_r+0x7a>
    c2bc:	6b61      	ldr	r1, [r4, #52]	; 0x34
    c2be:	b141      	cbz	r1, c2d2 <__swsetup_r+0x6a>
    c2c0:	f104 0344 	add.w	r3, r4, #68	; 0x44
    c2c4:	4299      	cmp	r1, r3
    c2c6:	d002      	beq.n	c2ce <__swsetup_r+0x66>
    c2c8:	4630      	mov	r0, r6
    c2ca:	f000 f9c9 	bl	c660 <_free_r>
    c2ce:	2300      	movs	r3, #0
    c2d0:	6363      	str	r3, [r4, #52]	; 0x34
    c2d2:	89a3      	ldrh	r3, [r4, #12]
    c2d4:	f023 0324 	bic.w	r3, r3, #36	; 0x24
    c2d8:	81a3      	strh	r3, [r4, #12]
    c2da:	2300      	movs	r3, #0
    c2dc:	6063      	str	r3, [r4, #4]
    c2de:	6923      	ldr	r3, [r4, #16]
    c2e0:	6023      	str	r3, [r4, #0]
    c2e2:	89a3      	ldrh	r3, [r4, #12]
    c2e4:	f043 0308 	orr.w	r3, r3, #8
    c2e8:	81a3      	strh	r3, [r4, #12]
    c2ea:	6923      	ldr	r3, [r4, #16]
    c2ec:	b94b      	cbnz	r3, c302 <__swsetup_r+0x9a>
    c2ee:	89a3      	ldrh	r3, [r4, #12]
    c2f0:	f403 7320 	and.w	r3, r3, #640	; 0x280
    c2f4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    c2f8:	d003      	beq.n	c302 <__swsetup_r+0x9a>
    c2fa:	4621      	mov	r1, r4
    c2fc:	4630      	mov	r0, r6
    c2fe:	f000 f96f 	bl	c5e0 <__smakebuf_r>
    c302:	89a0      	ldrh	r0, [r4, #12]
    c304:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    c308:	f010 0301 	ands.w	r3, r0, #1
    c30c:	d00a      	beq.n	c324 <__swsetup_r+0xbc>
    c30e:	2300      	movs	r3, #0
    c310:	60a3      	str	r3, [r4, #8]
    c312:	6963      	ldr	r3, [r4, #20]
    c314:	425b      	negs	r3, r3
    c316:	61a3      	str	r3, [r4, #24]
    c318:	6923      	ldr	r3, [r4, #16]
    c31a:	b943      	cbnz	r3, c32e <__swsetup_r+0xc6>
    c31c:	f010 0080 	ands.w	r0, r0, #128	; 0x80
    c320:	d1ba      	bne.n	c298 <__swsetup_r+0x30>
    c322:	bd70      	pop	{r4, r5, r6, pc}
    c324:	0781      	lsls	r1, r0, #30
    c326:	bf58      	it	pl
    c328:	6963      	ldrpl	r3, [r4, #20]
    c32a:	60a3      	str	r3, [r4, #8]
    c32c:	e7f4      	b.n	c318 <__swsetup_r+0xb0>
    c32e:	2000      	movs	r0, #0
    c330:	e7f7      	b.n	c322 <__swsetup_r+0xba>
    c332:	bf00      	nop
    c334:	20000368 	.word	0x20000368
    c338:	000130f4 	.word	0x000130f4
    c33c:	00013114 	.word	0x00013114
    c340:	000130d4 	.word	0x000130d4

0000c344 <__sflush_r>:
    c344:	898b      	ldrh	r3, [r1, #12]
    c346:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
    c34a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c34e:	4605      	mov	r5, r0
    c350:	0718      	lsls	r0, r3, #28
    c352:	460c      	mov	r4, r1
    c354:	d45f      	bmi.n	c416 <__sflush_r+0xd2>
    c356:	684b      	ldr	r3, [r1, #4]
    c358:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
    c35c:	2b00      	cmp	r3, #0
    c35e:	818a      	strh	r2, [r1, #12]
    c360:	dc05      	bgt.n	c36e <__sflush_r+0x2a>
    c362:	6c0b      	ldr	r3, [r1, #64]	; 0x40
    c364:	2b00      	cmp	r3, #0
    c366:	dc02      	bgt.n	c36e <__sflush_r+0x2a>
    c368:	2000      	movs	r0, #0
    c36a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    c36e:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    c370:	2e00      	cmp	r6, #0
    c372:	d0f9      	beq.n	c368 <__sflush_r+0x24>
    c374:	2300      	movs	r3, #0
    c376:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
    c37a:	682f      	ldr	r7, [r5, #0]
    c37c:	602b      	str	r3, [r5, #0]
    c37e:	d036      	beq.n	c3ee <__sflush_r+0xaa>
    c380:	6d60      	ldr	r0, [r4, #84]	; 0x54
    c382:	89a3      	ldrh	r3, [r4, #12]
    c384:	075a      	lsls	r2, r3, #29
    c386:	d505      	bpl.n	c394 <__sflush_r+0x50>
    c388:	6863      	ldr	r3, [r4, #4]
    c38a:	1ac0      	subs	r0, r0, r3
    c38c:	6b63      	ldr	r3, [r4, #52]	; 0x34
    c38e:	b10b      	cbz	r3, c394 <__sflush_r+0x50>
    c390:	6c23      	ldr	r3, [r4, #64]	; 0x40
    c392:	1ac0      	subs	r0, r0, r3
    c394:	2300      	movs	r3, #0
    c396:	4602      	mov	r2, r0
    c398:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    c39a:	6a21      	ldr	r1, [r4, #32]
    c39c:	4628      	mov	r0, r5
    c39e:	47b0      	blx	r6
    c3a0:	1c43      	adds	r3, r0, #1
    c3a2:	89a3      	ldrh	r3, [r4, #12]
    c3a4:	d106      	bne.n	c3b4 <__sflush_r+0x70>
    c3a6:	6829      	ldr	r1, [r5, #0]
    c3a8:	291d      	cmp	r1, #29
    c3aa:	d830      	bhi.n	c40e <__sflush_r+0xca>
    c3ac:	4a2b      	ldr	r2, [pc, #172]	; (c45c <__sflush_r+0x118>)
    c3ae:	40ca      	lsrs	r2, r1
    c3b0:	07d6      	lsls	r6, r2, #31
    c3b2:	d52c      	bpl.n	c40e <__sflush_r+0xca>
    c3b4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    c3b8:	b21b      	sxth	r3, r3
    c3ba:	2200      	movs	r2, #0
    c3bc:	6062      	str	r2, [r4, #4]
    c3be:	04d9      	lsls	r1, r3, #19
    c3c0:	6922      	ldr	r2, [r4, #16]
    c3c2:	81a3      	strh	r3, [r4, #12]
    c3c4:	6022      	str	r2, [r4, #0]
    c3c6:	d504      	bpl.n	c3d2 <__sflush_r+0x8e>
    c3c8:	1c42      	adds	r2, r0, #1
    c3ca:	d101      	bne.n	c3d0 <__sflush_r+0x8c>
    c3cc:	682b      	ldr	r3, [r5, #0]
    c3ce:	b903      	cbnz	r3, c3d2 <__sflush_r+0x8e>
    c3d0:	6560      	str	r0, [r4, #84]	; 0x54
    c3d2:	6b61      	ldr	r1, [r4, #52]	; 0x34
    c3d4:	602f      	str	r7, [r5, #0]
    c3d6:	2900      	cmp	r1, #0
    c3d8:	d0c6      	beq.n	c368 <__sflush_r+0x24>
    c3da:	f104 0344 	add.w	r3, r4, #68	; 0x44
    c3de:	4299      	cmp	r1, r3
    c3e0:	d002      	beq.n	c3e8 <__sflush_r+0xa4>
    c3e2:	4628      	mov	r0, r5
    c3e4:	f000 f93c 	bl	c660 <_free_r>
    c3e8:	2000      	movs	r0, #0
    c3ea:	6360      	str	r0, [r4, #52]	; 0x34
    c3ec:	e7bd      	b.n	c36a <__sflush_r+0x26>
    c3ee:	6a21      	ldr	r1, [r4, #32]
    c3f0:	2301      	movs	r3, #1
    c3f2:	4628      	mov	r0, r5
    c3f4:	47b0      	blx	r6
    c3f6:	1c41      	adds	r1, r0, #1
    c3f8:	d1c3      	bne.n	c382 <__sflush_r+0x3e>
    c3fa:	682b      	ldr	r3, [r5, #0]
    c3fc:	2b00      	cmp	r3, #0
    c3fe:	d0c0      	beq.n	c382 <__sflush_r+0x3e>
    c400:	2b1d      	cmp	r3, #29
    c402:	d001      	beq.n	c408 <__sflush_r+0xc4>
    c404:	2b16      	cmp	r3, #22
    c406:	d101      	bne.n	c40c <__sflush_r+0xc8>
    c408:	602f      	str	r7, [r5, #0]
    c40a:	e7ad      	b.n	c368 <__sflush_r+0x24>
    c40c:	89a3      	ldrh	r3, [r4, #12]
    c40e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    c412:	81a3      	strh	r3, [r4, #12]
    c414:	e7a9      	b.n	c36a <__sflush_r+0x26>
    c416:	690f      	ldr	r7, [r1, #16]
    c418:	2f00      	cmp	r7, #0
    c41a:	d0a5      	beq.n	c368 <__sflush_r+0x24>
    c41c:	079b      	lsls	r3, r3, #30
    c41e:	680e      	ldr	r6, [r1, #0]
    c420:	bf08      	it	eq
    c422:	694b      	ldreq	r3, [r1, #20]
    c424:	600f      	str	r7, [r1, #0]
    c426:	bf18      	it	ne
    c428:	2300      	movne	r3, #0
    c42a:	eba6 0807 	sub.w	r8, r6, r7
    c42e:	608b      	str	r3, [r1, #8]
    c430:	f1b8 0f00 	cmp.w	r8, #0
    c434:	dd98      	ble.n	c368 <__sflush_r+0x24>
    c436:	6a21      	ldr	r1, [r4, #32]
    c438:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    c43a:	4643      	mov	r3, r8
    c43c:	463a      	mov	r2, r7
    c43e:	4628      	mov	r0, r5
    c440:	47b0      	blx	r6
    c442:	2800      	cmp	r0, #0
    c444:	dc06      	bgt.n	c454 <__sflush_r+0x110>
    c446:	89a3      	ldrh	r3, [r4, #12]
    c448:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    c44c:	81a3      	strh	r3, [r4, #12]
    c44e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    c452:	e78a      	b.n	c36a <__sflush_r+0x26>
    c454:	4407      	add	r7, r0
    c456:	eba8 0800 	sub.w	r8, r8, r0
    c45a:	e7e9      	b.n	c430 <__sflush_r+0xec>
    c45c:	20400001 	.word	0x20400001

0000c460 <_fflush_r>:
    c460:	b538      	push	{r3, r4, r5, lr}
    c462:	690b      	ldr	r3, [r1, #16]
    c464:	4605      	mov	r5, r0
    c466:	460c      	mov	r4, r1
    c468:	b1db      	cbz	r3, c4a2 <_fflush_r+0x42>
    c46a:	b118      	cbz	r0, c474 <_fflush_r+0x14>
    c46c:	6983      	ldr	r3, [r0, #24]
    c46e:	b90b      	cbnz	r3, c474 <_fflush_r+0x14>
    c470:	f000 f84a 	bl	c508 <__sinit>
    c474:	4b0c      	ldr	r3, [pc, #48]	; (c4a8 <_fflush_r+0x48>)
    c476:	429c      	cmp	r4, r3
    c478:	d109      	bne.n	c48e <_fflush_r+0x2e>
    c47a:	686c      	ldr	r4, [r5, #4]
    c47c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    c480:	b17b      	cbz	r3, c4a2 <_fflush_r+0x42>
    c482:	4621      	mov	r1, r4
    c484:	4628      	mov	r0, r5
    c486:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    c48a:	f7ff bf5b 	b.w	c344 <__sflush_r>
    c48e:	4b07      	ldr	r3, [pc, #28]	; (c4ac <_fflush_r+0x4c>)
    c490:	429c      	cmp	r4, r3
    c492:	d101      	bne.n	c498 <_fflush_r+0x38>
    c494:	68ac      	ldr	r4, [r5, #8]
    c496:	e7f1      	b.n	c47c <_fflush_r+0x1c>
    c498:	4b05      	ldr	r3, [pc, #20]	; (c4b0 <_fflush_r+0x50>)
    c49a:	429c      	cmp	r4, r3
    c49c:	bf08      	it	eq
    c49e:	68ec      	ldreq	r4, [r5, #12]
    c4a0:	e7ec      	b.n	c47c <_fflush_r+0x1c>
    c4a2:	2000      	movs	r0, #0
    c4a4:	bd38      	pop	{r3, r4, r5, pc}
    c4a6:	bf00      	nop
    c4a8:	000130f4 	.word	0x000130f4
    c4ac:	00013114 	.word	0x00013114
    c4b0:	000130d4 	.word	0x000130d4

0000c4b4 <std>:
    c4b4:	2300      	movs	r3, #0
    c4b6:	b510      	push	{r4, lr}
    c4b8:	4604      	mov	r4, r0
    c4ba:	e9c0 3300 	strd	r3, r3, [r0]
    c4be:	e9c0 3304 	strd	r3, r3, [r0, #16]
    c4c2:	6083      	str	r3, [r0, #8]
    c4c4:	8181      	strh	r1, [r0, #12]
    c4c6:	6603      	str	r3, [r0, #96]	; 0x60
    c4c8:	81c2      	strh	r2, [r0, #14]
    c4ca:	6183      	str	r3, [r0, #24]
    c4cc:	4619      	mov	r1, r3
    c4ce:	2208      	movs	r2, #8
    c4d0:	3058      	adds	r0, #88	; 0x58
    c4d2:	f004 f874 	bl	105be <memset>
    c4d6:	4b05      	ldr	r3, [pc, #20]	; (c4ec <std+0x38>)
    c4d8:	6263      	str	r3, [r4, #36]	; 0x24
    c4da:	4b05      	ldr	r3, [pc, #20]	; (c4f0 <std+0x3c>)
    c4dc:	62a3      	str	r3, [r4, #40]	; 0x28
    c4de:	4b05      	ldr	r3, [pc, #20]	; (c4f4 <std+0x40>)
    c4e0:	62e3      	str	r3, [r4, #44]	; 0x2c
    c4e2:	4b05      	ldr	r3, [pc, #20]	; (c4f8 <std+0x44>)
    c4e4:	6224      	str	r4, [r4, #32]
    c4e6:	6323      	str	r3, [r4, #48]	; 0x30
    c4e8:	bd10      	pop	{r4, pc}
    c4ea:	bf00      	nop
    c4ec:	00010975 	.word	0x00010975
    c4f0:	00010997 	.word	0x00010997
    c4f4:	000109cf 	.word	0x000109cf
    c4f8:	000109f3 	.word	0x000109f3

0000c4fc <_cleanup_r>:
    c4fc:	4901      	ldr	r1, [pc, #4]	; (c504 <_cleanup_r+0x8>)
    c4fe:	f004 b92a 	b.w	10756 <_fwalk_reent>
    c502:	bf00      	nop
    c504:	0000c461 	.word	0x0000c461

0000c508 <__sinit>:
    c508:	6983      	ldr	r3, [r0, #24]
    c50a:	b510      	push	{r4, lr}
    c50c:	4604      	mov	r4, r0
    c50e:	bb33      	cbnz	r3, c55e <__sinit+0x56>
    c510:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
    c514:	6503      	str	r3, [r0, #80]	; 0x50
    c516:	4b12      	ldr	r3, [pc, #72]	; (c560 <__sinit+0x58>)
    c518:	4a12      	ldr	r2, [pc, #72]	; (c564 <__sinit+0x5c>)
    c51a:	681b      	ldr	r3, [r3, #0]
    c51c:	6282      	str	r2, [r0, #40]	; 0x28
    c51e:	4298      	cmp	r0, r3
    c520:	bf04      	itt	eq
    c522:	2301      	moveq	r3, #1
    c524:	6183      	streq	r3, [r0, #24]
    c526:	f000 f81f 	bl	c568 <__sfp>
    c52a:	6060      	str	r0, [r4, #4]
    c52c:	4620      	mov	r0, r4
    c52e:	f000 f81b 	bl	c568 <__sfp>
    c532:	60a0      	str	r0, [r4, #8]
    c534:	4620      	mov	r0, r4
    c536:	f000 f817 	bl	c568 <__sfp>
    c53a:	2200      	movs	r2, #0
    c53c:	60e0      	str	r0, [r4, #12]
    c53e:	2104      	movs	r1, #4
    c540:	6860      	ldr	r0, [r4, #4]
    c542:	f7ff ffb7 	bl	c4b4 <std>
    c546:	68a0      	ldr	r0, [r4, #8]
    c548:	2201      	movs	r2, #1
    c54a:	2109      	movs	r1, #9
    c54c:	f7ff ffb2 	bl	c4b4 <std>
    c550:	68e0      	ldr	r0, [r4, #12]
    c552:	2202      	movs	r2, #2
    c554:	2112      	movs	r1, #18
    c556:	f7ff ffad 	bl	c4b4 <std>
    c55a:	2301      	movs	r3, #1
    c55c:	61a3      	str	r3, [r4, #24]
    c55e:	bd10      	pop	{r4, pc}
    c560:	000130d0 	.word	0x000130d0
    c564:	0000c4fd 	.word	0x0000c4fd

0000c568 <__sfp>:
    c568:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c56a:	4b1b      	ldr	r3, [pc, #108]	; (c5d8 <__sfp+0x70>)
    c56c:	681e      	ldr	r6, [r3, #0]
    c56e:	69b3      	ldr	r3, [r6, #24]
    c570:	4607      	mov	r7, r0
    c572:	b913      	cbnz	r3, c57a <__sfp+0x12>
    c574:	4630      	mov	r0, r6
    c576:	f7ff ffc7 	bl	c508 <__sinit>
    c57a:	3648      	adds	r6, #72	; 0x48
    c57c:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
    c580:	3b01      	subs	r3, #1
    c582:	d503      	bpl.n	c58c <__sfp+0x24>
    c584:	6833      	ldr	r3, [r6, #0]
    c586:	b1db      	cbz	r3, c5c0 <__sfp+0x58>
    c588:	6836      	ldr	r6, [r6, #0]
    c58a:	e7f7      	b.n	c57c <__sfp+0x14>
    c58c:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
    c590:	b9a5      	cbnz	r5, c5bc <__sfp+0x54>
    c592:	4b12      	ldr	r3, [pc, #72]	; (c5dc <__sfp+0x74>)
    c594:	6625      	str	r5, [r4, #96]	; 0x60
    c596:	e9c4 5500 	strd	r5, r5, [r4]
    c59a:	e9c4 3503 	strd	r3, r5, [r4, #12]
    c59e:	e9c4 5505 	strd	r5, r5, [r4, #20]
    c5a2:	60a5      	str	r5, [r4, #8]
    c5a4:	2208      	movs	r2, #8
    c5a6:	4629      	mov	r1, r5
    c5a8:	f104 0058 	add.w	r0, r4, #88	; 0x58
    c5ac:	f004 f807 	bl	105be <memset>
    c5b0:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
    c5b4:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
    c5b8:	4620      	mov	r0, r4
    c5ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c5bc:	3464      	adds	r4, #100	; 0x64
    c5be:	e7df      	b.n	c580 <__sfp+0x18>
    c5c0:	2104      	movs	r1, #4
    c5c2:	4638      	mov	r0, r7
    c5c4:	f004 f8b1 	bl	1072a <__sfmoreglue>
    c5c8:	4604      	mov	r4, r0
    c5ca:	6030      	str	r0, [r6, #0]
    c5cc:	2800      	cmp	r0, #0
    c5ce:	d1db      	bne.n	c588 <__sfp+0x20>
    c5d0:	230c      	movs	r3, #12
    c5d2:	603b      	str	r3, [r7, #0]
    c5d4:	e7f0      	b.n	c5b8 <__sfp+0x50>
    c5d6:	bf00      	nop
    c5d8:	000130d0 	.word	0x000130d0
    c5dc:	ffff0001 	.word	0xffff0001

0000c5e0 <__smakebuf_r>:
    c5e0:	898b      	ldrh	r3, [r1, #12]
    c5e2:	b573      	push	{r0, r1, r4, r5, r6, lr}
    c5e4:	079d      	lsls	r5, r3, #30
    c5e6:	4606      	mov	r6, r0
    c5e8:	460c      	mov	r4, r1
    c5ea:	d507      	bpl.n	c5fc <__smakebuf_r+0x1c>
    c5ec:	f104 0347 	add.w	r3, r4, #71	; 0x47
    c5f0:	6023      	str	r3, [r4, #0]
    c5f2:	6123      	str	r3, [r4, #16]
    c5f4:	2301      	movs	r3, #1
    c5f6:	6163      	str	r3, [r4, #20]
    c5f8:	b002      	add	sp, #8
    c5fa:	bd70      	pop	{r4, r5, r6, pc}
    c5fc:	ab01      	add	r3, sp, #4
    c5fe:	466a      	mov	r2, sp
    c600:	f004 f8c8 	bl	10794 <__swhatbuf_r>
    c604:	9900      	ldr	r1, [sp, #0]
    c606:	4605      	mov	r5, r0
    c608:	4630      	mov	r0, r6
    c60a:	f000 f877 	bl	c6fc <_malloc_r>
    c60e:	b948      	cbnz	r0, c624 <__smakebuf_r+0x44>
    c610:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    c614:	059a      	lsls	r2, r3, #22
    c616:	d4ef      	bmi.n	c5f8 <__smakebuf_r+0x18>
    c618:	f023 0303 	bic.w	r3, r3, #3
    c61c:	f043 0302 	orr.w	r3, r3, #2
    c620:	81a3      	strh	r3, [r4, #12]
    c622:	e7e3      	b.n	c5ec <__smakebuf_r+0xc>
    c624:	4b0d      	ldr	r3, [pc, #52]	; (c65c <__smakebuf_r+0x7c>)
    c626:	62b3      	str	r3, [r6, #40]	; 0x28
    c628:	89a3      	ldrh	r3, [r4, #12]
    c62a:	6020      	str	r0, [r4, #0]
    c62c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    c630:	81a3      	strh	r3, [r4, #12]
    c632:	9b00      	ldr	r3, [sp, #0]
    c634:	6163      	str	r3, [r4, #20]
    c636:	9b01      	ldr	r3, [sp, #4]
    c638:	6120      	str	r0, [r4, #16]
    c63a:	b15b      	cbz	r3, c654 <__smakebuf_r+0x74>
    c63c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    c640:	4630      	mov	r0, r6
    c642:	f000 fa13 	bl	ca6c <_isatty_r>
    c646:	b128      	cbz	r0, c654 <__smakebuf_r+0x74>
    c648:	89a3      	ldrh	r3, [r4, #12]
    c64a:	f023 0303 	bic.w	r3, r3, #3
    c64e:	f043 0301 	orr.w	r3, r3, #1
    c652:	81a3      	strh	r3, [r4, #12]
    c654:	89a0      	ldrh	r0, [r4, #12]
    c656:	4305      	orrs	r5, r0
    c658:	81a5      	strh	r5, [r4, #12]
    c65a:	e7cd      	b.n	c5f8 <__smakebuf_r+0x18>
    c65c:	0000c4fd 	.word	0x0000c4fd

0000c660 <_free_r>:
    c660:	b538      	push	{r3, r4, r5, lr}
    c662:	4605      	mov	r5, r0
    c664:	2900      	cmp	r1, #0
    c666:	d045      	beq.n	c6f4 <_free_r+0x94>
    c668:	f851 3c04 	ldr.w	r3, [r1, #-4]
    c66c:	1f0c      	subs	r4, r1, #4
    c66e:	2b00      	cmp	r3, #0
    c670:	bfb8      	it	lt
    c672:	18e4      	addlt	r4, r4, r3
    c674:	f004 f9c1 	bl	109fa <__malloc_lock>
    c678:	4a1f      	ldr	r2, [pc, #124]	; (c6f8 <_free_r+0x98>)
    c67a:	6813      	ldr	r3, [r2, #0]
    c67c:	4610      	mov	r0, r2
    c67e:	b933      	cbnz	r3, c68e <_free_r+0x2e>
    c680:	6063      	str	r3, [r4, #4]
    c682:	6014      	str	r4, [r2, #0]
    c684:	4628      	mov	r0, r5
    c686:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    c68a:	f004 b9b7 	b.w	109fc <__malloc_unlock>
    c68e:	42a3      	cmp	r3, r4
    c690:	d90b      	bls.n	c6aa <_free_r+0x4a>
    c692:	6821      	ldr	r1, [r4, #0]
    c694:	1862      	adds	r2, r4, r1
    c696:	4293      	cmp	r3, r2
    c698:	bf04      	itt	eq
    c69a:	681a      	ldreq	r2, [r3, #0]
    c69c:	685b      	ldreq	r3, [r3, #4]
    c69e:	6063      	str	r3, [r4, #4]
    c6a0:	bf04      	itt	eq
    c6a2:	1852      	addeq	r2, r2, r1
    c6a4:	6022      	streq	r2, [r4, #0]
    c6a6:	6004      	str	r4, [r0, #0]
    c6a8:	e7ec      	b.n	c684 <_free_r+0x24>
    c6aa:	461a      	mov	r2, r3
    c6ac:	685b      	ldr	r3, [r3, #4]
    c6ae:	b10b      	cbz	r3, c6b4 <_free_r+0x54>
    c6b0:	42a3      	cmp	r3, r4
    c6b2:	d9fa      	bls.n	c6aa <_free_r+0x4a>
    c6b4:	6811      	ldr	r1, [r2, #0]
    c6b6:	1850      	adds	r0, r2, r1
    c6b8:	42a0      	cmp	r0, r4
    c6ba:	d10b      	bne.n	c6d4 <_free_r+0x74>
    c6bc:	6820      	ldr	r0, [r4, #0]
    c6be:	4401      	add	r1, r0
    c6c0:	1850      	adds	r0, r2, r1
    c6c2:	4283      	cmp	r3, r0
    c6c4:	6011      	str	r1, [r2, #0]
    c6c6:	d1dd      	bne.n	c684 <_free_r+0x24>
    c6c8:	6818      	ldr	r0, [r3, #0]
    c6ca:	685b      	ldr	r3, [r3, #4]
    c6cc:	6053      	str	r3, [r2, #4]
    c6ce:	4401      	add	r1, r0
    c6d0:	6011      	str	r1, [r2, #0]
    c6d2:	e7d7      	b.n	c684 <_free_r+0x24>
    c6d4:	d902      	bls.n	c6dc <_free_r+0x7c>
    c6d6:	230c      	movs	r3, #12
    c6d8:	602b      	str	r3, [r5, #0]
    c6da:	e7d3      	b.n	c684 <_free_r+0x24>
    c6dc:	6820      	ldr	r0, [r4, #0]
    c6de:	1821      	adds	r1, r4, r0
    c6e0:	428b      	cmp	r3, r1
    c6e2:	bf04      	itt	eq
    c6e4:	6819      	ldreq	r1, [r3, #0]
    c6e6:	685b      	ldreq	r3, [r3, #4]
    c6e8:	6063      	str	r3, [r4, #4]
    c6ea:	bf04      	itt	eq
    c6ec:	1809      	addeq	r1, r1, r0
    c6ee:	6021      	streq	r1, [r4, #0]
    c6f0:	6054      	str	r4, [r2, #4]
    c6f2:	e7c7      	b.n	c684 <_free_r+0x24>
    c6f4:	bd38      	pop	{r3, r4, r5, pc}
    c6f6:	bf00      	nop
    c6f8:	20005940 	.word	0x20005940

0000c6fc <_malloc_r>:
    c6fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c6fe:	1ccd      	adds	r5, r1, #3
    c700:	f025 0503 	bic.w	r5, r5, #3
    c704:	3508      	adds	r5, #8
    c706:	2d0c      	cmp	r5, #12
    c708:	bf38      	it	cc
    c70a:	250c      	movcc	r5, #12
    c70c:	2d00      	cmp	r5, #0
    c70e:	4606      	mov	r6, r0
    c710:	db01      	blt.n	c716 <_malloc_r+0x1a>
    c712:	42a9      	cmp	r1, r5
    c714:	d903      	bls.n	c71e <_malloc_r+0x22>
    c716:	230c      	movs	r3, #12
    c718:	6033      	str	r3, [r6, #0]
    c71a:	2000      	movs	r0, #0
    c71c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c71e:	f004 f96c 	bl	109fa <__malloc_lock>
    c722:	4921      	ldr	r1, [pc, #132]	; (c7a8 <_malloc_r+0xac>)
    c724:	680a      	ldr	r2, [r1, #0]
    c726:	4614      	mov	r4, r2
    c728:	b99c      	cbnz	r4, c752 <_malloc_r+0x56>
    c72a:	4f20      	ldr	r7, [pc, #128]	; (c7ac <_malloc_r+0xb0>)
    c72c:	683b      	ldr	r3, [r7, #0]
    c72e:	b923      	cbnz	r3, c73a <_malloc_r+0x3e>
    c730:	4621      	mov	r1, r4
    c732:	4630      	mov	r0, r6
    c734:	f000 f93c 	bl	c9b0 <_sbrk_r>
    c738:	6038      	str	r0, [r7, #0]
    c73a:	4629      	mov	r1, r5
    c73c:	4630      	mov	r0, r6
    c73e:	f000 f937 	bl	c9b0 <_sbrk_r>
    c742:	1c43      	adds	r3, r0, #1
    c744:	d123      	bne.n	c78e <_malloc_r+0x92>
    c746:	230c      	movs	r3, #12
    c748:	6033      	str	r3, [r6, #0]
    c74a:	4630      	mov	r0, r6
    c74c:	f004 f956 	bl	109fc <__malloc_unlock>
    c750:	e7e3      	b.n	c71a <_malloc_r+0x1e>
    c752:	6823      	ldr	r3, [r4, #0]
    c754:	1b5b      	subs	r3, r3, r5
    c756:	d417      	bmi.n	c788 <_malloc_r+0x8c>
    c758:	2b0b      	cmp	r3, #11
    c75a:	d903      	bls.n	c764 <_malloc_r+0x68>
    c75c:	6023      	str	r3, [r4, #0]
    c75e:	441c      	add	r4, r3
    c760:	6025      	str	r5, [r4, #0]
    c762:	e004      	b.n	c76e <_malloc_r+0x72>
    c764:	6863      	ldr	r3, [r4, #4]
    c766:	42a2      	cmp	r2, r4
    c768:	bf0c      	ite	eq
    c76a:	600b      	streq	r3, [r1, #0]
    c76c:	6053      	strne	r3, [r2, #4]
    c76e:	4630      	mov	r0, r6
    c770:	f004 f944 	bl	109fc <__malloc_unlock>
    c774:	f104 000b 	add.w	r0, r4, #11
    c778:	1d23      	adds	r3, r4, #4
    c77a:	f020 0007 	bic.w	r0, r0, #7
    c77e:	1ac2      	subs	r2, r0, r3
    c780:	d0cc      	beq.n	c71c <_malloc_r+0x20>
    c782:	1a1b      	subs	r3, r3, r0
    c784:	50a3      	str	r3, [r4, r2]
    c786:	e7c9      	b.n	c71c <_malloc_r+0x20>
    c788:	4622      	mov	r2, r4
    c78a:	6864      	ldr	r4, [r4, #4]
    c78c:	e7cc      	b.n	c728 <_malloc_r+0x2c>
    c78e:	1cc4      	adds	r4, r0, #3
    c790:	f024 0403 	bic.w	r4, r4, #3
    c794:	42a0      	cmp	r0, r4
    c796:	d0e3      	beq.n	c760 <_malloc_r+0x64>
    c798:	1a21      	subs	r1, r4, r0
    c79a:	4630      	mov	r0, r6
    c79c:	f000 f908 	bl	c9b0 <_sbrk_r>
    c7a0:	3001      	adds	r0, #1
    c7a2:	d1dd      	bne.n	c760 <_malloc_r+0x64>
    c7a4:	e7cf      	b.n	c746 <_malloc_r+0x4a>
    c7a6:	bf00      	nop
    c7a8:	20005940 	.word	0x20005940
    c7ac:	20005944 	.word	0x20005944

0000c7b0 <_svfiprintf_r>:
    c7b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c7b4:	4698      	mov	r8, r3
    c7b6:	898b      	ldrh	r3, [r1, #12]
    c7b8:	061b      	lsls	r3, r3, #24
    c7ba:	b09d      	sub	sp, #116	; 0x74
    c7bc:	4607      	mov	r7, r0
    c7be:	460d      	mov	r5, r1
    c7c0:	4614      	mov	r4, r2
    c7c2:	d50e      	bpl.n	c7e2 <_svfiprintf_r+0x32>
    c7c4:	690b      	ldr	r3, [r1, #16]
    c7c6:	b963      	cbnz	r3, c7e2 <_svfiprintf_r+0x32>
    c7c8:	2140      	movs	r1, #64	; 0x40
    c7ca:	f7ff ff97 	bl	c6fc <_malloc_r>
    c7ce:	6028      	str	r0, [r5, #0]
    c7d0:	6128      	str	r0, [r5, #16]
    c7d2:	b920      	cbnz	r0, c7de <_svfiprintf_r+0x2e>
    c7d4:	230c      	movs	r3, #12
    c7d6:	603b      	str	r3, [r7, #0]
    c7d8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    c7dc:	e0d1      	b.n	c982 <_svfiprintf_r+0x1d2>
    c7de:	2340      	movs	r3, #64	; 0x40
    c7e0:	616b      	str	r3, [r5, #20]
    c7e2:	2300      	movs	r3, #0
    c7e4:	9309      	str	r3, [sp, #36]	; 0x24
    c7e6:	2320      	movs	r3, #32
    c7e8:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    c7ec:	f8cd 800c 	str.w	r8, [sp, #12]
    c7f0:	2330      	movs	r3, #48	; 0x30
    c7f2:	f8df 81a8 	ldr.w	r8, [pc, #424]	; c99c <_svfiprintf_r+0x1ec>
    c7f6:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    c7fa:	f04f 0901 	mov.w	r9, #1
    c7fe:	4623      	mov	r3, r4
    c800:	469a      	mov	sl, r3
    c802:	f813 2b01 	ldrb.w	r2, [r3], #1
    c806:	b10a      	cbz	r2, c80c <_svfiprintf_r+0x5c>
    c808:	2a25      	cmp	r2, #37	; 0x25
    c80a:	d1f9      	bne.n	c800 <_svfiprintf_r+0x50>
    c80c:	ebba 0b04 	subs.w	fp, sl, r4
    c810:	d00b      	beq.n	c82a <_svfiprintf_r+0x7a>
    c812:	465b      	mov	r3, fp
    c814:	4622      	mov	r2, r4
    c816:	4629      	mov	r1, r5
    c818:	4638      	mov	r0, r7
    c81a:	f004 f826 	bl	1086a <__ssputs_r>
    c81e:	3001      	adds	r0, #1
    c820:	f000 80aa 	beq.w	c978 <_svfiprintf_r+0x1c8>
    c824:	9a09      	ldr	r2, [sp, #36]	; 0x24
    c826:	445a      	add	r2, fp
    c828:	9209      	str	r2, [sp, #36]	; 0x24
    c82a:	f89a 3000 	ldrb.w	r3, [sl]
    c82e:	2b00      	cmp	r3, #0
    c830:	f000 80a2 	beq.w	c978 <_svfiprintf_r+0x1c8>
    c834:	2300      	movs	r3, #0
    c836:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    c83a:	e9cd 2305 	strd	r2, r3, [sp, #20]
    c83e:	f10a 0a01 	add.w	sl, sl, #1
    c842:	9304      	str	r3, [sp, #16]
    c844:	9307      	str	r3, [sp, #28]
    c846:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    c84a:	931a      	str	r3, [sp, #104]	; 0x68
    c84c:	4654      	mov	r4, sl
    c84e:	2205      	movs	r2, #5
    c850:	f814 1b01 	ldrb.w	r1, [r4], #1
    c854:	4851      	ldr	r0, [pc, #324]	; (c99c <_svfiprintf_r+0x1ec>)
    c856:	f7f3 fc53 	bl	100 <memchr>
    c85a:	9a04      	ldr	r2, [sp, #16]
    c85c:	b9d8      	cbnz	r0, c896 <_svfiprintf_r+0xe6>
    c85e:	06d0      	lsls	r0, r2, #27
    c860:	bf44      	itt	mi
    c862:	2320      	movmi	r3, #32
    c864:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
    c868:	0711      	lsls	r1, r2, #28
    c86a:	bf44      	itt	mi
    c86c:	232b      	movmi	r3, #43	; 0x2b
    c86e:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
    c872:	f89a 3000 	ldrb.w	r3, [sl]
    c876:	2b2a      	cmp	r3, #42	; 0x2a
    c878:	d015      	beq.n	c8a6 <_svfiprintf_r+0xf6>
    c87a:	9a07      	ldr	r2, [sp, #28]
    c87c:	4654      	mov	r4, sl
    c87e:	2000      	movs	r0, #0
    c880:	f04f 0c0a 	mov.w	ip, #10
    c884:	4621      	mov	r1, r4
    c886:	f811 3b01 	ldrb.w	r3, [r1], #1
    c88a:	3b30      	subs	r3, #48	; 0x30
    c88c:	2b09      	cmp	r3, #9
    c88e:	d94e      	bls.n	c92e <_svfiprintf_r+0x17e>
    c890:	b1b0      	cbz	r0, c8c0 <_svfiprintf_r+0x110>
    c892:	9207      	str	r2, [sp, #28]
    c894:	e014      	b.n	c8c0 <_svfiprintf_r+0x110>
    c896:	eba0 0308 	sub.w	r3, r0, r8
    c89a:	fa09 f303 	lsl.w	r3, r9, r3
    c89e:	4313      	orrs	r3, r2
    c8a0:	9304      	str	r3, [sp, #16]
    c8a2:	46a2      	mov	sl, r4
    c8a4:	e7d2      	b.n	c84c <_svfiprintf_r+0x9c>
    c8a6:	9b03      	ldr	r3, [sp, #12]
    c8a8:	1d19      	adds	r1, r3, #4
    c8aa:	681b      	ldr	r3, [r3, #0]
    c8ac:	9103      	str	r1, [sp, #12]
    c8ae:	2b00      	cmp	r3, #0
    c8b0:	bfbb      	ittet	lt
    c8b2:	425b      	neglt	r3, r3
    c8b4:	f042 0202 	orrlt.w	r2, r2, #2
    c8b8:	9307      	strge	r3, [sp, #28]
    c8ba:	9307      	strlt	r3, [sp, #28]
    c8bc:	bfb8      	it	lt
    c8be:	9204      	strlt	r2, [sp, #16]
    c8c0:	7823      	ldrb	r3, [r4, #0]
    c8c2:	2b2e      	cmp	r3, #46	; 0x2e
    c8c4:	d10c      	bne.n	c8e0 <_svfiprintf_r+0x130>
    c8c6:	7863      	ldrb	r3, [r4, #1]
    c8c8:	2b2a      	cmp	r3, #42	; 0x2a
    c8ca:	d135      	bne.n	c938 <_svfiprintf_r+0x188>
    c8cc:	9b03      	ldr	r3, [sp, #12]
    c8ce:	1d1a      	adds	r2, r3, #4
    c8d0:	681b      	ldr	r3, [r3, #0]
    c8d2:	9203      	str	r2, [sp, #12]
    c8d4:	2b00      	cmp	r3, #0
    c8d6:	bfb8      	it	lt
    c8d8:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
    c8dc:	3402      	adds	r4, #2
    c8de:	9305      	str	r3, [sp, #20]
    c8e0:	f8df a0c8 	ldr.w	sl, [pc, #200]	; c9ac <_svfiprintf_r+0x1fc>
    c8e4:	7821      	ldrb	r1, [r4, #0]
    c8e6:	2203      	movs	r2, #3
    c8e8:	4650      	mov	r0, sl
    c8ea:	f7f3 fc09 	bl	100 <memchr>
    c8ee:	b140      	cbz	r0, c902 <_svfiprintf_r+0x152>
    c8f0:	2340      	movs	r3, #64	; 0x40
    c8f2:	eba0 000a 	sub.w	r0, r0, sl
    c8f6:	fa03 f000 	lsl.w	r0, r3, r0
    c8fa:	9b04      	ldr	r3, [sp, #16]
    c8fc:	4303      	orrs	r3, r0
    c8fe:	3401      	adds	r4, #1
    c900:	9304      	str	r3, [sp, #16]
    c902:	f814 1b01 	ldrb.w	r1, [r4], #1
    c906:	4826      	ldr	r0, [pc, #152]	; (c9a0 <_svfiprintf_r+0x1f0>)
    c908:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
    c90c:	2206      	movs	r2, #6
    c90e:	f7f3 fbf7 	bl	100 <memchr>
    c912:	2800      	cmp	r0, #0
    c914:	d038      	beq.n	c988 <_svfiprintf_r+0x1d8>
    c916:	4b23      	ldr	r3, [pc, #140]	; (c9a4 <_svfiprintf_r+0x1f4>)
    c918:	bb1b      	cbnz	r3, c962 <_svfiprintf_r+0x1b2>
    c91a:	9b03      	ldr	r3, [sp, #12]
    c91c:	3307      	adds	r3, #7
    c91e:	f023 0307 	bic.w	r3, r3, #7
    c922:	3308      	adds	r3, #8
    c924:	9303      	str	r3, [sp, #12]
    c926:	9b09      	ldr	r3, [sp, #36]	; 0x24
    c928:	4433      	add	r3, r6
    c92a:	9309      	str	r3, [sp, #36]	; 0x24
    c92c:	e767      	b.n	c7fe <_svfiprintf_r+0x4e>
    c92e:	fb0c 3202 	mla	r2, ip, r2, r3
    c932:	460c      	mov	r4, r1
    c934:	2001      	movs	r0, #1
    c936:	e7a5      	b.n	c884 <_svfiprintf_r+0xd4>
    c938:	2300      	movs	r3, #0
    c93a:	3401      	adds	r4, #1
    c93c:	9305      	str	r3, [sp, #20]
    c93e:	4619      	mov	r1, r3
    c940:	f04f 0c0a 	mov.w	ip, #10
    c944:	4620      	mov	r0, r4
    c946:	f810 2b01 	ldrb.w	r2, [r0], #1
    c94a:	3a30      	subs	r2, #48	; 0x30
    c94c:	2a09      	cmp	r2, #9
    c94e:	d903      	bls.n	c958 <_svfiprintf_r+0x1a8>
    c950:	2b00      	cmp	r3, #0
    c952:	d0c5      	beq.n	c8e0 <_svfiprintf_r+0x130>
    c954:	9105      	str	r1, [sp, #20]
    c956:	e7c3      	b.n	c8e0 <_svfiprintf_r+0x130>
    c958:	fb0c 2101 	mla	r1, ip, r1, r2
    c95c:	4604      	mov	r4, r0
    c95e:	2301      	movs	r3, #1
    c960:	e7f0      	b.n	c944 <_svfiprintf_r+0x194>
    c962:	ab03      	add	r3, sp, #12
    c964:	9300      	str	r3, [sp, #0]
    c966:	462a      	mov	r2, r5
    c968:	4b0f      	ldr	r3, [pc, #60]	; (c9a8 <_svfiprintf_r+0x1f8>)
    c96a:	a904      	add	r1, sp, #16
    c96c:	4638      	mov	r0, r7
    c96e:	f3af 8000 	nop.w
    c972:	1c42      	adds	r2, r0, #1
    c974:	4606      	mov	r6, r0
    c976:	d1d6      	bne.n	c926 <_svfiprintf_r+0x176>
    c978:	89ab      	ldrh	r3, [r5, #12]
    c97a:	065b      	lsls	r3, r3, #25
    c97c:	f53f af2c 	bmi.w	c7d8 <_svfiprintf_r+0x28>
    c980:	9809      	ldr	r0, [sp, #36]	; 0x24
    c982:	b01d      	add	sp, #116	; 0x74
    c984:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c988:	ab03      	add	r3, sp, #12
    c98a:	9300      	str	r3, [sp, #0]
    c98c:	462a      	mov	r2, r5
    c98e:	4b06      	ldr	r3, [pc, #24]	; (c9a8 <_svfiprintf_r+0x1f8>)
    c990:	a904      	add	r1, sp, #16
    c992:	4638      	mov	r0, r7
    c994:	f7ff fad0 	bl	bf38 <_printf_i>
    c998:	e7eb      	b.n	c972 <_svfiprintf_r+0x1c2>
    c99a:	bf00      	nop
    c99c:	00013271 	.word	0x00013271
    c9a0:	0001327b 	.word	0x0001327b
    c9a4:	00000000 	.word	0x00000000
    c9a8:	0001086b 	.word	0x0001086b
    c9ac:	00013277 	.word	0x00013277

0000c9b0 <_sbrk_r>:
    c9b0:	b538      	push	{r3, r4, r5, lr}
    c9b2:	4d06      	ldr	r5, [pc, #24]	; (c9cc <_sbrk_r+0x1c>)
    c9b4:	2300      	movs	r3, #0
    c9b6:	4604      	mov	r4, r0
    c9b8:	4608      	mov	r0, r1
    c9ba:	602b      	str	r3, [r5, #0]
    c9bc:	f7f6 fd88 	bl	34d0 <_sbrk>
    c9c0:	1c43      	adds	r3, r0, #1
    c9c2:	d102      	bne.n	c9ca <_sbrk_r+0x1a>
    c9c4:	682b      	ldr	r3, [r5, #0]
    c9c6:	b103      	cbz	r3, c9ca <_sbrk_r+0x1a>
    c9c8:	6023      	str	r3, [r4, #0]
    c9ca:	bd38      	pop	{r3, r4, r5, pc}
    c9cc:	20005958 	.word	0x20005958

0000c9d0 <raise>:
    c9d0:	4b02      	ldr	r3, [pc, #8]	; (c9dc <raise+0xc>)
    c9d2:	4601      	mov	r1, r0
    c9d4:	6818      	ldr	r0, [r3, #0]
    c9d6:	f003 bfa3 	b.w	10920 <_raise_r>
    c9da:	bf00      	nop
    c9dc:	20000368 	.word	0x20000368

0000c9e0 <_kill_r>:
    c9e0:	b538      	push	{r3, r4, r5, lr}
    c9e2:	4d07      	ldr	r5, [pc, #28]	; (ca00 <_kill_r+0x20>)
    c9e4:	2300      	movs	r3, #0
    c9e6:	4604      	mov	r4, r0
    c9e8:	4608      	mov	r0, r1
    c9ea:	4611      	mov	r1, r2
    c9ec:	602b      	str	r3, [r5, #0]
    c9ee:	f001 fb88 	bl	e102 <_kill>
    c9f2:	1c43      	adds	r3, r0, #1
    c9f4:	d102      	bne.n	c9fc <_kill_r+0x1c>
    c9f6:	682b      	ldr	r3, [r5, #0]
    c9f8:	b103      	cbz	r3, c9fc <_kill_r+0x1c>
    c9fa:	6023      	str	r3, [r4, #0]
    c9fc:	bd38      	pop	{r3, r4, r5, pc}
    c9fe:	bf00      	nop
    ca00:	20005958 	.word	0x20005958

0000ca04 <_write_r>:
    ca04:	b538      	push	{r3, r4, r5, lr}
    ca06:	4d07      	ldr	r5, [pc, #28]	; (ca24 <_write_r+0x20>)
    ca08:	4604      	mov	r4, r0
    ca0a:	4608      	mov	r0, r1
    ca0c:	4611      	mov	r1, r2
    ca0e:	2200      	movs	r2, #0
    ca10:	602a      	str	r2, [r5, #0]
    ca12:	461a      	mov	r2, r3
    ca14:	f001 fb68 	bl	e0e8 <_write>
    ca18:	1c43      	adds	r3, r0, #1
    ca1a:	d102      	bne.n	ca22 <_write_r+0x1e>
    ca1c:	682b      	ldr	r3, [r5, #0]
    ca1e:	b103      	cbz	r3, ca22 <_write_r+0x1e>
    ca20:	6023      	str	r3, [r4, #0]
    ca22:	bd38      	pop	{r3, r4, r5, pc}
    ca24:	20005958 	.word	0x20005958

0000ca28 <_close_r>:
    ca28:	b538      	push	{r3, r4, r5, lr}
    ca2a:	4d06      	ldr	r5, [pc, #24]	; (ca44 <_close_r+0x1c>)
    ca2c:	2300      	movs	r3, #0
    ca2e:	4604      	mov	r4, r0
    ca30:	4608      	mov	r0, r1
    ca32:	602b      	str	r3, [r5, #0]
    ca34:	f001 fb5e 	bl	e0f4 <_close>
    ca38:	1c43      	adds	r3, r0, #1
    ca3a:	d102      	bne.n	ca42 <_close_r+0x1a>
    ca3c:	682b      	ldr	r3, [r5, #0]
    ca3e:	b103      	cbz	r3, ca42 <_close_r+0x1a>
    ca40:	6023      	str	r3, [r4, #0]
    ca42:	bd38      	pop	{r3, r4, r5, pc}
    ca44:	20005958 	.word	0x20005958

0000ca48 <_fstat_r>:
    ca48:	b538      	push	{r3, r4, r5, lr}
    ca4a:	4d07      	ldr	r5, [pc, #28]	; (ca68 <_fstat_r+0x20>)
    ca4c:	2300      	movs	r3, #0
    ca4e:	4604      	mov	r4, r0
    ca50:	4608      	mov	r0, r1
    ca52:	4611      	mov	r1, r2
    ca54:	602b      	str	r3, [r5, #0]
    ca56:	f001 fb58 	bl	e10a <_fstat>
    ca5a:	1c43      	adds	r3, r0, #1
    ca5c:	d102      	bne.n	ca64 <_fstat_r+0x1c>
    ca5e:	682b      	ldr	r3, [r5, #0]
    ca60:	b103      	cbz	r3, ca64 <_fstat_r+0x1c>
    ca62:	6023      	str	r3, [r4, #0]
    ca64:	bd38      	pop	{r3, r4, r5, pc}
    ca66:	bf00      	nop
    ca68:	20005958 	.word	0x20005958

0000ca6c <_isatty_r>:
    ca6c:	b538      	push	{r3, r4, r5, lr}
    ca6e:	4d06      	ldr	r5, [pc, #24]	; (ca88 <_isatty_r+0x1c>)
    ca70:	2300      	movs	r3, #0
    ca72:	4604      	mov	r4, r0
    ca74:	4608      	mov	r0, r1
    ca76:	602b      	str	r3, [r5, #0]
    ca78:	f001 fb41 	bl	e0fe <_isatty>
    ca7c:	1c43      	adds	r3, r0, #1
    ca7e:	d102      	bne.n	ca86 <_isatty_r+0x1a>
    ca80:	682b      	ldr	r3, [r5, #0]
    ca82:	b103      	cbz	r3, ca86 <_isatty_r+0x1a>
    ca84:	6023      	str	r3, [r4, #0]
    ca86:	bd38      	pop	{r3, r4, r5, pc}
    ca88:	20005958 	.word	0x20005958

0000ca8c <_lseek_r>:
    ca8c:	b538      	push	{r3, r4, r5, lr}
    ca8e:	4d07      	ldr	r5, [pc, #28]	; (caac <_lseek_r+0x20>)
    ca90:	4604      	mov	r4, r0
    ca92:	4608      	mov	r0, r1
    ca94:	4611      	mov	r1, r2
    ca96:	2200      	movs	r2, #0
    ca98:	602a      	str	r2, [r5, #0]
    ca9a:	461a      	mov	r2, r3
    ca9c:	f001 fb2d 	bl	e0fa <_lseek>
    caa0:	1c43      	adds	r3, r0, #1
    caa2:	d102      	bne.n	caaa <_lseek_r+0x1e>
    caa4:	682b      	ldr	r3, [r5, #0]
    caa6:	b103      	cbz	r3, caaa <_lseek_r+0x1e>
    caa8:	6023      	str	r3, [r4, #0]
    caaa:	bd38      	pop	{r3, r4, r5, pc}
    caac:	20005958 	.word	0x20005958

0000cab0 <_read_r>:
    cab0:	b538      	push	{r3, r4, r5, lr}
    cab2:	4d07      	ldr	r5, [pc, #28]	; (cad0 <_read_r+0x20>)
    cab4:	4604      	mov	r4, r0
    cab6:	4608      	mov	r0, r1
    cab8:	4611      	mov	r1, r2
    caba:	2200      	movs	r2, #0
    cabc:	602a      	str	r2, [r5, #0]
    cabe:	461a      	mov	r2, r3
    cac0:	f001 fb0c 	bl	e0dc <_read>
    cac4:	1c43      	adds	r3, r0, #1
    cac6:	d102      	bne.n	cace <_read_r+0x1e>
    cac8:	682b      	ldr	r3, [r5, #0]
    caca:	b103      	cbz	r3, cace <_read_r+0x1e>
    cacc:	6023      	str	r3, [r4, #0]
    cace:	bd38      	pop	{r3, r4, r5, pc}
    cad0:	20005958 	.word	0x20005958

0000cad4 <_OffsetAbsSyms>:
#include "offsets_aarch64.c"
#else
#include "offsets_aarch32.c"
#endif

GEN_ABS_SYM_END
    cad4:	4770      	bx	lr

0000cad6 <create_switching_pattern_array>:
{
    cad6:	b4f0      	push	{r4, r5, r6, r7}
    cad8:	9d04      	ldr	r5, [sp, #16]
    cada:	f89d 6014 	ldrb.w	r6, [sp, #20]
	if (array == NULL || len == 0 || gpio_patterns == NULL ||
    cade:	b1e0      	cbz	r0, cb1a <create_switching_pattern_array+0x44>
    cae0:	4607      	mov	r7, r0
    cae2:	b1e9      	cbz	r1, cb20 <create_switching_pattern_array+0x4a>
    cae4:	b1fa      	cbz	r2, cb26 <create_switching_pattern_array+0x50>
    cae6:	b30b      	cbz	r3, cb2c <create_switching_pattern_array+0x56>
	    gpio_patterns_len == 0 || switch_array == NULL ||
    cae8:	b31d      	cbz	r5, cb32 <create_switching_pattern_array+0x5c>
    caea:	b32e      	cbz	r6, cb38 <create_switching_pattern_array+0x62>
	    switch_array_len == 0 || len < switch_array_len) {
    caec:	42b1      	cmp	r1, r6
    caee:	d326      	bcc.n	cb3e <create_switching_pattern_array+0x68>
	for (u8_t idx = 0; idx < switch_array_len; ++idx) {
    caf0:	2000      	movs	r0, #0
    caf2:	42b0      	cmp	r0, r6
    caf4:	d205      	bcs.n	cb02 <create_switching_pattern_array+0x2c>
		if (switch_array[idx] >= gpio_patterns_len)
    caf6:	5c2c      	ldrb	r4, [r5, r0]
    caf8:	429c      	cmp	r4, r3
    cafa:	d223      	bcs.n	cb44 <create_switching_pattern_array+0x6e>
	for (u8_t idx = 0; idx < switch_array_len; ++idx) {
    cafc:	3001      	adds	r0, #1
    cafe:	b2c0      	uxtb	r0, r0
    cb00:	e7f7      	b.n	caf2 <create_switching_pattern_array+0x1c>
	for (u8_t idx = 0; idx < len; ++idx) {
    cb02:	2300      	movs	r3, #0
    cb04:	428b      	cmp	r3, r1
    cb06:	d205      	bcs.n	cb14 <create_switching_pattern_array+0x3e>
		array[idx] = gpio_patterns[switch_array[idx]];
    cb08:	5ce8      	ldrb	r0, [r5, r3]
    cb0a:	5c10      	ldrb	r0, [r2, r0]
    cb0c:	54f8      	strb	r0, [r7, r3]
	for (u8_t idx = 0; idx < len; ++idx) {
    cb0e:	3301      	adds	r3, #1
    cb10:	b2db      	uxtb	r3, r3
    cb12:	e7f7      	b.n	cb04 <create_switching_pattern_array+0x2e>
	return 0;
    cb14:	2000      	movs	r0, #0
}
    cb16:	bcf0      	pop	{r4, r5, r6, r7}
    cb18:	4770      	bx	lr
		return -EINVAL;
    cb1a:	f06f 0015 	mvn.w	r0, #21
    cb1e:	e7fa      	b.n	cb16 <create_switching_pattern_array+0x40>
    cb20:	f06f 0015 	mvn.w	r0, #21
    cb24:	e7f7      	b.n	cb16 <create_switching_pattern_array+0x40>
    cb26:	f06f 0015 	mvn.w	r0, #21
    cb2a:	e7f4      	b.n	cb16 <create_switching_pattern_array+0x40>
    cb2c:	f06f 0015 	mvn.w	r0, #21
    cb30:	e7f1      	b.n	cb16 <create_switching_pattern_array+0x40>
    cb32:	f06f 0015 	mvn.w	r0, #21
    cb36:	e7ee      	b.n	cb16 <create_switching_pattern_array+0x40>
    cb38:	f06f 0015 	mvn.w	r0, #21
    cb3c:	e7eb      	b.n	cb16 <create_switching_pattern_array+0x40>
    cb3e:	f06f 0015 	mvn.w	r0, #21
    cb42:	e7e8      	b.n	cb16 <create_switching_pattern_array+0x40>
			return -ERANGE;
    cb44:	f06f 0021 	mvn.w	r0, #33	; 0x21
    cb48:	e7e5      	b.n	cb16 <create_switching_pattern_array+0x40>

0000cb4a <get_switch_spacing_ns>:
	switch(spacing) {
    cb4a:	2803      	cmp	r0, #3
    cb4c:	d803      	bhi.n	cb56 <get_switch_spacing_ns+0xc>
    cb4e:	e8df f000 	tbb	[pc, r0]
    cb52:	050e      	.short	0x050e
    cb54:	0b08      	.short	0x0b08
			spacing_ns = DFE_NS(1000);
    cb56:	f64f 70ff 	movw	r0, #65535	; 0xffff
    cb5a:	4770      	bx	lr
			spacing_ns = DFE_NS(4000);
    cb5c:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
			break;
    cb60:	4770      	bx	lr
			spacing_ns = DFE_NS(2000);
    cb62:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
			break;
    cb66:	4770      	bx	lr
			spacing_ns = DFE_NS(1000);
    cb68:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
			break;
    cb6c:	4770      	bx	lr
			spacing_ns = DFE_NS(8000);
    cb6e:	f44f 50fa 	mov.w	r0, #8000	; 0x1f40
}
    cb72:	4770      	bx	lr

0000cb74 <dfe_get_ant_gpios_config_len>:
}
    cb74:	2004      	movs	r0, #4
    cb76:	4770      	bx	lr

0000cb78 <dfe_get_sample_spacing_ns>:
	switch(sampling) {
    cb78:	3801      	subs	r0, #1
    cb7a:	2805      	cmp	r0, #5
    cb7c:	d811      	bhi.n	cba2 <dfe_get_sample_spacing_ns+0x2a>
    cb7e:	e8df f000 	tbb	[pc, r0]
    cb82:	1303      	.short	0x1303
    cb84:	0e0c0906 	.word	0x0e0c0906
			sampling_ns = DFE_NS(125);
    cb88:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
    cb8c:	4770      	bx	lr
			sampling_ns = DFE_NS(1000);
    cb8e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
			break;
    cb92:	4770      	bx	lr
			sampling_ns = DFE_NS(500);
    cb94:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
			break;
    cb98:	4770      	bx	lr
			sampling_ns = DFE_NS(250);
    cb9a:	20fa      	movs	r0, #250	; 0xfa
			break;
    cb9c:	4770      	bx	lr
			sampling_ns = DFE_NS(125);
    cb9e:	207d      	movs	r0, #125	; 0x7d
			break;
    cba0:	4770      	bx	lr
			sampling_ns = -1;
    cba2:	f64f 70ff 	movw	r0, #65535	; 0xffff
    cba6:	4770      	bx	lr
			sampling_ns = DFE_NS(2000);
    cba8:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
}
    cbac:	4770      	bx	lr

0000cbae <dfe_get_sample_spacing_ref_ns>:
	switch(sampling) {
    cbae:	3801      	subs	r0, #1
    cbb0:	2805      	cmp	r0, #5
    cbb2:	d811      	bhi.n	cbd8 <dfe_get_sample_spacing_ref_ns+0x2a>
    cbb4:	e8df f000 	tbb	[pc, r0]
    cbb8:	09061303 	.word	0x09061303
    cbbc:	0e0c      	.short	0x0e0c
			sampling_ns = DFE_NS(125);
    cbbe:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
    cbc2:	4770      	bx	lr
			sampling_ns = DFE_NS(1000);
    cbc4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
			break;
    cbc8:	4770      	bx	lr
			sampling_ns = DFE_NS(500);
    cbca:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
			break;
    cbce:	4770      	bx	lr
			sampling_ns = DFE_NS(250);
    cbd0:	20fa      	movs	r0, #250	; 0xfa
			break;
    cbd2:	4770      	bx	lr
			sampling_ns = DFE_NS(125);
    cbd4:	207d      	movs	r0, #125	; 0x7d
			break;
    cbd6:	4770      	bx	lr
			sampling_ns = -1;
    cbd8:	f64f 70ff 	movw	r0, #65535	; 0xffff
    cbdc:	4770      	bx	lr
			sampling_ns = DFE_NS(2000);
    cbde:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
}
    cbe2:	4770      	bx	lr

0000cbe4 <arch_printk_char_out>:
}
    cbe4:	2000      	movs	r0, #0
    cbe6:	4770      	bx	lr

0000cbe8 <print_err>:
{
    cbe8:	b538      	push	{r3, r4, r5, lr}
    cbea:	4604      	mov	r4, r0
    cbec:	460d      	mov	r5, r1
	out('E', ctx);
    cbee:	2045      	movs	r0, #69	; 0x45
    cbf0:	47a0      	blx	r4
	out('R', ctx);
    cbf2:	4629      	mov	r1, r5
    cbf4:	2052      	movs	r0, #82	; 0x52
    cbf6:	47a0      	blx	r4
	out('R', ctx);
    cbf8:	4629      	mov	r1, r5
    cbfa:	2052      	movs	r0, #82	; 0x52
    cbfc:	47a0      	blx	r4
}
    cbfe:	bd38      	pop	{r3, r4, r5, pc}

0000cc00 <_printk_hex_ulong>:
{
    cc00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cc04:	b083      	sub	sp, #12
    cc06:	4681      	mov	r9, r0
    cc08:	468a      	mov	sl, r1
    cc0a:	4690      	mov	r8, r2
    cc0c:	461d      	mov	r5, r3
    cc0e:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    cc12:	9301      	str	r3, [sp, #4]
	int digits = 0;
    cc14:	2600      	movs	r6, #0
	int remaining = 16; /* 16 digits max */
    cc16:	f04f 0b10 	mov.w	fp, #16
	int found_largest_digit = 0;
    cc1a:	4637      	mov	r7, r6
	int shift = sizeof(num) * 8;
    cc1c:	2440      	movs	r4, #64	; 0x40
	while (shift >= 4) {
    cc1e:	e007      	b.n	cc30 <_printk_hex_ulong+0x30>
			nibble += nibble > 9 ? 87 : 48;
    cc20:	2809      	cmp	r0, #9
    cc22:	d92a      	bls.n	cc7a <_printk_hex_ulong+0x7a>
    cc24:	2357      	movs	r3, #87	; 0x57
			out((int)nibble, ctx);
    cc26:	4651      	mov	r1, sl
    cc28:	4418      	add	r0, r3
    cc2a:	47c8      	blx	r9
			digits++;
    cc2c:	3601      	adds	r6, #1
			found_largest_digit = 1;
    cc2e:	2701      	movs	r7, #1
	while (shift >= 4) {
    cc30:	2c03      	cmp	r4, #3
    cc32:	dd33      	ble.n	cc9c <_printk_hex_ulong+0x9c>
		shift -= 4;
    cc34:	3c04      	subs	r4, #4
		nibble = (num >> shift) & 0xf;
    cc36:	f1c4 0220 	rsb	r2, r4, #32
    cc3a:	f1a4 0320 	sub.w	r3, r4, #32
    cc3e:	fa28 f004 	lsr.w	r0, r8, r4
    cc42:	fa05 f202 	lsl.w	r2, r5, r2
    cc46:	4310      	orrs	r0, r2
    cc48:	fa25 f303 	lsr.w	r3, r5, r3
    cc4c:	4318      	orrs	r0, r3
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
    cc4e:	f010 000f 	ands.w	r0, r0, #15
    cc52:	d1e5      	bne.n	cc20 <_printk_hex_ulong+0x20>
    cc54:	2f00      	cmp	r7, #0
    cc56:	d1e3      	bne.n	cc20 <_printk_hex_ulong+0x20>
    cc58:	2c00      	cmp	r4, #0
    cc5a:	d0e1      	beq.n	cc20 <_printk_hex_ulong+0x20>
		if (remaining-- <= min_width) {
    cc5c:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
    cc60:	9300      	str	r3, [sp, #0]
    cc62:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    cc64:	459b      	cmp	fp, r3
    cc66:	dc16      	bgt.n	cc96 <_printk_hex_ulong+0x96>
			if (padding == PAD_ZERO_BEFORE) {
    cc68:	9b01      	ldr	r3, [sp, #4]
    cc6a:	2b01      	cmp	r3, #1
    cc6c:	d007      	beq.n	cc7e <_printk_hex_ulong+0x7e>
			} else if (padding == PAD_SPACE_BEFORE) {
    cc6e:	9b01      	ldr	r3, [sp, #4]
    cc70:	2b02      	cmp	r3, #2
    cc72:	d00a      	beq.n	cc8a <_printk_hex_ulong+0x8a>
		if (remaining-- <= min_width) {
    cc74:	f8dd b000 	ldr.w	fp, [sp]
    cc78:	e7da      	b.n	cc30 <_printk_hex_ulong+0x30>
			nibble += nibble > 9 ? 87 : 48;
    cc7a:	2330      	movs	r3, #48	; 0x30
    cc7c:	e7d3      	b.n	cc26 <_printk_hex_ulong+0x26>
				out('0', ctx);
    cc7e:	4651      	mov	r1, sl
    cc80:	2030      	movs	r0, #48	; 0x30
    cc82:	47c8      	blx	r9
		if (remaining-- <= min_width) {
    cc84:	f8dd b000 	ldr.w	fp, [sp]
    cc88:	e7d2      	b.n	cc30 <_printk_hex_ulong+0x30>
				out(' ', ctx);
    cc8a:	4651      	mov	r1, sl
    cc8c:	2020      	movs	r0, #32
    cc8e:	47c8      	blx	r9
		if (remaining-- <= min_width) {
    cc90:	f8dd b000 	ldr.w	fp, [sp]
    cc94:	e7cc      	b.n	cc30 <_printk_hex_ulong+0x30>
    cc96:	f8dd b000 	ldr.w	fp, [sp]
    cc9a:	e7c9      	b.n	cc30 <_printk_hex_ulong+0x30>
	if (padding == PAD_SPACE_AFTER) {
    cc9c:	9b01      	ldr	r3, [sp, #4]
    cc9e:	2b03      	cmp	r3, #3
    cca0:	d002      	beq.n	cca8 <_printk_hex_ulong+0xa8>
}
    cca2:	b003      	add	sp, #12
    cca4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		remaining = min_width * 2 - digits;
    cca8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    ccaa:	ebc6 0643 	rsb	r6, r6, r3, lsl #1
		while (remaining-- > 0) {
    ccae:	e003      	b.n	ccb8 <_printk_hex_ulong+0xb8>
			out(' ', ctx);
    ccb0:	4651      	mov	r1, sl
    ccb2:	2020      	movs	r0, #32
    ccb4:	47c8      	blx	r9
		while (remaining-- > 0) {
    ccb6:	4626      	mov	r6, r4
    ccb8:	1e74      	subs	r4, r6, #1
    ccba:	2e00      	cmp	r6, #0
    ccbc:	dcf8      	bgt.n	ccb0 <_printk_hex_ulong+0xb0>
    ccbe:	e7f0      	b.n	cca2 <_printk_hex_ulong+0xa2>

0000ccc0 <str_out>:
{
    ccc0:	b410      	push	{r4}
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    ccc2:	680c      	ldr	r4, [r1, #0]
    ccc4:	b154      	cbz	r4, ccdc <str_out+0x1c>
    ccc6:	688a      	ldr	r2, [r1, #8]
    ccc8:	684b      	ldr	r3, [r1, #4]
    ccca:	429a      	cmp	r2, r3
    cccc:	da06      	bge.n	ccdc <str_out+0x1c>
	if (ctx->count == ctx->max - 1) {
    ccce:	3b01      	subs	r3, #1
    ccd0:	429a      	cmp	r2, r3
    ccd2:	d008      	beq.n	cce6 <str_out+0x26>
		ctx->str[ctx->count++] = c;
    ccd4:	1c53      	adds	r3, r2, #1
    ccd6:	608b      	str	r3, [r1, #8]
    ccd8:	54a0      	strb	r0, [r4, r2]
    ccda:	e002      	b.n	cce2 <str_out+0x22>
		ctx->count++;
    ccdc:	688b      	ldr	r3, [r1, #8]
    ccde:	3301      	adds	r3, #1
    cce0:	608b      	str	r3, [r1, #8]
}
    cce2:	bc10      	pop	{r4}
    cce4:	4770      	bx	lr
		ctx->str[ctx->count++] = '\0';
    cce6:	1c53      	adds	r3, r2, #1
    cce8:	608b      	str	r3, [r1, #8]
    ccea:	2300      	movs	r3, #0
    ccec:	54a3      	strb	r3, [r4, r2]
    ccee:	e7f8      	b.n	cce2 <str_out+0x22>

0000ccf0 <z_vprintk>:
{
    ccf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ccf4:	b087      	sub	sp, #28
    ccf6:	4607      	mov	r7, r0
    ccf8:	460e      	mov	r6, r1
    ccfa:	4614      	mov	r4, r2
    ccfc:	9305      	str	r3, [sp, #20]
	char length_mod = 0;
    ccfe:	f04f 0800 	mov.w	r8, #0
	int min_width = -1;
    cd02:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
	enum pad_type padding = PAD_NONE;
    cd06:	46c2      	mov	sl, r8
	int might_format = 0; /* 1 if encountered a '%' */
    cd08:	4645      	mov	r5, r8
	while (*fmt) {
    cd0a:	e002      	b.n	cd12 <z_vprintk+0x22>
				out((int)*fmt, ctx);
    cd0c:	4631      	mov	r1, r6
    cd0e:	47b8      	blx	r7
		++fmt;
    cd10:	3401      	adds	r4, #1
	while (*fmt) {
    cd12:	7820      	ldrb	r0, [r4, #0]
    cd14:	2800      	cmp	r0, #0
    cd16:	f000 8187 	beq.w	d028 <z_vprintk+0x338>
		if (!might_format) {
    cd1a:	b945      	cbnz	r5, cd2e <z_vprintk+0x3e>
			if (*fmt != '%') {
    cd1c:	2825      	cmp	r0, #37	; 0x25
    cd1e:	d1f5      	bne.n	cd0c <z_vprintk+0x1c>
				length_mod = 0;
    cd20:	f04f 0800 	mov.w	r8, #0
				min_width = -1;
    cd24:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
				padding = PAD_NONE;
    cd28:	46c2      	mov	sl, r8
				might_format = 1;
    cd2a:	2501      	movs	r5, #1
    cd2c:	e7f0      	b.n	cd10 <z_vprintk+0x20>
			switch (*fmt) {
    cd2e:	4602      	mov	r2, r0
    cd30:	f1a0 0325 	sub.w	r3, r0, #37	; 0x25
    cd34:	2b55      	cmp	r3, #85	; 0x55
    cd36:	f200 8169 	bhi.w	d00c <z_vprintk+0x31c>
    cd3a:	e8df f013 	tbh	[pc, r3, lsl #1]
    cd3e:	0162      	.short	0x0162
    cd40:	01670167 	.word	0x01670167
    cd44:	01670167 	.word	0x01670167
    cd48:	01670167 	.word	0x01670167
    cd4c:	016f0167 	.word	0x016f0167
    cd50:	01670167 	.word	0x01670167
    cd54:	005d0056 	.word	0x005d0056
    cd58:	005d005d 	.word	0x005d005d
    cd5c:	005d005d 	.word	0x005d005d
    cd60:	005d005d 	.word	0x005d005d
    cd64:	005d005d 	.word	0x005d005d
    cd68:	01670167 	.word	0x01670167
    cd6c:	01670167 	.word	0x01670167
    cd70:	01670167 	.word	0x01670167
    cd74:	01670167 	.word	0x01670167
    cd78:	01670167 	.word	0x01670167
    cd7c:	01670167 	.word	0x01670167
    cd80:	01670167 	.word	0x01670167
    cd84:	01670167 	.word	0x01670167
    cd88:	01670167 	.word	0x01670167
    cd8c:	01670167 	.word	0x01670167
    cd90:	01670167 	.word	0x01670167
    cd94:	01670167 	.word	0x01670167
    cd98:	01670167 	.word	0x01670167
    cd9c:	01670167 	.word	0x01670167
    cda0:	01670167 	.word	0x01670167
    cda4:	0167010c 	.word	0x0167010c
    cda8:	01670167 	.word	0x01670167
    cdac:	01670167 	.word	0x01670167
    cdb0:	01670167 	.word	0x01670167
    cdb4:	01670167 	.word	0x01670167
    cdb8:	015a0167 	.word	0x015a0167
    cdbc:	0167008a 	.word	0x0167008a
    cdc0:	01670167 	.word	0x01670167
    cdc4:	008a0070 	.word	0x008a0070
    cdc8:	01670167 	.word	0x01670167
    cdcc:	01670070 	.word	0x01670070
    cdd0:	01670167 	.word	0x01670167
    cdd4:	01670102 	.word	0x01670102
    cdd8:	013a0167 	.word	0x013a0167
    cddc:	00cf0167 	.word	0x00cf0167
    cde0:	01670167 	.word	0x01670167
    cde4:	0167010c 	.word	0x0167010c
    cde8:	0070      	.short	0x0070
				if (min_width < 0 && padding == PAD_NONE) {
    cdea:	f1b9 0f00 	cmp.w	r9, #0
    cdee:	da03      	bge.n	cdf8 <z_vprintk+0x108>
    cdf0:	f1ba 0f00 	cmp.w	sl, #0
    cdf4:	f000 8115 	beq.w	d022 <z_vprintk+0x332>
				if (min_width < 0) {
    cdf8:	f1b9 0f00 	cmp.w	r9, #0
    cdfc:	db0c      	blt.n	ce18 <z_vprintk+0x128>
					min_width = 10 * min_width + *fmt - '0';
    cdfe:	eb09 0989 	add.w	r9, r9, r9, lsl #2
    ce02:	eb02 0949 	add.w	r9, r2, r9, lsl #1
    ce06:	f1a9 0930 	sub.w	r9, r9, #48	; 0x30
				if (padding == PAD_NONE) {
    ce0a:	f1ba 0f00 	cmp.w	sl, #0
    ce0e:	f47f af7f 	bne.w	cd10 <z_vprintk+0x20>
					padding = PAD_SPACE_BEFORE;
    ce12:	f04f 0a02 	mov.w	sl, #2
				goto still_might_format;
    ce16:	e77b      	b.n	cd10 <z_vprintk+0x20>
					min_width = *fmt - '0';
    ce18:	f1a2 0930 	sub.w	r9, r2, #48	; 0x30
    ce1c:	e7f5      	b.n	ce0a <z_vprintk+0x11a>
				if (*fmt == 'h' && length_mod == 'h') {
    ce1e:	2868      	cmp	r0, #104	; 0x68
    ce20:	d00c      	beq.n	ce3c <z_vprintk+0x14c>
				} else if (*fmt == 'l' && length_mod == 'l') {
    ce22:	286c      	cmp	r0, #108	; 0x6c
    ce24:	d010      	beq.n	ce48 <z_vprintk+0x158>
				} else if (length_mod == 0) {
    ce26:	f1b8 0f00 	cmp.w	r8, #0
    ce2a:	d00b      	beq.n	ce44 <z_vprintk+0x154>
					out((int)'%', ctx);
    ce2c:	4631      	mov	r1, r6
    ce2e:	2025      	movs	r0, #37	; 0x25
    ce30:	47b8      	blx	r7
					out((int)*fmt, ctx);
    ce32:	4631      	mov	r1, r6
    ce34:	7820      	ldrb	r0, [r4, #0]
    ce36:	47b8      	blx	r7
			might_format = 0;
    ce38:	2500      	movs	r5, #0
					break;
    ce3a:	e769      	b.n	cd10 <z_vprintk+0x20>
				if (*fmt == 'h' && length_mod == 'h') {
    ce3c:	f1b8 0f68 	cmp.w	r8, #104	; 0x68
    ce40:	d1ef      	bne.n	ce22 <z_vprintk+0x132>
					length_mod = 'H';
    ce42:	2048      	movs	r0, #72	; 0x48
				goto still_might_format;
    ce44:	4680      	mov	r8, r0
    ce46:	e763      	b.n	cd10 <z_vprintk+0x20>
				} else if (*fmt == 'l' && length_mod == 'l') {
    ce48:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
    ce4c:	d1eb      	bne.n	ce26 <z_vprintk+0x136>
					length_mod = 'L';
    ce4e:	204c      	movs	r0, #76	; 0x4c
    ce50:	e7f8      	b.n	ce44 <z_vprintk+0x154>
				if (length_mod == 'z') {
    ce52:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
    ce56:	d00a      	beq.n	ce6e <z_vprintk+0x17e>
				} else if (length_mod == 'l') {
    ce58:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
    ce5c:	d017      	beq.n	ce8e <z_vprintk+0x19e>
				} else if (length_mod == 'L') {
    ce5e:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
    ce62:	d019      	beq.n	ce98 <z_vprintk+0x1a8>
					d = va_arg(ap, int);
    ce64:	9b05      	ldr	r3, [sp, #20]
    ce66:	1d1a      	adds	r2, r3, #4
    ce68:	9205      	str	r2, [sp, #20]
    ce6a:	681d      	ldr	r5, [r3, #0]
    ce6c:	e003      	b.n	ce76 <z_vprintk+0x186>
					d = va_arg(ap, ssize_t);
    ce6e:	9b05      	ldr	r3, [sp, #20]
    ce70:	1d1a      	adds	r2, r3, #4
    ce72:	9205      	str	r2, [sp, #20]
    ce74:	681d      	ldr	r5, [r3, #0]
				if (d < 0) {
    ce76:	2d00      	cmp	r5, #0
    ce78:	db29      	blt.n	cece <z_vprintk+0x1de>
				_printk_dec_ulong(out, ctx, d, padding,
    ce7a:	f8cd 9000 	str.w	r9, [sp]
    ce7e:	4653      	mov	r3, sl
    ce80:	462a      	mov	r2, r5
    ce82:	4631      	mov	r1, r6
    ce84:	4638      	mov	r0, r7
    ce86:	f7f4 fa05 	bl	1294 <_printk_dec_ulong>
			might_format = 0;
    ce8a:	2500      	movs	r5, #0
				break;
    ce8c:	e740      	b.n	cd10 <z_vprintk+0x20>
					d = va_arg(ap, long);
    ce8e:	9b05      	ldr	r3, [sp, #20]
    ce90:	1d1a      	adds	r2, r3, #4
    ce92:	9205      	str	r2, [sp, #20]
    ce94:	681d      	ldr	r5, [r3, #0]
    ce96:	e7ee      	b.n	ce76 <z_vprintk+0x186>
					long long lld = va_arg(ap, long long);
    ce98:	9b05      	ldr	r3, [sp, #20]
    ce9a:	3307      	adds	r3, #7
    ce9c:	f023 0307 	bic.w	r3, r3, #7
    cea0:	f103 0208 	add.w	r2, r3, #8
    cea4:	9205      	str	r2, [sp, #20]
    cea6:	681d      	ldr	r5, [r3, #0]
    cea8:	685b      	ldr	r3, [r3, #4]
					if (lld > __LONG_MAX__ ||
    ceaa:	f115 4200 	adds.w	r2, r5, #2147483648	; 0x80000000
    ceae:	9202      	str	r2, [sp, #8]
    ceb0:	f143 0300 	adc.w	r3, r3, #0
    ceb4:	9303      	str	r3, [sp, #12]
    ceb6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    ceba:	2b01      	cmp	r3, #1
    cebc:	bf08      	it	eq
    cebe:	2a00      	cmpeq	r2, #0
    cec0:	d3d9      	bcc.n	ce76 <z_vprintk+0x186>
						print_err(out, ctx);
    cec2:	4631      	mov	r1, r6
    cec4:	4638      	mov	r0, r7
    cec6:	f7ff fe8f 	bl	cbe8 <print_err>
			might_format = 0;
    ceca:	2500      	movs	r5, #0
						break;
    cecc:	e720      	b.n	cd10 <z_vprintk+0x20>
					out((int)'-', ctx);
    cece:	4631      	mov	r1, r6
    ced0:	202d      	movs	r0, #45	; 0x2d
    ced2:	47b8      	blx	r7
					d = -d;
    ced4:	426d      	negs	r5, r5
					min_width--;
    ced6:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
    ceda:	e7ce      	b.n	ce7a <z_vprintk+0x18a>
				if (length_mod == 'z') {
    cedc:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
    cee0:	d00a      	beq.n	cef8 <z_vprintk+0x208>
				} else if (length_mod == 'l') {
    cee2:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
    cee6:	d014      	beq.n	cf12 <z_vprintk+0x222>
				} else if (length_mod == 'L') {
    cee8:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
    ceec:	d016      	beq.n	cf1c <z_vprintk+0x22c>
					u = va_arg(ap, unsigned int);
    ceee:	9b05      	ldr	r3, [sp, #20]
    cef0:	1d1a      	adds	r2, r3, #4
    cef2:	9205      	str	r2, [sp, #20]
    cef4:	681a      	ldr	r2, [r3, #0]
    cef6:	e003      	b.n	cf00 <z_vprintk+0x210>
					u = va_arg(ap, size_t);
    cef8:	9b05      	ldr	r3, [sp, #20]
    cefa:	1d1a      	adds	r2, r3, #4
    cefc:	9205      	str	r2, [sp, #20]
    cefe:	681a      	ldr	r2, [r3, #0]
				_printk_dec_ulong(out, ctx, u, padding,
    cf00:	f8cd 9000 	str.w	r9, [sp]
    cf04:	4653      	mov	r3, sl
    cf06:	4631      	mov	r1, r6
    cf08:	4638      	mov	r0, r7
    cf0a:	f7f4 f9c3 	bl	1294 <_printk_dec_ulong>
			might_format = 0;
    cf0e:	2500      	movs	r5, #0
				break;
    cf10:	e6fe      	b.n	cd10 <z_vprintk+0x20>
					u = va_arg(ap, unsigned long);
    cf12:	9b05      	ldr	r3, [sp, #20]
    cf14:	1d1a      	adds	r2, r3, #4
    cf16:	9205      	str	r2, [sp, #20]
    cf18:	681a      	ldr	r2, [r3, #0]
    cf1a:	e7f1      	b.n	cf00 <z_vprintk+0x210>
					unsigned long long llu =
    cf1c:	9b05      	ldr	r3, [sp, #20]
    cf1e:	3307      	adds	r3, #7
    cf20:	f023 0307 	bic.w	r3, r3, #7
    cf24:	f103 0208 	add.w	r2, r3, #8
    cf28:	9205      	str	r2, [sp, #20]
    cf2a:	e9d3 2300 	ldrd	r2, r3, [r3]
					if (llu > ~0UL) {
    cf2e:	2b01      	cmp	r3, #1
    cf30:	bf08      	it	eq
    cf32:	2a00      	cmpeq	r2, #0
    cf34:	d3e4      	bcc.n	cf00 <z_vprintk+0x210>
						print_err(out, ctx);
    cf36:	4631      	mov	r1, r6
    cf38:	4638      	mov	r0, r7
    cf3a:	f7ff fe55 	bl	cbe8 <print_err>
			might_format = 0;
    cf3e:	2500      	movs	r5, #0
						break;
    cf40:	e6e6      	b.n	cd10 <z_vprintk+0x20>
				out('0', ctx);
    cf42:	4631      	mov	r1, r6
    cf44:	2030      	movs	r0, #48	; 0x30
    cf46:	47b8      	blx	r7
				out('x', ctx);
    cf48:	4631      	mov	r1, r6
    cf4a:	2078      	movs	r0, #120	; 0x78
    cf4c:	47b8      	blx	r7
					min_width = 8;
    cf4e:	f04f 0908 	mov.w	r9, #8
				padding = PAD_ZERO_BEFORE;
    cf52:	f04f 0a01 	mov.w	sl, #1
				if (*fmt == 'p') {
    cf56:	7823      	ldrb	r3, [r4, #0]
    cf58:	2b70      	cmp	r3, #112	; 0x70
    cf5a:	d00b      	beq.n	cf74 <z_vprintk+0x284>
				} else if (length_mod == 'l') {
    cf5c:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
    cf60:	d017      	beq.n	cf92 <z_vprintk+0x2a2>
				} else if (length_mod == 'L') {
    cf62:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
    cf66:	d01a      	beq.n	cf9e <z_vprintk+0x2ae>
					x = va_arg(ap, unsigned int);
    cf68:	9b05      	ldr	r3, [sp, #20]
    cf6a:	1d1a      	adds	r2, r3, #4
    cf6c:	9205      	str	r2, [sp, #20]
    cf6e:	681a      	ldr	r2, [r3, #0]
    cf70:	2300      	movs	r3, #0
    cf72:	e004      	b.n	cf7e <z_vprintk+0x28e>
					x = (uintptr_t)va_arg(ap, void *);
    cf74:	9b05      	ldr	r3, [sp, #20]
    cf76:	1d1a      	adds	r2, r3, #4
    cf78:	9205      	str	r2, [sp, #20]
    cf7a:	681a      	ldr	r2, [r3, #0]
    cf7c:	2300      	movs	r3, #0
				_printk_hex_ulong(out, ctx, x, padding,
    cf7e:	f8cd 9004 	str.w	r9, [sp, #4]
    cf82:	f8cd a000 	str.w	sl, [sp]
    cf86:	4631      	mov	r1, r6
    cf88:	4638      	mov	r0, r7
    cf8a:	f7ff fe39 	bl	cc00 <_printk_hex_ulong>
			might_format = 0;
    cf8e:	2500      	movs	r5, #0
				break;
    cf90:	e6be      	b.n	cd10 <z_vprintk+0x20>
					x = va_arg(ap, unsigned long);
    cf92:	9b05      	ldr	r3, [sp, #20]
    cf94:	1d1a      	adds	r2, r3, #4
    cf96:	9205      	str	r2, [sp, #20]
    cf98:	681a      	ldr	r2, [r3, #0]
    cf9a:	2300      	movs	r3, #0
    cf9c:	e7ef      	b.n	cf7e <z_vprintk+0x28e>
					x = va_arg(ap, unsigned long long);
    cf9e:	9b05      	ldr	r3, [sp, #20]
    cfa0:	3307      	adds	r3, #7
    cfa2:	f023 0307 	bic.w	r3, r3, #7
    cfa6:	f103 0208 	add.w	r2, r3, #8
    cfaa:	9205      	str	r2, [sp, #20]
    cfac:	681a      	ldr	r2, [r3, #0]
    cfae:	685b      	ldr	r3, [r3, #4]
    cfb0:	e7e5      	b.n	cf7e <z_vprintk+0x28e>
				char *s = va_arg(ap, char *);
    cfb2:	9b05      	ldr	r3, [sp, #20]
    cfb4:	1d1a      	adds	r2, r3, #4
    cfb6:	9205      	str	r2, [sp, #20]
    cfb8:	f8d3 b000 	ldr.w	fp, [r3]
    cfbc:	465d      	mov	r5, fp
				while (*s) {
    cfbe:	e002      	b.n	cfc6 <z_vprintk+0x2d6>
					out((int)(*s++), ctx);
    cfc0:	3501      	adds	r5, #1
    cfc2:	4631      	mov	r1, r6
    cfc4:	47b8      	blx	r7
				while (*s) {
    cfc6:	7828      	ldrb	r0, [r5, #0]
    cfc8:	2800      	cmp	r0, #0
    cfca:	d1f9      	bne.n	cfc0 <z_vprintk+0x2d0>
				if (padding == PAD_SPACE_AFTER) {
    cfcc:	f1ba 0f03 	cmp.w	sl, #3
    cfd0:	d001      	beq.n	cfd6 <z_vprintk+0x2e6>
			might_format = 0;
    cfd2:	2500      	movs	r5, #0
    cfd4:	e69c      	b.n	cd10 <z_vprintk+0x20>
					int remaining = min_width - (s - start);
    cfd6:	eba5 030b 	sub.w	r3, r5, fp
    cfda:	eba9 0303 	sub.w	r3, r9, r3
					while (remaining-- > 0) {
    cfde:	e003      	b.n	cfe8 <z_vprintk+0x2f8>
						out(' ', ctx);
    cfe0:	4631      	mov	r1, r6
    cfe2:	2020      	movs	r0, #32
    cfe4:	47b8      	blx	r7
					while (remaining-- > 0) {
    cfe6:	462b      	mov	r3, r5
    cfe8:	1e5d      	subs	r5, r3, #1
    cfea:	2b00      	cmp	r3, #0
    cfec:	dcf8      	bgt.n	cfe0 <z_vprintk+0x2f0>
			might_format = 0;
    cfee:	2500      	movs	r5, #0
    cff0:	e68e      	b.n	cd10 <z_vprintk+0x20>
				int c = va_arg(ap, int);
    cff2:	9b05      	ldr	r3, [sp, #20]
    cff4:	1d1a      	adds	r2, r3, #4
    cff6:	9205      	str	r2, [sp, #20]
				out(c, ctx);
    cff8:	4631      	mov	r1, r6
    cffa:	6818      	ldr	r0, [r3, #0]
    cffc:	47b8      	blx	r7
			might_format = 0;
    cffe:	2500      	movs	r5, #0
				break;
    d000:	e686      	b.n	cd10 <z_vprintk+0x20>
				out((int)'%', ctx);
    d002:	4631      	mov	r1, r6
    d004:	2025      	movs	r0, #37	; 0x25
    d006:	47b8      	blx	r7
			might_format = 0;
    d008:	2500      	movs	r5, #0
				break;
    d00a:	e681      	b.n	cd10 <z_vprintk+0x20>
				out((int)'%', ctx);
    d00c:	4631      	mov	r1, r6
    d00e:	2025      	movs	r0, #37	; 0x25
    d010:	47b8      	blx	r7
				out((int)*fmt, ctx);
    d012:	4631      	mov	r1, r6
    d014:	7820      	ldrb	r0, [r4, #0]
    d016:	47b8      	blx	r7
			might_format = 0;
    d018:	2500      	movs	r5, #0
				break;
    d01a:	e679      	b.n	cd10 <z_vprintk+0x20>
			switch (*fmt) {
    d01c:	f04f 0a03 	mov.w	sl, #3
    d020:	e676      	b.n	cd10 <z_vprintk+0x20>
					padding = PAD_ZERO_BEFORE;
    d022:	f04f 0a01 	mov.w	sl, #1
    d026:	e673      	b.n	cd10 <z_vprintk+0x20>
}
    d028:	b007      	add	sp, #28
    d02a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000d02e <printk>:
{
    d02e:	b40f      	push	{r0, r1, r2, r3}
    d030:	b500      	push	{lr}
    d032:	b083      	sub	sp, #12
    d034:	a904      	add	r1, sp, #16
    d036:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
    d03a:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
    d03c:	f7f4 f984 	bl	1348 <vprintk>
}
    d040:	b003      	add	sp, #12
    d042:	f85d eb04 	ldr.w	lr, [sp], #4
    d046:	b004      	add	sp, #16
    d048:	4770      	bx	lr

0000d04a <snprintk>:
{
    d04a:	b40c      	push	{r2, r3}
    d04c:	b500      	push	{lr}
    d04e:	b083      	sub	sp, #12
    d050:	ab04      	add	r3, sp, #16
    d052:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
    d056:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
    d058:	f7f4 f986 	bl	1368 <vsnprintk>
}
    d05c:	b003      	add	sp, #12
    d05e:	f85d eb04 	ldr.w	lr, [sp], #4
    d062:	b002      	add	sp, #8
    d064:	4770      	bx	lr

0000d066 <sys_sem_give>:

	return 0;
}

int sys_sem_give(struct sys_sem *sem)
{
    d066:	b508      	push	{r3, lr}
	z_impl_k_sem_give(sem);
    d068:	f7fe f948 	bl	b2fc <z_impl_k_sem_give>
	k_sem_give(&sem->kernel_sem);

	return 0;
}
    d06c:	2000      	movs	r0, #0
    d06e:	bd08      	pop	{r3, pc}

0000d070 <sys_sem_take>:

int sys_sem_take(struct sys_sem *sem, k_timeout_t timeout)
{
    d070:	b508      	push	{r3, lr}
	return z_impl_k_sem_take(sem, timeout);
    d072:	f7fe f96b 	bl	b34c <z_impl_k_sem_take>
	int ret_value = 0;

	ret_value = k_sem_take(&sem->kernel_sem, timeout);
	if (ret_value == -EAGAIN || ret_value == -EBUSY) {
    d076:	f110 0f0b 	cmn.w	r0, #11
    d07a:	d003      	beq.n	d084 <sys_sem_take+0x14>
    d07c:	f110 0f10 	cmn.w	r0, #16
    d080:	d003      	beq.n	d08a <sys_sem_take+0x1a>
		ret_value = -ETIMEDOUT;
	}

	return ret_value;
}
    d082:	bd08      	pop	{r3, pc}
		ret_value = -ETIMEDOUT;
    d084:	f06f 0073 	mvn.w	r0, #115	; 0x73
    d088:	e7fb      	b.n	d082 <sys_sem_take+0x12>
    d08a:	f06f 0073 	mvn.w	r0, #115	; 0x73
	return ret_value;
    d08e:	e7f8      	b.n	d082 <sys_sem_take+0x12>

0000d090 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    d090:	b508      	push	{r3, lr}
    d092:	4604      	mov	r4, r0
    d094:	4608      	mov	r0, r1
    d096:	4611      	mov	r1, r2
	entry(p1, p2, p3);
    d098:	461a      	mov	r2, r3
    d09a:	47a0      	blx	r4
	return z_impl_k_current_get();
    d09c:	f7fe f928 	bl	b2f0 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
    d0a0:	f7f6 f8e2 	bl	3268 <z_impl_k_thread_abort>

0000d0a4 <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
    d0a4:	b538      	push	{r3, r4, r5, lr}
    d0a6:	4604      	mov	r4, r0
	struct k_work_q *work_q = work_q_ptr;
    d0a8:	e001      	b.n	d0ae <z_work_q_main+0xa>
	z_impl_k_yield();
    d0aa:	f7fe f861 	bl	b170 <z_impl_k_yield>
	return z_impl_k_queue_get(queue, timeout);
    d0ae:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    d0b2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    d0b6:	4620      	mov	r0, r4
    d0b8:	f7fd fd14 	bl	aae4 <z_impl_k_queue_get>
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
    d0bc:	4603      	mov	r3, r0
    d0be:	2800      	cmp	r0, #0
    d0c0:	d0f5      	beq.n	d0ae <z_work_q_main+0xa>
			continue;
		}

		handler = work->handler;
    d0c2:	6845      	ldr	r5, [r0, #4]

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
    d0c4:	f100 0208 	add.w	r2, r0, #8
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    d0c8:	f3bf 8f5b 	dmb	ish
    d0cc:	e852 1f00 	ldrex	r1, [r2]
    d0d0:	f021 0001 	bic.w	r0, r1, #1
    d0d4:	e842 0c00 	strex	ip, r0, [r2]
    d0d8:	f1bc 0f00 	cmp.w	ip, #0
    d0dc:	d1f6      	bne.n	d0cc <z_work_q_main+0x28>
    d0de:	f3bf 8f5b 	dmb	ish
    d0e2:	f011 0f01 	tst.w	r1, #1
    d0e6:	d0e0      	beq.n	d0aa <z_work_q_main+0x6>
					      K_WORK_STATE_PENDING)) {
			handler(work);
    d0e8:	4618      	mov	r0, r3
    d0ea:	47a8      	blx	r5
    d0ec:	e7dd      	b.n	d0aa <z_work_q_main+0x6>

0000d0ee <chunk_mem>:
#include <kernel.h>
#include "heap.h"

static void *chunk_mem(struct z_heap *h, chunkid_t c)
{
	u8_t *ret = ((u8_t *)&h->buf[c]) + chunk_header_bytes(h);
    d0ee:	6803      	ldr	r3, [r0, #0]
    d0f0:	00c9      	lsls	r1, r1, #3
	size_t list_size;
};

static inline bool big_heap(struct z_heap *h)
{
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d0f2:	6882      	ldr	r2, [r0, #8]
	return c + size(h, c);
}

static inline size_t chunk_header_bytes(struct z_heap *h)
{
	return big_heap(h) ? 8 : 4;
    d0f4:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    d0f8:	d303      	bcc.n	d102 <chunk_mem+0x14>
    d0fa:	2008      	movs	r0, #8
    d0fc:	4408      	add	r0, r1

	CHECK(!(((size_t)ret) & (big_heap(h) ? 7 : 3)));

	return ret;
}
    d0fe:	4418      	add	r0, r3
    d100:	4770      	bx	lr
    d102:	2004      	movs	r0, #4
    d104:	e7fa      	b.n	d0fc <chunk_mem+0xe>

0000d106 <free_list_remove>:

static void free_list_remove(struct z_heap *h, int bidx,
			     chunkid_t c)
{
    d106:	b430      	push	{r4, r5}
	struct z_heap_bucket *b = &h->buckets[bidx];
    d108:	6844      	ldr	r4, [r0, #4]
    d10a:	eb04 05c1 	add.w	r5, r4, r1, lsl #3
	CHECK(b->next != 0);
	CHECK(b->list_size > 0);
	CHECK((((h->avail_buckets & (1 << bidx)) == 0)
	       == (h->buckets[bidx].next == 0)));

	b->list_size--;
    d10e:	686b      	ldr	r3, [r5, #4]
    d110:	3b01      	subs	r3, #1
    d112:	606b      	str	r3, [r5, #4]

	if (b->list_size == 0) {
    d114:	b95b      	cbnz	r3, d12e <free_list_remove+0x28>
		h->avail_buckets &= ~(1 << bidx);
    d116:	2301      	movs	r3, #1
    d118:	fa03 f201 	lsl.w	r2, r3, r1
    d11c:	6943      	ldr	r3, [r0, #20]
    d11e:	ea23 0302 	bic.w	r3, r3, r2
    d122:	6143      	str	r3, [r0, #20]
		b->next = 0;
    d124:	2300      	movs	r3, #0
    d126:	f844 3031 	str.w	r3, [r4, r1, lsl #3]

		b->next = second;
		chunk_set(h, first, FREE_NEXT, second);
		chunk_set(h, second, FREE_PREV, first);
	}
}
    d12a:	bc30      	pop	{r4, r5}
    d12c:	4770      	bx	lr
	void *cmem = &h->buf[c];
    d12e:	6803      	ldr	r3, [r0, #0]
    d130:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d134:	6883      	ldr	r3, [r0, #8]
	if (big_heap(h)) {
    d136:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    d13a:	d317      	bcc.n	d16c <free_list_remove+0x66>
		return ((u32_t *)cmem)[f];
    d13c:	6895      	ldr	r5, [r2, #8]
	if (big_heap(h)) {
    d13e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    d142:	d315      	bcc.n	d170 <free_list_remove+0x6a>
		return ((u32_t *)cmem)[f];
    d144:	68d2      	ldr	r2, [r2, #12]
		b->next = second;
    d146:	f844 2031 	str.w	r2, [r4, r1, lsl #3]
	void *cmem = &h->buf[c];
    d14a:	6803      	ldr	r3, [r0, #0]
    d14c:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d150:	6881      	ldr	r1, [r0, #8]
	if (big_heap(h)) {
    d152:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
    d156:	d30d      	bcc.n	d174 <free_list_remove+0x6e>
		((u32_t *)cmem)[f] = (u32_t) val;
    d158:	60da      	str	r2, [r3, #12]
	void *cmem = &h->buf[c];
    d15a:	6803      	ldr	r3, [r0, #0]
    d15c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d160:	6882      	ldr	r2, [r0, #8]
	if (big_heap(h)) {
    d162:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    d166:	d307      	bcc.n	d178 <free_list_remove+0x72>
		((u32_t *)cmem)[f] = (u32_t) val;
    d168:	609d      	str	r5, [r3, #8]
    d16a:	e7de      	b.n	d12a <free_list_remove+0x24>
		return ((u16_t *)cmem)[f];
    d16c:	8895      	ldrh	r5, [r2, #4]
    d16e:	e7e6      	b.n	d13e <free_list_remove+0x38>
    d170:	88d2      	ldrh	r2, [r2, #6]
    d172:	e7e8      	b.n	d146 <free_list_remove+0x40>
		((u16_t *)cmem)[f] = (u16_t) val;
    d174:	80da      	strh	r2, [r3, #6]
    d176:	e7f0      	b.n	d15a <free_list_remove+0x54>
    d178:	809d      	strh	r5, [r3, #4]
}
    d17a:	e7d6      	b.n	d12a <free_list_remove+0x24>

0000d17c <bucket_idx>:
}

static int bucket_idx(struct z_heap *h, size_t sz)
{
	/* A chunk of size 2 is the minimum size on big heaps */
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
    d17c:	fab1 f181 	clz	r1, r1
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d180:	6880      	ldr	r0, [r0, #8]
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
    d182:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
    d186:	bf34      	ite	cc
    d188:	4608      	movcc	r0, r1
    d18a:	1c48      	addcs	r0, r1, #1
}
    d18c:	f1c0 001f 	rsb	r0, r0, #31
    d190:	4770      	bx	lr

0000d192 <free_list_add>:

static void free_list_add(struct z_heap *h, chunkid_t c)
{
    d192:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d194:	4604      	mov	r4, r0
    d196:	460d      	mov	r5, r1
	void *cmem = &h->buf[c];
    d198:	6803      	ldr	r3, [r0, #0]
    d19a:	00ce      	lsls	r6, r1, #3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d19c:	6882      	ldr	r2, [r0, #8]
	if (big_heap(h)) {
    d19e:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    d1a2:	d325      	bcc.n	d1f0 <free_list_add+0x5e>
		return ((u32_t *)cmem)[f];
    d1a4:	f853 3031 	ldr.w	r3, [r3, r1, lsl #3]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
    d1a8:	68e1      	ldr	r1, [r4, #12]
	int b = bucket_idx(h, size(h, c));
    d1aa:	4019      	ands	r1, r3
    d1ac:	4620      	mov	r0, r4
    d1ae:	f7ff ffe5 	bl	d17c <bucket_idx>

	if (h->buckets[b].list_size++ == 0) {
    d1b2:	6863      	ldr	r3, [r4, #4]
    d1b4:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    d1b8:	685a      	ldr	r2, [r3, #4]
    d1ba:	1c51      	adds	r1, r2, #1
    d1bc:	6059      	str	r1, [r3, #4]
    d1be:	b9f2      	cbnz	r2, d1fe <free_list_add+0x6c>
		CHECK(h->buckets[b].next == 0);
		CHECK((h->avail_buckets & (1 << b)) == 0);

		/* Empty list, first item */
		h->avail_buckets |= (1 << b);
    d1c0:	2301      	movs	r3, #1
    d1c2:	fa03 f200 	lsl.w	r2, r3, r0
    d1c6:	6963      	ldr	r3, [r4, #20]
    d1c8:	4313      	orrs	r3, r2
    d1ca:	6163      	str	r3, [r4, #20]
		h->buckets[b].next = c;
    d1cc:	6863      	ldr	r3, [r4, #4]
    d1ce:	f843 5030 	str.w	r5, [r3, r0, lsl #3]
	void *cmem = &h->buf[c];
    d1d2:	6823      	ldr	r3, [r4, #0]
    d1d4:	4433      	add	r3, r6
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d1d6:	68a2      	ldr	r2, [r4, #8]
	if (big_heap(h)) {
    d1d8:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    d1dc:	d30b      	bcc.n	d1f6 <free_list_add+0x64>
		((u32_t *)cmem)[f] = (u32_t) val;
    d1de:	609d      	str	r5, [r3, #8]
	void *cmem = &h->buf[c];
    d1e0:	6823      	ldr	r3, [r4, #0]
    d1e2:	441e      	add	r6, r3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d1e4:	68a3      	ldr	r3, [r4, #8]
	if (big_heap(h)) {
    d1e6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    d1ea:	d306      	bcc.n	d1fa <free_list_add+0x68>
		((u32_t *)cmem)[f] = (u32_t) val;
    d1ec:	60f5      	str	r5, [r6, #12]
		chunk_set(h, first, FREE_NEXT, c);
		chunk_set(h, second, FREE_PREV, c);
	}

	CHECK(h->avail_buckets & (1 << bucket_idx(h, size(h, c))));
}
    d1ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return ((u16_t *)cmem)[f];
    d1f0:	f833 3031 	ldrh.w	r3, [r3, r1, lsl #3]
    d1f4:	e7d8      	b.n	d1a8 <free_list_add+0x16>
		((u16_t *)cmem)[f] = (u16_t) val;
    d1f6:	809d      	strh	r5, [r3, #4]
    d1f8:	e7f2      	b.n	d1e0 <free_list_add+0x4e>
    d1fa:	80f5      	strh	r5, [r6, #6]
    d1fc:	e7f7      	b.n	d1ee <free_list_add+0x5c>
		chunkid_t second = h->buckets[b].next;
    d1fe:	6863      	ldr	r3, [r4, #4]
    d200:	f853 0030 	ldr.w	r0, [r3, r0, lsl #3]
	void *cmem = &h->buf[c];
    d204:	6823      	ldr	r3, [r4, #0]
    d206:	ea4f 0cc0 	mov.w	ip, r0, lsl #3
    d20a:	eb03 01c0 	add.w	r1, r3, r0, lsl #3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d20e:	68a2      	ldr	r2, [r4, #8]
	if (big_heap(h)) {
    d210:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    d214:	d31c      	bcc.n	d250 <free_list_add+0xbe>
		return ((u32_t *)cmem)[f];
    d216:	688f      	ldr	r7, [r1, #8]
	void *cmem = &h->buf[c];
    d218:	4433      	add	r3, r6
	if (big_heap(h)) {
    d21a:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    d21e:	d319      	bcc.n	d254 <free_list_add+0xc2>
		((u32_t *)cmem)[f] = (u32_t) val;
    d220:	609f      	str	r7, [r3, #8]
	void *cmem = &h->buf[c];
    d222:	6821      	ldr	r1, [r4, #0]
    d224:	440e      	add	r6, r1
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d226:	68a3      	ldr	r3, [r4, #8]
	if (big_heap(h)) {
    d228:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    d22c:	d314      	bcc.n	d258 <free_list_add+0xc6>
		((u32_t *)cmem)[f] = (u32_t) val;
    d22e:	60f0      	str	r0, [r6, #12]
	void *cmem = &h->buf[c];
    d230:	6822      	ldr	r2, [r4, #0]
    d232:	eb02 02c7 	add.w	r2, r2, r7, lsl #3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d236:	68a3      	ldr	r3, [r4, #8]
	if (big_heap(h)) {
    d238:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    d23c:	d30e      	bcc.n	d25c <free_list_add+0xca>
		((u32_t *)cmem)[f] = (u32_t) val;
    d23e:	60d5      	str	r5, [r2, #12]
	void *cmem = &h->buf[c];
    d240:	6823      	ldr	r3, [r4, #0]
    d242:	4463      	add	r3, ip
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d244:	68a2      	ldr	r2, [r4, #8]
	if (big_heap(h)) {
    d246:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    d24a:	d309      	bcc.n	d260 <free_list_add+0xce>
		((u32_t *)cmem)[f] = (u32_t) val;
    d24c:	609d      	str	r5, [r3, #8]
    d24e:	e7ce      	b.n	d1ee <free_list_add+0x5c>
		return ((u16_t *)cmem)[f];
    d250:	888f      	ldrh	r7, [r1, #4]
    d252:	e7e1      	b.n	d218 <free_list_add+0x86>
		((u16_t *)cmem)[f] = (u16_t) val;
    d254:	809f      	strh	r7, [r3, #4]
    d256:	e7e4      	b.n	d222 <free_list_add+0x90>
    d258:	80f0      	strh	r0, [r6, #6]
    d25a:	e7e9      	b.n	d230 <free_list_add+0x9e>
    d25c:	80d5      	strh	r5, [r2, #6]
    d25e:	e7ef      	b.n	d240 <free_list_add+0xae>
    d260:	809d      	strh	r5, [r3, #4]
}
    d262:	e7c4      	b.n	d1ee <free_list_add+0x5c>

0000d264 <split_alloc>:

/* Allocates (fit check has already been perfomred) from the next
 * chunk at the specified bucket level
 */
static void *split_alloc(struct z_heap *h, int bidx, size_t sz)
{
    d264:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d266:	4604      	mov	r4, r0
    d268:	4616      	mov	r6, r2
	CHECK(h->buckets[bidx].next != 0
	      && sz <= size(h, h->buckets[bidx].next));

	chunkid_t c = h->buckets[bidx].next;
    d26a:	6843      	ldr	r3, [r0, #4]
    d26c:	f853 5031 	ldr.w	r5, [r3, r1, lsl #3]

	free_list_remove(h, bidx, c);
    d270:	462a      	mov	r2, r5
    d272:	f7ff ff48 	bl	d106 <free_list_remove>
	void *cmem = &h->buf[c];
    d276:	6827      	ldr	r7, [r4, #0]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d278:	68a2      	ldr	r2, [r4, #8]
	if (big_heap(h)) {
    d27a:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    d27e:	d34b      	bcc.n	d318 <split_alloc+0xb4>
		return ((u32_t *)cmem)[f];
    d280:	f857 1035 	ldr.w	r1, [r7, r5, lsl #3]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
    d284:	68e3      	ldr	r3, [r4, #12]
    d286:	400b      	ands	r3, r1

	/* Split off remainder if it's usefully large */
	size_t rem = size(h, c) - sz;
    d288:	1b98      	subs	r0, r3, r6

	CHECK(rem < h->len);

	if (rem >= (big_heap(h) ? 2 : 1)) {
    d28a:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    d28e:	d346      	bcc.n	d31e <split_alloc+0xba>
    d290:	2102      	movs	r1, #2
    d292:	4281      	cmp	r1, r0
    d294:	d82b      	bhi.n	d2ee <split_alloc+0x8a>
		chunkid_t c2 = c + sz;
    d296:	19a9      	adds	r1, r5, r6
	return c + size(h, c);
    d298:	eb03 0c05 	add.w	ip, r3, r5
	if (big_heap(h)) {
    d29c:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    d2a0:	d33f      	bcc.n	d322 <split_alloc+0xbe>
		((u32_t *)cmem)[f] = (u32_t) val;
    d2a2:	f847 6035 	str.w	r6, [r7, r5, lsl #3]
	void *cmem = &h->buf[c];
    d2a6:	6822      	ldr	r2, [r4, #0]
    d2a8:	00cf      	lsls	r7, r1, #3
	if (big_heap(h)) {
    d2aa:	68a3      	ldr	r3, [r4, #8]
    d2ac:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    d2b0:	d33a      	bcc.n	d328 <split_alloc+0xc4>
		((u32_t *)cmem)[f] = (u32_t) val;
    d2b2:	f842 0031 	str.w	r0, [r2, r1, lsl #3]
	void *cmem = &h->buf[c];
    d2b6:	6822      	ldr	r2, [r4, #0]
    d2b8:	443a      	add	r2, r7
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d2ba:	68a7      	ldr	r7, [r4, #8]
	if (big_heap(h)) {
    d2bc:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
    d2c0:	d335      	bcc.n	d32e <split_alloc+0xca>
		((u32_t *)cmem)[f] = (u32_t) val;
    d2c2:	6056      	str	r6, [r2, #4]
	void *cmem = &h->buf[c];
    d2c4:	6826      	ldr	r6, [r4, #0]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d2c6:	68a7      	ldr	r7, [r4, #8]
	if (big_heap(h)) {
    d2c8:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
    d2cc:	d331      	bcc.n	d332 <split_alloc+0xce>
		return ((u32_t *)cmem)[f];
    d2ce:	f856 2031 	ldr.w	r2, [r6, r1, lsl #3]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
    d2d2:	68e3      	ldr	r3, [r4, #12]
    d2d4:	401a      	ands	r2, r3
	return (c + size(h, c)) == h->len;
    d2d6:	440a      	add	r2, r1
		chunkid_t c3 = right_chunk(h, c);

		chunk_set(h, c, SIZE_AND_USED, sz);
		chunk_set(h, c2, SIZE_AND_USED, rem);
		chunk_set(h, c2, LEFT_SIZE, sz);
		if (!last_chunk(h, c2)) {
    d2d8:	42ba      	cmp	r2, r7
    d2da:	d005      	beq.n	d2e8 <split_alloc+0x84>
	void *cmem = &h->buf[c];
    d2dc:	eb06 03cc 	add.w	r3, r6, ip, lsl #3
	if (big_heap(h)) {
    d2e0:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
    d2e4:	d328      	bcc.n	d338 <split_alloc+0xd4>
		((u32_t *)cmem)[f] = (u32_t) val;
    d2e6:	6058      	str	r0, [r3, #4]
			chunk_set(h, c3, LEFT_SIZE, rem);
		}
		free_list_add(h, c2);
    d2e8:	4620      	mov	r0, r4
    d2ea:	f7ff ff52 	bl	d192 <free_list_add>
	void *cmem = &h->buf[c];
    d2ee:	6821      	ldr	r1, [r4, #0]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d2f0:	68a0      	ldr	r0, [r4, #8]
	if (big_heap(h)) {
    d2f2:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
    d2f6:	d321      	bcc.n	d33c <split_alloc+0xd8>
		return ((u32_t *)cmem)[f];
    d2f8:	f851 3035 	ldr.w	r3, [r1, r5, lsl #3]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
    d2fc:	68e2      	ldr	r2, [r4, #12]
    d2fe:	4013      	ands	r3, r2
		  size(h, c) | (used ? (h->size_mask + 1) : 0));
    d300:	3201      	adds	r2, #1
	chunk_set(h, c, SIZE_AND_USED,
    d302:	4313      	orrs	r3, r2
	if (big_heap(h)) {
    d304:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
    d308:	d31b      	bcc.n	d342 <split_alloc+0xde>
		((u32_t *)cmem)[f] = (u32_t) val;
    d30a:	f841 3035 	str.w	r3, [r1, r5, lsl #3]
	}

	chunk_set_used(h, c, true);

	return chunk_mem(h, c);
    d30e:	4629      	mov	r1, r5
    d310:	4620      	mov	r0, r4
    d312:	f7ff feec 	bl	d0ee <chunk_mem>
}
    d316:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return ((u16_t *)cmem)[f];
    d318:	f837 1035 	ldrh.w	r1, [r7, r5, lsl #3]
    d31c:	e7b2      	b.n	d284 <split_alloc+0x20>
	if (rem >= (big_heap(h) ? 2 : 1)) {
    d31e:	2101      	movs	r1, #1
    d320:	e7b7      	b.n	d292 <split_alloc+0x2e>
		((u16_t *)cmem)[f] = (u16_t) val;
    d322:	f827 6035 	strh.w	r6, [r7, r5, lsl #3]
    d326:	e7be      	b.n	d2a6 <split_alloc+0x42>
    d328:	f822 0031 	strh.w	r0, [r2, r1, lsl #3]
    d32c:	e7c3      	b.n	d2b6 <split_alloc+0x52>
    d32e:	8056      	strh	r6, [r2, #2]
    d330:	e7c8      	b.n	d2c4 <split_alloc+0x60>
		return ((u16_t *)cmem)[f];
    d332:	f836 2031 	ldrh.w	r2, [r6, r1, lsl #3]
    d336:	e7cc      	b.n	d2d2 <split_alloc+0x6e>
		((u16_t *)cmem)[f] = (u16_t) val;
    d338:	8058      	strh	r0, [r3, #2]
    d33a:	e7d5      	b.n	d2e8 <split_alloc+0x84>
		return ((u16_t *)cmem)[f];
    d33c:	f831 3035 	ldrh.w	r3, [r1, r5, lsl #3]
    d340:	e7dc      	b.n	d2fc <split_alloc+0x98>
		((u16_t *)cmem)[f] = (u16_t) val;
    d342:	f821 3035 	strh.w	r3, [r1, r5, lsl #3]
    d346:	e7e2      	b.n	d30e <split_alloc+0xaa>

0000d348 <sys_heap_free>:

void sys_heap_free(struct sys_heap *heap, void *mem)
{
	if (mem == NULL) {
    d348:	2900      	cmp	r1, #0
    d34a:	f000 80c5 	beq.w	d4d8 <sys_heap_free+0x190>
{
    d34e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    d352:	460c      	mov	r4, r1
		return; /* ISO C free() semantics */
	}

	struct z_heap *h = heap->heap;
    d354:	6805      	ldr	r5, [r0, #0]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d356:	68ab      	ldr	r3, [r5, #8]
	return big_heap(h) ? 8 : 4;
    d358:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    d35c:	d35b      	bcc.n	d416 <sys_heap_free+0xce>
    d35e:	2208      	movs	r2, #8
	chunkid_t c = ((u8_t *)mem - chunk_header_bytes(h)
    d360:	1aa4      	subs	r4, r4, r2
		       - (u8_t *)h->buf) / CHUNK_UNIT;
    d362:	682a      	ldr	r2, [r5, #0]
    d364:	1aa4      	subs	r4, r4, r2
    d366:	d458      	bmi.n	d41a <sys_heap_free+0xd2>
    d368:	10e4      	asrs	r4, r4, #3
	chunkid_t c = ((u8_t *)mem - chunk_header_bytes(h)
    d36a:	4626      	mov	r6, r4
	void *cmem = &h->buf[c];
    d36c:	00e7      	lsls	r7, r4, #3
	if (big_heap(h)) {
    d36e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    d372:	d354      	bcc.n	d41e <sys_heap_free+0xd6>
		return ((u32_t *)cmem)[f];
    d374:	f852 0034 	ldr.w	r0, [r2, r4, lsl #3]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
    d378:	68e9      	ldr	r1, [r5, #12]
    d37a:	4008      	ands	r0, r1
	return (c + size(h, c)) == h->len;
    d37c:	eb04 0800 	add.w	r8, r4, r0

	/* Merge with right chunk?  We can just absorb it. */
	if (!last_chunk(h, c) && !used(h, right_chunk(h, c))) {
    d380:	4598      	cmp	r8, r3
    d382:	d007      	beq.n	d394 <sys_heap_free+0x4c>
	if (big_heap(h)) {
    d384:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    d388:	d34c      	bcc.n	d424 <sys_heap_free+0xdc>
		return ((u32_t *)cmem)[f];
    d38a:	f852 3038 	ldr.w	r3, [r2, r8, lsl #3]
    d38e:	ea33 0201 	bics.w	r2, r3, r1
    d392:	d04a      	beq.n	d42a <sys_heap_free+0xe2>
			chunk_set(h, right_chunk(h, c), LEFT_SIZE, newsz);
		}
	}

	/* Merge with left chunk?  It absorbs us. */
	if (c != h->chunk0 && !used(h, left_chunk(h, c))) {
    d394:	692b      	ldr	r3, [r5, #16]
    d396:	42a3      	cmp	r3, r4
    d398:	f000 8085 	beq.w	d4a6 <sys_heap_free+0x15e>
	void *cmem = &h->buf[c];
    d39c:	682b      	ldr	r3, [r5, #0]
    d39e:	19d9      	adds	r1, r3, r7
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d3a0:	68aa      	ldr	r2, [r5, #8]
	if (big_heap(h)) {
    d3a2:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    d3a6:	d36d      	bcc.n	d484 <sys_heap_free+0x13c>
		return ((u32_t *)cmem)[f];
    d3a8:	6849      	ldr	r1, [r1, #4]
	return c - left_size(h, c);
    d3aa:	eba4 0801 	sub.w	r8, r4, r1
	if (big_heap(h)) {
    d3ae:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    d3b2:	d369      	bcc.n	d488 <sys_heap_free+0x140>
		return ((u32_t *)cmem)[f];
    d3b4:	f853 0038 	ldr.w	r0, [r3, r8, lsl #3]
	return (chunk_field(h, c, SIZE_AND_USED) & ~h->size_mask) != 0;
    d3b8:	68e9      	ldr	r1, [r5, #12]
    d3ba:	ea30 0c01 	bics.w	ip, r0, r1
    d3be:	d172      	bne.n	d4a6 <sys_heap_free+0x15e>
	if (big_heap(h)) {
    d3c0:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    d3c4:	d363      	bcc.n	d48e <sys_heap_free+0x146>
		return ((u32_t *)cmem)[f];
    d3c6:	59db      	ldr	r3, [r3, r7]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
    d3c8:	400b      	ands	r3, r1
	return c + size(h, c);
    d3ca:	441c      	add	r4, r3
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
    d3cc:	4001      	ands	r1, r0
		chunkid_t lc = left_chunk(h, c);
		chunkid_t rc = right_chunk(h, c);
		size_t csz = size(h, c);
		size_t merged_sz = csz + size(h, lc);
    d3ce:	18ce      	adds	r6, r1, r3

		free_list_remove(h, bucket_idx(h, size(h, lc)), lc);
    d3d0:	4628      	mov	r0, r5
    d3d2:	f7ff fed3 	bl	d17c <bucket_idx>
    d3d6:	4601      	mov	r1, r0
    d3d8:	4642      	mov	r2, r8
    d3da:	4628      	mov	r0, r5
    d3dc:	f7ff fe93 	bl	d106 <free_list_remove>
	void *cmem = &h->buf[c];
    d3e0:	682b      	ldr	r3, [r5, #0]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d3e2:	68aa      	ldr	r2, [r5, #8]
	if (big_heap(h)) {
    d3e4:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    d3e8:	d353      	bcc.n	d492 <sys_heap_free+0x14a>
		((u32_t *)cmem)[f] = (u32_t) val;
    d3ea:	f843 6038 	str.w	r6, [r3, r8, lsl #3]
	void *cmem = &h->buf[c];
    d3ee:	682a      	ldr	r2, [r5, #0]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d3f0:	68a9      	ldr	r1, [r5, #8]
	if (big_heap(h)) {
    d3f2:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
    d3f6:	d34f      	bcc.n	d498 <sys_heap_free+0x150>
		return ((u32_t *)cmem)[f];
    d3f8:	f852 0038 	ldr.w	r0, [r2, r8, lsl #3]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
    d3fc:	68eb      	ldr	r3, [r5, #12]
    d3fe:	4003      	ands	r3, r0
	return (c + size(h, c)) == h->len;
    d400:	4443      	add	r3, r8
		chunk_set(h, lc, SIZE_AND_USED, merged_sz);
		if (!last_chunk(h, lc)) {
    d402:	428b      	cmp	r3, r1
    d404:	d04e      	beq.n	d4a4 <sys_heap_free+0x15c>
	void *cmem = &h->buf[c];
    d406:	eb02 04c4 	add.w	r4, r2, r4, lsl #3
	if (big_heap(h)) {
    d40a:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
    d40e:	d346      	bcc.n	d49e <sys_heap_free+0x156>
		((u32_t *)cmem)[f] = (u32_t) val;
    d410:	6066      	str	r6, [r4, #4]
			chunk_set(h, rc, LEFT_SIZE, merged_sz);
		}

		c = lc;
    d412:	4646      	mov	r6, r8
    d414:	e047      	b.n	d4a6 <sys_heap_free+0x15e>
	return big_heap(h) ? 8 : 4;
    d416:	2204      	movs	r2, #4
    d418:	e7a2      	b.n	d360 <sys_heap_free+0x18>
		       - (u8_t *)h->buf) / CHUNK_UNIT;
    d41a:	3407      	adds	r4, #7
    d41c:	e7a4      	b.n	d368 <sys_heap_free+0x20>
		return ((u16_t *)cmem)[f];
    d41e:	f832 0034 	ldrh.w	r0, [r2, r4, lsl #3]
    d422:	e7a9      	b.n	d378 <sys_heap_free+0x30>
    d424:	f832 3038 	ldrh.w	r3, [r2, r8, lsl #3]
    d428:	e7b1      	b.n	d38e <sys_heap_free+0x46>
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
    d42a:	4019      	ands	r1, r3
		size_t newsz = size(h, c) + size(h, rc);
    d42c:	eb01 0900 	add.w	r9, r1, r0
		free_list_remove(h, bucket_idx(h, size(h, rc)), rc);
    d430:	4628      	mov	r0, r5
    d432:	f7ff fea3 	bl	d17c <bucket_idx>
    d436:	4601      	mov	r1, r0
    d438:	4642      	mov	r2, r8
    d43a:	4628      	mov	r0, r5
    d43c:	f7ff fe63 	bl	d106 <free_list_remove>
	void *cmem = &h->buf[c];
    d440:	682b      	ldr	r3, [r5, #0]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d442:	68aa      	ldr	r2, [r5, #8]
	if (big_heap(h)) {
    d444:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    d448:	d314      	bcc.n	d474 <sys_heap_free+0x12c>
		((u32_t *)cmem)[f] = (u32_t) val;
    d44a:	f843 9007 	str.w	r9, [r3, r7]
	void *cmem = &h->buf[c];
    d44e:	682a      	ldr	r2, [r5, #0]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d450:	68a9      	ldr	r1, [r5, #8]
	if (big_heap(h)) {
    d452:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
    d456:	d310      	bcc.n	d47a <sys_heap_free+0x132>
		return ((u32_t *)cmem)[f];
    d458:	59d0      	ldr	r0, [r2, r7]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
    d45a:	68eb      	ldr	r3, [r5, #12]
    d45c:	4003      	ands	r3, r0
	return (c + size(h, c)) == h->len;
    d45e:	4423      	add	r3, r4
		if (!last_chunk(h, c)) {
    d460:	428b      	cmp	r3, r1
    d462:	d097      	beq.n	d394 <sys_heap_free+0x4c>
	void *cmem = &h->buf[c];
    d464:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
	if (big_heap(h)) {
    d468:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
    d46c:	d307      	bcc.n	d47e <sys_heap_free+0x136>
		((u32_t *)cmem)[f] = (u32_t) val;
    d46e:	f8c3 9004 	str.w	r9, [r3, #4]
    d472:	e78f      	b.n	d394 <sys_heap_free+0x4c>
		((u16_t *)cmem)[f] = (u16_t) val;
    d474:	f823 9007 	strh.w	r9, [r3, r7]
    d478:	e7e9      	b.n	d44e <sys_heap_free+0x106>
		return ((u16_t *)cmem)[f];
    d47a:	5bd0      	ldrh	r0, [r2, r7]
    d47c:	e7ed      	b.n	d45a <sys_heap_free+0x112>
		((u16_t *)cmem)[f] = (u16_t) val;
    d47e:	f8a3 9002 	strh.w	r9, [r3, #2]
    d482:	e787      	b.n	d394 <sys_heap_free+0x4c>
		return ((u16_t *)cmem)[f];
    d484:	8849      	ldrh	r1, [r1, #2]
    d486:	e790      	b.n	d3aa <sys_heap_free+0x62>
    d488:	f833 0038 	ldrh.w	r0, [r3, r8, lsl #3]
    d48c:	e794      	b.n	d3b8 <sys_heap_free+0x70>
    d48e:	5bdb      	ldrh	r3, [r3, r7]
    d490:	e79a      	b.n	d3c8 <sys_heap_free+0x80>
		((u16_t *)cmem)[f] = (u16_t) val;
    d492:	f823 6038 	strh.w	r6, [r3, r8, lsl #3]
    d496:	e7aa      	b.n	d3ee <sys_heap_free+0xa6>
		return ((u16_t *)cmem)[f];
    d498:	f832 0038 	ldrh.w	r0, [r2, r8, lsl #3]
    d49c:	e7ae      	b.n	d3fc <sys_heap_free+0xb4>
		((u16_t *)cmem)[f] = (u16_t) val;
    d49e:	8066      	strh	r6, [r4, #2]
		c = lc;
    d4a0:	4646      	mov	r6, r8
    d4a2:	e000      	b.n	d4a6 <sys_heap_free+0x15e>
    d4a4:	4646      	mov	r6, r8
	void *cmem = &h->buf[c];
    d4a6:	6829      	ldr	r1, [r5, #0]
    d4a8:	00f0      	lsls	r0, r6, #3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d4aa:	68aa      	ldr	r2, [r5, #8]
	if (big_heap(h)) {
    d4ac:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    d4b0:	d30d      	bcc.n	d4ce <sys_heap_free+0x186>
		return ((u32_t *)cmem)[f];
    d4b2:	f851 4036 	ldr.w	r4, [r1, r6, lsl #3]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
    d4b6:	68eb      	ldr	r3, [r5, #12]
    d4b8:	4023      	ands	r3, r4
	if (big_heap(h)) {
    d4ba:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    d4be:	d309      	bcc.n	d4d4 <sys_heap_free+0x18c>
		((u32_t *)cmem)[f] = (u32_t) val;
    d4c0:	500b      	str	r3, [r1, r0]
	}

	chunk_set_used(h, c, false);
	free_list_add(h, c);
    d4c2:	4631      	mov	r1, r6
    d4c4:	4628      	mov	r0, r5
    d4c6:	f7ff fe64 	bl	d192 <free_list_add>
}
    d4ca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ((u16_t *)cmem)[f];
    d4ce:	f831 4036 	ldrh.w	r4, [r1, r6, lsl #3]
    d4d2:	e7f0      	b.n	d4b6 <sys_heap_free+0x16e>
		((u16_t *)cmem)[f] = (u16_t) val;
    d4d4:	520b      	strh	r3, [r1, r0]
    d4d6:	e7f4      	b.n	d4c2 <sys_heap_free+0x17a>
    d4d8:	4770      	bx	lr

0000d4da <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
    d4da:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    d4de:	4688      	mov	r8, r1
	struct z_heap *h = heap->heap;
    d4e0:	6804      	ldr	r4, [r0, #0]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d4e2:	f8d4 9008 	ldr.w	r9, [r4, #8]
	return big_heap(h) ? 8 : 4;
    d4e6:	f5b9 4f00 	cmp.w	r9, #32768	; 0x8000
    d4ea:	d31b      	bcc.n	d524 <sys_heap_alloc+0x4a>
    d4ec:	2608      	movs	r6, #8
	return chunksz(chunk_header_bytes(h) + bytes);
    d4ee:	4446      	add	r6, r8
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
    d4f0:	3607      	adds	r6, #7
    d4f2:	08f6      	lsrs	r6, r6, #3
	size_t sz = bytes_to_chunksz(h, bytes);
	int bi = bucket_idx(h, sz);
    d4f4:	4631      	mov	r1, r6
    d4f6:	4620      	mov	r0, r4
    d4f8:	f7ff fe40 	bl	d17c <bucket_idx>
    d4fc:	4607      	mov	r7, r0
	struct z_heap_bucket *b = &h->buckets[bi];
    d4fe:	6865      	ldr	r5, [r4, #4]
    d500:	eb05 05c0 	add.w	r5, r5, r0, lsl #3

	if (bytes == 0 || bi > bucket_idx(h, h->len)) {
    d504:	f1b8 0f00 	cmp.w	r8, #0
    d508:	d045      	beq.n	d596 <sys_heap_alloc+0xbc>
    d50a:	4649      	mov	r1, r9
    d50c:	4620      	mov	r0, r4
    d50e:	f7ff fe35 	bl	d17c <bucket_idx>
    d512:	42b8      	cmp	r0, r7
    d514:	db41      	blt.n	d59a <sys_heap_alloc+0xc0>
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	int loops = MIN(b->list_size, CONFIG_SYS_HEAP_ALLOC_LOOPS);
    d516:	686b      	ldr	r3, [r5, #4]
    d518:	2b03      	cmp	r3, #3
    d51a:	bf28      	it	cs
    d51c:	2303      	movcs	r3, #3
    d51e:	469e      	mov	lr, r3

	for (int i = 0; i < loops; i++) {
    d520:	2200      	movs	r2, #0
    d522:	e00f      	b.n	d544 <sys_heap_alloc+0x6a>
	return big_heap(h) ? 8 : 4;
    d524:	2604      	movs	r6, #4
    d526:	e7e2      	b.n	d4ee <sys_heap_alloc+0x14>
		return ((u16_t *)cmem)[f];
    d528:	f833 1031 	ldrh.w	r1, [r3, r1, lsl #3]
    d52c:	e016      	b.n	d55c <sys_heap_alloc+0x82>
		CHECK(b->next != 0);
		if (size(h, b->next) >= sz) {
			return split_alloc(h, bi, sz);
    d52e:	4632      	mov	r2, r6
    d530:	4639      	mov	r1, r7
    d532:	4620      	mov	r0, r4
    d534:	f7ff fe96 	bl	d264 <split_alloc>

		return split_alloc(h, minbucket, sz);
	}

	return NULL;
}
    d538:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    d53c:	f8bc 3006 	ldrh.w	r3, [ip, #6]
		b->next = free_next(h, b->next);
    d540:	602b      	str	r3, [r5, #0]
	for (int i = 0; i < loops; i++) {
    d542:	3201      	adds	r2, #1
    d544:	4572      	cmp	r2, lr
    d546:	da13      	bge.n	d570 <sys_heap_alloc+0x96>
		if (size(h, b->next) >= sz) {
    d548:	6829      	ldr	r1, [r5, #0]
	void *cmem = &h->buf[c];
    d54a:	6823      	ldr	r3, [r4, #0]
    d54c:	eb03 0cc1 	add.w	ip, r3, r1, lsl #3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d550:	68a0      	ldr	r0, [r4, #8]
	if (big_heap(h)) {
    d552:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
    d556:	d3e7      	bcc.n	d528 <sys_heap_alloc+0x4e>
		return ((u32_t *)cmem)[f];
    d558:	f853 1031 	ldr.w	r1, [r3, r1, lsl #3]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
    d55c:	68e3      	ldr	r3, [r4, #12]
    d55e:	400b      	ands	r3, r1
    d560:	42b3      	cmp	r3, r6
    d562:	d2e4      	bcs.n	d52e <sys_heap_alloc+0x54>
	if (big_heap(h)) {
    d564:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
    d568:	d3e8      	bcc.n	d53c <sys_heap_alloc+0x62>
		return ((u32_t *)cmem)[f];
    d56a:	f8dc 300c 	ldr.w	r3, [ip, #12]
    d56e:	e7e7      	b.n	d540 <sys_heap_alloc+0x66>
	size_t bmask = h->avail_buckets & ~((1 << (bi + 1)) - 1);
    d570:	6961      	ldr	r1, [r4, #20]
    d572:	3701      	adds	r7, #1
    d574:	2301      	movs	r3, #1
    d576:	fa03 f707 	lsl.w	r7, r3, r7
    d57a:	427f      	negs	r7, r7
	if ((bmask & h->avail_buckets) != 0) {
    d57c:	4039      	ands	r1, r7
    d57e:	d101      	bne.n	d584 <sys_heap_alloc+0xaa>
	return NULL;
    d580:	2000      	movs	r0, #0
    d582:	e7d9      	b.n	d538 <sys_heap_alloc+0x5e>
		return split_alloc(h, minbucket, sz);
    d584:	4632      	mov	r2, r6
    d586:	fa91 f1a1 	rbit	r1, r1
    d58a:	fab1 f181 	clz	r1, r1
    d58e:	4620      	mov	r0, r4
    d590:	f7ff fe68 	bl	d264 <split_alloc>
    d594:	e7d0      	b.n	d538 <sys_heap_alloc+0x5e>
		return NULL;
    d596:	2000      	movs	r0, #0
    d598:	e7ce      	b.n	d538 <sys_heap_alloc+0x5e>
    d59a:	2000      	movs	r0, #0
    d59c:	e7cc      	b.n	d538 <sys_heap_alloc+0x5e>

0000d59e <sys_heap_init>:

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
    d59e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    d5a2:	4606      	mov	r6, r0
#if __SIZEOF_SIZE_T__ > 4
	CHECK(bytes < 0x800000000ULL);
#endif

	/* Round the start up, the end down */
	size_t addr = ((size_t)mem + CHUNK_UNIT - 1) & ~(CHUNK_UNIT - 1);
    d5a4:	1dcf      	adds	r7, r1, #7
    d5a6:	f027 0707 	bic.w	r7, r7, #7
	size_t end = ((size_t)mem + bytes) & ~(CHUNK_UNIT - 1);
    d5aa:	eb01 0802 	add.w	r8, r1, r2
    d5ae:	f028 0807 	bic.w	r8, r8, #7
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
    d5b2:	eba8 0807 	sub.w	r8, r8, r7
    d5b6:	ea4f 08d8 	mov.w	r8, r8, lsr #3

	CHECK(end > addr);

	struct z_heap *h = (struct z_heap *)addr;

	heap->heap = (struct z_heap *)addr;
    d5ba:	6007      	str	r7, [r0, #0]
	h->buf = (u64_t *)addr;
    d5bc:	603f      	str	r7, [r7, #0]
	h->buckets = (void *)(addr + CHUNK_UNIT * hdr_chunks);
    d5be:	f107 0318 	add.w	r3, r7, #24
    d5c2:	607b      	str	r3, [r7, #4]
	h->len = buf_sz;
    d5c4:	f8c7 8008 	str.w	r8, [r7, #8]
	h->size_mask = (1 << (big_heap(h) ? 31 : 15)) - 1;
    d5c8:	f5b8 4f00 	cmp.w	r8, #32768	; 0x8000
    d5cc:	d31f      	bcc.n	d60e <sys_heap_init+0x70>
    d5ce:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
    d5d2:	60fb      	str	r3, [r7, #12]
	h->avail_buckets = 0;
    d5d4:	2400      	movs	r4, #0
    d5d6:	617c      	str	r4, [r7, #20]

	size_t buckets_bytes = ((bucket_idx(h, buf_sz) + 1)
    d5d8:	4641      	mov	r1, r8
    d5da:	4638      	mov	r0, r7
    d5dc:	f7ff fdce 	bl	d17c <bucket_idx>
    d5e0:	1c43      	adds	r3, r0, #1
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
    d5e2:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
				* sizeof(struct z_heap_bucket));

	h->chunk0 = hdr_chunks + chunksz(buckets_bytes);
    d5e6:	3303      	adds	r3, #3
    d5e8:	613b      	str	r3, [r7, #16]

	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
    d5ea:	6835      	ldr	r5, [r6, #0]
    d5ec:	68a9      	ldr	r1, [r5, #8]
    d5ee:	4628      	mov	r0, r5
    d5f0:	f7ff fdc4 	bl	d17c <bucket_idx>
    d5f4:	42a0      	cmp	r0, r4
    d5f6:	db0d      	blt.n	d614 <sys_heap_init+0x76>
		heap->heap->buckets[i].list_size = 0;
    d5f8:	686b      	ldr	r3, [r5, #4]
    d5fa:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
    d5fe:	2200      	movs	r2, #0
    d600:	605a      	str	r2, [r3, #4]
		heap->heap->buckets[i].next = 0;
    d602:	6833      	ldr	r3, [r6, #0]
    d604:	685b      	ldr	r3, [r3, #4]
    d606:	f843 2034 	str.w	r2, [r3, r4, lsl #3]
	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
    d60a:	3401      	adds	r4, #1
    d60c:	e7ed      	b.n	d5ea <sys_heap_init+0x4c>
	h->size_mask = (1 << (big_heap(h) ? 31 : 15)) - 1;
    d60e:	f647 73ff 	movw	r3, #32767	; 0x7fff
    d612:	e7de      	b.n	d5d2 <sys_heap_init+0x34>
	}

	chunk_set(h, h->chunk0, SIZE_AND_USED, buf_sz - h->chunk0);
    d614:	693a      	ldr	r2, [r7, #16]
    d616:	eba8 0302 	sub.w	r3, r8, r2
	void *cmem = &h->buf[c];
    d61a:	6839      	ldr	r1, [r7, #0]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
    d61c:	68b8      	ldr	r0, [r7, #8]
	if (big_heap(h)) {
    d61e:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
    d622:	d307      	bcc.n	d634 <sys_heap_init+0x96>
		((u32_t *)cmem)[f] = (u32_t) val;
    d624:	f841 3032 	str.w	r3, [r1, r2, lsl #3]
	free_list_add(h, h->chunk0);
    d628:	6939      	ldr	r1, [r7, #16]
    d62a:	4638      	mov	r0, r7
    d62c:	f7ff fdb1 	bl	d192 <free_list_add>
}
    d630:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		((u16_t *)cmem)[f] = (u16_t) val;
    d634:	f821 3032 	strh.w	r3, [r1, r2, lsl #3]
    d638:	e7f6      	b.n	d628 <sys_heap_init+0x8a>

0000d63a <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    d63a:	4770      	bx	lr

0000d63c <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
    d63c:	2300      	movs	r3, #0
    d63e:	6043      	str	r3, [r0, #4]
	list->head = NULL;
    d640:	6003      	str	r3, [r0, #0]
}
    d642:	4770      	bx	lr

0000d644 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
    d644:	6803      	ldr	r3, [r0, #0]
    d646:	b12b      	cbz	r3, d654 <log_list_add_tail+0x10>
		list->head = msg;
	} else {
		list->tail->next = msg;
    d648:	6843      	ldr	r3, [r0, #4]
    d64a:	6019      	str	r1, [r3, #0]
	}

	list->tail = msg;
    d64c:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
    d64e:	2300      	movs	r3, #0
    d650:	600b      	str	r3, [r1, #0]
}
    d652:	4770      	bx	lr
		list->head = msg;
    d654:	6001      	str	r1, [r0, #0]
    d656:	e7f9      	b.n	d64c <log_list_add_tail+0x8>

0000d658 <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
    d658:	6800      	ldr	r0, [r0, #0]
    d65a:	4770      	bx	lr

0000d65c <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
    d65c:	4603      	mov	r3, r0
	struct log_msg *msg = list->head;
    d65e:	6800      	ldr	r0, [r0, #0]

	if (list->head != NULL) {
    d660:	b108      	cbz	r0, d666 <log_list_head_get+0xa>
		list->head = list->head->next;
    d662:	6802      	ldr	r2, [r0, #0]
    d664:	601a      	str	r2, [r3, #0]
	}

	return msg;
}
    d666:	4770      	bx	lr

0000d668 <dummy_timestamp>:
}
    d668:	2000      	movs	r0, #0
    d66a:	4770      	bx	lr

0000d66c <msg_filter_check>:
}
    d66c:	2001      	movs	r0, #1
    d66e:	4770      	bx	lr

0000d670 <k_cycle_get_32_wrapper>:
{
    d670:	b508      	push	{r3, lr}
#ifndef _ASMLANGUAGE
extern u32_t z_timer_cycle_get_32(void);

static inline u32_t arch_k_cycle_get_32(void)
{
	return z_timer_cycle_get_32();
    d672:	f7f4 ffe9 	bl	2648 <z_timer_cycle_get_32>
}
    d676:	bd08      	pop	{r3, pc}

0000d678 <block_on_alloc>:
}
    d678:	2000      	movs	r0, #0
    d67a:	4770      	bx	lr

0000d67c <cont_arg_get>:

static log_arg_t cont_arg_get(struct log_msg *msg, u32_t arg_idx)
{
	struct log_msg_cont *cont;

	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
    d67c:	2901      	cmp	r1, #1
    d67e:	d906      	bls.n	d68e <cont_arg_get+0x12>
		return msg->payload.ext.data.args[arg_idx];
	}


	cont = msg->payload.ext.next;
    d680:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
    d682:	3902      	subs	r1, #2

	while (arg_idx >= ARGS_CONT_MSG) {
    d684:	2906      	cmp	r1, #6
    d686:	d907      	bls.n	d698 <cont_arg_get+0x1c>
		arg_idx -= ARGS_CONT_MSG;
    d688:	3907      	subs	r1, #7
		cont = cont->next;
    d68a:	681b      	ldr	r3, [r3, #0]
    d68c:	e7fa      	b.n	d684 <cont_arg_get+0x8>
		return msg->payload.ext.data.args[arg_idx];
    d68e:	3104      	adds	r1, #4
    d690:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    d694:	6888      	ldr	r0, [r1, #8]
    d696:	4770      	bx	lr
	}

	return cont->payload.args[arg_idx];
    d698:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    d69c:	6848      	ldr	r0, [r1, #4]
}
    d69e:	4770      	bx	lr

0000d6a0 <copy_args_to_msg>:

	return msg;
}

static void copy_args_to_msg(struct  log_msg *msg, log_arg_t *args, u32_t nargs)
{
    d6a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    d6a4:	460d      	mov	r5, r1
	struct log_msg_cont *cont = msg->payload.ext.next;
    d6a6:	6946      	ldr	r6, [r0, #20]

	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
    d6a8:	2a03      	cmp	r2, #3
    d6aa:	d917      	bls.n	d6dc <copy_args_to_msg+0x3c>
    d6ac:	6809      	ldr	r1, [r1, #0]
    d6ae:	686b      	ldr	r3, [r5, #4]
    d6b0:	6181      	str	r1, [r0, #24]
    d6b2:	61c3      	str	r3, [r0, #28]
		(void)memcpy(msg->payload.ext.data.args, args,
		       LOG_MSG_NARGS_HEAD_CHUNK * sizeof(log_arg_t));
		nargs -= LOG_MSG_NARGS_HEAD_CHUNK;
    d6b4:	1e94      	subs	r4, r2, #2
		args += LOG_MSG_NARGS_HEAD_CHUNK;
    d6b6:	3508      	adds	r5, #8
		(void)memcpy(msg->payload.single.args, args,
			     nargs * sizeof(log_arg_t));
		nargs  = 0U;
	}

	while (nargs != 0U) {
    d6b8:	b1b4      	cbz	r4, d6e8 <copy_args_to_msg+0x48>
		u32_t cpy_args = MIN(nargs, ARGS_CONT_MSG);
    d6ba:	46a0      	mov	r8, r4
    d6bc:	2c07      	cmp	r4, #7
    d6be:	bf28      	it	cs
    d6c0:	f04f 0807 	movcs.w	r8, #7

		(void)memcpy(cont->payload.args, args,
    d6c4:	ea4f 0788 	mov.w	r7, r8, lsl #2
    d6c8:	463a      	mov	r2, r7
    d6ca:	4629      	mov	r1, r5
    d6cc:	1d30      	adds	r0, r6, #4
    d6ce:	f002 ff68 	bl	105a2 <memcpy>
			     cpy_args * sizeof(log_arg_t));
		nargs -= cpy_args;
    d6d2:	eba4 0408 	sub.w	r4, r4, r8
		args += cpy_args;
    d6d6:	443d      	add	r5, r7
		cont = cont->next;
    d6d8:	6836      	ldr	r6, [r6, #0]
    d6da:	e7ed      	b.n	d6b8 <copy_args_to_msg+0x18>
    d6dc:	0092      	lsls	r2, r2, #2
    d6de:	3014      	adds	r0, #20
    d6e0:	f002 ff5f 	bl	105a2 <memcpy>
		nargs  = 0U;
    d6e4:	2400      	movs	r4, #0
    d6e6:	e7e7      	b.n	d6b8 <copy_args_to_msg+0x18>
	}
}
    d6e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000d6ec <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    u8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
    d6ec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    d6f0:	4688      	mov	r8, r1
    d6f2:	461c      	mov	r4, r3
    d6f4:	f89d 9020 	ldrb.w	r9, [sp, #32]
	u32_t available_len = msg->hdr.params.hexdump.length;
    d6f8:	8901      	ldrh	r1, [r0, #8]
	u8_t *head_data;
	u32_t chunk_len;
	u32_t req_len;
	u32_t cpy_len;

	if (offset >= available_len) {
    d6fa:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
    d6fe:	d21f      	bcs.n	d740 <log_msg_hexdump_data_op+0x54>
    d700:	088b      	lsrs	r3, r1, #2
		*length = 0;
		return;
	}

	if ((offset + *length) > available_len) {
    d702:	6811      	ldr	r1, [r2, #0]
    d704:	4421      	add	r1, r4
    d706:	4299      	cmp	r1, r3
    d708:	d901      	bls.n	d70e <log_msg_hexdump_data_op+0x22>
		*length = available_len - offset;
    d70a:	1b19      	subs	r1, r3, r4
    d70c:	6011      	str	r1, [r2, #0]
	}

	req_len = *length;
    d70e:	6816      	ldr	r6, [r2, #0]

	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
    d710:	2b0c      	cmp	r3, #12
    d712:	d919      	bls.n	d748 <log_msg_hexdump_data_op+0x5c>
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
		head_data = msg->payload.ext.data.bytes;
    d714:	f100 0c18 	add.w	ip, r0, #24
		cont = msg->payload.ext.next;
    d718:	6947      	ldr	r7, [r0, #20]
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
    d71a:	2308      	movs	r3, #8
		head_data = msg->payload.single.bytes;
		chunk_len = available_len;

	}

	if (offset < chunk_len) {
    d71c:	42a3      	cmp	r3, r4
    d71e:	d91e      	bls.n	d75e <log_msg_hexdump_data_op+0x72>
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    d720:	42b3      	cmp	r3, r6
    d722:	bf28      	it	cs
    d724:	4633      	movcs	r3, r6
    d726:	461d      	mov	r5, r3

		if (put_op) {
    d728:	f1b9 0f00 	cmp.w	r9, #0
    d72c:	d010      	beq.n	d750 <log_msg_hexdump_data_op+0x64>
    d72e:	461a      	mov	r2, r3
    d730:	4641      	mov	r1, r8
    d732:	eb0c 0004 	add.w	r0, ip, r4
    d736:	f002 ff34 	bl	105a2 <memcpy>
			(void)memcpy(&head_data[offset], data, cpy_len);
		} else {
			(void)memcpy(data, &head_data[offset], cpy_len);
		}

		req_len -= cpy_len;
    d73a:	1b76      	subs	r6, r6, r5
		data += cpy_len;
    d73c:	44a8      	add	r8, r5
    d73e:	e021      	b.n	d784 <log_msg_hexdump_data_op+0x98>
		*length = 0;
    d740:	2300      	movs	r3, #0
    d742:	6013      	str	r3, [r2, #0]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
    d744:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		head_data = msg->payload.single.bytes;
    d748:	f100 0c14 	add.w	ip, r0, #20
	struct log_msg_cont *cont = NULL;
    d74c:	2700      	movs	r7, #0
    d74e:	e7e5      	b.n	d71c <log_msg_hexdump_data_op+0x30>
    d750:	461a      	mov	r2, r3
    d752:	eb0c 0104 	add.w	r1, ip, r4
    d756:	4640      	mov	r0, r8
    d758:	f002 ff23 	bl	105a2 <memcpy>
    d75c:	e7ed      	b.n	d73a <log_msg_hexdump_data_op+0x4e>
		offset -= chunk_len;
    d75e:	1ae4      	subs	r4, r4, r3
		if (cont == NULL) {
    d760:	b127      	cbz	r7, d76c <log_msg_hexdump_data_op+0x80>
		while (offset >= chunk_len) {
    d762:	2c1b      	cmp	r4, #27
    d764:	d90e      	bls.n	d784 <log_msg_hexdump_data_op+0x98>
			cont = cont->next;
    d766:	683f      	ldr	r7, [r7, #0]
			offset -= chunk_len;
    d768:	3c1c      	subs	r4, #28
    d76a:	e7fa      	b.n	d762 <log_msg_hexdump_data_op+0x76>
			cont = msg->payload.ext.next;
    d76c:	6947      	ldr	r7, [r0, #20]
    d76e:	e7f8      	b.n	d762 <log_msg_hexdump_data_op+0x76>
			(void)memcpy(data, &cont->payload.bytes[offset],
    d770:	1939      	adds	r1, r7, r4
    d772:	462a      	mov	r2, r5
    d774:	3104      	adds	r1, #4
    d776:	4640      	mov	r0, r8
    d778:	f002 ff13 	bl	105a2 <memcpy>
		cont = cont->next;
    d77c:	683f      	ldr	r7, [r7, #0]
		req_len -= cpy_len;
    d77e:	1b76      	subs	r6, r6, r5
		data += cpy_len;
    d780:	44a8      	add	r8, r5
		offset = 0;
    d782:	2400      	movs	r4, #0
	while (req_len > 0) {
    d784:	2e00      	cmp	r6, #0
    d786:	d0dd      	beq.n	d744 <log_msg_hexdump_data_op+0x58>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
    d788:	f1c4 051c 	rsb	r5, r4, #28
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    d78c:	42b5      	cmp	r5, r6
    d78e:	bf28      	it	cs
    d790:	4635      	movcs	r5, r6
		if (put_op) {
    d792:	f1b9 0f00 	cmp.w	r9, #0
    d796:	d0eb      	beq.n	d770 <log_msg_hexdump_data_op+0x84>
			(void)memcpy(&cont->payload.bytes[offset],
    d798:	1938      	adds	r0, r7, r4
    d79a:	462a      	mov	r2, r5
    d79c:	4641      	mov	r1, r8
    d79e:	3004      	adds	r0, #4
    d7a0:	f002 feff 	bl	105a2 <memcpy>
    d7a4:	e7ea      	b.n	d77c <log_msg_hexdump_data_op+0x90>

0000d7a6 <log_msg_get>:
	atomic_inc(&msg->hdr.ref_cnt);
    d7a6:	3004      	adds	r0, #4
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    d7a8:	f3bf 8f5b 	dmb	ish
    d7ac:	e850 3f00 	ldrex	r3, [r0]
    d7b0:	3301      	adds	r3, #1
    d7b2:	e840 3200 	strex	r2, r3, [r0]
    d7b6:	2a00      	cmp	r2, #0
    d7b8:	d1f8      	bne.n	d7ac <log_msg_get+0x6>
    d7ba:	f3bf 8f5b 	dmb	ish
}
    d7be:	4770      	bx	lr

0000d7c0 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
    d7c0:	7a40      	ldrb	r0, [r0, #9]
}
    d7c2:	0900      	lsrs	r0, r0, #4
    d7c4:	4770      	bx	lr

0000d7c6 <log_msg_arg_get>:
{
    d7c6:	b508      	push	{r3, lr}
	if (arg_idx >= msg->hdr.params.std.nargs) {
    d7c8:	7a43      	ldrb	r3, [r0, #9]
    d7ca:	ebb1 1f13 	cmp.w	r1, r3, lsr #4
    d7ce:	d20a      	bcs.n	d7e6 <log_msg_arg_get+0x20>
    d7d0:	091a      	lsrs	r2, r3, #4
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
    d7d2:	2a03      	cmp	r2, #3
    d7d4:	d804      	bhi.n	d7e0 <log_msg_arg_get+0x1a>
		arg = msg->payload.single.args[arg_idx];
    d7d6:	3104      	adds	r1, #4
    d7d8:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    d7dc:	6840      	ldr	r0, [r0, #4]
    d7de:	e003      	b.n	d7e8 <log_msg_arg_get+0x22>
		arg = cont_arg_get(msg, arg_idx);
    d7e0:	f7ff ff4c 	bl	d67c <cont_arg_get>
    d7e4:	e000      	b.n	d7e8 <log_msg_arg_get+0x22>
		return 0;
    d7e6:	2000      	movs	r0, #0
}
    d7e8:	bd08      	pop	{r3, pc}

0000d7ea <log_msg_str_get>:
}
    d7ea:	6900      	ldr	r0, [r0, #16]
    d7ec:	4770      	bx	lr

0000d7ee <log_msg_put>:
{
    d7ee:	b508      	push	{r3, lr}
	atomic_dec(&msg->hdr.ref_cnt);
    d7f0:	1d03      	adds	r3, r0, #4
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    d7f2:	f3bf 8f5b 	dmb	ish
    d7f6:	e853 2f00 	ldrex	r2, [r3]
    d7fa:	3a01      	subs	r2, #1
    d7fc:	e843 2100 	strex	r1, r2, [r3]
    d800:	2900      	cmp	r1, #0
    d802:	d1f8      	bne.n	d7f6 <log_msg_put+0x8>
    d804:	f3bf 8f5b 	dmb	ish
	if (msg->hdr.ref_cnt == 0) {
    d808:	6843      	ldr	r3, [r0, #4]
    d80a:	b103      	cbz	r3, d80e <log_msg_put+0x20>
}
    d80c:	bd08      	pop	{r3, pc}
		msg_free(msg);
    d80e:	f7f4 fb2b 	bl	1e68 <msg_free>
}
    d812:	e7fb      	b.n	d80c <log_msg_put+0x1e>

0000d814 <msg_alloc>:
{
    d814:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d816:	4605      	mov	r5, r0
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    d818:	f7f4 fb0a 	bl	1e30 <log_msg_chunk_alloc>
	if (msg != NULL) {
    d81c:	4607      	mov	r7, r0
    d81e:	b140      	cbz	r0, d832 <msg_alloc+0x1e>
		msg->hdr.ref_cnt = 1;
    d820:	2301      	movs	r3, #1
    d822:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
    d824:	2200      	movs	r2, #0
    d826:	8102      	strh	r2, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
    d828:	f04f 0300 	mov.w	r3, #0
    d82c:	f362 0300 	bfi	r3, r2, #0, #1
    d830:	7203      	strb	r3, [r0, #8]
	if ((msg == NULL) || nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
    d832:	b1f7      	cbz	r7, d872 <msg_alloc+0x5e>
    d834:	2d03      	cmp	r5, #3
    d836:	d91c      	bls.n	d872 <msg_alloc+0x5e>
	msg->hdr.params.std.nargs = 0U;
    d838:	7a7b      	ldrb	r3, [r7, #9]
    d83a:	f36f 1307 	bfc	r3, #4, #4
    d83e:	727b      	strb	r3, [r7, #9]
	msg->hdr.params.generic.ext = 1;
    d840:	7a3b      	ldrb	r3, [r7, #8]
    d842:	f043 0302 	orr.w	r3, r3, #2
    d846:	723b      	strb	r3, [r7, #8]
	n -= LOG_MSG_NARGS_HEAD_CHUNK;
    d848:	3d02      	subs	r5, #2
	next = &msg->payload.ext.next;
    d84a:	f107 0614 	add.w	r6, r7, #20
	*next = NULL;
    d84e:	2300      	movs	r3, #0
    d850:	617b      	str	r3, [r7, #20]
	while (n > 0) {
    d852:	2d00      	cmp	r5, #0
    d854:	dd0d      	ble.n	d872 <msg_alloc+0x5e>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
    d856:	f7f4 faeb 	bl	1e30 <log_msg_chunk_alloc>
		if (cont == NULL) {
    d85a:	4604      	mov	r4, r0
    d85c:	b128      	cbz	r0, d86a <msg_alloc+0x56>
		*next = cont;
    d85e:	6030      	str	r0, [r6, #0]
		cont->next = NULL;
    d860:	2300      	movs	r3, #0
    d862:	6003      	str	r3, [r0, #0]
		next = &cont->next;
    d864:	4606      	mov	r6, r0
		n -= ARGS_CONT_MSG;
    d866:	3d07      	subs	r5, #7
    d868:	e7f3      	b.n	d852 <msg_alloc+0x3e>
			msg_free(msg);
    d86a:	4638      	mov	r0, r7
    d86c:	f7f4 fafc 	bl	1e68 <msg_free>
			return NULL;
    d870:	4627      	mov	r7, r4
}
    d872:	4638      	mov	r0, r7
    d874:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000d876 <log_msg_create_n>:
{
    d876:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d878:	4607      	mov	r7, r0
    d87a:	460e      	mov	r6, r1
    d87c:	4614      	mov	r4, r2
	msg = msg_alloc(nargs);
    d87e:	4610      	mov	r0, r2
    d880:	f7ff ffc8 	bl	d814 <msg_alloc>
	if (msg != NULL) {
    d884:	4605      	mov	r5, r0
    d886:	b140      	cbz	r0, d89a <log_msg_create_n+0x24>
		msg->str = str;
    d888:	6107      	str	r7, [r0, #16]
		msg->hdr.params.std.nargs = nargs;
    d88a:	7a43      	ldrb	r3, [r0, #9]
    d88c:	f364 1307 	bfi	r3, r4, #4, #4
    d890:	7243      	strb	r3, [r0, #9]
		copy_args_to_msg(msg, args, nargs);
    d892:	4622      	mov	r2, r4
    d894:	4631      	mov	r1, r6
    d896:	f7ff ff03 	bl	d6a0 <copy_args_to_msg>
}
    d89a:	4628      	mov	r0, r5
    d89c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000d89e <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      u8_t *data,
			      size_t *length,
			      size_t offset)
{
    d89e:	b510      	push	{r4, lr}
    d8a0:	b082      	sub	sp, #8
	log_msg_hexdump_data_op(msg, data, length, offset, false);
    d8a2:	2400      	movs	r4, #0
    d8a4:	9400      	str	r4, [sp, #0]
    d8a6:	f7ff ff21 	bl	d6ec <log_msg_hexdump_data_op>
}
    d8aa:	b002      	add	sp, #8
    d8ac:	bd10      	pop	{r4, pc}

0000d8ae <buffer_write>:
{
    d8ae:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d8b0:	4607      	mov	r7, r0
    d8b2:	460d      	mov	r5, r1
    d8b4:	4614      	mov	r4, r2
    d8b6:	461e      	mov	r6, r3
		processed = outf(buf, len, ctx);
    d8b8:	4632      	mov	r2, r6
    d8ba:	4621      	mov	r1, r4
    d8bc:	4628      	mov	r0, r5
    d8be:	47b8      	blx	r7
		buf += processed;
    d8c0:	4405      	add	r5, r0
	} while (len != 0);
    d8c2:	1a24      	subs	r4, r4, r0
    d8c4:	d1f8      	bne.n	d8b8 <buffer_write+0xa>
}
    d8c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000d8c8 <color_prefix>:
{
    d8c8:	b508      	push	{r3, lr}
    d8ca:	4613      	mov	r3, r2
	color_print(log_output, color, true, level);
    d8cc:	2201      	movs	r2, #1
    d8ce:	f7f4 fb65 	bl	1f9c <color_print>
}
    d8d2:	bd08      	pop	{r3, pc}

0000d8d4 <color_postfix>:
{
    d8d4:	b508      	push	{r3, lr}
    d8d6:	4613      	mov	r3, r2
	color_print(log_output, color, false, level);
    d8d8:	2200      	movs	r2, #0
    d8da:	f7f4 fb5f 	bl	1f9c <color_print>
}
    d8de:	bd08      	pop	{r3, pc}

0000d8e0 <postfix_print>:
{
    d8e0:	b538      	push	{r3, r4, r5, lr}
    d8e2:	4605      	mov	r5, r0
    d8e4:	460c      	mov	r4, r1
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
    d8e6:	f001 0101 	and.w	r1, r1, #1
    d8ea:	f7ff fff3 	bl	d8d4 <color_postfix>
	newline_print(log_output, flags);
    d8ee:	4621      	mov	r1, r4
    d8f0:	4628      	mov	r0, r5
    d8f2:	f7f4 fb69 	bl	1fc8 <newline_print>
}
    d8f6:	bd38      	pop	{r3, r4, r5, pc}

0000d8f8 <prefix_print>:
{
    d8f8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    d8fc:	b083      	sub	sp, #12
    d8fe:	4604      	mov	r4, r0
    d900:	4615      	mov	r5, r2
    d902:	f89d 6028 	ldrb.w	r6, [sp, #40]	; 0x28
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
    d906:	f001 0901 	and.w	r9, r1, #1
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
    d90a:	f3c1 08c0 	ubfx	r8, r1, #3, #1
	if (stamp) {
    d90e:	f011 0702 	ands.w	r7, r1, #2
    d912:	d113      	bne.n	d93c <prefix_print+0x44>
		color_prefix(log_output, colors_on, level);
    d914:	4632      	mov	r2, r6
    d916:	4649      	mov	r1, r9
    d918:	4620      	mov	r0, r4
    d91a:	f7ff ffd5 	bl	d8c8 <color_prefix>
		length += ids_print(log_output, level_on, func_on,
    d91e:	9601      	str	r6, [sp, #4]
    d920:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
    d924:	9300      	str	r3, [sp, #0]
    d926:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    d92a:	462a      	mov	r2, r5
    d92c:	4641      	mov	r1, r8
    d92e:	4620      	mov	r0, r4
    d930:	f7f4 fbc0 	bl	20b4 <ids_print>
}
    d934:	4438      	add	r0, r7
    d936:	b003      	add	sp, #12
    d938:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		length += timestamp_print(log_output, flags, timestamp);
    d93c:	461a      	mov	r2, r3
    d93e:	f7f4 fae7 	bl	1f10 <timestamp_print>
    d942:	4607      	mov	r7, r0
    d944:	e7e6      	b.n	d914 <prefix_print+0x1c>

0000d946 <std_print>:
{
    d946:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    d94a:	b08e      	sub	sp, #56	; 0x38
    d94c:	af0e      	add	r7, sp, #56	; 0x38
    d94e:	4606      	mov	r6, r0
    d950:	4689      	mov	r9, r1
	const char *str = log_msg_str_get(msg);
    d952:	f7ff ff4a 	bl	d7ea <log_msg_str_get>
    d956:	4682      	mov	sl, r0
	u32_t nargs = log_msg_nargs_get(msg);
    d958:	4630      	mov	r0, r6
    d95a:	f7ff ff31 	bl	d7c0 <log_msg_nargs_get>
    d95e:	4680      	mov	r8, r0
	u32_t *args = alloca(sizeof(u32_t)*nargs);
    d960:	0083      	lsls	r3, r0, #2
    d962:	3307      	adds	r3, #7
    d964:	f023 0307 	bic.w	r3, r3, #7
    d968:	ebad 0d03 	sub.w	sp, sp, r3
    d96c:	ad0e      	add	r5, sp, #56	; 0x38
	for (i = 0; i < nargs; i++) {
    d96e:	2400      	movs	r4, #0
    d970:	4544      	cmp	r4, r8
    d972:	d207      	bcs.n	d984 <std_print+0x3e>
		args[i] = log_msg_arg_get(msg, i);
    d974:	4621      	mov	r1, r4
    d976:	4630      	mov	r0, r6
    d978:	f7ff ff25 	bl	d7c6 <log_msg_arg_get>
    d97c:	f845 0024 	str.w	r0, [r5, r4, lsl #2]
	for (i = 0; i < nargs; i++) {
    d980:	3401      	adds	r4, #1
    d982:	e7f5      	b.n	d970 <std_print+0x2a>
	switch (log_msg_nargs_get(msg)) {
    d984:	4630      	mov	r0, r6
    d986:	f7ff ff1b 	bl	d7c0 <log_msg_nargs_get>
    d98a:	280f      	cmp	r0, #15
    d98c:	d815      	bhi.n	d9ba <std_print+0x74>
    d98e:	e8df f010 	tbh	[pc, r0, lsl #1]
    d992:	0010      	.short	0x0010
    d994:	001d0017 	.word	0x001d0017
    d998:	002d0024 	.word	0x002d0024
    d99c:	00450038 	.word	0x00450038
    d9a0:	00650054 	.word	0x00650054
    d9a4:	008d0078 	.word	0x008d0078
    d9a8:	00bd00a4 	.word	0x00bd00a4
    d9ac:	00f500d8 	.word	0x00f500d8
    d9b0:	0114      	.short	0x0114
		print_formatted(log_output, str);
    d9b2:	4651      	mov	r1, sl
    d9b4:	4648      	mov	r0, r9
    d9b6:	f7f4 fa97 	bl	1ee8 <print_formatted>
}
    d9ba:	46bd      	mov	sp, r7
    d9bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, str, args[0]);
    d9c0:	682a      	ldr	r2, [r5, #0]
    d9c2:	4651      	mov	r1, sl
    d9c4:	4648      	mov	r0, r9
    d9c6:	f7f4 fa8f 	bl	1ee8 <print_formatted>
		break;
    d9ca:	e7f6      	b.n	d9ba <std_print+0x74>
		print_formatted(log_output, str, args[0], args[1]);
    d9cc:	686b      	ldr	r3, [r5, #4]
    d9ce:	682a      	ldr	r2, [r5, #0]
    d9d0:	4651      	mov	r1, sl
    d9d2:	4648      	mov	r0, r9
    d9d4:	f7f4 fa88 	bl	1ee8 <print_formatted>
		break;
    d9d8:	e7ef      	b.n	d9ba <std_print+0x74>
		print_formatted(log_output, str, args[0], args[1], args[2]);
    d9da:	686b      	ldr	r3, [r5, #4]
    d9dc:	682a      	ldr	r2, [r5, #0]
    d9de:	68a9      	ldr	r1, [r5, #8]
    d9e0:	9100      	str	r1, [sp, #0]
    d9e2:	4651      	mov	r1, sl
    d9e4:	4648      	mov	r0, r9
    d9e6:	f7f4 fa7f 	bl	1ee8 <print_formatted>
		break;
    d9ea:	e7e6      	b.n	d9ba <std_print+0x74>
		print_formatted(log_output, str, args[0], args[1], args[2],
    d9ec:	686b      	ldr	r3, [r5, #4]
    d9ee:	682a      	ldr	r2, [r5, #0]
    d9f0:	68e9      	ldr	r1, [r5, #12]
    d9f2:	9101      	str	r1, [sp, #4]
    d9f4:	68a9      	ldr	r1, [r5, #8]
    d9f6:	9100      	str	r1, [sp, #0]
    d9f8:	4651      	mov	r1, sl
    d9fa:	4648      	mov	r0, r9
    d9fc:	f7f4 fa74 	bl	1ee8 <print_formatted>
		break;
    da00:	e7db      	b.n	d9ba <std_print+0x74>
		print_formatted(log_output, str, args[0], args[1], args[2],
    da02:	686b      	ldr	r3, [r5, #4]
    da04:	682a      	ldr	r2, [r5, #0]
    da06:	6929      	ldr	r1, [r5, #16]
    da08:	9102      	str	r1, [sp, #8]
    da0a:	68e9      	ldr	r1, [r5, #12]
    da0c:	9101      	str	r1, [sp, #4]
    da0e:	68a9      	ldr	r1, [r5, #8]
    da10:	9100      	str	r1, [sp, #0]
    da12:	4651      	mov	r1, sl
    da14:	4648      	mov	r0, r9
    da16:	f7f4 fa67 	bl	1ee8 <print_formatted>
		break;
    da1a:	e7ce      	b.n	d9ba <std_print+0x74>
		print_formatted(log_output, str, args[0], args[1], args[2],
    da1c:	686b      	ldr	r3, [r5, #4]
    da1e:	682a      	ldr	r2, [r5, #0]
    da20:	6969      	ldr	r1, [r5, #20]
    da22:	9103      	str	r1, [sp, #12]
    da24:	6929      	ldr	r1, [r5, #16]
    da26:	9102      	str	r1, [sp, #8]
    da28:	68e9      	ldr	r1, [r5, #12]
    da2a:	9101      	str	r1, [sp, #4]
    da2c:	68a9      	ldr	r1, [r5, #8]
    da2e:	9100      	str	r1, [sp, #0]
    da30:	4651      	mov	r1, sl
    da32:	4648      	mov	r0, r9
    da34:	f7f4 fa58 	bl	1ee8 <print_formatted>
		break;
    da38:	e7bf      	b.n	d9ba <std_print+0x74>
		print_formatted(log_output, str, args[0], args[1], args[2],
    da3a:	686b      	ldr	r3, [r5, #4]
    da3c:	682a      	ldr	r2, [r5, #0]
    da3e:	69a9      	ldr	r1, [r5, #24]
    da40:	9104      	str	r1, [sp, #16]
    da42:	6969      	ldr	r1, [r5, #20]
    da44:	9103      	str	r1, [sp, #12]
    da46:	6929      	ldr	r1, [r5, #16]
    da48:	9102      	str	r1, [sp, #8]
    da4a:	68e9      	ldr	r1, [r5, #12]
    da4c:	9101      	str	r1, [sp, #4]
    da4e:	68a9      	ldr	r1, [r5, #8]
    da50:	9100      	str	r1, [sp, #0]
    da52:	4651      	mov	r1, sl
    da54:	4648      	mov	r0, r9
    da56:	f7f4 fa47 	bl	1ee8 <print_formatted>
		break;
    da5a:	e7ae      	b.n	d9ba <std_print+0x74>
		print_formatted(log_output, str, args[0], args[1], args[2],
    da5c:	686b      	ldr	r3, [r5, #4]
    da5e:	682a      	ldr	r2, [r5, #0]
    da60:	69e9      	ldr	r1, [r5, #28]
    da62:	9105      	str	r1, [sp, #20]
    da64:	69a9      	ldr	r1, [r5, #24]
    da66:	9104      	str	r1, [sp, #16]
    da68:	6969      	ldr	r1, [r5, #20]
    da6a:	9103      	str	r1, [sp, #12]
    da6c:	6929      	ldr	r1, [r5, #16]
    da6e:	9102      	str	r1, [sp, #8]
    da70:	68e9      	ldr	r1, [r5, #12]
    da72:	9101      	str	r1, [sp, #4]
    da74:	68a9      	ldr	r1, [r5, #8]
    da76:	9100      	str	r1, [sp, #0]
    da78:	4651      	mov	r1, sl
    da7a:	4648      	mov	r0, r9
    da7c:	f7f4 fa34 	bl	1ee8 <print_formatted>
		break;
    da80:	e79b      	b.n	d9ba <std_print+0x74>
		print_formatted(log_output, str, args[0], args[1], args[2],
    da82:	686b      	ldr	r3, [r5, #4]
    da84:	682a      	ldr	r2, [r5, #0]
    da86:	6a29      	ldr	r1, [r5, #32]
    da88:	9106      	str	r1, [sp, #24]
    da8a:	69e9      	ldr	r1, [r5, #28]
    da8c:	9105      	str	r1, [sp, #20]
    da8e:	69a9      	ldr	r1, [r5, #24]
    da90:	9104      	str	r1, [sp, #16]
    da92:	6969      	ldr	r1, [r5, #20]
    da94:	9103      	str	r1, [sp, #12]
    da96:	6929      	ldr	r1, [r5, #16]
    da98:	9102      	str	r1, [sp, #8]
    da9a:	68e9      	ldr	r1, [r5, #12]
    da9c:	9101      	str	r1, [sp, #4]
    da9e:	68a9      	ldr	r1, [r5, #8]
    daa0:	9100      	str	r1, [sp, #0]
    daa2:	4651      	mov	r1, sl
    daa4:	4648      	mov	r0, r9
    daa6:	f7f4 fa1f 	bl	1ee8 <print_formatted>
		break;
    daaa:	e786      	b.n	d9ba <std_print+0x74>
		print_formatted(log_output, str, args[0], args[1], args[2],
    daac:	686b      	ldr	r3, [r5, #4]
    daae:	682a      	ldr	r2, [r5, #0]
    dab0:	6a69      	ldr	r1, [r5, #36]	; 0x24
    dab2:	9107      	str	r1, [sp, #28]
    dab4:	6a29      	ldr	r1, [r5, #32]
    dab6:	9106      	str	r1, [sp, #24]
    dab8:	69e9      	ldr	r1, [r5, #28]
    daba:	9105      	str	r1, [sp, #20]
    dabc:	69a9      	ldr	r1, [r5, #24]
    dabe:	9104      	str	r1, [sp, #16]
    dac0:	6969      	ldr	r1, [r5, #20]
    dac2:	9103      	str	r1, [sp, #12]
    dac4:	6929      	ldr	r1, [r5, #16]
    dac6:	9102      	str	r1, [sp, #8]
    dac8:	68e9      	ldr	r1, [r5, #12]
    daca:	9101      	str	r1, [sp, #4]
    dacc:	68a9      	ldr	r1, [r5, #8]
    dace:	9100      	str	r1, [sp, #0]
    dad0:	4651      	mov	r1, sl
    dad2:	4648      	mov	r0, r9
    dad4:	f7f4 fa08 	bl	1ee8 <print_formatted>
		break;
    dad8:	e76f      	b.n	d9ba <std_print+0x74>
		print_formatted(log_output, str, args[0], args[1], args[2],
    dada:	686b      	ldr	r3, [r5, #4]
    dadc:	682a      	ldr	r2, [r5, #0]
    dade:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    dae0:	9108      	str	r1, [sp, #32]
    dae2:	6a69      	ldr	r1, [r5, #36]	; 0x24
    dae4:	9107      	str	r1, [sp, #28]
    dae6:	6a29      	ldr	r1, [r5, #32]
    dae8:	9106      	str	r1, [sp, #24]
    daea:	69e9      	ldr	r1, [r5, #28]
    daec:	9105      	str	r1, [sp, #20]
    daee:	69a9      	ldr	r1, [r5, #24]
    daf0:	9104      	str	r1, [sp, #16]
    daf2:	6969      	ldr	r1, [r5, #20]
    daf4:	9103      	str	r1, [sp, #12]
    daf6:	6929      	ldr	r1, [r5, #16]
    daf8:	9102      	str	r1, [sp, #8]
    dafa:	68e9      	ldr	r1, [r5, #12]
    dafc:	9101      	str	r1, [sp, #4]
    dafe:	68a9      	ldr	r1, [r5, #8]
    db00:	9100      	str	r1, [sp, #0]
    db02:	4651      	mov	r1, sl
    db04:	4648      	mov	r0, r9
    db06:	f7f4 f9ef 	bl	1ee8 <print_formatted>
		break;
    db0a:	e756      	b.n	d9ba <std_print+0x74>
		print_formatted(log_output, str, args[0], args[1], args[2],
    db0c:	686b      	ldr	r3, [r5, #4]
    db0e:	682a      	ldr	r2, [r5, #0]
    db10:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
    db12:	9109      	str	r1, [sp, #36]	; 0x24
    db14:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    db16:	9108      	str	r1, [sp, #32]
    db18:	6a69      	ldr	r1, [r5, #36]	; 0x24
    db1a:	9107      	str	r1, [sp, #28]
    db1c:	6a29      	ldr	r1, [r5, #32]
    db1e:	9106      	str	r1, [sp, #24]
    db20:	69e9      	ldr	r1, [r5, #28]
    db22:	9105      	str	r1, [sp, #20]
    db24:	69a9      	ldr	r1, [r5, #24]
    db26:	9104      	str	r1, [sp, #16]
    db28:	6969      	ldr	r1, [r5, #20]
    db2a:	9103      	str	r1, [sp, #12]
    db2c:	6929      	ldr	r1, [r5, #16]
    db2e:	9102      	str	r1, [sp, #8]
    db30:	68e9      	ldr	r1, [r5, #12]
    db32:	9101      	str	r1, [sp, #4]
    db34:	68a9      	ldr	r1, [r5, #8]
    db36:	9100      	str	r1, [sp, #0]
    db38:	4651      	mov	r1, sl
    db3a:	4648      	mov	r0, r9
    db3c:	f7f4 f9d4 	bl	1ee8 <print_formatted>
		break;
    db40:	e73b      	b.n	d9ba <std_print+0x74>
		print_formatted(log_output, str, args[0], args[1], args[2],
    db42:	686b      	ldr	r3, [r5, #4]
    db44:	682a      	ldr	r2, [r5, #0]
    db46:	6b29      	ldr	r1, [r5, #48]	; 0x30
    db48:	910a      	str	r1, [sp, #40]	; 0x28
    db4a:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
    db4c:	9109      	str	r1, [sp, #36]	; 0x24
    db4e:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    db50:	9108      	str	r1, [sp, #32]
    db52:	6a69      	ldr	r1, [r5, #36]	; 0x24
    db54:	9107      	str	r1, [sp, #28]
    db56:	6a29      	ldr	r1, [r5, #32]
    db58:	9106      	str	r1, [sp, #24]
    db5a:	69e9      	ldr	r1, [r5, #28]
    db5c:	9105      	str	r1, [sp, #20]
    db5e:	69a9      	ldr	r1, [r5, #24]
    db60:	9104      	str	r1, [sp, #16]
    db62:	6969      	ldr	r1, [r5, #20]
    db64:	9103      	str	r1, [sp, #12]
    db66:	6929      	ldr	r1, [r5, #16]
    db68:	9102      	str	r1, [sp, #8]
    db6a:	68e9      	ldr	r1, [r5, #12]
    db6c:	9101      	str	r1, [sp, #4]
    db6e:	68a9      	ldr	r1, [r5, #8]
    db70:	9100      	str	r1, [sp, #0]
    db72:	4651      	mov	r1, sl
    db74:	4648      	mov	r0, r9
    db76:	f7f4 f9b7 	bl	1ee8 <print_formatted>
		break;
    db7a:	e71e      	b.n	d9ba <std_print+0x74>
		print_formatted(log_output, str, args[0], args[1], args[2],
    db7c:	686b      	ldr	r3, [r5, #4]
    db7e:	682a      	ldr	r2, [r5, #0]
    db80:	6b69      	ldr	r1, [r5, #52]	; 0x34
    db82:	910b      	str	r1, [sp, #44]	; 0x2c
    db84:	6b29      	ldr	r1, [r5, #48]	; 0x30
    db86:	910a      	str	r1, [sp, #40]	; 0x28
    db88:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
    db8a:	9109      	str	r1, [sp, #36]	; 0x24
    db8c:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    db8e:	9108      	str	r1, [sp, #32]
    db90:	6a69      	ldr	r1, [r5, #36]	; 0x24
    db92:	9107      	str	r1, [sp, #28]
    db94:	6a29      	ldr	r1, [r5, #32]
    db96:	9106      	str	r1, [sp, #24]
    db98:	69e9      	ldr	r1, [r5, #28]
    db9a:	9105      	str	r1, [sp, #20]
    db9c:	69a9      	ldr	r1, [r5, #24]
    db9e:	9104      	str	r1, [sp, #16]
    dba0:	6969      	ldr	r1, [r5, #20]
    dba2:	9103      	str	r1, [sp, #12]
    dba4:	6929      	ldr	r1, [r5, #16]
    dba6:	9102      	str	r1, [sp, #8]
    dba8:	68e9      	ldr	r1, [r5, #12]
    dbaa:	9101      	str	r1, [sp, #4]
    dbac:	68a9      	ldr	r1, [r5, #8]
    dbae:	9100      	str	r1, [sp, #0]
    dbb0:	4651      	mov	r1, sl
    dbb2:	4648      	mov	r0, r9
    dbb4:	f7f4 f998 	bl	1ee8 <print_formatted>
		break;
    dbb8:	e6ff      	b.n	d9ba <std_print+0x74>
		print_formatted(log_output, str, args[0], args[1], args[2],
    dbba:	686b      	ldr	r3, [r5, #4]
    dbbc:	682a      	ldr	r2, [r5, #0]
    dbbe:	6ba9      	ldr	r1, [r5, #56]	; 0x38
    dbc0:	910c      	str	r1, [sp, #48]	; 0x30
    dbc2:	6b69      	ldr	r1, [r5, #52]	; 0x34
    dbc4:	910b      	str	r1, [sp, #44]	; 0x2c
    dbc6:	6b29      	ldr	r1, [r5, #48]	; 0x30
    dbc8:	910a      	str	r1, [sp, #40]	; 0x28
    dbca:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
    dbcc:	9109      	str	r1, [sp, #36]	; 0x24
    dbce:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    dbd0:	9108      	str	r1, [sp, #32]
    dbd2:	6a69      	ldr	r1, [r5, #36]	; 0x24
    dbd4:	9107      	str	r1, [sp, #28]
    dbd6:	6a29      	ldr	r1, [r5, #32]
    dbd8:	9106      	str	r1, [sp, #24]
    dbda:	69e9      	ldr	r1, [r5, #28]
    dbdc:	9105      	str	r1, [sp, #20]
    dbde:	69a9      	ldr	r1, [r5, #24]
    dbe0:	9104      	str	r1, [sp, #16]
    dbe2:	6969      	ldr	r1, [r5, #20]
    dbe4:	9103      	str	r1, [sp, #12]
    dbe6:	6929      	ldr	r1, [r5, #16]
    dbe8:	9102      	str	r1, [sp, #8]
    dbea:	68e9      	ldr	r1, [r5, #12]
    dbec:	9101      	str	r1, [sp, #4]
    dbee:	68a9      	ldr	r1, [r5, #8]
    dbf0:	9100      	str	r1, [sp, #0]
    dbf2:	4651      	mov	r1, sl
    dbf4:	4648      	mov	r0, r9
    dbf6:	f7f4 f977 	bl	1ee8 <print_formatted>
}
    dbfa:	e6de      	b.n	d9ba <std_print+0x74>

0000dbfc <log_output_flush>:
{
    dbfc:	b510      	push	{r4, lr}
    dbfe:	4604      	mov	r4, r0
		     log_output->control_block->offset,
    dc00:	6842      	ldr	r2, [r0, #4]
	buffer_write(log_output->func, log_output->buf,
    dc02:	6853      	ldr	r3, [r2, #4]
    dc04:	6812      	ldr	r2, [r2, #0]
    dc06:	6881      	ldr	r1, [r0, #8]
    dc08:	6800      	ldr	r0, [r0, #0]
    dc0a:	f7ff fe50 	bl	d8ae <buffer_write>
	log_output->control_block->offset = 0;
    dc0e:	6863      	ldr	r3, [r4, #4]
    dc10:	2200      	movs	r2, #0
    dc12:	601a      	str	r2, [r3, #0]
}
    dc14:	bd10      	pop	{r4, pc}

0000dc16 <out_func>:
{
    dc16:	b538      	push	{r3, r4, r5, lr}
    dc18:	4605      	mov	r5, r0
    dc1a:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
    dc1c:	684b      	ldr	r3, [r1, #4]
    dc1e:	681a      	ldr	r2, [r3, #0]
    dc20:	68cb      	ldr	r3, [r1, #12]
    dc22:	429a      	cmp	r2, r3
    dc24:	d00f      	beq.n	dc46 <out_func+0x30>
	idx = atomic_inc(&out_ctx->control_block->offset);
    dc26:	6863      	ldr	r3, [r4, #4]
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    dc28:	f3bf 8f5b 	dmb	ish
    dc2c:	e853 2f00 	ldrex	r2, [r3]
    dc30:	1c51      	adds	r1, r2, #1
    dc32:	e843 1000 	strex	r0, r1, [r3]
    dc36:	2800      	cmp	r0, #0
    dc38:	d1f8      	bne.n	dc2c <out_func+0x16>
    dc3a:	f3bf 8f5b 	dmb	ish
	out_ctx->buf[idx] = (u8_t)c;
    dc3e:	68a3      	ldr	r3, [r4, #8]
    dc40:	549d      	strb	r5, [r3, r2]
}
    dc42:	2000      	movs	r0, #0
    dc44:	bd38      	pop	{r3, r4, r5, pc}
		log_output_flush(out_ctx);
    dc46:	4608      	mov	r0, r1
    dc48:	f7ff ffd8 	bl	dbfc <log_output_flush>
    dc4c:	e7eb      	b.n	dc26 <out_func+0x10>

0000dc4e <log_output_msg_process>:
{
    dc4e:	b5f0      	push	{r4, r5, r6, r7, lr}
    dc50:	b085      	sub	sp, #20
    dc52:	4606      	mov	r6, r0
    dc54:	460c      	mov	r4, r1
    dc56:	4617      	mov	r7, r2
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    dc58:	7a0b      	ldrb	r3, [r1, #8]
    dc5a:	f083 0301 	eor.w	r3, r3, #1
    dc5e:	f003 0201 	and.w	r2, r3, #1
	return msg->hdr.timestamp;
    dc62:	68cb      	ldr	r3, [r1, #12]
	return msg->hdr.ids.level;
    dc64:	7a89      	ldrb	r1, [r1, #10]
	return msg->hdr.ids.domain_id;
    dc66:	f3c1 0cc2 	ubfx	ip, r1, #3, #3
	return msg->hdr.ids.source_id;
    dc6a:	8960      	ldrh	r0, [r4, #10]
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    dc6c:	f011 0507 	ands.w	r5, r1, #7
    dc70:	d10f      	bne.n	dc92 <log_output_msg_process+0x44>
    dc72:	2200      	movs	r2, #0
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    dc74:	7a23      	ldrb	r3, [r4, #8]
	if (log_msg_is_std(msg)) {
    dc76:	f013 0f01 	tst.w	r3, #1
    dc7a:	d015      	beq.n	dca8 <log_output_msg_process+0x5a>
	} else if (raw_string) {
    dc7c:	b9cd      	cbnz	r5, dcb2 <log_output_msg_process+0x64>
		raw_string_print(msg, log_output);
    dc7e:	4631      	mov	r1, r6
    dc80:	4620      	mov	r0, r4
    dc82:	f7f4 fa6f 	bl	2164 <raw_string_print>
	if (!raw_string) {
    dc86:	b9d5      	cbnz	r5, dcbe <log_output_msg_process+0x70>
	log_output_flush(log_output);
    dc88:	4630      	mov	r0, r6
    dc8a:	f7ff ffb7 	bl	dbfc <log_output_flush>
}
    dc8e:	b005      	add	sp, #20
    dc90:	bdf0      	pop	{r4, r5, r6, r7, pc}
    dc92:	0980      	lsrs	r0, r0, #6
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    dc94:	9002      	str	r0, [sp, #8]
    dc96:	f8cd c004 	str.w	ip, [sp, #4]
    dc9a:	9500      	str	r5, [sp, #0]
    dc9c:	4639      	mov	r1, r7
    dc9e:	4630      	mov	r0, r6
    dca0:	f7ff fe2a 	bl	d8f8 <prefix_print>
    dca4:	4602      	mov	r2, r0
    dca6:	e7e5      	b.n	dc74 <log_output_msg_process+0x26>
		std_print(msg, log_output);
    dca8:	4631      	mov	r1, r6
    dcaa:	4620      	mov	r0, r4
    dcac:	f7ff fe4b 	bl	d946 <std_print>
    dcb0:	e7e9      	b.n	dc86 <log_output_msg_process+0x38>
		hexdump_print(msg, log_output, prefix_offset, flags);
    dcb2:	463b      	mov	r3, r7
    dcb4:	4631      	mov	r1, r6
    dcb6:	4620      	mov	r0, r4
    dcb8:	f7f4 fa2a 	bl	2110 <hexdump_print>
    dcbc:	e7e3      	b.n	dc86 <log_output_msg_process+0x38>
		postfix_print(log_output, flags, level);
    dcbe:	462a      	mov	r2, r5
    dcc0:	4639      	mov	r1, r7
    dcc2:	4630      	mov	r0, r6
    dcc4:	f7ff fe0c 	bl	d8e0 <postfix_print>
    dcc8:	e7de      	b.n	dc88 <log_output_msg_process+0x3a>

0000dcca <char_out>:
{
    dcca:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    dccc:	4607      	mov	r7, r0
    dcce:	460e      	mov	r6, r1
    dcd0:	4615      	mov	r5, r2
	for (size_t i = 0; i < length; i++) {
    dcd2:	2400      	movs	r4, #0
    dcd4:	42b4      	cmp	r4, r6
    dcd6:	d206      	bcs.n	dce6 <char_out+0x1c>
		uart_poll_out(dev, data[i]);
    dcd8:	5d39      	ldrb	r1, [r7, r4]
	const struct uart_driver_api *api =
    dcda:	68ab      	ldr	r3, [r5, #8]
	api->poll_out(dev, out_char);
    dcdc:	685b      	ldr	r3, [r3, #4]
    dcde:	4628      	mov	r0, r5
    dce0:	4798      	blx	r3
	for (size_t i = 0; i < length; i++) {
    dce2:	3401      	adds	r4, #1
    dce4:	e7f6      	b.n	dcd4 <char_out+0xa>
}
    dce6:	4630      	mov	r0, r6
    dce8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000dcea <clock_event_check_and_clean>:
#endif
}

NRF_STATIC_INLINE bool nrf_clock_event_check(NRF_CLOCK_Type const * p_reg, nrf_clock_event_t event)
{
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    dcea:	f100 4380 	add.w	r3, r0, #1073741824	; 0x40000000
    dcee:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
    dcf0:	b13a      	cbz	r2, dd02 <clock_event_check_and_clean+0x18>
    return p_reg->INTENSET & mask;
    dcf2:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    dcf6:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
    dcfa:	4211      	tst	r1, r2
    dcfc:	d00c      	beq.n	dd18 <clock_event_check_and_clean+0x2e>
    dcfe:	2201      	movs	r2, #1
    dd00:	e000      	b.n	dd04 <clock_event_check_and_clean+0x1a>
    dd02:	2200      	movs	r2, #0
	if (ret) {
    dd04:	4610      	mov	r0, r2
    dd06:	b14a      	cbz	r2, dd1c <clock_event_check_and_clean+0x32>
{
    dd08:	b082      	sub	sp, #8
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    dd0a:	2200      	movs	r2, #0
    dd0c:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    dd0e:	681b      	ldr	r3, [r3, #0]
    dd10:	9301      	str	r3, [sp, #4]
    (void)dummy;
    dd12:	9b01      	ldr	r3, [sp, #4]
}
    dd14:	b002      	add	sp, #8
    dd16:	4770      	bx	lr
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
    dd18:	2200      	movs	r2, #0
    dd1a:	e7f3      	b.n	dd04 <clock_event_check_and_clean+0x1a>
}
    dd1c:	4770      	bx	lr

0000dd1e <clock_irqs_disable>:
    p_reg->INTENCLR = mask;
    dd1e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    dd22:	2203      	movs	r2, #3
    dd24:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
    dd28:	4770      	bx	lr

0000dd2a <clock_irqs_enable>:
    p_reg->INTENSET = mask;
    dd2a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    dd2e:	2203      	movs	r2, #3
    dd30:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    dd34:	4770      	bx	lr

0000dd36 <get_sub_data>:
	struct nrf_clock_control_data *data = dev->driver_data;
    dd36:	68c0      	ldr	r0, [r0, #12]
	return &data->subsys[type];
    dd38:	eb01 0141 	add.w	r1, r1, r1, lsl #1
}
    dd3c:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    dd40:	4770      	bx	lr

0000dd42 <get_sub_config>:
	const struct nrf_clock_control_config *config =
    dd42:	6840      	ldr	r0, [r0, #4]
}
    dd44:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
    dd48:	4770      	bx	lr

0000dd4a <get_status>:
{
    dd4a:	b508      	push	{r3, lr}
	data = get_sub_data(dev, type);
    dd4c:	b2c9      	uxtb	r1, r1
    dd4e:	f7ff fff2 	bl	dd36 <get_sub_data>
	if (data->started) {
    dd52:	7a43      	ldrb	r3, [r0, #9]
    dd54:	b91b      	cbnz	r3, dd5e <get_status+0x14>
	if (data->ref > 0) {
    dd56:	7a03      	ldrb	r3, [r0, #8]
    dd58:	b91b      	cbnz	r3, dd62 <get_status+0x18>
	return CLOCK_CONTROL_STATUS_OFF;
    dd5a:	2001      	movs	r0, #1
}
    dd5c:	bd08      	pop	{r3, pc}
		return CLOCK_CONTROL_STATUS_ON;
    dd5e:	2002      	movs	r0, #2
    dd60:	e7fc      	b.n	dd5c <get_status+0x12>
		return CLOCK_CONTROL_STATUS_STARTING;
    dd62:	2000      	movs	r0, #0
    dd64:	e7fa      	b.n	dd5c <get_status+0x12>

0000dd66 <clock_stop>:
{
    dd66:	b570      	push	{r4, r5, r6, lr}
    dd68:	4606      	mov	r6, r0
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
    dd6a:	b2cc      	uxtb	r4, r1
	config = get_sub_config(dev, type);
    dd6c:	4621      	mov	r1, r4
    dd6e:	f7ff ffe8 	bl	dd42 <get_sub_config>
    dd72:	4605      	mov	r5, r0
	data = get_sub_data(dev, type);
    dd74:	4621      	mov	r1, r4
    dd76:	4630      	mov	r0, r6
    dd78:	f7ff ffdd 	bl	dd36 <get_sub_data>
	__asm__ volatile(
    dd7c:	f04f 0320 	mov.w	r3, #32
    dd80:	f3ef 8211 	mrs	r2, BASEPRI
    dd84:	f383 8811 	msr	BASEPRI, r3
    dd88:	f3bf 8f6f 	isb	sy
	if (data->ref == 0) {
    dd8c:	7a03      	ldrb	r3, [r0, #8]
    dd8e:	b18b      	cbz	r3, ddb4 <clock_stop+0x4e>
	data->ref--;
    dd90:	3b01      	subs	r3, #1
    dd92:	b2db      	uxtb	r3, r3
    dd94:	7203      	strb	r3, [r0, #8]
	if (data->ref == 0) {
    dd96:	b983      	cbnz	r3, ddba <clock_stop+0x54>
	list->head = NULL;
    dd98:	6003      	str	r3, [r0, #0]
	list->tail = NULL;
    dd9a:	6043      	str	r3, [r0, #4]
		nrf_clock_task_trigger(NRF_CLOCK, config->stop_tsk);
    dd9c:	78e9      	ldrb	r1, [r5, #3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    dd9e:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
    dda2:	2401      	movs	r4, #1
    dda4:	600c      	str	r4, [r1, #0]
		data->started = false;
    dda6:	7243      	strb	r3, [r0, #9]
	int err = 0;
    dda8:	4618      	mov	r0, r3
	__asm__ volatile(
    ddaa:	f382 8811 	msr	BASEPRI, r2
    ddae:	f3bf 8f6f 	isb	sy
}
    ddb2:	bd70      	pop	{r4, r5, r6, pc}
		err = -EALREADY;
    ddb4:	f06f 0077 	mvn.w	r0, #119	; 0x77
    ddb8:	e7f7      	b.n	ddaa <clock_stop+0x44>
	int err = 0;
    ddba:	2000      	movs	r0, #0
    ddbc:	e7f5      	b.n	ddaa <clock_stop+0x44>

0000ddbe <is_in_list>:
	return list->head;
    ddbe:	6803      	ldr	r3, [r0, #0]
		if (item == node) {
    ddc0:	428b      	cmp	r3, r1
    ddc2:	d005      	beq.n	ddd0 <is_in_list+0x12>
Z_GENLIST_PEEK_NEXT(slist, snode)
    ddc4:	b133      	cbz	r3, ddd4 <is_in_list+0x16>
	return node->next;
    ddc6:	681b      	ldr	r3, [r3, #0]
	} while (item);
    ddc8:	2b00      	cmp	r3, #0
    ddca:	d1f9      	bne.n	ddc0 <is_in_list+0x2>
	return false;
    ddcc:	2000      	movs	r0, #0
    ddce:	4770      	bx	lr
			return true;
    ddd0:	2001      	movs	r0, #1
    ddd2:	4770      	bx	lr
	return false;
    ddd4:	2000      	movs	r0, #0
}
    ddd6:	4770      	bx	lr

0000ddd8 <list_append>:
	__asm__ volatile(
    ddd8:	f04f 0320 	mov.w	r3, #32
    dddc:	f3ef 8211 	mrs	r2, BASEPRI
    dde0:	f383 8811 	msr	BASEPRI, r3
    dde4:	f3bf 8f6f 	isb	sy
	parent->next = child;
    dde8:	2300      	movs	r3, #0
    ddea:	600b      	str	r3, [r1, #0]
	return list->tail;
    ddec:	6843      	ldr	r3, [r0, #4]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    ddee:	b133      	cbz	r3, ddfe <list_append+0x26>
	parent->next = child;
    ddf0:	6019      	str	r1, [r3, #0]
	list->tail = node;
    ddf2:	6041      	str	r1, [r0, #4]
	__asm__ volatile(
    ddf4:	f382 8811 	msr	BASEPRI, r2
    ddf8:	f3bf 8f6f 	isb	sy
}
    ddfc:	4770      	bx	lr
    ddfe:	6041      	str	r1, [r0, #4]
	list->head = node;
    de00:	6001      	str	r1, [r0, #0]
}
    de02:	e7f7      	b.n	ddf4 <list_append+0x1c>

0000de04 <list_get>:
{
    de04:	4603      	mov	r3, r0
	__asm__ volatile(
    de06:	f04f 0120 	mov.w	r1, #32
    de0a:	f3ef 8211 	mrs	r2, BASEPRI
    de0e:	f381 8811 	msr	BASEPRI, r1
    de12:	f3bf 8f6f 	isb	sy
	return list->head;
    de16:	6800      	ldr	r0, [r0, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    de18:	b168      	cbz	r0, de36 <list_get+0x32>
    de1a:	b410      	push	{r4}
	return node->next;
    de1c:	6801      	ldr	r1, [r0, #0]
	list->head = node;
    de1e:	6019      	str	r1, [r3, #0]
	return list->tail;
    de20:	685c      	ldr	r4, [r3, #4]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    de22:	42a0      	cmp	r0, r4
    de24:	d005      	beq.n	de32 <list_get+0x2e>
	__asm__ volatile(
    de26:	f382 8811 	msr	BASEPRI, r2
    de2a:	f3bf 8f6f 	isb	sy
}
    de2e:	bc10      	pop	{r4}
    de30:	4770      	bx	lr
	list->tail = node;
    de32:	6059      	str	r1, [r3, #4]
}
    de34:	e7f7      	b.n	de26 <list_get+0x22>
    de36:	f382 8811 	msr	BASEPRI, r2
    de3a:	f3bf 8f6f 	isb	sy
    de3e:	4770      	bx	lr

0000de40 <clock_async_start>:
{
    de40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    de44:	4607      	mov	r7, r0
    de46:	4688      	mov	r8, r1
    de48:	4615      	mov	r5, r2
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
    de4a:	b2cc      	uxtb	r4, r1
	config = get_sub_config(dev, type);
    de4c:	4621      	mov	r1, r4
    de4e:	f7ff ff78 	bl	dd42 <get_sub_config>
    de52:	4681      	mov	r9, r0
	clk_data = get_sub_data(dev, type);
    de54:	4621      	mov	r1, r4
    de56:	4638      	mov	r0, r7
    de58:	f7ff ff6d 	bl	dd36 <get_sub_data>
    de5c:	4606      	mov	r6, r0
	if ((data != NULL)
    de5e:	b11d      	cbz	r5, de68 <clock_async_start+0x28>
	    && is_in_list(&clk_data->list, &data->node)) {
    de60:	4629      	mov	r1, r5
    de62:	f7ff ffac 	bl	ddbe <is_in_list>
    de66:	bb98      	cbnz	r0, ded0 <clock_async_start+0x90>
	__asm__ volatile(
    de68:	f04f 0220 	mov.w	r2, #32
    de6c:	f3ef 8311 	mrs	r3, BASEPRI
    de70:	f382 8811 	msr	BASEPRI, r2
    de74:	f3bf 8f6f 	isb	sy
	ref = ++clk_data->ref;
    de78:	7a34      	ldrb	r4, [r6, #8]
    de7a:	3401      	adds	r4, #1
    de7c:	b2e4      	uxtb	r4, r4
    de7e:	7234      	strb	r4, [r6, #8]
	__asm__ volatile(
    de80:	f383 8811 	msr	BASEPRI, r3
    de84:	f3bf 8f6f 	isb	sy
	if (data) {
    de88:	b185      	cbz	r5, deac <clock_async_start+0x6c>
		clock_irqs_disable();
    de8a:	f7ff ff48 	bl	dd1e <clock_irqs_disable>
		already_started = clk_data->started;
    de8e:	f896 a009 	ldrb.w	sl, [r6, #9]
		if (!already_started) {
    de92:	f1ba 0f00 	cmp.w	sl, #0
    de96:	d00e      	beq.n	deb6 <clock_async_start+0x76>
		clock_irqs_enable();
    de98:	f7ff ff47 	bl	dd2a <clock_irqs_enable>
		if (already_started) {
    de9c:	f1ba 0f00 	cmp.w	sl, #0
    dea0:	d004      	beq.n	deac <clock_async_start+0x6c>
			data->cb(dev, subsys, data->user_data);
    dea2:	686b      	ldr	r3, [r5, #4]
    dea4:	68aa      	ldr	r2, [r5, #8]
    dea6:	4641      	mov	r1, r8
    dea8:	4638      	mov	r0, r7
    deaa:	4798      	blx	r3
	if (ref == 1) {
    deac:	2c01      	cmp	r4, #1
    deae:	d007      	beq.n	dec0 <clock_async_start+0x80>
	return 0;
    deb0:	2000      	movs	r0, #0
}
    deb2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			list_append(&clk_data->list, &data->node);
    deb6:	4629      	mov	r1, r5
    deb8:	4630      	mov	r0, r6
    deba:	f7ff ff8d 	bl	ddd8 <list_append>
    debe:	e7eb      	b.n	de98 <clock_async_start+0x58>
		nrf_clock_task_trigger(NRF_CLOCK, config->start_tsk);
    dec0:	f899 3002 	ldrb.w	r3, [r9, #2]
    dec4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    dec8:	2201      	movs	r2, #1
    deca:	601a      	str	r2, [r3, #0]
	return 0;
    decc:	2000      	movs	r0, #0
}
    dece:	e7f0      	b.n	deb2 <clock_async_start+0x72>
		return -EBUSY;
    ded0:	f06f 000f 	mvn.w	r0, #15
    ded4:	e7ed      	b.n	deb2 <clock_async_start+0x72>

0000ded6 <clock_start>:
{
    ded6:	b508      	push	{r3, lr}
	return clock_async_start(dev, sub_system, NULL);
    ded8:	2200      	movs	r2, #0
    deda:	f7ff ffb1 	bl	de40 <clock_async_start>
}
    dede:	bd08      	pop	{r3, pc}

0000dee0 <clkstarted_handle>:
{
    dee0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    dee2:	4607      	mov	r7, r0
    dee4:	460e      	mov	r6, r1
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
    dee6:	f7ff ff26 	bl	dd36 <get_sub_data>
    deea:	4605      	mov	r5, r0
	sub_data->started = true;
    deec:	2301      	movs	r3, #1
    deee:	7243      	strb	r3, [r0, #9]
	while ((async_data = list_get(&sub_data->list)) != NULL) {
    def0:	4628      	mov	r0, r5
    def2:	f7ff ff87 	bl	de04 <list_get>
    def6:	4603      	mov	r3, r0
    def8:	b128      	cbz	r0, df06 <clkstarted_handle+0x26>
		async_data->cb(dev, (clock_control_subsys_t)type,
    defa:	685c      	ldr	r4, [r3, #4]
    defc:	689a      	ldr	r2, [r3, #8]
    defe:	4631      	mov	r1, r6
    df00:	4638      	mov	r0, r7
    df02:	47a0      	blx	r4
    df04:	e7f4      	b.n	def0 <clkstarted_handle+0x10>
}
    df06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000df08 <clk_init>:
{
    df08:	b538      	push	{r3, r4, r5, lr}
    df0a:	4605      	mov	r5, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    df0c:	2200      	movs	r2, #0
    df0e:	2101      	movs	r1, #1
    df10:	4610      	mov	r0, r2
    df12:	f7f4 fcd5 	bl	28c0 <z_arm_irq_priority_set>
	irq_enable(DT_INST_IRQN(0));
    df16:	2000      	movs	r0, #0
    df18:	f7f4 fca0 	bl	285c <arch_irq_enable>
}

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
    p_reg->LFCLKSRC = (uint32_t)(source);
    df1c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    df20:	2201      	movs	r2, #1
    df22:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
	clock_irqs_enable();
    df26:	f7ff ff00 	bl	dd2a <clock_irqs_enable>
	for (enum clock_control_nrf_type i = 0;
    df2a:	2400      	movs	r4, #0
    df2c:	e008      	b.n	df40 <clk_init+0x38>
		sys_slist_init(&(get_sub_data(dev, i)->list));
    df2e:	4621      	mov	r1, r4
    df30:	4628      	mov	r0, r5
    df32:	f7ff ff00 	bl	dd36 <get_sub_data>
	list->head = NULL;
    df36:	2300      	movs	r3, #0
    df38:	6003      	str	r3, [r0, #0]
	list->tail = NULL;
    df3a:	6043      	str	r3, [r0, #4]
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
    df3c:	3401      	adds	r4, #1
    df3e:	b2e4      	uxtb	r4, r4
	for (enum clock_control_nrf_type i = 0;
    df40:	2c01      	cmp	r4, #1
    df42:	d9f4      	bls.n	df2e <clk_init+0x26>
}
    df44:	2000      	movs	r0, #0
    df46:	bd38      	pop	{r3, r4, r5, pc}

0000df48 <z_clock_isr>:
/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
	__ASSERT_NO_MSG(false);
}
    df48:	4770      	bx	lr

0000df4a <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
    df4a:	4770      	bx	lr

0000df4c <counter_sub>:
	return (a - b) & COUNTER_MAX;
    df4c:	1a40      	subs	r0, r0, r1
}
    df4e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    df52:	4770      	bx	lr

0000df54 <handle_next_tick_case>:
{
    df54:	b510      	push	{r4, lr}
    df56:	4604      	mov	r4, r0
	set_comparator(t + 2);
    df58:	3002      	adds	r0, #2
    df5a:	f7f4 fa95 	bl	2488 <set_comparator>
	while (t != counter()) {
    df5e:	f7f4 fac5 	bl	24ec <counter>
    df62:	42a0      	cmp	r0, r4
    df64:	d006      	beq.n	df74 <handle_next_tick_case+0x20>
		t = counter();
    df66:	f7f4 fac1 	bl	24ec <counter>
    df6a:	4604      	mov	r4, r0
		set_comparator(t + 2);
    df6c:	3002      	adds	r0, #2
    df6e:	f7f4 fa8b 	bl	2488 <set_comparator>
    df72:	e7f4      	b.n	df5e <handle_next_tick_case+0xa>
}
    df74:	bd10      	pop	{r4, pc}

0000df76 <set_absolute_ticks>:
{
    df76:	b538      	push	{r3, r4, r5, lr}
    df78:	4604      	mov	r4, r0
	u32_t t = counter();
    df7a:	f7f4 fab7 	bl	24ec <counter>
    df7e:	4605      	mov	r5, r0
	diff = counter_sub(abs_val, t);
    df80:	4601      	mov	r1, r0
    df82:	4620      	mov	r0, r4
    df84:	f7ff ffe2 	bl	df4c <counter_sub>
	if (diff == 1) {
    df88:	2801      	cmp	r0, #1
    df8a:	d00d      	beq.n	dfa8 <set_absolute_ticks+0x32>
	set_comparator(abs_val);
    df8c:	4620      	mov	r0, r4
    df8e:	f7f4 fa7b 	bl	2488 <set_comparator>
	t = counter();
    df92:	f7f4 faab 	bl	24ec <counter>
    df96:	4605      	mov	r5, r0
	diff = counter_sub(abs_val - 2, t);
    df98:	4601      	mov	r1, r0
    df9a:	1ea0      	subs	r0, r4, #2
    df9c:	f7ff ffd6 	bl	df4c <counter_sub>
	if (diff > MAX_TICKS) {
    dfa0:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    dfa4:	d204      	bcs.n	dfb0 <set_absolute_ticks+0x3a>
}
    dfa6:	bd38      	pop	{r3, r4, r5, pc}
		handle_next_tick_case(t);
    dfa8:	4628      	mov	r0, r5
    dfaa:	f7ff ffd3 	bl	df54 <handle_next_tick_case>
		return;
    dfae:	e7fa      	b.n	dfa6 <set_absolute_ticks+0x30>
		handle_next_tick_case(t);
    dfb0:	4628      	mov	r0, r5
    dfb2:	f7ff ffcf 	bl	df54 <handle_next_tick_case>
    dfb6:	e7f6      	b.n	dfa6 <set_absolute_ticks+0x30>

0000dfb8 <set_protected_absolute_ticks>:
{
    dfb8:	b510      	push	{r4, lr}
    dfba:	4604      	mov	r4, r0
	int_disable();
    dfbc:	f7f4 fa86 	bl	24cc <int_disable>
	prevent_false_prev_evt();
    dfc0:	f7f4 faac 	bl	251c <prevent_false_prev_evt>
	set_absolute_ticks(ticks);
    dfc4:	4620      	mov	r0, r4
    dfc6:	f7ff ffd6 	bl	df76 <set_absolute_ticks>
	int_enable();
    dfca:	f7f4 fa87 	bl	24dc <int_enable>
}
    dfce:	bd10      	pop	{r4, pc}

0000dfd0 <SEGGER_RTT_Init>:
*  Function description
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
    dfd0:	b508      	push	{r3, lr}
  _DoInit();
    dfd2:	f7f4 fb51 	bl	2678 <_DoInit>
}
    dfd6:	bd08      	pop	{r3, pc}

0000dfd8 <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(struct device *unused)
{
    dfd8:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
    dfda:	f7ff fff9 	bl	dfd0 <SEGGER_RTT_Init>

	return 0;
}
    dfde:	2000      	movs	r0, #0
    dfe0:	bd08      	pop	{r3, pc}

0000dfe2 <z_irq_spurious>:
{
    dfe2:	b508      	push	{r3, lr}
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    dfe4:	2100      	movs	r1, #0
    dfe6:	2001      	movs	r0, #1
    dfe8:	f000 f801 	bl	dfee <z_arm_fatal_error>
}
    dfec:	bd08      	pop	{r3, pc}

0000dfee <z_arm_fatal_error>:

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    dfee:	b538      	push	{r3, r4, r5, lr}
    dff0:	4604      	mov	r4, r0

	if (esf != NULL) {
    dff2:	460d      	mov	r5, r1
    dff4:	b111      	cbz	r1, dffc <z_arm_fatal_error+0xe>
		esf_dump(esf);
    dff6:	4608      	mov	r0, r1
    dff8:	f7f4 fcd4 	bl	29a4 <esf_dump>
	}
	z_fatal_error(reason, esf);
    dffc:	4629      	mov	r1, r5
    dffe:	4620      	mov	r0, r4
    e000:	f7fc f9d6 	bl	a3b0 <z_fatal_error>
}
    e004:	bd38      	pop	{r3, r4, r5, pc}

0000e006 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
    e006:	b508      	push	{r3, lr}
    e008:	4601      	mov	r1, r0
			reason = K_ERR_KERNEL_OOPS;
		}
	}

#endif /* CONFIG_USERSPACE */
	z_arm_fatal_error(reason, esf);
    e00a:	6800      	ldr	r0, [r0, #0]
    e00c:	f7ff ffef 	bl	dfee <z_arm_fatal_error>
}
    e010:	bd08      	pop	{r3, pc}

0000e012 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
    e012:	b508      	push	{r3, lr}
	handler();
    e014:	f7f4 fd16 	bl	2a44 <z_SysNmiOnReset>
	z_arm_int_exit();
    e018:	f7f5 f8fe 	bl	3218 <z_arm_exc_exit>
}
    e01c:	bd08      	pop	{r3, pc}

0000e01e <memory_fault_recoverable>:
}
    e01e:	2000      	movs	r0, #0
    e020:	4770      	bx	lr

0000e022 <fault_handle>:
{
    e022:	b508      	push	{r3, lr}
	*recoverable = false;
    e024:	2300      	movs	r3, #0
    e026:	7013      	strb	r3, [r2, #0]
	switch (fault) {
    e028:	1ecb      	subs	r3, r1, #3
    e02a:	2b09      	cmp	r3, #9
    e02c:	d819      	bhi.n	e062 <fault_handle+0x40>
    e02e:	e8df f003 	tbb	[pc, r3]
    e032:	0905      	.short	0x0905
    e034:	1818110d 	.word	0x1818110d
    e038:	14181818 	.word	0x14181818
		reason = hard_fault(esf, recoverable);
    e03c:	4611      	mov	r1, r2
    e03e:	f7f4 ffe3 	bl	3008 <hard_fault>
}
    e042:	bd08      	pop	{r3, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
    e044:	2100      	movs	r1, #0
    e046:	f7f4 fe39 	bl	2cbc <mem_manage_fault>
		break;
    e04a:	e7fa      	b.n	e042 <fault_handle+0x20>
		reason = bus_fault(esf, 0, recoverable);
    e04c:	2100      	movs	r1, #0
    e04e:	f7f4 fefb 	bl	2e48 <bus_fault>
		break;
    e052:	e7f6      	b.n	e042 <fault_handle+0x20>
		reason = usage_fault(esf);
    e054:	f7f4 fd5e 	bl	2b14 <usage_fault>
		break;
    e058:	e7f3      	b.n	e042 <fault_handle+0x20>
		debug_monitor(esf);
    e05a:	f7f4 fe15 	bl	2c88 <debug_monitor>
	u32_t reason = K_ERR_CPU_EXCEPTION;
    e05e:	2000      	movs	r0, #0
		break;
    e060:	e7ef      	b.n	e042 <fault_handle+0x20>
		reserved_exception(esf, fault);
    e062:	f7f5 f845 	bl	30f0 <reserved_exception>
	u32_t reason = K_ERR_CPU_EXCEPTION;
    e066:	2000      	movs	r0, #0
	return reason;
    e068:	e7eb      	b.n	e042 <fault_handle+0x20>

0000e06a <mpu_partition_is_valid>:
		((part->size & (part->size - 1)) == 0U)
    e06a:	6843      	ldr	r3, [r0, #4]
    e06c:	1e5a      	subs	r2, r3, #1
		&&
    e06e:	4213      	tst	r3, r2
    e070:	d106      	bne.n	e080 <mpu_partition_is_valid+0x16>
		&&
    e072:	2b1f      	cmp	r3, #31
    e074:	d906      	bls.n	e084 <mpu_partition_is_valid+0x1a>
		((part->start & (part->size - 1)) == 0U);
    e076:	6803      	ldr	r3, [r0, #0]
		&&
    e078:	421a      	tst	r2, r3
    e07a:	d005      	beq.n	e088 <mpu_partition_is_valid+0x1e>
    e07c:	2000      	movs	r0, #0
    e07e:	4770      	bx	lr
    e080:	2000      	movs	r0, #0
    e082:	4770      	bx	lr
    e084:	2000      	movs	r0, #0
    e086:	4770      	bx	lr
    e088:	2001      	movs	r0, #1
}
    e08a:	4770      	bx	lr

0000e08c <mpu_configure_region>:
{
    e08c:	b500      	push	{lr}
    e08e:	b085      	sub	sp, #20
	region_conf.base = new_region->start;
    e090:	680b      	ldr	r3, [r1, #0]
    e092:	9301      	str	r3, [sp, #4]
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
    e094:	684b      	ldr	r3, [r1, #4]
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    e096:	688a      	ldr	r2, [r1, #8]
	if (size <= 32U) {
    e098:	2b20      	cmp	r3, #32
    e09a:	d912      	bls.n	e0c2 <mpu_configure_region+0x36>
	if (size > (1UL << 31)) {
    e09c:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
    e0a0:	d811      	bhi.n	e0c6 <mpu_configure_region+0x3a>
	return ((32 - __builtin_clz(size - 1) - 2 + 1) << MPU_RASR_SIZE_Pos) &
    e0a2:	3b01      	subs	r3, #1
    e0a4:	fab3 f383 	clz	r3, r3
    e0a8:	f1c3 031f 	rsb	r3, r3, #31
    e0ac:	005b      	lsls	r3, r3, #1
    e0ae:	f003 033e 	and.w	r3, r3, #62	; 0x3e
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    e0b2:	4313      	orrs	r3, r2
    e0b4:	9303      	str	r3, [sp, #12]
	return region_allocate_and_init(index,
    e0b6:	a901      	add	r1, sp, #4
    e0b8:	f7f5 f92a 	bl	3310 <region_allocate_and_init>
}
    e0bc:	b005      	add	sp, #20
    e0be:	f85d fb04 	ldr.w	pc, [sp], #4
		return REGION_32B;
    e0c2:	2308      	movs	r3, #8
    e0c4:	e7f5      	b.n	e0b2 <mpu_configure_region+0x26>
		return REGION_4G;
    e0c6:	233e      	movs	r3, #62	; 0x3e
    e0c8:	e7f3      	b.n	e0b2 <mpu_configure_region+0x26>

0000e0ca <arm_core_mpu_configure_static_mpu_regions>:
{
    e0ca:	b508      	push	{r3, lr}
	if (mpu_configure_static_mpu_regions(static_regions, regions_num,
    e0cc:	f7f5 f982 	bl	33d4 <mpu_configure_static_mpu_regions>
}
    e0d0:	bd08      	pop	{r3, pc}

0000e0d2 <_stdout_hook_default>:
}
    e0d2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    e0d6:	4770      	bx	lr

0000e0d8 <_stdin_hook_default>:
}
    e0d8:	2000      	movs	r0, #0
    e0da:	4770      	bx	lr

0000e0dc <_read>:
{
    e0dc:	b508      	push	{r3, lr}
    e0de:	4608      	mov	r0, r1
	return z_impl_zephyr_read_stdin(buf, nbytes);
    e0e0:	4611      	mov	r1, r2
    e0e2:	f7f5 f9bb 	bl	345c <z_impl_zephyr_read_stdin>
}
    e0e6:	bd08      	pop	{r3, pc}

0000e0e8 <_write>:
{
    e0e8:	b508      	push	{r3, lr}
    e0ea:	4608      	mov	r0, r1
	return z_impl_zephyr_write_stdout(buf, nbytes);
    e0ec:	4611      	mov	r1, r2
    e0ee:	f7f5 f9cb 	bl	3488 <z_impl_zephyr_write_stdout>
}
    e0f2:	bd08      	pop	{r3, pc}

0000e0f4 <_close>:
}
    e0f4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    e0f8:	4770      	bx	lr

0000e0fa <_lseek>:
}
    e0fa:	2000      	movs	r0, #0
    e0fc:	4770      	bx	lr

0000e0fe <_isatty>:
}
    e0fe:	2001      	movs	r0, #1
    e100:	4770      	bx	lr

0000e102 <_kill>:
}
    e102:	2000      	movs	r0, #0
    e104:	4770      	bx	lr

0000e106 <_getpid>:
}
    e106:	2000      	movs	r0, #0
    e108:	4770      	bx	lr

0000e10a <_fstat>:
	st->st_mode = S_IFCHR;
    e10a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    e10e:	604b      	str	r3, [r1, #4]
}
    e110:	2000      	movs	r0, #0
    e112:	4770      	bx	lr

0000e114 <z_platform_init>:

void z_platform_init(void)
{
    e114:	b508      	push	{r3, lr}
	SystemInit();
    e116:	f7fc f809 	bl	a12c <SystemInit>
}
    e11a:	bd08      	pop	{r3, pc}

0000e11c <get_adv_props>:
	switch (evt_type) {
    e11c:	2804      	cmp	r0, #4
    e11e:	d80a      	bhi.n	e136 <get_adv_props+0x1a>
    e120:	e8df f000 	tbb	[pc, r0]
    e124:	050c0b03 	.word	0x050c0b03
    e128:	07          	.byte	0x07
    e129:	00          	.byte	0x00
		return BT_GAP_ADV_PROP_SCAN_RESPONSE |
    e12a:	2003      	movs	r0, #3
    e12c:	4770      	bx	lr
		return 0;
    e12e:	2000      	movs	r0, #0
    e130:	4770      	bx	lr
		return BT_GAP_ADV_PROP_SCAN_RESPONSE |
    e132:	200a      	movs	r0, #10
    e134:	4770      	bx	lr
		return 0;
    e136:	2000      	movs	r0, #0
    e138:	4770      	bx	lr
		return BT_GAP_ADV_PROP_CONNECTABLE |
    e13a:	2005      	movs	r0, #5
}
    e13c:	4770      	bx	lr

0000e13e <br_init>:
}
    e13e:	2000      	movs	r0, #0
    e140:	4770      	bx	lr

0000e142 <valid_le_scan_param>:
	if (param->type != BT_HCI_LE_SCAN_PASSIVE &&
    e142:	7803      	ldrb	r3, [r0, #0]
    e144:	2b01      	cmp	r3, #1
    e146:	d815      	bhi.n	e174 <valid_le_scan_param+0x32>
	if (param->options & ~(BT_LE_SCAN_OPT_FILTER_DUPLICATE |
    e148:	6843      	ldr	r3, [r0, #4]
    e14a:	f033 030f 	bics.w	r3, r3, #15
    e14e:	d113      	bne.n	e178 <valid_le_scan_param+0x36>
	if (param->interval < 0x0004 || param->interval > 0x4000) {
    e150:	8902      	ldrh	r2, [r0, #8]
    e152:	1f13      	subs	r3, r2, #4
    e154:	b29b      	uxth	r3, r3
    e156:	f643 71fc 	movw	r1, #16380	; 0x3ffc
    e15a:	428b      	cmp	r3, r1
    e15c:	d80e      	bhi.n	e17c <valid_le_scan_param+0x3a>
	if (param->window < 0x0004 || param->window > 0x4000) {
    e15e:	8941      	ldrh	r1, [r0, #10]
    e160:	1f0b      	subs	r3, r1, #4
    e162:	b29b      	uxth	r3, r3
    e164:	f643 70fc 	movw	r0, #16380	; 0x3ffc
    e168:	4283      	cmp	r3, r0
    e16a:	d809      	bhi.n	e180 <valid_le_scan_param+0x3e>
	if (param->window > param->interval) {
    e16c:	428a      	cmp	r2, r1
    e16e:	d309      	bcc.n	e184 <valid_le_scan_param+0x42>
	return true;
    e170:	2001      	movs	r0, #1
    e172:	4770      	bx	lr
		return false;
    e174:	2000      	movs	r0, #0
    e176:	4770      	bx	lr
		return false;
    e178:	2000      	movs	r0, #0
    e17a:	4770      	bx	lr
		return false;
    e17c:	2000      	movs	r0, #0
    e17e:	4770      	bx	lr
		return false;
    e180:	2000      	movs	r0, #0
    e182:	4770      	bx	lr
		return false;
    e184:	2000      	movs	r0, #0
}
    e186:	4770      	bx	lr

0000e188 <cmd_state_set_init>:
	state->target = target;
    e188:	6001      	str	r1, [r0, #0]
	state->bit = bit;
    e18a:	6042      	str	r2, [r0, #4]
	state->val = val;
    e18c:	7203      	strb	r3, [r0, #8]
}
    e18e:	4770      	bx	lr

0000e190 <le_set_event_mask>:
{
    e190:	b510      	push	{r4, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
    e192:	2108      	movs	r1, #8
    e194:	f242 0001 	movw	r0, #8193	; 0x2001
    e198:	f7f5 fdaa 	bl	3cf0 <bt_hci_cmd_create>
	if (!buf) {
    e19c:	b1a0      	cbz	r0, e1c8 <le_set_event_mask+0x38>
    e19e:	4604      	mov	r4, r0
	cp_mask = net_buf_add(buf, sizeof(*cp_mask));
    e1a0:	2108      	movs	r1, #8
    e1a2:	4408      	add	r0, r1
    e1a4:	f001 fa7a 	bl	f69c <net_buf_simple_add>
	dst[0] = val;
    e1a8:	2302      	movs	r3, #2
    e1aa:	7003      	strb	r3, [r0, #0]
	dst[1] = val >> 8;
    e1ac:	2200      	movs	r2, #0
    e1ae:	7042      	strb	r2, [r0, #1]
	dst[0] = val;
    e1b0:	7082      	strb	r2, [r0, #2]
	dst[1] = val >> 8;
    e1b2:	70c2      	strb	r2, [r0, #3]
	dst[0] = val;
    e1b4:	7102      	strb	r2, [r0, #4]
	dst[1] = val >> 8;
    e1b6:	7142      	strb	r2, [r0, #5]
	dst[0] = val;
    e1b8:	7182      	strb	r2, [r0, #6]
	dst[1] = val >> 8;
    e1ba:	71c2      	strb	r2, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
    e1bc:	4621      	mov	r1, r4
    e1be:	f242 0001 	movw	r0, #8193	; 0x2001
    e1c2:	f7f5 fdd1 	bl	3d68 <bt_hci_cmd_send_sync>
}
    e1c6:	bd10      	pop	{r4, pc}
		return -ENOBUFS;
    e1c8:	f06f 0068 	mvn.w	r0, #104	; 0x68
    e1cc:	e7fb      	b.n	e1c6 <le_set_event_mask+0x36>

0000e1ce <set_event_mask>:
{
    e1ce:	b510      	push	{r4, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_EVENT_MASK, sizeof(*ev));
    e1d0:	2108      	movs	r1, #8
    e1d2:	f640 4001 	movw	r0, #3073	; 0xc01
    e1d6:	f7f5 fd8b 	bl	3cf0 <bt_hci_cmd_create>
	if (!buf) {
    e1da:	b1b0      	cbz	r0, e20a <set_event_mask+0x3c>
    e1dc:	4604      	mov	r4, r0
	ev = net_buf_add(buf, sizeof(*ev));
    e1de:	2108      	movs	r1, #8
    e1e0:	4408      	add	r0, r1
    e1e2:	f001 fa5b 	bl	f69c <net_buf_simple_add>
	dst[0] = val;
    e1e6:	2200      	movs	r2, #0
    e1e8:	7002      	strb	r2, [r0, #0]
	dst[1] = val >> 8;
    e1ea:	2380      	movs	r3, #128	; 0x80
    e1ec:	7043      	strb	r3, [r0, #1]
	dst[0] = val;
    e1ee:	7082      	strb	r2, [r0, #2]
	dst[1] = val >> 8;
    e1f0:	2302      	movs	r3, #2
    e1f2:	70c3      	strb	r3, [r0, #3]
	dst[0] = val;
    e1f4:	7102      	strb	r2, [r0, #4]
	dst[1] = val >> 8;
    e1f6:	7142      	strb	r2, [r0, #5]
	dst[0] = val;
    e1f8:	7182      	strb	r2, [r0, #6]
	dst[1] = val >> 8;
    e1fa:	2320      	movs	r3, #32
    e1fc:	71c3      	strb	r3, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
    e1fe:	4621      	mov	r1, r4
    e200:	f640 4001 	movw	r0, #3073	; 0xc01
    e204:	f7f5 fdb0 	bl	3d68 <bt_hci_cmd_send_sync>
}
    e208:	bd10      	pop	{r4, pc}
		return -ENOBUFS;
    e20a:	f06f 0068 	mvn.w	r0, #104	; 0x68
    e20e:	e7fb      	b.n	e208 <set_event_mask+0x3a>

0000e210 <le_set_private_addr>:
{
    e210:	b500      	push	{lr}
    e212:	b083      	sub	sp, #12
	err = bt_rand(nrpa.val, sizeof(nrpa.val));
    e214:	2106      	movs	r1, #6
    e216:	4668      	mov	r0, sp
    e218:	f000 fe24 	bl	ee64 <bt_rand>
	if (err) {
    e21c:	b110      	cbz	r0, e224 <le_set_private_addr+0x14>
}
    e21e:	b003      	add	sp, #12
    e220:	f85d fb04 	ldr.w	pc, [sp], #4
	nrpa.val[5] &= 0x3f;
    e224:	f89d 3005 	ldrb.w	r3, [sp, #5]
    e228:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    e22c:	f88d 3005 	strb.w	r3, [sp, #5]
	return set_random_address(&nrpa);
    e230:	4668      	mov	r0, sp
    e232:	f7f5 ff9f 	bl	4174 <set_random_address>
    e236:	e7f2      	b.n	e21e <le_set_private_addr+0xe>

0000e238 <set_le_scan_enable>:
{
    e238:	b508      	push	{r3, lr}
	return set_le_scan_enable_legacy(enable);
    e23a:	f7f5 ffc9 	bl	41d0 <set_le_scan_enable_legacy>
}
    e23e:	bd08      	pop	{r3, pc}

0000e240 <bt_lookup_id_addr>:
}
    e240:	4608      	mov	r0, r1
    e242:	4770      	bx	lr

0000e244 <bt_le_scan_random_addr_check>:
}
    e244:	2001      	movs	r0, #1
    e246:	4770      	bx	lr

0000e248 <bt_addr_le_create_static>:
{
    e248:	b510      	push	{r4, lr}
    e24a:	4604      	mov	r4, r0
	addr->type = BT_ADDR_LE_RANDOM;
    e24c:	2301      	movs	r3, #1
    e24e:	f800 3b01 	strb.w	r3, [r0], #1
	return bt_rand(addr->a.val, 6);
    e252:	2106      	movs	r1, #6
    e254:	f000 fe06 	bl	ee64 <bt_rand>
	if (err) {
    e258:	b918      	cbnz	r0, e262 <bt_addr_le_create_static+0x1a>
	BT_ADDR_SET_STATIC(&addr->a);
    e25a:	79a3      	ldrb	r3, [r4, #6]
    e25c:	f063 033f 	orn	r3, r3, #63	; 0x3f
    e260:	71a3      	strb	r3, [r4, #6]
}
    e262:	bd10      	pop	{r4, pc}

0000e264 <bt_init>:
{
    e264:	b510      	push	{r4, lr}
	err = hci_init();
    e266:	f7f6 fcd7 	bl	4c18 <hci_init>
	if (err) {
    e26a:	4604      	mov	r4, r0
    e26c:	b108      	cbz	r0, e272 <bt_init+0xe>
}
    e26e:	4620      	mov	r0, r4
    e270:	bd10      	pop	{r4, pc}
	bt_finalize_init();
    e272:	f7f6 fba9 	bl	49c8 <bt_finalize_init>
	return 0;
    e276:	e7fa      	b.n	e26e <bt_init+0xa>

0000e278 <mem_init>:

#include "mem.h"

void mem_init(void *mem_pool, u16_t mem_size, u16_t mem_count,
	      void **mem_head)
{
    e278:	b410      	push	{r4}
    e27a:	b083      	sub	sp, #12
	*mem_head = mem_pool;
    e27c:	6018      	str	r0, [r3, #0]

	/* Store free mem_count after the list's next pointer at an 32-bit
	 * aligned memory location to ensure atomic read/write (in ARM for now).
	 */
	*((u16_t *)MROUND((u8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
    e27e:	1dc3      	adds	r3, r0, #7
    e280:	f023 0303 	bic.w	r3, r3, #3
    e284:	801a      	strh	r2, [r3, #0]

	/* Initialize next pointers to form a free list,
	 * next pointer is stored in the first 32-bit of each block
	 */
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
    e286:	460c      	mov	r4, r1
    e288:	3a01      	subs	r2, #1
    e28a:	b292      	uxth	r2, r2
    e28c:	fb02 f101 	mul.w	r1, r2, r1
__ssp_bos_icheck3(memset, void *, int)
    e290:	2300      	movs	r3, #0
    e292:	5043      	str	r3, [r0, r1]
		     sizeof(mem_pool));
	while (mem_count--) {
    e294:	1e53      	subs	r3, r2, #1
    e296:	b29b      	uxth	r3, r3
    e298:	b13a      	cbz	r2, e2aa <mem_init+0x32>
		u32_t next;

		next = (u32_t)((u8_t *) mem_pool +
			       (mem_size * (mem_count + 1)));
    e29a:	fb03 4204 	mla	r2, r3, r4, r4
		next = (u32_t)((u8_t *) mem_pool +
    e29e:	4402      	add	r2, r0
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
    e2a0:	fb03 f104 	mul.w	r1, r3, r4
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    e2a4:	5042      	str	r2, [r0, r1]
	while (mem_count--) {
    e2a6:	461a      	mov	r2, r3
    e2a8:	e7f4      	b.n	e294 <mem_init+0x1c>
		       (void *)&next, sizeof(next));
	}
}
    e2aa:	b003      	add	sp, #12
    e2ac:	bc10      	pop	{r4}
    e2ae:	4770      	bx	lr

0000e2b0 <mem_acquire>:

void *mem_acquire(void **mem_head)
{
    e2b0:	4603      	mov	r3, r0
	if (*mem_head) {
    e2b2:	6800      	ldr	r0, [r0, #0]
    e2b4:	b188      	cbz	r0, e2da <mem_acquire+0x2a>
		u16_t free_count;
		void *head;
		void *mem;

		/* Get the free count from the list and decrement it */
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
    e2b6:	1dc2      	adds	r2, r0, #7
    e2b8:	f022 0203 	bic.w	r2, r2, #3
    e2bc:	8812      	ldrh	r2, [r2, #0]
					       sizeof(mem_head)));
		free_count--;
    e2be:	3a01      	subs	r2, #1
    e2c0:	b292      	uxth	r2, r2

		mem = *mem_head;
		memcpy(&head, mem, sizeof(head));
    e2c2:	6801      	ldr	r1, [r0, #0]

		/* Store free mem_count after the list's next pointer */
		if (head) {
    e2c4:	b139      	cbz	r1, e2d6 <mem_acquire+0x26>
{
    e2c6:	b410      	push	{r4}
			*((u16_t *)MROUND((u8_t *)head + sizeof(head))) =
    e2c8:	1dcc      	adds	r4, r1, #7
    e2ca:	f024 0403 	bic.w	r4, r4, #3
    e2ce:	8022      	strh	r2, [r4, #0]
				free_count;
		}

		*mem_head = head;
    e2d0:	6019      	str	r1, [r3, #0]
		return mem;
	}

	return NULL;
}
    e2d2:	bc10      	pop	{r4}
    e2d4:	4770      	bx	lr
		*mem_head = head;
    e2d6:	6019      	str	r1, [r3, #0]
		return mem;
    e2d8:	4770      	bx	lr
}
    e2da:	4770      	bx	lr

0000e2dc <mem_release>:

void mem_release(void *mem, void **mem_head)
{
    e2dc:	b410      	push	{r4}
	u16_t free_count = 0U;

	/* Get the free count from the list and increment it */
	if (*mem_head) {
    e2de:	680b      	ldr	r3, [r1, #0]
    e2e0:	b173      	cbz	r3, e300 <mem_release+0x24>
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
    e2e2:	3307      	adds	r3, #7
    e2e4:	f023 0303 	bic.w	r3, r3, #3
    e2e8:	881a      	ldrh	r2, [r3, #0]
					       sizeof(mem_head)));
	}
	free_count++;
    e2ea:	3201      	adds	r2, #1
    e2ec:	680c      	ldr	r4, [r1, #0]
    e2ee:	4603      	mov	r3, r0
    e2f0:	f843 4b07 	str.w	r4, [r3], #7

	memcpy(mem, mem_head, sizeof(mem));

	/* Store free mem_count after the list's next pointer */
	*((u16_t *)MROUND((u8_t *)mem + sizeof(mem))) = free_count;
    e2f4:	f023 0303 	bic.w	r3, r3, #3
    e2f8:	801a      	strh	r2, [r3, #0]

	*mem_head = mem;
    e2fa:	6008      	str	r0, [r1, #0]
}
    e2fc:	bc10      	pop	{r4}
    e2fe:	4770      	bx	lr
	u16_t free_count = 0U;
    e300:	2200      	movs	r2, #0
    e302:	e7f2      	b.n	e2ea <mem_release+0xe>

0000e304 <mem_rcopy>:
 * @brief  Copy bytes in reverse
 * @details Example: [ 0x11 0x22 0x33 ] -> [ 0x33 0x22 0x11 ]
 */
void mem_rcopy(u8_t *dst, u8_t const *src, u16_t len)
{
	src += len;
    e304:	4411      	add	r1, r2
	while (len--) {
    e306:	1e53      	subs	r3, r2, #1
    e308:	b29b      	uxth	r3, r3
    e30a:	b12a      	cbz	r2, e318 <mem_rcopy+0x14>
		*dst++ = *--src;
    e30c:	f811 2d01 	ldrb.w	r2, [r1, #-1]!
    e310:	f800 2b01 	strb.w	r2, [r0], #1
	while (len--) {
    e314:	461a      	mov	r2, r3
    e316:	e7f6      	b.n	e306 <mem_rcopy+0x2>
	}
}
    e318:	4770      	bx	lr

0000e31a <mem_nz>:
 * @brief Determine if src[0..len-1] contains one or more non-zero bytes
 * @return 0 if all bytes are zero; otherwise 1
 */
u8_t mem_nz(u8_t *src, u16_t len)
{
	while (len--) {
    e31a:	460b      	mov	r3, r1
    e31c:	3901      	subs	r1, #1
    e31e:	b289      	uxth	r1, r1
    e320:	b12b      	cbz	r3, e32e <mem_nz+0x14>
		if (*src++) {
    e322:	f810 3b01 	ldrb.w	r3, [r0], #1
    e326:	2b00      	cmp	r3, #0
    e328:	d0f7      	beq.n	e31a <mem_nz>
			return 1;
    e32a:	2001      	movs	r0, #1
		}
	}

	return 0;
}
    e32c:	4770      	bx	lr
	return 0;
    e32e:	2000      	movs	r0, #0
    e330:	4770      	bx	lr

0000e332 <memq_init>:
 * @return          Initial link-element
 */
memq_link_t *memq_init(memq_link_t *link, memq_link_t **head, memq_link_t **tail)
{
	/* Head and tail pointer to the initial link - forms an empty queue */
	*head = *tail = link;
    e332:	6010      	str	r0, [r2, #0]
    e334:	6008      	str	r0, [r1, #0]

	return link;
}
    e336:	4770      	bx	lr

0000e338 <memq_enqueue>:
 * @param mem[in]      The memory payload to be enqueued. Pointed to by old tail
 * @param tail[in,out] Tail of queue. Will be updated to point to link
 * @return             New tail. Note: Does not point to the new mem
 */
memq_link_t *memq_enqueue(memq_link_t *link, void *mem, memq_link_t **tail)
{
    e338:	b410      	push	{r4}
	/* Let the old tail element point to the new tail element */
	(*tail)->next = link;
    e33a:	6814      	ldr	r4, [r2, #0]
    e33c:	6020      	str	r0, [r4, #0]

	/* Let the old tail element point the the new memory */
	(*tail)->mem = mem;
    e33e:	6814      	ldr	r4, [r2, #0]
    e340:	6061      	str	r1, [r4, #4]

	/* Update the tail-pointer to point to the new tail element.
	 * The new tail-element is not expected to point to anything sensible
	 */
	*tail = link;
    e342:	6010      	str	r0, [r2, #0]

	return link;
}
    e344:	bc10      	pop	{r4}
    e346:	4770      	bx	lr

0000e348 <memq_peek>:
 * @return         head or NULL if queue is empty
 */
memq_link_t *memq_peek(memq_link_t *head, memq_link_t *tail, void **mem)
{
	/* If head and tail are equal, then queue empty */
	if (head == tail) {
    e348:	4288      	cmp	r0, r1
    e34a:	d003      	beq.n	e354 <memq_peek+0xc>
		return NULL;
	}

	/* Extract the head link-element's memory */
	if (mem) {
    e34c:	b11a      	cbz	r2, e356 <memq_peek+0xe>
		*mem = head->mem;
    e34e:	6843      	ldr	r3, [r0, #4]
    e350:	6013      	str	r3, [r2, #0]
    e352:	4770      	bx	lr
		return NULL;
    e354:	2000      	movs	r0, #0
	}

	return head; /* queue was not empty */
}
    e356:	4770      	bx	lr

0000e358 <memq_dequeue>:
 * @param head[in,out] Pointer to head link-element of queue. Will be updated
 * @param mem[out]     The memory pointed to by head-element
 * @return             head or NULL if queue is empty
 */
memq_link_t *memq_dequeue(memq_link_t *tail, memq_link_t **head, void **mem)
{
    e358:	b510      	push	{r4, lr}
    e35a:	460c      	mov	r4, r1
	memq_link_t *old_head;

	/* Use memq peek to get the old head and its mem */
	old_head = memq_peek(*head, tail, mem);
    e35c:	4601      	mov	r1, r0
    e35e:	6820      	ldr	r0, [r4, #0]
    e360:	f7ff fff2 	bl	e348 <memq_peek>
	if (old_head == NULL) {
    e364:	b108      	cbz	r0, e36a <memq_dequeue+0x12>
		return NULL; /* queue is empty */
	}

	/* Update the head-pointer to point to the new head element */
	*head = old_head->next;
    e366:	6803      	ldr	r3, [r0, #0]
    e368:	6023      	str	r3, [r4, #0]

	return old_head;
}
    e36a:	bd10      	pop	{r4, pc}

0000e36c <ticker_by_next_slot_get>:
{
    e36c:	b5f0      	push	{r4, r5, r6, r7, lr}
    e36e:	4696      	mov	lr, r2
	node = instance->nodes;
    e370:	6807      	ldr	r7, [r0, #0]
	_ticker_id_head = *ticker_id_head;
    e372:	f891 c000 	ldrb.w	ip, [r1]
	_ticks_to_expire = *ticks_to_expire;
    e376:	681e      	ldr	r6, [r3, #0]
	if ((_ticker_id_head == TICKER_NULL) ||
    e378:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
    e37c:	d004      	beq.n	e388 <ticker_by_next_slot_get+0x1c>
	    (*ticks_current != instance->ticks_current)) {
    e37e:	6942      	ldr	r2, [r0, #20]
	if ((_ticker_id_head == TICKER_NULL) ||
    e380:	f8de 5000 	ldr.w	r5, [lr]
    e384:	4295      	cmp	r5, r2
    e386:	d005      	beq.n	e394 <ticker_by_next_slot_get+0x28>
		_ticker_id_head = instance->ticker_id_head;
    e388:	7f45      	ldrb	r5, [r0, #29]
		*ticks_current = instance->ticks_current;
    e38a:	6940      	ldr	r0, [r0, #20]
    e38c:	f8ce 0000 	str.w	r0, [lr]
		_ticks_to_expire = 0U;
    e390:	2600      	movs	r6, #0
    e392:	e00a      	b.n	e3aa <ticker_by_next_slot_get+0x3e>
		ticker = &node[_ticker_id_head];
    e394:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
    e398:	ea4f 120c 	mov.w	r2, ip, lsl #4
    e39c:	eb07 140c 	add.w	r4, r7, ip, lsl #4
		_ticker_id_head = ticker->next;
    e3a0:	5cbd      	ldrb	r5, [r7, r2]
    e3a2:	e002      	b.n	e3aa <ticker_by_next_slot_get+0x3e>
		_ticks_to_expire += ticker->ticks_to_expire;
    e3a4:	68a2      	ldr	r2, [r4, #8]
    e3a6:	4416      	add	r6, r2
		_ticker_id_head = ticker->next;
    e3a8:	5c3d      	ldrb	r5, [r7, r0]
	while ((_ticker_id_head != TICKER_NULL) &&
    e3aa:	2dff      	cmp	r5, #255	; 0xff
    e3ac:	d007      	beq.n	e3be <ticker_by_next_slot_get+0x52>
	       ((ticker = &node[_ticker_id_head])->ticks_slot == 0U)) {
    e3ae:	eb05 0445 	add.w	r4, r5, r5, lsl #1
    e3b2:	0120      	lsls	r0, r4, #4
    e3b4:	eb07 1404 	add.w	r4, r7, r4, lsl #4
    e3b8:	69a2      	ldr	r2, [r4, #24]
	while ((_ticker_id_head != TICKER_NULL) &&
    e3ba:	2a00      	cmp	r2, #0
    e3bc:	d0f2      	beq.n	e3a4 <ticker_by_next_slot_get+0x38>
	if (_ticker_id_head != TICKER_NULL) {
    e3be:	2dff      	cmp	r5, #255	; 0xff
    e3c0:	d001      	beq.n	e3c6 <ticker_by_next_slot_get+0x5a>
		_ticks_to_expire += ticker->ticks_to_expire;
    e3c2:	68a2      	ldr	r2, [r4, #8]
    e3c4:	4416      	add	r6, r2
	*ticker_id_head = _ticker_id_head;
    e3c6:	700d      	strb	r5, [r1, #0]
	*ticks_to_expire = _ticks_to_expire;
    e3c8:	601e      	str	r6, [r3, #0]
}
    e3ca:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000e3cc <ticker_enqueue>:
{
    e3cc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    e3d0:	4680      	mov	r8, r0
    e3d2:	4608      	mov	r0, r1
	node = &instance->nodes[0];
    e3d4:	f8d8 6000 	ldr.w	r6, [r8]
	ticker_new = &node[id];
    e3d8:	eb01 0e41 	add.w	lr, r1, r1, lsl #1
    e3dc:	ea4f 110e 	mov.w	r1, lr, lsl #4
    e3e0:	eb06 1e0e 	add.w	lr, r6, lr, lsl #4
	ticks_to_expire = ticker_new->ticks_to_expire;
    e3e4:	f8de 4008 	ldr.w	r4, [lr, #8]
	current = instance->ticker_id_head;
    e3e8:	f898 201d 	ldrb.w	r2, [r8, #29]
	previous = TICKER_NULL;
    e3ec:	f04f 0cff 	mov.w	ip, #255	; 0xff
	while ((current != TICKER_NULL) && (ticks_to_expire >=
    e3f0:	e001      	b.n	e3f6 <ticker_enqueue+0x2a>
		previous = current;
    e3f2:	4694      	mov	ip, r2
		current = ticker_current->next;
    e3f4:	5df2      	ldrb	r2, [r6, r7]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
    e3f6:	2aff      	cmp	r2, #255	; 0xff
    e3f8:	d00f      	beq.n	e41a <ticker_enqueue+0x4e>
		(ticker_current = &node[current])->ticks_to_expire))) {
    e3fa:	eb02 0342 	add.w	r3, r2, r2, lsl #1
    e3fe:	011f      	lsls	r7, r3, #4
    e400:	eb06 1303 	add.w	r3, r6, r3, lsl #4
		(ticks_to_expire_current =
    e404:	689d      	ldr	r5, [r3, #8]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
    e406:	42ac      	cmp	r4, r5
    e408:	d307      	bcc.n	e41a <ticker_enqueue+0x4e>
		if (ticks_to_expire == 0 && (ticker_new->lazy_current >
    e40a:	1b64      	subs	r4, r4, r5
    e40c:	d1f1      	bne.n	e3f2 <ticker_enqueue+0x26>
    e40e:	f8be 901e 	ldrh.w	r9, [lr, #30]
					     ticker_current->lazy_current)) {
    e412:	8bdb      	ldrh	r3, [r3, #30]
		if (ticks_to_expire == 0 && (ticker_new->lazy_current >
    e414:	4599      	cmp	r9, r3
    e416:	d9ec      	bls.n	e3f2 <ticker_enqueue+0x26>
			ticks_to_expire = ticks_to_expire_current;
    e418:	462c      	mov	r4, r5
	ticker_new->ticks_to_expire = ticks_to_expire;
    e41a:	f8ce 4008 	str.w	r4, [lr, #8]
	ticker_new->next = current;
    e41e:	5472      	strb	r2, [r6, r1]
	if (previous == TICKER_NULL) {
    e420:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
    e424:	d010      	beq.n	e448 <ticker_enqueue+0x7c>
		node[previous].next = id;
    e426:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
    e42a:	ea4f 1c0c 	mov.w	ip, ip, lsl #4
    e42e:	f806 000c 	strb.w	r0, [r6, ip]
	if (current != TICKER_NULL) {
    e432:	2aff      	cmp	r2, #255	; 0xff
    e434:	d006      	beq.n	e444 <ticker_enqueue+0x78>
		node[current].ticks_to_expire -= ticks_to_expire;
    e436:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    e43a:	eb06 1202 	add.w	r2, r6, r2, lsl #4
    e43e:	6893      	ldr	r3, [r2, #8]
    e440:	1b1c      	subs	r4, r3, r4
    e442:	6094      	str	r4, [r2, #8]
}
    e444:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		instance->ticker_id_head = id;
    e448:	f888 001d 	strb.w	r0, [r8, #29]
    e44c:	e7f1      	b.n	e432 <ticker_enqueue+0x66>

0000e44e <ticker_dequeue>:
{
    e44e:	b4f0      	push	{r4, r5, r6, r7}
	node = &instance->nodes[0];
    e450:	6805      	ldr	r5, [r0, #0]
	previous = instance->ticker_id_head;
    e452:	7f47      	ldrb	r7, [r0, #29]
	current = previous;
    e454:	463b      	mov	r3, r7
	total = 0U;
    e456:	2400      	movs	r4, #0
	ticker_current = 0;
    e458:	4622      	mov	r2, r4
	while (current != TICKER_NULL) {
    e45a:	2bff      	cmp	r3, #255	; 0xff
    e45c:	d00b      	beq.n	e476 <ticker_dequeue+0x28>
		ticker_current = &node[current];
    e45e:	eb03 0243 	add.w	r2, r3, r3, lsl #1
    e462:	0116      	lsls	r6, r2, #4
    e464:	eb05 1202 	add.w	r2, r5, r2, lsl #4
		if (current == id) {
    e468:	428b      	cmp	r3, r1
    e46a:	d004      	beq.n	e476 <ticker_dequeue+0x28>
		total += ticker_current->ticks_to_expire;
    e46c:	6897      	ldr	r7, [r2, #8]
    e46e:	443c      	add	r4, r7
		previous = current;
    e470:	461f      	mov	r7, r3
		current = ticker_current->next;
    e472:	5dab      	ldrb	r3, [r5, r6]
    e474:	e7f1      	b.n	e45a <ticker_dequeue+0xc>
	if (current == TICKER_NULL) {
    e476:	2bff      	cmp	r3, #255	; 0xff
    e478:	d016      	beq.n	e4a8 <ticker_dequeue+0x5a>
	if (previous == current) {
    e47a:	429f      	cmp	r7, r3
    e47c:	d011      	beq.n	e4a2 <ticker_dequeue+0x54>
	timeout = ticker_current->ticks_to_expire;
    e47e:	6890      	ldr	r0, [r2, #8]
	node[previous].next = ticker_current->next;
    e480:	eb07 0747 	add.w	r7, r7, r7, lsl #1
    e484:	013f      	lsls	r7, r7, #4
    e486:	7813      	ldrb	r3, [r2, #0]
    e488:	55eb      	strb	r3, [r5, r7]
	if (ticker_current->next != TICKER_NULL) {
    e48a:	2bff      	cmp	r3, #255	; 0xff
    e48c:	d006      	beq.n	e49c <ticker_dequeue+0x4e>
		node[ticker_current->next].ticks_to_expire += timeout;
    e48e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    e492:	eb05 1503 	add.w	r5, r5, r3, lsl #4
    e496:	68ab      	ldr	r3, [r5, #8]
    e498:	4403      	add	r3, r0
    e49a:	60ab      	str	r3, [r5, #8]
	return (total + timeout);
    e49c:	4420      	add	r0, r4
}
    e49e:	bcf0      	pop	{r4, r5, r6, r7}
    e4a0:	4770      	bx	lr
		instance->ticker_id_head = ticker_current->next;
    e4a2:	7813      	ldrb	r3, [r2, #0]
    e4a4:	7743      	strb	r3, [r0, #29]
    e4a6:	e7ea      	b.n	e47e <ticker_dequeue+0x30>
		return 0;
    e4a8:	2000      	movs	r0, #0
    e4aa:	e7f8      	b.n	e49e <ticker_dequeue+0x50>

0000e4ac <ticker_resolve_collision>:
	if ((ticker->priority != TICKER_PRIORITY_CRITICAL) &&
    e4ac:	f991 c02d 	ldrsb.w	ip, [r1, #45]	; 0x2d
    e4b0:	f11c 0f80 	cmn.w	ip, #128	; 0x80
    e4b4:	d054      	beq.n	e560 <ticker_resolve_collision+0xb4>
	    (ticker->next != TICKER_NULL)) {
    e4b6:	780b      	ldrb	r3, [r1, #0]
	if ((ticker->priority != TICKER_PRIORITY_CRITICAL) &&
    e4b8:	2bff      	cmp	r3, #255	; 0xff
    e4ba:	d053      	beq.n	e564 <ticker_resolve_collision+0xb8>
{
    e4bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e4c0:	b083      	sub	sp, #12
		s32_t lazy_current = ticker->lazy_current;
    e4c2:	f8b1 e01e 	ldrh.w	lr, [r1, #30]
		if (lazy_current >= ticker->lazy_periodic) {
    e4c6:	8b8a      	ldrh	r2, [r1, #28]
    e4c8:	4596      	cmp	lr, r2
    e4ca:	d301      	bcc.n	e4d0 <ticker_resolve_collision+0x24>
			lazy_current -= ticker->lazy_periodic;
    e4cc:	ebae 0e02 	sub.w	lr, lr, r2
		u32_t current_age = ticker->ticks_periodic +
    e4d0:	684a      	ldr	r2, [r1, #4]
    e4d2:	fb0e 2202 	mla	r2, lr, r2, r2
    e4d6:	9201      	str	r2, [sp, #4]
		u32_t acc_ticks_to_expire = 0U;
    e4d8:	2500      	movs	r5, #0
		while (id_head != TICKER_NULL) {
    e4da:	e01a      	b.n	e512 <ticker_resolve_collision+0x66>
				id_head = ticker_next->next;
    e4dc:	5d83      	ldrb	r3, [r0, r6]
				continue;
    e4de:	e018      	b.n	e512 <ticker_resolve_collision+0x66>
					  0U :
    e4e0:	4622      	mov	r2, r4
			u32_t next_age = (ticker_next->ticks_periodic == 0U ?
    e4e2:	fb04 220a 	mla	r2, r4, sl, r2
			u8_t next_force = (ticker_next->force > ticker->force);
    e4e6:	f893 b003 	ldrb.w	fp, [r3, #3]
    e4ea:	78cc      	ldrb	r4, [r1, #3]
				(lazy_next - ticker_next->priority) >
    e4ec:	ebaa 0309 	sub.w	r3, sl, r9
				(lazy_current - ticker->priority);
    e4f0:	ebae 0a0c 	sub.w	sl, lr, ip
			if (!lazy_next_periodic_skip &&
    e4f4:	4547      	cmp	r7, r8
    e4f6:	d30b      	bcc.n	e510 <ticker_resolve_collision+0x64>
    e4f8:	45a3      	cmp	fp, r4
    e4fa:	d837      	bhi.n	e56c <ticker_resolve_collision+0xc0>
			    (next_force ||
    e4fc:	f119 0f80 	cmn.w	r9, #128	; 0x80
    e500:	d036      	beq.n	e570 <ticker_resolve_collision+0xc4>
			     next_is_critical ||
    e502:	4553      	cmp	r3, sl
    e504:	dd02      	ble.n	e50c <ticker_resolve_collision+0x60>
			    (next_has_priority && !current_is_older) ||
    e506:	9b01      	ldr	r3, [sp, #4]
    e508:	4293      	cmp	r3, r2
    e50a:	d933      	bls.n	e574 <ticker_resolve_collision+0xc8>
    e50c:	45cc      	cmp	ip, r9
    e50e:	d01e      	beq.n	e54e <ticker_resolve_collision+0xa2>
			id_head = ticker_next->next;
    e510:	5d83      	ldrb	r3, [r0, r6]
		while (id_head != TICKER_NULL) {
    e512:	2bff      	cmp	r3, #255	; 0xff
    e514:	d020      	beq.n	e558 <ticker_resolve_collision+0xac>
			struct ticker_node *ticker_next = &nodes[id_head];
    e516:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    e51a:	011e      	lsls	r6, r3, #4
    e51c:	eb00 1303 	add.w	r3, r0, r3, lsl #4
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
    e520:	689a      	ldr	r2, [r3, #8]
    e522:	4415      	add	r5, r2
			if (acc_ticks_to_expire > ticker->ticks_slot) {
    e524:	698c      	ldr	r4, [r1, #24]
    e526:	42ac      	cmp	r4, r5
    e528:	d31e      	bcc.n	e568 <ticker_resolve_collision+0xbc>
			if (ticker_next->ticks_slot == 0U) {
    e52a:	699c      	ldr	r4, [r3, #24]
    e52c:	2c00      	cmp	r4, #0
    e52e:	d0d5      	beq.n	e4dc <ticker_resolve_collision+0x30>
			s32_t lazy_next = ticker_next->lazy_current;
    e530:	8bdf      	ldrh	r7, [r3, #30]
    e532:	46ba      	mov	sl, r7
				ticker_next->lazy_periodic > lazy_next;
    e534:	f8b3 801c 	ldrh.w	r8, [r3, #28]
			if (!lazy_next_periodic_skip) {
    e538:	4547      	cmp	r7, r8
    e53a:	d301      	bcc.n	e540 <ticker_resolve_collision+0x94>
				lazy_next -= ticker_next->lazy_periodic;
    e53c:	eba7 0a08 	sub.w	sl, r7, r8
				ticker_next->priority;
    e540:	f993 902d 	ldrsb.w	r9, [r3, #45]	; 0x2d
			u32_t next_age = (ticker_next->ticks_periodic == 0U ?
    e544:	685c      	ldr	r4, [r3, #4]
					  0U :
    e546:	2c00      	cmp	r4, #0
    e548:	d0ca      	beq.n	e4e0 <ticker_resolve_collision+0x34>
    e54a:	1aa2      	subs	r2, r4, r2
    e54c:	e7c9      	b.n	e4e2 <ticker_resolve_collision+0x36>
			    (equal_priority && next_is_older))) {
    e54e:	9b01      	ldr	r3, [sp, #4]
    e550:	4293      	cmp	r3, r2
    e552:	d2dd      	bcs.n	e510 <ticker_resolve_collision+0x64>
				return 1U;
    e554:	2001      	movs	r0, #1
    e556:	e000      	b.n	e55a <ticker_resolve_collision+0xae>
	return 0U;
    e558:	2000      	movs	r0, #0
}
    e55a:	b003      	add	sp, #12
    e55c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return 0U;
    e560:	2000      	movs	r0, #0
    e562:	4770      	bx	lr
    e564:	2000      	movs	r0, #0
}
    e566:	4770      	bx	lr
	return 0U;
    e568:	2000      	movs	r0, #0
    e56a:	e7f6      	b.n	e55a <ticker_resolve_collision+0xae>
				return 1U;
    e56c:	2001      	movs	r0, #1
    e56e:	e7f4      	b.n	e55a <ticker_resolve_collision+0xae>
    e570:	2001      	movs	r0, #1
    e572:	e7f2      	b.n	e55a <ticker_resolve_collision+0xae>
    e574:	2001      	movs	r0, #1
    e576:	e7f0      	b.n	e55a <ticker_resolve_collision+0xae>

0000e578 <ticker_job_op_cb>:
{
    e578:	b508      	push	{r3, lr}
    e57a:	4603      	mov	r3, r0
	user_op->op = TICKER_USER_OP_TYPE_NONE;
    e57c:	2200      	movs	r2, #0
    e57e:	7002      	strb	r2, [r0, #0]
	user_op->status = status;
    e580:	6281      	str	r1, [r0, #40]	; 0x28
	if (user_op->fp_op_func) {
    e582:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    e584:	b112      	cbz	r2, e58c <ticker_job_op_cb+0x14>
    e586:	4608      	mov	r0, r1
		user_op->fp_op_func(user_op->status, user_op->op_context);
    e588:	6b19      	ldr	r1, [r3, #48]	; 0x30
    e58a:	4790      	blx	r2
}
    e58c:	bd08      	pop	{r3, pc}

0000e58e <ticker_job_reschedule_in_window>:
{
    e58e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e592:	b083      	sub	sp, #12
    e594:	9000      	str	r0, [sp, #0]
    e596:	9101      	str	r1, [sp, #4]
	nodes = &instance->nodes[0];
    e598:	6804      	ldr	r4, [r0, #0]
	u8_t  rescheduled = 0U;
    e59a:	2000      	movs	r0, #0
	u32_t ticks_slot_window = 0;
    e59c:	4681      	mov	r9, r0
	while (rescheduling) {
    e59e:	e097      	b.n	e6d0 <ticker_job_reschedule_in_window+0x142>
			ticker_id_head = ticker->next;
    e5a0:	5c65      	ldrb	r5, [r4, r1]
		while (ticker_id_head != TICKER_NULL) {
    e5a2:	2dff      	cmp	r5, #255	; 0xff
    e5a4:	d00a      	beq.n	e5bc <ticker_job_reschedule_in_window+0x2e>
			ticker = &nodes[ticker_id_head];
    e5a6:	eb05 0245 	add.w	r2, r5, r5, lsl #1
    e5aa:	0111      	lsls	r1, r2, #4
    e5ac:	eb04 1202 	add.w	r2, r4, r2, lsl #4
			ext_data = ticker->ext_data;
    e5b0:	6a93      	ldr	r3, [r2, #40]	; 0x28
			if (ext_data && ext_data->reschedule_state ==
    e5b2:	2b00      	cmp	r3, #0
    e5b4:	d0f4      	beq.n	e5a0 <ticker_job_reschedule_in_window+0x12>
    e5b6:	7a1e      	ldrb	r6, [r3, #8]
    e5b8:	2e01      	cmp	r6, #1
    e5ba:	d1f1      	bne.n	e5a0 <ticker_job_reschedule_in_window+0x12>
    e5bc:	4698      	mov	r8, r3
		if (ticker_id_head == TICKER_NULL) {
    e5be:	2dff      	cmp	r5, #255	; 0xff
    e5c0:	f000 808a 	beq.w	e6d8 <ticker_job_reschedule_in_window+0x14a>
		if (instance->ticker_id_slot_previous != TICKER_NULL &&
    e5c4:	9900      	ldr	r1, [sp, #0]
    e5c6:	7f0b      	ldrb	r3, [r1, #28]
    e5c8:	2bff      	cmp	r3, #255	; 0xff
    e5ca:	d006      	beq.n	e5da <ticker_job_reschedule_in_window+0x4c>
			instance->ticks_slot_previous > ticks_elapsed) {
    e5cc:	698b      	ldr	r3, [r1, #24]
		if (instance->ticker_id_slot_previous != TICKER_NULL &&
    e5ce:	9901      	ldr	r1, [sp, #4]
    e5d0:	428b      	cmp	r3, r1
    e5d2:	d915      	bls.n	e600 <ticker_job_reschedule_in_window+0x72>
			window_start_ticks = instance->ticks_slot_previous -
    e5d4:	eba3 0c01 	sub.w	ip, r3, r1
    e5d8:	e001      	b.n	e5de <ticker_job_reschedule_in_window+0x50>
		window_start_ticks = 0U;
    e5da:	f04f 0c00 	mov.w	ip, #0
		ticker_id_iter = nodes[ticker_id_head].next;
    e5de:	eb05 0b45 	add.w	fp, r5, r5, lsl #1
    e5e2:	ea4f 1b0b 	mov.w	fp, fp, lsl #4
    e5e6:	f814 300b 	ldrb.w	r3, [r4, fp]
		if (ext_data->ticks_drift < ext_data->ticks_slot_window) {
    e5ea:	f8d8 1004 	ldr.w	r1, [r8, #4]
    e5ee:	f8d8 0000 	ldr.w	r0, [r8]
    e5f2:	4281      	cmp	r1, r0
    e5f4:	d207      	bcs.n	e606 <ticker_job_reschedule_in_window+0x78>
			ticks_slot_window = ext_data->ticks_slot_window -
    e5f6:	eba0 0901 	sub.w	r9, r0, r1
				window_end_ticks = 0;
    e5fa:	2700      	movs	r7, #0
    e5fc:	4639      	mov	r1, r7
    e5fe:	e011      	b.n	e624 <ticker_job_reschedule_in_window+0x96>
		window_start_ticks = 0U;
    e600:	f04f 0c00 	mov.w	ip, #0
    e604:	e7eb      	b.n	e5de <ticker_job_reschedule_in_window+0x50>
			ticker_id_iter = TICKER_NULL;
    e606:	23ff      	movs	r3, #255	; 0xff
    e608:	e7f7      	b.n	e5fa <ticker_job_reschedule_in_window+0x6c>
				ticker_id_iter = node->next;
    e60a:	f814 300e 	ldrb.w	r3, [r4, lr]
				continue;
    e60e:	e009      	b.n	e624 <ticker_job_reschedule_in_window+0x96>
				window_end_ticks = 0;
    e610:	2100      	movs	r1, #0
    e612:	e028      	b.n	e666 <ticker_job_reschedule_in_window+0xd8>
			ticks_start_offset += node->ticks_to_expire;
    e614:	4457      	add	r7, sl
					      node->ticks_slot;
    e616:	699b      	ldr	r3, [r3, #24]
			window_start_ticks  = node->ticks_to_expire +
    e618:	eb0a 0c03 	add.w	ip, sl, r3
			ticks_to_expire     = ticks_slot_window -
    e61c:	eba9 0100 	sub.w	r1, r9, r0
			ticker_id_iter = node->next;
    e620:	f814 300e 	ldrb.w	r3, [r4, lr]
		while (ticker_id_iter != TICKER_NULL &&
    e624:	2bff      	cmp	r3, #255	; 0xff
    e626:	d024      	beq.n	e672 <ticker_job_reschedule_in_window+0xe4>
		       ticks_start_offset + ticker->ticks_slot <=
    e628:	6990      	ldr	r0, [r2, #24]
    e62a:	19c6      	adds	r6, r0, r7
		while (ticker_id_iter != TICKER_NULL &&
    e62c:	454e      	cmp	r6, r9
    e62e:	d820      	bhi.n	e672 <ticker_job_reschedule_in_window+0xe4>
			node = &nodes[ticker_id_iter];
    e630:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    e634:	ea4f 1e03 	mov.w	lr, r3, lsl #4
    e638:	eb04 1303 	add.w	r3, r4, r3, lsl #4
			if (node->ext_data &&
    e63c:	f8d3 a028 	ldr.w	sl, [r3, #40]	; 0x28
    e640:	f1ba 0f00 	cmp.w	sl, #0
    e644:	d004      	beq.n	e650 <ticker_job_reschedule_in_window+0xc2>
			    node->ext_data->reschedule_state ==
    e646:	f89a a008 	ldrb.w	sl, [sl, #8]
			if (node->ext_data &&
    e64a:	f1ba 0f01 	cmp.w	sl, #1
    e64e:	d0dc      	beq.n	e60a <ticker_job_reschedule_in_window+0x7c>
			if (node->ticks_to_expire >
    e650:	f8d3 a008 	ldr.w	sl, [r3, #8]
    e654:	f1ba 0f04 	cmp.w	sl, #4
    e658:	d9da      	bls.n	e610 <ticker_job_reschedule_in_window+0x82>
					MIN(ticks_slot_window,
    e65a:	eb0a 0107 	add.w	r1, sl, r7
    e65e:	3904      	subs	r1, #4
				window_end_ticks =
    e660:	4549      	cmp	r1, r9
    e662:	bf28      	it	cs
    e664:	4649      	movcs	r1, r9
			if (window_end_ticks > ticks_start_offset +
    e666:	428e      	cmp	r6, r1
    e668:	d2d4      	bcs.n	e614 <ticker_job_reschedule_in_window+0x86>
			if (ticks_to_expire != 0U &&
    e66a:	1a09      	subs	r1, r1, r0
    e66c:	d0d2      	beq.n	e614 <ticker_job_reschedule_in_window+0x86>
    e66e:	458c      	cmp	ip, r1
    e670:	d8d0      	bhi.n	e614 <ticker_job_reschedule_in_window+0x86>
		ticker->ticks_to_expire = ticks_to_expire;
    e672:	6091      	str	r1, [r2, #8]
		ticker_id_iter = nodes[ticker_id_head].next;
    e674:	f814 300b 	ldrb.w	r3, [r4, fp]
		ticker_id_prev = TICKER_NULL;
    e678:	f04f 0cff 	mov.w	ip, #255	; 0xff
		while (ticker_id_iter != TICKER_NULL) {
    e67c:	2bff      	cmp	r3, #255	; 0xff
    e67e:	d00f      	beq.n	e6a0 <ticker_job_reschedule_in_window+0x112>
			node = &nodes[ticker_id_iter];
    e680:	eb03 0143 	add.w	r1, r3, r3, lsl #1
    e684:	010f      	lsls	r7, r1, #4
    e686:	eb04 1101 	add.w	r1, r4, r1, lsl #4
			if (ticker->ticks_to_expire > node->ticks_to_expire) {
    e68a:	6890      	ldr	r0, [r2, #8]
    e68c:	688e      	ldr	r6, [r1, #8]
    e68e:	42b0      	cmp	r0, r6
    e690:	d904      	bls.n	e69c <ticker_job_reschedule_in_window+0x10e>
				ticker->ticks_to_expire -=
    e692:	1b80      	subs	r0, r0, r6
    e694:	6090      	str	r0, [r2, #8]
			ticker_id_prev = ticker_id_iter;
    e696:	469c      	mov	ip, r3
			ticker_id_iter = node->next;
    e698:	5de3      	ldrb	r3, [r4, r7]
    e69a:	e7ef      	b.n	e67c <ticker_job_reschedule_in_window+0xee>
				node->ticks_to_expire -=
    e69c:	1a30      	subs	r0, r6, r0
    e69e:	6088      	str	r0, [r1, #8]
		if (ticker_id_prev != TICKER_NULL) {
    e6a0:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
    e6a4:	d00d      	beq.n	e6c2 <ticker_job_reschedule_in_window+0x134>
			instance->ticker_id_head = nodes[ticker_id_head].next;
    e6a6:	f814 300b 	ldrb.w	r3, [r4, fp]
    e6aa:	9900      	ldr	r1, [sp, #0]
    e6ac:	774b      	strb	r3, [r1, #29]
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
    e6ae:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
    e6b2:	ea4f 1c0c 	mov.w	ip, ip, lsl #4
    e6b6:	f814 300c 	ldrb.w	r3, [r4, ip]
    e6ba:	f804 300b 	strb.w	r3, [r4, fp]
			nodes[ticker_id_prev].next = ticker_id_head;
    e6be:	f804 500c 	strb.w	r5, [r4, ip]
		ticker->lazy_current--;
    e6c2:	8bd3      	ldrh	r3, [r2, #30]
    e6c4:	3b01      	subs	r3, #1
    e6c6:	83d3      	strh	r3, [r2, #30]
		ext_data->reschedule_state =
    e6c8:	2302      	movs	r3, #2
    e6ca:	f888 3008 	strb.w	r3, [r8, #8]
		rescheduled  = 1U;
    e6ce:	2001      	movs	r0, #1
		ticker_id_head = instance->ticker_id_head;
    e6d0:	9b00      	ldr	r3, [sp, #0]
    e6d2:	7f5d      	ldrb	r5, [r3, #29]
		while (ticker_id_head != TICKER_NULL) {
    e6d4:	4643      	mov	r3, r8
    e6d6:	e764      	b.n	e5a2 <ticker_job_reschedule_in_window+0x14>
}
    e6d8:	b003      	add	sp, #12
    e6da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000e6de <ticker_start>:
{
    e6de:	b510      	push	{r4, lr}
    e6e0:	b08a      	sub	sp, #40	; 0x28
	return ticker_start_ext(instance_index, user_id, ticker_id,
    e6e2:	2400      	movs	r4, #0
    e6e4:	9409      	str	r4, [sp, #36]	; 0x24
    e6e6:	9c14      	ldr	r4, [sp, #80]	; 0x50
    e6e8:	9408      	str	r4, [sp, #32]
    e6ea:	9c13      	ldr	r4, [sp, #76]	; 0x4c
    e6ec:	9407      	str	r4, [sp, #28]
    e6ee:	9c12      	ldr	r4, [sp, #72]	; 0x48
    e6f0:	9406      	str	r4, [sp, #24]
    e6f2:	9c11      	ldr	r4, [sp, #68]	; 0x44
    e6f4:	9405      	str	r4, [sp, #20]
    e6f6:	9c10      	ldr	r4, [sp, #64]	; 0x40
    e6f8:	9404      	str	r4, [sp, #16]
    e6fa:	f8bd 403c 	ldrh.w	r4, [sp, #60]	; 0x3c
    e6fe:	9403      	str	r4, [sp, #12]
    e700:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    e702:	9402      	str	r4, [sp, #8]
    e704:	9c0d      	ldr	r4, [sp, #52]	; 0x34
    e706:	9401      	str	r4, [sp, #4]
    e708:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    e70a:	9400      	str	r4, [sp, #0]
    e70c:	f7f6 fe6a 	bl	53e4 <ticker_start_ext>
}
    e710:	b00a      	add	sp, #40	; 0x28
    e712:	bd10      	pop	{r4, pc}

0000e714 <ticker_ticks_now_get>:
 * @brief Get current absolute tick count
 *
 * @return Absolute tick count
 */
u32_t ticker_ticks_now_get(void)
{
    e714:	b508      	push	{r3, lr}
	return cntr_cnt_get();
    e716:	f7f9 fdd9 	bl	82cc <cntr_cnt_get>
}
    e71a:	bd08      	pop	{r3, pc}

0000e71c <ticker_ticks_diff_get>:
 * @param ticks_now Highest tick count (now)
 * @param ticks_old Tick count to subtract from ticks_now
 */
u32_t ticker_ticks_diff_get(u32_t ticks_now, u32_t ticks_old)
{
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    e71c:	1a40      	subs	r0, r0, r1
}
    e71e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    e722:	4770      	bx	lr

0000e724 <ticker_worker>:
{
    e724:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e728:	b083      	sub	sp, #12
	instance->worker_trigger = 1U;
    e72a:	2301      	movs	r3, #1
    e72c:	77c3      	strb	r3, [r0, #31]
	if (instance->job_guard) {
    e72e:	f890 a01e 	ldrb.w	sl, [r0, #30]
    e732:	f1ba 0f00 	cmp.w	sl, #0
    e736:	f040 80a1 	bne.w	e87c <ticker_worker+0x158>
    e73a:	4607      	mov	r7, r0
	if (instance->ticker_id_head == TICKER_NULL) {
    e73c:	7f43      	ldrb	r3, [r0, #29]
    e73e:	2bff      	cmp	r3, #255	; 0xff
    e740:	d00f      	beq.n	e762 <ticker_worker+0x3e>
	ticks_elapsed = ticker_ticks_diff_get(cntr_cnt_get(),
    e742:	f7f9 fdc3 	bl	82cc <cntr_cnt_get>
    e746:	6979      	ldr	r1, [r7, #20]
    e748:	f7ff ffe8 	bl	e71c <ticker_ticks_diff_get>
    e74c:	4606      	mov	r6, r0
	ticker_id_head = instance->ticker_id_head;
    e74e:	7f7d      	ldrb	r5, [r7, #29]
	if (instance->ticker_id_slot_previous != TICKER_NULL) {
    e750:	7f3b      	ldrb	r3, [r7, #28]
    e752:	2bff      	cmp	r3, #255	; 0xff
    e754:	d008      	beq.n	e768 <ticker_worker+0x44>
		if (instance->ticks_slot_previous > ticks_elapsed) {
    e756:	69bb      	ldr	r3, [r7, #24]
    e758:	4283      	cmp	r3, r0
    e75a:	d82a      	bhi.n	e7b2 <ticker_worker+0x8e>
	u8_t slot_reserved = 0;
    e75c:	f8cd a004 	str.w	sl, [sp, #4]
    e760:	e004      	b.n	e76c <ticker_worker+0x48>
		instance->worker_trigger = 0U;
    e762:	2300      	movs	r3, #0
    e764:	77c3      	strb	r3, [r0, #31]
		return;
    e766:	e089      	b.n	e87c <ticker_worker+0x158>
	u8_t slot_reserved = 0;
    e768:	f8cd a004 	str.w	sl, [sp, #4]
	node = &instance->nodes[0];
    e76c:	f8d7 9000 	ldr.w	r9, [r7]
	ticks_expired = 0U;
    e770:	f04f 0800 	mov.w	r8, #0
	while (ticker_id_head != TICKER_NULL) {
    e774:	2dff      	cmp	r5, #255	; 0xff
    e776:	d06f      	beq.n	e858 <ticker_worker+0x134>
		ticker = &node[ticker_id_head];
    e778:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    e77c:	012a      	lsls	r2, r5, #4
    e77e:	eb09 1405 	add.w	r4, r9, r5, lsl #4
		ticks_to_expire = ticker->ticks_to_expire;
    e782:	68a3      	ldr	r3, [r4, #8]
		if (ticks_elapsed < ticks_to_expire) {
    e784:	429e      	cmp	r6, r3
    e786:	d367      	bcc.n	e858 <ticker_worker+0x134>
		ticks_elapsed -= ticks_to_expire;
    e788:	1af6      	subs	r6, r6, r3
		ticks_expired += ticks_to_expire;
    e78a:	4498      	add	r8, r3
		ticker_id_head = ticker->next;
    e78c:	f819 5002 	ldrb.w	r5, [r9, r2]
		if (ticker->ticks_slot != 0U &&
    e790:	69a3      	ldr	r3, [r4, #24]
    e792:	b373      	cbz	r3, e7f2 <ticker_worker+0xce>
    e794:	9b01      	ldr	r3, [sp, #4]
    e796:	b17b      	cbz	r3, e7b8 <ticker_worker+0x94>
			struct ticker_ext *ext_data = ticker->ext_data;
    e798:	6aa3      	ldr	r3, [r4, #40]	; 0x28
			if (ext_data &&
    e79a:	b1a3      	cbz	r3, e7c6 <ticker_worker+0xa2>
			    ext_data->ticks_slot_window != 0U &&
    e79c:	681a      	ldr	r2, [r3, #0]
			if (ext_data &&
    e79e:	b192      	cbz	r2, e7c6 <ticker_worker+0xa2>
			    ext_data->reschedule_state ==
    e7a0:	7a1a      	ldrb	r2, [r3, #8]
			    ext_data->ticks_slot_window != 0U &&
    e7a2:	b982      	cbnz	r2, e7c6 <ticker_worker+0xa2>
			   (ticker->lazy_periodic <= ticker->lazy_current)) {
    e7a4:	8ba1      	ldrh	r1, [r4, #28]
    e7a6:	8be2      	ldrh	r2, [r4, #30]
			    TICKER_RESCHEDULE_STATE_NONE &&
    e7a8:	4291      	cmp	r1, r2
    e7aa:	d80c      	bhi.n	e7c6 <ticker_worker+0xa2>
				ext_data->reschedule_state =
    e7ac:	2201      	movs	r2, #1
    e7ae:	721a      	strb	r2, [r3, #8]
    e7b0:	e00c      	b.n	e7cc <ticker_worker+0xa8>
			slot_reserved = 1;
    e7b2:	2301      	movs	r3, #1
    e7b4:	9301      	str	r3, [sp, #4]
    e7b6:	e7d9      	b.n	e76c <ticker_worker+0x48>
		   (slot_reserved || ticker_resolve_collision(node, ticker))) {
    e7b8:	4621      	mov	r1, r4
    e7ba:	4648      	mov	r0, r9
    e7bc:	f7ff fe76 	bl	e4ac <ticker_resolve_collision>
    e7c0:	9000      	str	r0, [sp, #0]
    e7c2:	b1c0      	cbz	r0, e7f6 <ticker_worker+0xd2>
    e7c4:	e7e8      	b.n	e798 <ticker_worker+0x74>
			} else if (ext_data) {
    e7c6:	b10b      	cbz	r3, e7cc <ticker_worker+0xa8>
				ext_data->reschedule_state =
    e7c8:	2200      	movs	r2, #0
    e7ca:	721a      	strb	r2, [r3, #8]
			ticker->lazy_current++;
    e7cc:	8be3      	ldrh	r3, [r4, #30]
    e7ce:	3301      	adds	r3, #1
    e7d0:	b29b      	uxth	r3, r3
    e7d2:	83e3      	strh	r3, [r4, #30]
			if ((ticker->must_expire == 0U) ||
    e7d4:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    e7d8:	2a00      	cmp	r2, #0
    e7da:	d0cb      	beq.n	e774 <ticker_worker+0x50>
			    (ticker->lazy_periodic >= ticker->lazy_current) ||
    e7dc:	8ba2      	ldrh	r2, [r4, #28]
			if ((ticker->must_expire == 0U) ||
    e7de:	4293      	cmp	r3, r2
    e7e0:	d9c8      	bls.n	e774 <ticker_worker+0x50>
			    TICKER_RESCHEDULE_PENDING(ticker)) {
    e7e2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
			    (ticker->lazy_periodic >= ticker->lazy_current) ||
    e7e4:	b333      	cbz	r3, e834 <ticker_worker+0x110>
			    TICKER_RESCHEDULE_PENDING(ticker)) {
    e7e6:	7a1b      	ldrb	r3, [r3, #8]
    e7e8:	2b01      	cmp	r3, #1
    e7ea:	d0c3      	beq.n	e774 <ticker_worker+0x50>
			must_expire_skip = 1U;
    e7ec:	2301      	movs	r3, #1
    e7ee:	9300      	str	r3, [sp, #0]
    e7f0:	e001      	b.n	e7f6 <ticker_worker+0xd2>
		must_expire_skip = 0U;
    e7f2:	f8cd a000 	str.w	sl, [sp]
		if (ticker->ext_data) {
    e7f6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    e7f8:	b11b      	cbz	r3, e802 <ticker_worker+0xde>
			ticker->ext_data->ticks_drift = 0U;
    e7fa:	2200      	movs	r2, #0
    e7fc:	605a      	str	r2, [r3, #4]
			ticker->ext_data->reschedule_state =
    e7fe:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    e800:	721a      	strb	r2, [r3, #8]
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
    e802:	7863      	ldrb	r3, [r4, #1]
    e804:	78a2      	ldrb	r2, [r4, #2]
    e806:	1a9b      	subs	r3, r3, r2
    e808:	b2db      	uxtb	r3, r3
    e80a:	2b01      	cmp	r3, #1
    e80c:	d1b2      	bne.n	e774 <ticker_worker+0x50>
		ticker->ack--;
    e80e:	3a01      	subs	r2, #1
    e810:	70a2      	strb	r2, [r4, #2]
		if (ticker->timeout_func) {
    e812:	f8d4 b00c 	ldr.w	fp, [r4, #12]
    e816:	f1bb 0f00 	cmp.w	fp, #0
    e81a:	d0ab      	beq.n	e774 <ticker_worker+0x50>
			ticks_at_expire = (instance->ticks_current +
    e81c:	697b      	ldr	r3, [r7, #20]
    e81e:	eb03 0008 	add.w	r0, r3, r8
					   ticker->ticks_to_expire_minus) &
    e822:	6963      	ldr	r3, [r4, #20]
					   ticks_expired -
    e824:	1ac0      	subs	r0, r0, r3
			ticks_at_expire = (instance->ticks_current +
    e826:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			ticker->timeout_func(ticks_at_expire,
    e82a:	6a61      	ldr	r1, [r4, #36]	; 0x24
    e82c:	9b00      	ldr	r3, [sp, #0]
    e82e:	b923      	cbnz	r3, e83a <ticker_worker+0x116>
    e830:	8be2      	ldrh	r2, [r4, #30]
    e832:	e004      	b.n	e83e <ticker_worker+0x11a>
			must_expire_skip = 1U;
    e834:	2301      	movs	r3, #1
    e836:	9300      	str	r3, [sp, #0]
    e838:	e7dd      	b.n	e7f6 <ticker_worker+0xd2>
			ticker->timeout_func(ticks_at_expire,
    e83a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    e83e:	6923      	ldr	r3, [r4, #16]
    e840:	47d8      	blx	fp
			if (must_expire_skip == 0U) {
    e842:	9b00      	ldr	r3, [sp, #0]
    e844:	2b00      	cmp	r3, #0
    e846:	d195      	bne.n	e774 <ticker_worker+0x50>
				ticker->lazy_current = 0U;
    e848:	83e3      	strh	r3, [r4, #30]
				ticker->force = 0U;
    e84a:	70e3      	strb	r3, [r4, #3]
				if (ticker->ticks_slot != 0U) {
    e84c:	69a3      	ldr	r3, [r4, #24]
    e84e:	2b00      	cmp	r3, #0
    e850:	d090      	beq.n	e774 <ticker_worker+0x50>
					slot_reserved = 1U;
    e852:	2301      	movs	r3, #1
    e854:	9301      	str	r3, [sp, #4]
    e856:	e78d      	b.n	e774 <ticker_worker+0x50>
	if (instance->ticks_elapsed_first == instance->ticks_elapsed_last) {
    e858:	7aba      	ldrb	r2, [r7, #10]
    e85a:	7afb      	ldrb	r3, [r7, #11]
    e85c:	429a      	cmp	r2, r3
    e85e:	d010      	beq.n	e882 <ticker_worker+0x15e>
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
    e860:	7afb      	ldrb	r3, [r7, #11]
    e862:	3302      	adds	r3, #2
    e864:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    e868:	f8c3 8004 	str.w	r8, [r3, #4]
	instance->worker_trigger = 0U;
    e86c:	2300      	movs	r3, #0
    e86e:	77fb      	strb	r3, [r7, #31]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
    e870:	6a7c      	ldr	r4, [r7, #36]	; 0x24
    e872:	463b      	mov	r3, r7
    e874:	2201      	movs	r2, #1
    e876:	2104      	movs	r1, #4
    e878:	2003      	movs	r0, #3
    e87a:	47a0      	blx	r4
}
    e87c:	b003      	add	sp, #12
    e87e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	u8_t idx = *ticks_elapsed_index + 1;
    e882:	b25b      	sxtb	r3, r3
    e884:	3301      	adds	r3, #1
    e886:	b2db      	uxtb	r3, r3
	if (idx == DOUBLE_BUFFER_SIZE) {
    e888:	2b02      	cmp	r3, #2
    e88a:	d000      	beq.n	e88e <ticker_worker+0x16a>
	u8_t idx = *ticks_elapsed_index + 1;
    e88c:	469a      	mov	sl, r3
	*ticks_elapsed_index = idx;
    e88e:	f887 a00b 	strb.w	sl, [r7, #11]
}
    e892:	e7e5      	b.n	e860 <ticker_worker+0x13c>

0000e894 <ticks_to_expire_prep>:
{
    e894:	b570      	push	{r4, r5, r6, lr}
    e896:	4605      	mov	r5, r0
    e898:	460b      	mov	r3, r1
    e89a:	4610      	mov	r0, r2
	u32_t ticks_to_expire = ticker->ticks_to_expire;
    e89c:	68ac      	ldr	r4, [r5, #8]
	u32_t ticks_to_expire_minus = ticker->ticks_to_expire_minus;
    e89e:	696e      	ldr	r6, [r5, #20]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
    e8a0:	1a52      	subs	r2, r2, r1
    e8a2:	f412 0f00 	tst.w	r2, #8388608	; 0x800000
    e8a6:	d109      	bne.n	e8bc <ticks_to_expire_prep+0x28>
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
    e8a8:	f7ff ff38 	bl	e71c <ticker_ticks_diff_get>
    e8ac:	1823      	adds	r3, r4, r0
	if (ticks_to_expire > ticks_to_expire_minus) {
    e8ae:	42b3      	cmp	r3, r6
    e8b0:	d910      	bls.n	e8d4 <ticks_to_expire_prep+0x40>
		ticks_to_expire -= ticks_to_expire_minus;
    e8b2:	1b9b      	subs	r3, r3, r6
		ticks_to_expire_minus = 0U;
    e8b4:	2600      	movs	r6, #0
	ticker->ticks_to_expire = ticks_to_expire;
    e8b6:	60ab      	str	r3, [r5, #8]
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
    e8b8:	616e      	str	r6, [r5, #20]
}
    e8ba:	bd70      	pop	{r4, r5, r6, pc}
		delta_current_start = ticker_ticks_diff_get(ticks_current,
    e8bc:	4601      	mov	r1, r0
    e8be:	4618      	mov	r0, r3
    e8c0:	f7ff ff2c 	bl	e71c <ticker_ticks_diff_get>
		if (ticks_to_expire > delta_current_start) {
    e8c4:	4284      	cmp	r4, r0
    e8c6:	d901      	bls.n	e8cc <ticks_to_expire_prep+0x38>
			ticks_to_expire -= delta_current_start;
    e8c8:	1a23      	subs	r3, r4, r0
    e8ca:	e7f0      	b.n	e8ae <ticks_to_expire_prep+0x1a>
			    (delta_current_start - ticks_to_expire);
    e8cc:	1b03      	subs	r3, r0, r4
			ticks_to_expire_minus +=
    e8ce:	441e      	add	r6, r3
			ticks_to_expire = 0U;
    e8d0:	2300      	movs	r3, #0
    e8d2:	e7ec      	b.n	e8ae <ticks_to_expire_prep+0x1a>
		ticks_to_expire_minus -= ticks_to_expire;
    e8d4:	1af6      	subs	r6, r6, r3
		ticks_to_expire = 0U;
    e8d6:	2300      	movs	r3, #0
    e8d8:	e7ed      	b.n	e8b6 <ticks_to_expire_prep+0x22>

0000e8da <ll_tx_pwr_get>:
{
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	*min = lll_radio_tx_pwr_min_get();
	*max = lll_radio_tx_pwr_max_get();
#else
	*min = RADIO_TXP_DEFAULT;
    e8da:	2300      	movs	r3, #0
    e8dc:	7003      	strb	r3, [r0, #0]
	*max = RADIO_TXP_DEFAULT;
    e8de:	700b      	strb	r3, [r1, #0]
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */
}
    e8e0:	4770      	bx	lr

0000e8e2 <process_prio_evt>:
}
    e8e2:	2000      	movs	r0, #0
    e8e4:	4770      	bx	lr

0000e8e6 <link_control_cmd_handle>:
}
    e8e6:	f06f 0015 	mvn.w	r0, #21
    e8ea:	4770      	bx	lr

0000e8ec <status_cmd_handle>:
}
    e8ec:	f06f 0015 	mvn.w	r0, #21
    e8f0:	4770      	bx	lr

0000e8f2 <hci_evt_create>:
{
    e8f2:	b538      	push	{r3, r4, r5, lr}
    e8f4:	460d      	mov	r5, r1
    e8f6:	4614      	mov	r4, r2
	hdr = net_buf_add(buf, sizeof(*hdr));
    e8f8:	2102      	movs	r1, #2
    e8fa:	3008      	adds	r0, #8
    e8fc:	f000 fece 	bl	f69c <net_buf_simple_add>
	hdr->evt = evt;
    e900:	7005      	strb	r5, [r0, #0]
	hdr->len = len;
    e902:	7044      	strb	r4, [r0, #1]
}
    e904:	bd38      	pop	{r3, r4, r5, pc}

0000e906 <meta_evt>:
{
    e906:	b570      	push	{r4, r5, r6, lr}
    e908:	4604      	mov	r4, r0
    e90a:	460e      	mov	r6, r1
    e90c:	4615      	mov	r5, r2
	hci_evt_create(buf, BT_HCI_EVT_LE_META_EVENT, sizeof(*me) + melen);
    e90e:	3201      	adds	r2, #1
    e910:	b2d2      	uxtb	r2, r2
    e912:	213e      	movs	r1, #62	; 0x3e
    e914:	f7ff ffed 	bl	e8f2 <hci_evt_create>
	me = net_buf_add(buf, sizeof(*me));
    e918:	3408      	adds	r4, #8
    e91a:	2101      	movs	r1, #1
    e91c:	4620      	mov	r0, r4
    e91e:	f000 febd 	bl	f69c <net_buf_simple_add>
	me->subevent = subevt;
    e922:	7006      	strb	r6, [r0, #0]
	return net_buf_add(buf, melen);
    e924:	4629      	mov	r1, r5
    e926:	4620      	mov	r0, r4
    e928:	f000 feb8 	bl	f69c <net_buf_simple_add>
}
    e92c:	bd70      	pop	{r4, r5, r6, pc}

0000e92e <bt_hci_evt_create>:
{
    e92e:	b570      	push	{r4, r5, r6, lr}
    e930:	4605      	mov	r5, r0
    e932:	460e      	mov	r6, r1
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
    e934:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    e938:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    e93c:	2100      	movs	r1, #0
    e93e:	f7f6 fb3d 	bl	4fbc <bt_buf_get_evt>
    e942:	4604      	mov	r4, r0
	hci_evt_create(buf, evt, len);
    e944:	4632      	mov	r2, r6
    e946:	4629      	mov	r1, r5
    e948:	f7ff ffd3 	bl	e8f2 <hci_evt_create>
}
    e94c:	4620      	mov	r0, r4
    e94e:	bd70      	pop	{r4, r5, r6, pc}

0000e950 <bt_hci_cmd_complete_create>:
{
    e950:	b538      	push	{r3, r4, r5, lr}
    e952:	4605      	mov	r5, r0
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
    e954:	3103      	adds	r1, #3
    e956:	b2c9      	uxtb	r1, r1
    e958:	200e      	movs	r0, #14
    e95a:	f7ff ffe8 	bl	e92e <bt_hci_evt_create>
    e95e:	4604      	mov	r4, r0
	cc = net_buf_add(buf, sizeof(*cc));
    e960:	2103      	movs	r1, #3
    e962:	3008      	adds	r0, #8
    e964:	f000 fe9a 	bl	f69c <net_buf_simple_add>
	cc->ncmd = 1U;
    e968:	2301      	movs	r3, #1
    e96a:	7003      	strb	r3, [r0, #0]
	cc->opcode = sys_cpu_to_le16(op);
    e96c:	f8a0 5001 	strh.w	r5, [r0, #1]
}
    e970:	4620      	mov	r0, r4
    e972:	bd38      	pop	{r3, r4, r5, pc}

0000e974 <bt_hci_cmd_status_create>:
{
    e974:	b570      	push	{r4, r5, r6, lr}
    e976:	4605      	mov	r5, r0
    e978:	460e      	mov	r6, r1
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
    e97a:	2104      	movs	r1, #4
    e97c:	200f      	movs	r0, #15
    e97e:	f7ff ffd6 	bl	e92e <bt_hci_evt_create>
    e982:	4604      	mov	r4, r0
	cs = net_buf_add(buf, sizeof(*cs));
    e984:	2104      	movs	r1, #4
    e986:	3008      	adds	r0, #8
    e988:	f000 fe88 	bl	f69c <net_buf_simple_add>
	cs->status = status;
    e98c:	7006      	strb	r6, [r0, #0]
	cs->ncmd = 1U;
    e98e:	2201      	movs	r2, #1
    e990:	7042      	strb	r2, [r0, #1]
	cs->opcode = sys_cpu_to_le16(op);
    e992:	8045      	strh	r5, [r0, #2]
}
    e994:	4620      	mov	r0, r4
    e996:	bd70      	pop	{r4, r5, r6, pc}

0000e998 <vs_read_version_info>:
{
    e998:	b508      	push	{r3, lr}
    e99a:	4608      	mov	r0, r1
	rp = hci_cmd_complete(evt, sizeof(*rp));
    e99c:	210d      	movs	r1, #13
    e99e:	f7f7 fc39 	bl	6214 <hci_cmd_complete>
	rp->status = 0x00;
    e9a2:	2300      	movs	r3, #0
    e9a4:	7003      	strb	r3, [r0, #0]
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
    e9a6:	2202      	movs	r2, #2
    e9a8:	7042      	strb	r2, [r0, #1]
    e9aa:	7083      	strb	r3, [r0, #2]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
    e9ac:	70c2      	strb	r2, [r0, #3]
    e9ae:	7103      	strb	r3, [r0, #4]
	rp->fw_variant = 0U;
    e9b0:	7143      	strb	r3, [r0, #5]
	rp->fw_version = (KERNEL_VERSION_MAJOR & 0xff);
    e9b2:	7182      	strb	r2, [r0, #6]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
    e9b4:	2203      	movs	r2, #3
    e9b6:	71c2      	strb	r2, [r0, #7]
    e9b8:	7203      	strb	r3, [r0, #8]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
    e9ba:	7243      	strb	r3, [r0, #9]
    e9bc:	7283      	strb	r3, [r0, #10]
    e9be:	72c3      	strb	r3, [r0, #11]
    e9c0:	7303      	strb	r3, [r0, #12]
}
    e9c2:	bd08      	pop	{r3, pc}

0000e9c4 <vs_read_supported_commands>:
{
    e9c4:	b510      	push	{r4, lr}
    e9c6:	4608      	mov	r0, r1
	rp = hci_cmd_complete(evt, sizeof(*rp));
    e9c8:	2141      	movs	r1, #65	; 0x41
    e9ca:	f7f7 fc23 	bl	6214 <hci_cmd_complete>
    e9ce:	4604      	mov	r4, r0
	rp->status = 0x00;
    e9d0:	2100      	movs	r1, #0
    e9d2:	f800 1b01 	strb.w	r1, [r0], #1
__ssp_bos_icheck3(memset, void *, int)
    e9d6:	2240      	movs	r2, #64	; 0x40
    e9d8:	f001 fdf1 	bl	105be <memset>
	rp->commands[0] |= BIT(5) | BIT(7);
    e9dc:	f06f 0358 	mvn.w	r3, #88	; 0x58
    e9e0:	7063      	strb	r3, [r4, #1]
	rp->commands[1] |= BIT(0) | BIT(1);
    e9e2:	2303      	movs	r3, #3
    e9e4:	70a3      	strb	r3, [r4, #2]
}
    e9e6:	bd10      	pop	{r4, pc}

0000e9e8 <vs_read_supported_features>:
{
    e9e8:	b508      	push	{r3, lr}
    e9ea:	4608      	mov	r0, r1
	rp = hci_cmd_complete(evt, sizeof(*rp));
    e9ec:	2109      	movs	r1, #9
    e9ee:	f7f7 fc11 	bl	6214 <hci_cmd_complete>
	rp->status = 0x00;
    e9f2:	2200      	movs	r2, #0
    e9f4:	4603      	mov	r3, r0
    e9f6:	f803 2b01 	strb.w	r2, [r3], #1
    e9fa:	f8c0 2001 	str.w	r2, [r0, #1]
    e9fe:	605a      	str	r2, [r3, #4]
}
    ea00:	bd08      	pop	{r3, pc}

0000ea02 <vs_write_bd_addr>:
{
    ea02:	b510      	push	{r4, lr}
    ea04:	460c      	mov	r4, r1
	ll_addr_set(0, &cmd->bdaddr.val[0]);
    ea06:	6881      	ldr	r1, [r0, #8]
    ea08:	2000      	movs	r0, #0
    ea0a:	f7f7 f991 	bl	5d30 <ll_addr_set>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    ea0e:	2101      	movs	r1, #1
    ea10:	4620      	mov	r0, r4
    ea12:	f7f7 fbff 	bl	6214 <hci_cmd_complete>
	ccst->status = 0x00;
    ea16:	2300      	movs	r3, #0
    ea18:	7003      	strb	r3, [r0, #0]
}
    ea1a:	bd10      	pop	{r4, pc}

0000ea1c <set_event_mask_page_2>:
{
    ea1c:	b508      	push	{r3, lr}
    ea1e:	4608      	mov	r0, r1
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    ea20:	2101      	movs	r1, #1
    ea22:	f7f7 fbf7 	bl	6214 <hci_cmd_complete>
	ccst->status = 0x00;
    ea26:	2300      	movs	r3, #0
    ea28:	7003      	strb	r3, [r0, #0]
}
    ea2a:	bd08      	pop	{r3, pc}

0000ea2c <ctrl_bb_cmd_handle>:
{
    ea2c:	b508      	push	{r3, lr}
    ea2e:	4603      	mov	r3, r0
    ea30:	4608      	mov	r0, r1
    ea32:	4611      	mov	r1, r2
	switch (ocf) {
    ea34:	2b03      	cmp	r3, #3
    ea36:	d00a      	beq.n	ea4e <ctrl_bb_cmd_handle+0x22>
    ea38:	2b63      	cmp	r3, #99	; 0x63
    ea3a:	d00c      	beq.n	ea56 <ctrl_bb_cmd_handle+0x2a>
    ea3c:	2b01      	cmp	r3, #1
    ea3e:	d002      	beq.n	ea46 <ctrl_bb_cmd_handle+0x1a>
    ea40:	f06f 0015 	mvn.w	r0, #21
}
    ea44:	bd08      	pop	{r3, pc}
		set_event_mask(cmd, evt);
    ea46:	f7f7 fc19 	bl	627c <set_event_mask>
	return 0;
    ea4a:	2000      	movs	r0, #0
		break;
    ea4c:	e7fa      	b.n	ea44 <ctrl_bb_cmd_handle+0x18>
		reset(cmd, evt);
    ea4e:	f7f7 fc39 	bl	62c4 <reset>
	return 0;
    ea52:	2000      	movs	r0, #0
		break;
    ea54:	e7f6      	b.n	ea44 <ctrl_bb_cmd_handle+0x18>
		set_event_mask_page_2(cmd, evt);
    ea56:	f7ff ffe1 	bl	ea1c <set_event_mask_page_2>
	return 0;
    ea5a:	2000      	movs	r0, #0
		break;
    ea5c:	e7f2      	b.n	ea44 <ctrl_bb_cmd_handle+0x18>

0000ea5e <read_local_version_info>:
{
    ea5e:	b508      	push	{r3, lr}
    ea60:	4608      	mov	r0, r1
	rp = hci_cmd_complete(evt, sizeof(*rp));
    ea62:	2109      	movs	r1, #9
    ea64:	f7f7 fbd6 	bl	6214 <hci_cmd_complete>
	rp->status = 0x00;
    ea68:	2300      	movs	r3, #0
    ea6a:	7003      	strb	r3, [r0, #0]
	rp->hci_version = LL_VERSION_NUMBER;
    ea6c:	220b      	movs	r2, #11
    ea6e:	7042      	strb	r2, [r0, #1]
	rp->hci_revision = sys_cpu_to_le16(0);
    ea70:	7083      	strb	r3, [r0, #2]
    ea72:	70c3      	strb	r3, [r0, #3]
	rp->lmp_version = LL_VERSION_NUMBER;
    ea74:	7102      	strb	r2, [r0, #4]
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
    ea76:	f06f 030e 	mvn.w	r3, #14
    ea7a:	7143      	strb	r3, [r0, #5]
    ea7c:	2305      	movs	r3, #5
    ea7e:	7183      	strb	r3, [r0, #6]
	rp->lmp_subversion = sys_cpu_to_le16(ll_settings_subversion_number());
    ea80:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    ea84:	71c3      	strb	r3, [r0, #7]
    ea86:	7203      	strb	r3, [r0, #8]
}
    ea88:	bd08      	pop	{r3, pc}

0000ea8a <read_supported_commands>:
{
    ea8a:	b510      	push	{r4, lr}
    ea8c:	4608      	mov	r0, r1
	rp = hci_cmd_complete(evt, sizeof(*rp));
    ea8e:	2141      	movs	r1, #65	; 0x41
    ea90:	f7f7 fbc0 	bl	6214 <hci_cmd_complete>
    ea94:	4604      	mov	r4, r0
	rp->status = 0x00;
    ea96:	2100      	movs	r1, #0
    ea98:	f800 1b01 	strb.w	r1, [r0], #1
    ea9c:	2240      	movs	r2, #64	; 0x40
    ea9e:	f001 fd8e 	bl	105be <memset>
	rp->commands[5] |= BIT(6) | BIT(7);
    eaa2:	f06f 033f 	mvn.w	r3, #63	; 0x3f
    eaa6:	71a3      	strb	r3, [r4, #6]
	rp->commands[10] |= BIT(2);
    eaa8:	2304      	movs	r3, #4
    eaaa:	72e3      	strb	r3, [r4, #11]
	rp->commands[14] |= BIT(3) | BIT(5);
    eaac:	2328      	movs	r3, #40	; 0x28
    eaae:	73e3      	strb	r3, [r4, #15]
	rp->commands[15] |= BIT(1);
    eab0:	2302      	movs	r3, #2
    eab2:	7423      	strb	r3, [r4, #16]
	rp->commands[22] |= BIT(2);
    eab4:	2304      	movs	r3, #4
    eab6:	75e3      	strb	r3, [r4, #23]
	rp->commands[25] |= BIT(0) | BIT(1) | BIT(2) | BIT(4);
    eab8:	2317      	movs	r3, #23
    eaba:	76a3      	strb	r3, [r4, #26]
	rp->commands[27] |= BIT(6) | BIT(7);
    eabc:	f06f 033c 	mvn.w	r3, #60	; 0x3c
    eac0:	7723      	strb	r3, [r4, #28]
	rp->commands[28] |= BIT(3);
    eac2:	2308      	movs	r3, #8
    eac4:	7763      	strb	r3, [r4, #29]
	rp->commands[26] |= BIT(2) | BIT(3);
    eac6:	23cc      	movs	r3, #204	; 0xcc
    eac8:	76e3      	strb	r3, [r4, #27]
	rp->commands[38] |= BIT(7);
    eaca:	f06f 037f 	mvn.w	r3, #127	; 0x7f
    eace:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
}
    ead2:	bd10      	pop	{r4, pc}

0000ead4 <read_local_features>:
{
    ead4:	b508      	push	{r3, lr}
    ead6:	4608      	mov	r0, r1
	rp = hci_cmd_complete(evt, sizeof(*rp));
    ead8:	2109      	movs	r1, #9
    eada:	f7f7 fb9b 	bl	6214 <hci_cmd_complete>
	rp->status = 0x00;
    eade:	2200      	movs	r2, #0
    eae0:	4603      	mov	r3, r0
    eae2:	f803 2b01 	strb.w	r2, [r3], #1
    eae6:	f8c0 2001 	str.w	r2, [r0, #1]
    eaea:	605a      	str	r2, [r3, #4]
	rp->features[4] = (1 << 5) | (1 << 6);
    eaec:	2360      	movs	r3, #96	; 0x60
    eaee:	7143      	strb	r3, [r0, #5]
}
    eaf0:	bd08      	pop	{r3, pc}

0000eaf2 <read_bd_addr>:
{
    eaf2:	b508      	push	{r3, lr}
    eaf4:	4608      	mov	r0, r1
	rp = hci_cmd_complete(evt, sizeof(*rp));
    eaf6:	2107      	movs	r1, #7
    eaf8:	f7f7 fb8c 	bl	6214 <hci_cmd_complete>
    eafc:	4601      	mov	r1, r0
	rp->status = 0x00;
    eafe:	2000      	movs	r0, #0
    eb00:	f801 0b01 	strb.w	r0, [r1], #1
	ll_addr_get(0, &rp->bdaddr.val[0]);
    eb04:	f7f7 f8f8 	bl	5cf8 <ll_addr_get>
}
    eb08:	bd08      	pop	{r3, pc}

0000eb0a <info_cmd_handle>:
{
    eb0a:	b510      	push	{r4, lr}
    eb0c:	460c      	mov	r4, r1
    eb0e:	4611      	mov	r1, r2
	switch (ocf) {
    eb10:	1e43      	subs	r3, r0, #1
    eb12:	2b08      	cmp	r3, #8
    eb14:	d81a      	bhi.n	eb4c <info_cmd_handle+0x42>
    eb16:	e8df f003 	tbb	[pc, r3]
    eb1a:	0a05      	.short	0x0a05
    eb1c:	1919190f 	.word	0x1919190f
    eb20:	1919      	.short	0x1919
    eb22:	14          	.byte	0x14
    eb23:	00          	.byte	0x00
		read_local_version_info(cmd, evt);
    eb24:	4620      	mov	r0, r4
    eb26:	f7ff ff9a 	bl	ea5e <read_local_version_info>
	return 0;
    eb2a:	2000      	movs	r0, #0
		break;
    eb2c:	e010      	b.n	eb50 <info_cmd_handle+0x46>
		read_supported_commands(cmd, evt);
    eb2e:	4620      	mov	r0, r4
    eb30:	f7ff ffab 	bl	ea8a <read_supported_commands>
	return 0;
    eb34:	2000      	movs	r0, #0
		break;
    eb36:	e00b      	b.n	eb50 <info_cmd_handle+0x46>
		read_local_features(cmd, evt);
    eb38:	4620      	mov	r0, r4
    eb3a:	f7ff ffcb 	bl	ead4 <read_local_features>
	return 0;
    eb3e:	2000      	movs	r0, #0
		break;
    eb40:	e006      	b.n	eb50 <info_cmd_handle+0x46>
		read_bd_addr(cmd, evt);
    eb42:	4620      	mov	r0, r4
    eb44:	f7ff ffd5 	bl	eaf2 <read_bd_addr>
	return 0;
    eb48:	2000      	movs	r0, #0
		break;
    eb4a:	e001      	b.n	eb50 <info_cmd_handle+0x46>
	return 0;
    eb4c:	f06f 0015 	mvn.w	r0, #21
}
    eb50:	bd10      	pop	{r4, pc}

0000eb52 <le_read_buffer_size>:
{
    eb52:	b508      	push	{r3, lr}
    eb54:	4608      	mov	r0, r1
	rp = hci_cmd_complete(evt, sizeof(*rp));
    eb56:	2104      	movs	r1, #4
    eb58:	f7f7 fb5c 	bl	6214 <hci_cmd_complete>
	rp->status = 0x00;
    eb5c:	2300      	movs	r3, #0
    eb5e:	7003      	strb	r3, [r0, #0]
	rp->le_max_len = sys_cpu_to_le16(CONFIG_BT_CTLR_TX_BUFFER_SIZE);
    eb60:	221b      	movs	r2, #27
    eb62:	7042      	strb	r2, [r0, #1]
    eb64:	7083      	strb	r3, [r0, #2]
	rp->le_max_num = CONFIG_BT_CTLR_TX_BUFFERS;
    eb66:	2303      	movs	r3, #3
    eb68:	70c3      	strb	r3, [r0, #3]
}
    eb6a:	bd08      	pop	{r3, pc}

0000eb6c <le_read_local_features>:
{
    eb6c:	b508      	push	{r3, lr}
    eb6e:	4608      	mov	r0, r1
	rp = hci_cmd_complete(evt, sizeof(*rp));
    eb70:	2109      	movs	r1, #9
    eb72:	f7f7 fb4f 	bl	6214 <hci_cmd_complete>
	rp->status = 0x00;
    eb76:	2300      	movs	r3, #0
    eb78:	4602      	mov	r2, r0
    eb7a:	f802 3b01 	strb.w	r3, [r2], #1
    eb7e:	f8c0 3001 	str.w	r3, [r0, #1]
    eb82:	6053      	str	r3, [r2, #4]
	dst[0] = val;
    eb84:	7043      	strb	r3, [r0, #1]
	dst[1] = val >> 8;
    eb86:	7083      	strb	r3, [r0, #2]
	dst[2] = val >> 16;
    eb88:	70c3      	strb	r3, [r0, #3]
}
    eb8a:	bd08      	pop	{r3, pc}

0000eb8c <le_set_random_address>:
{
    eb8c:	b538      	push	{r3, r4, r5, lr}
    eb8e:	460d      	mov	r5, r1
	status = ll_addr_set(1, &cmd->bdaddr.val[0]);
    eb90:	6881      	ldr	r1, [r0, #8]
    eb92:	2001      	movs	r0, #1
    eb94:	f7f7 f8cc 	bl	5d30 <ll_addr_set>
    eb98:	4604      	mov	r4, r0
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    eb9a:	2101      	movs	r1, #1
    eb9c:	4628      	mov	r0, r5
    eb9e:	f7f7 fb39 	bl	6214 <hci_cmd_complete>
	ccst->status = status;
    eba2:	7004      	strb	r4, [r0, #0]
}
    eba4:	bd38      	pop	{r3, r4, r5, pc}

0000eba6 <le_read_wl_size>:
{
    eba6:	b510      	push	{r4, lr}
    eba8:	4608      	mov	r0, r1
	rp = hci_cmd_complete(evt, sizeof(*rp));
    ebaa:	2102      	movs	r1, #2
    ebac:	f7f7 fb32 	bl	6214 <hci_cmd_complete>
    ebb0:	4604      	mov	r4, r0
	rp->status = 0x00;
    ebb2:	2300      	movs	r3, #0
    ebb4:	7003      	strb	r3, [r0, #0]
	rp->wl_size = ll_wl_size_get();
    ebb6:	f000 fa6e 	bl	f096 <ll_wl_size_get>
    ebba:	7060      	strb	r0, [r4, #1]
}
    ebbc:	bd10      	pop	{r4, pc}

0000ebbe <le_clear_wl>:
{
    ebbe:	b510      	push	{r4, lr}
    ebc0:	4608      	mov	r0, r1
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    ebc2:	2101      	movs	r1, #1
    ebc4:	f7f7 fb26 	bl	6214 <hci_cmd_complete>
    ebc8:	4604      	mov	r4, r0
	ccst->status = ll_wl_clear();
    ebca:	f7f8 fbe3 	bl	7394 <ll_wl_clear>
    ebce:	7020      	strb	r0, [r4, #0]
}
    ebd0:	bd10      	pop	{r4, pc}

0000ebd2 <le_add_dev_to_wl>:
{
    ebd2:	b538      	push	{r3, r4, r5, lr}
    ebd4:	460d      	mov	r5, r1
	status = ll_wl_add(&cmd->addr);
    ebd6:	6880      	ldr	r0, [r0, #8]
    ebd8:	f7f8 fbf0 	bl	73bc <ll_wl_add>
    ebdc:	4604      	mov	r4, r0
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    ebde:	2101      	movs	r1, #1
    ebe0:	4628      	mov	r0, r5
    ebe2:	f7f7 fb17 	bl	6214 <hci_cmd_complete>
	ccst->status = status;
    ebe6:	7004      	strb	r4, [r0, #0]
}
    ebe8:	bd38      	pop	{r3, r4, r5, pc}

0000ebea <le_rem_dev_from_wl>:
{
    ebea:	b538      	push	{r3, r4, r5, lr}
    ebec:	460d      	mov	r5, r1
	status = ll_wl_remove(&cmd->addr);
    ebee:	6880      	ldr	r0, [r0, #8]
    ebf0:	f7f8 fc00 	bl	73f4 <ll_wl_remove>
    ebf4:	4604      	mov	r4, r0
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    ebf6:	2101      	movs	r1, #1
    ebf8:	4628      	mov	r0, r5
    ebfa:	f7f7 fb0b 	bl	6214 <hci_cmd_complete>
	ccst->status = status;
    ebfe:	7004      	strb	r4, [r0, #0]
}
    ec00:	bd38      	pop	{r3, r4, r5, pc}

0000ec02 <le_encrypt>:
{
    ec02:	b570      	push	{r4, r5, r6, lr}
    ec04:	b084      	sub	sp, #16
    ec06:	460c      	mov	r4, r1
	struct bt_hci_cp_le_encrypt *cmd = (void *)buf->data;
    ec08:	6880      	ldr	r0, [r0, #8]
	ecb_encrypt(cmd->key, cmd->plaintext, enc_data, NULL);
    ec0a:	2300      	movs	r3, #0
    ec0c:	466a      	mov	r2, sp
    ec0e:	f100 0110 	add.w	r1, r0, #16
    ec12:	f000 faf7 	bl	f204 <ecb_encrypt>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    ec16:	2111      	movs	r1, #17
    ec18:	4620      	mov	r0, r4
    ec1a:	f7f7 fafb 	bl	6214 <hci_cmd_complete>
    ec1e:	4606      	mov	r6, r0
	rp->status = 0x00;
    ec20:	4605      	mov	r5, r0
    ec22:	2300      	movs	r3, #0
    ec24:	f805 3b01 	strb.w	r3, [r5], #1
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    ec28:	466c      	mov	r4, sp
    ec2a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    ec2c:	f8c6 0001 	str.w	r0, [r6, #1]
    ec30:	6069      	str	r1, [r5, #4]
    ec32:	60aa      	str	r2, [r5, #8]
    ec34:	60eb      	str	r3, [r5, #12]
}
    ec36:	b004      	add	sp, #16
    ec38:	bd70      	pop	{r4, r5, r6, pc}

0000ec3a <le_rand>:
{
    ec3a:	b508      	push	{r3, lr}
    ec3c:	4608      	mov	r0, r1
	rp = hci_cmd_complete(evt, sizeof(*rp));
    ec3e:	2109      	movs	r1, #9
    ec40:	f7f7 fae8 	bl	6214 <hci_cmd_complete>
	rp->status = 0x00;
    ec44:	2300      	movs	r3, #0
    ec46:	f800 3b01 	strb.w	r3, [r0], #1
	lll_trng_get(rp->rand, count);
    ec4a:	2108      	movs	r1, #8
    ec4c:	f7f8 fde8 	bl	7820 <lll_trng_get>
}
    ec50:	bd08      	pop	{r3, pc}

0000ec52 <le_read_supp_states>:
{
    ec52:	b508      	push	{r3, lr}
    ec54:	4608      	mov	r0, r1
	rp = hci_cmd_complete(evt, sizeof(*rp));
    ec56:	2109      	movs	r1, #9
    ec58:	f7f7 fadc 	bl	6214 <hci_cmd_complete>
	rp->status = 0x00;
    ec5c:	2300      	movs	r3, #0
    ec5e:	7003      	strb	r3, [r0, #0]
	dst[0] = val;
    ec60:	2230      	movs	r2, #48	; 0x30
    ec62:	7042      	strb	r2, [r0, #1]
	dst[1] = val >> 8;
    ec64:	2233      	movs	r2, #51	; 0x33
    ec66:	7082      	strb	r2, [r0, #2]
	dst[0] = val;
    ec68:	70c3      	strb	r3, [r0, #3]
	dst[1] = val >> 8;
    ec6a:	7103      	strb	r3, [r0, #4]
	dst[0] = val;
    ec6c:	7143      	strb	r3, [r0, #5]
	dst[1] = val >> 8;
    ec6e:	7183      	strb	r3, [r0, #6]
	dst[0] = val;
    ec70:	71c3      	strb	r3, [r0, #7]
	dst[1] = val >> 8;
    ec72:	7203      	strb	r3, [r0, #8]
}
    ec74:	bd08      	pop	{r3, pc}

0000ec76 <le_set_scan_param>:
{
    ec76:	b530      	push	{r4, r5, lr}
    ec78:	b083      	sub	sp, #12
    ec7a:	460d      	mov	r5, r1
	struct bt_hci_cp_le_set_scan_param *cmd = (void *)buf->data;
    ec7c:	6884      	ldr	r4, [r0, #8]
	interval = sys_le16_to_cpu(cmd->interval);
    ec7e:	f8b4 1001 	ldrh.w	r1, [r4, #1]
	window = sys_le16_to_cpu(cmd->window);
    ec82:	f8b4 2003 	ldrh.w	r2, [r4, #3]
	status = ll_scan_params_set(cmd->scan_type, interval, window,
    ec86:	7963      	ldrb	r3, [r4, #5]
    ec88:	7820      	ldrb	r0, [r4, #0]
    ec8a:	79a4      	ldrb	r4, [r4, #6]
    ec8c:	9400      	str	r4, [sp, #0]
    ec8e:	f000 f93c 	bl	ef0a <ll_scan_params_set>
    ec92:	4604      	mov	r4, r0
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
    ec94:	2101      	movs	r1, #1
    ec96:	4628      	mov	r0, r5
    ec98:	f7f7 fabc 	bl	6214 <hci_cmd_complete>
	ccst->status = status;
    ec9c:	7004      	strb	r4, [r0, #0]
}
    ec9e:	b003      	add	sp, #12
    eca0:	bd30      	pop	{r4, r5, pc}

0000eca2 <le_read_tx_power>:
{
    eca2:	b508      	push	{r3, lr}
    eca4:	4608      	mov	r0, r1
	rp = hci_cmd_complete(evt, sizeof(*rp));
    eca6:	2103      	movs	r1, #3
    eca8:	f7f7 fab4 	bl	6214 <hci_cmd_complete>
	rp->status = 0x00;
    ecac:	4601      	mov	r1, r0
    ecae:	2300      	movs	r3, #0
    ecb0:	f801 3b02 	strb.w	r3, [r1], #2
	ll_tx_pwr_get(&rp->min_tx_power, &rp->max_tx_power);
    ecb4:	3001      	adds	r0, #1
    ecb6:	f7ff fe10 	bl	e8da <ll_tx_pwr_get>
}
    ecba:	bd08      	pop	{r3, pc}

0000ecbc <controller_cmd_handle>:
{
    ecbc:	b508      	push	{r3, lr}
    ecbe:	4603      	mov	r3, r0
    ecc0:	4608      	mov	r0, r1
    ecc2:	4611      	mov	r1, r2
	switch (ocf) {
    ecc4:	3b01      	subs	r3, #1
    ecc6:	2b4a      	cmp	r3, #74	; 0x4a
    ecc8:	d85f      	bhi.n	ed8a <controller_cmd_handle+0xce>
    ecca:	e8df f003 	tbb	[pc, r3]
    ecce:	2a26      	.short	0x2a26
    ecd0:	5e325e2e 	.word	0x5e325e2e
    ecd4:	5e5e5e5e 	.word	0x5e5e5e5e
    ecd8:	5e5e5652 	.word	0x5e5e5652
    ecdc:	423e3a36 	.word	0x423e3a36
    ece0:	5e5e5e5e 	.word	0x5e5e5e5e
    ece4:	5e5e4a46 	.word	0x5e5e4a46
    ece8:	5e5e4e5e 	.word	0x5e5e4e5e
    ecec:	5e5e5e5e 	.word	0x5e5e5e5e
    ecf0:	5e5e5e5e 	.word	0x5e5e5e5e
    ecf4:	5e5e5e5e 	.word	0x5e5e5e5e
    ecf8:	5e5e5e5e 	.word	0x5e5e5e5e
    ecfc:	5e5e5e5e 	.word	0x5e5e5e5e
    ed00:	5e5e5e5e 	.word	0x5e5e5e5e
    ed04:	5e5e5e5e 	.word	0x5e5e5e5e
    ed08:	5e5e5e5e 	.word	0x5e5e5e5e
    ed0c:	5e5e5e5e 	.word	0x5e5e5e5e
    ed10:	5e5e5e5e 	.word	0x5e5e5e5e
    ed14:	5e5e5e5e 	.word	0x5e5e5e5e
    ed18:	5a          	.byte	0x5a
    ed19:	00          	.byte	0x00
		le_set_event_mask(cmd, evt);
    ed1a:	f7f7 faf5 	bl	6308 <le_set_event_mask>
	return 0;
    ed1e:	2000      	movs	r0, #0
		break;
    ed20:	e035      	b.n	ed8e <controller_cmd_handle+0xd2>
		le_read_buffer_size(cmd, evt);
    ed22:	f7ff ff16 	bl	eb52 <le_read_buffer_size>
	return 0;
    ed26:	2000      	movs	r0, #0
		break;
    ed28:	e031      	b.n	ed8e <controller_cmd_handle+0xd2>
		le_read_local_features(cmd, evt);
    ed2a:	f7ff ff1f 	bl	eb6c <le_read_local_features>
	return 0;
    ed2e:	2000      	movs	r0, #0
		break;
    ed30:	e02d      	b.n	ed8e <controller_cmd_handle+0xd2>
		le_set_random_address(cmd, evt);
    ed32:	f7ff ff2b 	bl	eb8c <le_set_random_address>
	return 0;
    ed36:	2000      	movs	r0, #0
		break;
    ed38:	e029      	b.n	ed8e <controller_cmd_handle+0xd2>
		le_read_wl_size(cmd, evt);
    ed3a:	f7ff ff34 	bl	eba6 <le_read_wl_size>
	return 0;
    ed3e:	2000      	movs	r0, #0
		break;
    ed40:	e025      	b.n	ed8e <controller_cmd_handle+0xd2>
		le_clear_wl(cmd, evt);
    ed42:	f7ff ff3c 	bl	ebbe <le_clear_wl>
	return 0;
    ed46:	2000      	movs	r0, #0
		break;
    ed48:	e021      	b.n	ed8e <controller_cmd_handle+0xd2>
		le_add_dev_to_wl(cmd, evt);
    ed4a:	f7ff ff42 	bl	ebd2 <le_add_dev_to_wl>
	return 0;
    ed4e:	2000      	movs	r0, #0
		break;
    ed50:	e01d      	b.n	ed8e <controller_cmd_handle+0xd2>
		le_rem_dev_from_wl(cmd, evt);
    ed52:	f7ff ff4a 	bl	ebea <le_rem_dev_from_wl>
	return 0;
    ed56:	2000      	movs	r0, #0
		break;
    ed58:	e019      	b.n	ed8e <controller_cmd_handle+0xd2>
		le_encrypt(cmd, evt);
    ed5a:	f7ff ff52 	bl	ec02 <le_encrypt>
	return 0;
    ed5e:	2000      	movs	r0, #0
		break;
    ed60:	e015      	b.n	ed8e <controller_cmd_handle+0xd2>
		le_rand(cmd, evt);
    ed62:	f7ff ff6a 	bl	ec3a <le_rand>
	return 0;
    ed66:	2000      	movs	r0, #0
		break;
    ed68:	e011      	b.n	ed8e <controller_cmd_handle+0xd2>
		le_read_supp_states(cmd, evt);
    ed6a:	f7ff ff72 	bl	ec52 <le_read_supp_states>
	return 0;
    ed6e:	2000      	movs	r0, #0
		break;
    ed70:	e00d      	b.n	ed8e <controller_cmd_handle+0xd2>
		le_set_scan_param(cmd, evt);
    ed72:	f7ff ff80 	bl	ec76 <le_set_scan_param>
	return 0;
    ed76:	2000      	movs	r0, #0
		break;
    ed78:	e009      	b.n	ed8e <controller_cmd_handle+0xd2>
		le_set_scan_enable(cmd, evt);
    ed7a:	f7f7 fae9 	bl	6350 <le_set_scan_enable>
	return 0;
    ed7e:	2000      	movs	r0, #0
		break;
    ed80:	e005      	b.n	ed8e <controller_cmd_handle+0xd2>
		le_read_tx_power(cmd, evt);
    ed82:	f7ff ff8e 	bl	eca2 <le_read_tx_power>
	return 0;
    ed86:	2000      	movs	r0, #0
		break;
    ed88:	e001      	b.n	ed8e <controller_cmd_handle+0xd2>
	return 0;
    ed8a:	f06f 0015 	mvn.w	r0, #21
}
    ed8e:	bd08      	pop	{r3, pc}

0000ed90 <vs_read_static_addrs>:
{
    ed90:	b510      	push	{r4, lr}
    ed92:	4608      	mov	r0, r1
	rp = hci_cmd_complete(evt, sizeof(*rp) +
    ed94:	2118      	movs	r1, #24
    ed96:	f7f7 fa3d 	bl	6214 <hci_cmd_complete>
    ed9a:	4604      	mov	r4, r0
	rp->status = 0x00;
    ed9c:	2300      	movs	r3, #0
    ed9e:	f800 3b02 	strb.w	r3, [r0], #2
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
    eda2:	2101      	movs	r1, #1
    eda4:	f000 fa8c 	bl	f2c0 <hci_vendor_read_static_addr>
    eda8:	7060      	strb	r0, [r4, #1]
}
    edaa:	bd10      	pop	{r4, pc}

0000edac <vs_read_key_hierarchy_roots>:
{
    edac:	b508      	push	{r3, lr}
    edae:	4608      	mov	r0, r1
	rp = hci_cmd_complete(evt, sizeof(*rp));
    edb0:	2121      	movs	r1, #33	; 0x21
    edb2:	f7f7 fa2f 	bl	6214 <hci_cmd_complete>
    edb6:	4601      	mov	r1, r0
	rp->status = 0x00;
    edb8:	2300      	movs	r3, #0
    edba:	f800 3b01 	strb.w	r3, [r0], #1
	hci_vendor_read_key_hierarchy_roots(rp->ir, rp->er);
    edbe:	3111      	adds	r1, #17
    edc0:	f000 faf5 	bl	f3ae <hci_vendor_read_key_hierarchy_roots>
}
    edc4:	bd08      	pop	{r3, pc}

0000edc6 <hci_vendor_cmd_handle_common>:
{
    edc6:	b508      	push	{r3, lr}
    edc8:	4603      	mov	r3, r0
    edca:	4608      	mov	r0, r1
    edcc:	4611      	mov	r1, r2
	switch (ocf) {
    edce:	3b01      	subs	r3, #1
    edd0:	2b09      	cmp	r3, #9
    edd2:	d822      	bhi.n	ee1a <hci_vendor_cmd_handle_common+0x54>
    edd4:	e8df f003 	tbb	[pc, r3]
    edd8:	210d0905 	.word	0x210d0905
    eddc:	11211521 	.word	0x11211521
    ede0:	1d19      	.short	0x1d19
		vs_read_version_info(cmd, evt);
    ede2:	f7ff fdd9 	bl	e998 <vs_read_version_info>
	return 0;
    ede6:	2000      	movs	r0, #0
		break;
    ede8:	e019      	b.n	ee1e <hci_vendor_cmd_handle_common+0x58>
		vs_read_supported_commands(cmd, evt);
    edea:	f7ff fdeb 	bl	e9c4 <vs_read_supported_commands>
	return 0;
    edee:	2000      	movs	r0, #0
		break;
    edf0:	e015      	b.n	ee1e <hci_vendor_cmd_handle_common+0x58>
		vs_read_supported_features(cmd, evt);
    edf2:	f7ff fdf9 	bl	e9e8 <vs_read_supported_features>
	return 0;
    edf6:	2000      	movs	r0, #0
		break;
    edf8:	e011      	b.n	ee1e <hci_vendor_cmd_handle_common+0x58>
		vs_read_build_info(cmd, evt);
    edfa:	f7f7 fa1b 	bl	6234 <vs_read_build_info>
	return 0;
    edfe:	2000      	movs	r0, #0
		break;
    ee00:	e00d      	b.n	ee1e <hci_vendor_cmd_handle_common+0x58>
		vs_write_bd_addr(cmd, evt);
    ee02:	f7ff fdfe 	bl	ea02 <vs_write_bd_addr>
	return 0;
    ee06:	2000      	movs	r0, #0
		break;
    ee08:	e009      	b.n	ee1e <hci_vendor_cmd_handle_common+0x58>
		vs_read_static_addrs(cmd, evt);
    ee0a:	f7ff ffc1 	bl	ed90 <vs_read_static_addrs>
	return 0;
    ee0e:	2000      	movs	r0, #0
		break;
    ee10:	e005      	b.n	ee1e <hci_vendor_cmd_handle_common+0x58>
		vs_read_key_hierarchy_roots(cmd, evt);
    ee12:	f7ff ffcb 	bl	edac <vs_read_key_hierarchy_roots>
	return 0;
    ee16:	2000      	movs	r0, #0
		break;
    ee18:	e001      	b.n	ee1e <hci_vendor_cmd_handle_common+0x58>
	return 0;
    ee1a:	f06f 0015 	mvn.w	r0, #21
}
    ee1e:	bd08      	pop	{r3, pc}

0000ee20 <hci_evt_encode>:
	}
}
#endif /* CONFIG_BT_CONN */

void hci_evt_encode(struct node_rx_pdu *node_rx, struct net_buf *buf)
{
    ee20:	b570      	push	{r4, r5, r6, lr}
    ee22:	4604      	mov	r4, r0
    ee24:	460d      	mov	r5, r1
	struct pdu_data *pdu_data = PDU_DATA(node_rx);
    ee26:	f100 06b4 	add.w	r6, r0, #180	; 0xb4
#if defined(CONFIG_BT_CTLR_DFE_RX)
	enquque_dfe_data_packet(node_rx);
    ee2a:	f7f7 f8ed 	bl	6008 <enquque_dfe_data_packet>
#endif /* CONFIG_BT_CTLR_DFE_RX */
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
    ee2e:	7923      	ldrb	r3, [r4, #4]
    ee30:	2b02      	cmp	r3, #2
    ee32:	d100      	bne.n	ee36 <hci_evt_encode+0x16>
		encode_control(node_rx, pdu_data, buf);
	} else if (IS_ENABLED(CONFIG_BT_CONN)) {
		encode_data_ctrl(node_rx, pdu_data, buf);
	}
}
    ee34:	bd70      	pop	{r4, r5, r6, pc}
		encode_control(node_rx, pdu_data, buf);
    ee36:	462a      	mov	r2, r5
    ee38:	4631      	mov	r1, r6
    ee3a:	4620      	mov	r0, r4
    ee3c:	f7f7 f9c2 	bl	61c4 <encode_control>
}
    ee40:	e7f8      	b.n	ee34 <hci_evt_encode+0x14>

0000ee42 <hci_get_class>:
{
#if defined(CONFIG_BT_CONN)
	struct pdu_data *pdu_data = PDU_DATA(node_rx);
#endif

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
    ee42:	7903      	ldrb	r3, [r0, #4]
    ee44:	2b02      	cmp	r3, #2
    ee46:	d005      	beq.n	ee54 <hci_get_class+0x12>

		switch (node_rx->hdr.type) {
    ee48:	2b04      	cmp	r3, #4
    ee4a:	d001      	beq.n	ee50 <hci_get_class+0xe>
		case NODE_RX_TYPE_USER_START ... NODE_RX_TYPE_USER_END:
			return hci_user_ext_get_class(node_rx);
#endif /* CONFIG_BT_CTLR_USER_EXT */

		default:
			return HCI_CLASS_NONE;
    ee4c:	2000      	movs	r0, #0
#else
	} else {
		return HCI_CLASS_NONE;
	}
#endif
}
    ee4e:	4770      	bx	lr
			return HCI_CLASS_EVT_DISCARDABLE;
    ee50:	2002      	movs	r0, #2
    ee52:	4770      	bx	lr
		return HCI_CLASS_NONE;
    ee54:	2000      	movs	r0, #0
    ee56:	4770      	bx	lr

0000ee58 <hci_init>:

void hci_init(struct k_poll_signal *signal_host_buf)
{
    ee58:	b508      	push	{r3, lr}
#if defined(CONFIG_BT_HCI_ACL_FLOW_CONTROL)
	hbuf_signal = signal_host_buf;
#endif
	reset(NULL, NULL);
    ee5a:	2100      	movs	r1, #0
    ee5c:	4608      	mov	r0, r1
    ee5e:	f7f7 fa31 	bl	62c4 <reset>
}
    ee62:	bd08      	pop	{r3, pc}

0000ee64 <bt_rand>:

#include "hal/ecb.h"
#include "lll.h"

int bt_rand(void *buf, size_t len)
{
    ee64:	b508      	push	{r3, lr}
	return lll_trng_get(buf, len);
    ee66:	f7f8 fcdb 	bl	7820 <lll_trng_get>
}
    ee6a:	bd08      	pop	{r3, pc}

0000ee6c <disabled_cb>:
	}
}

static void disabled_cb(void *param)
{
    ee6c:	b508      	push	{r3, lr}
	z_impl_k_sem_give(sem);
    ee6e:	f7fc fa45 	bl	b2fc <z_impl_k_sem_give>
	k_sem_give(param);
}
    ee72:	bd08      	pop	{r3, pc}

0000ee74 <init_reset>:
}
    ee74:	2000      	movs	r0, #0
    ee76:	4770      	bx	lr

0000ee78 <ull_scan_init>:
{
    ee78:	b508      	push	{r3, lr}
	err = init_reset();
    ee7a:	f7ff fffb 	bl	ee74 <init_reset>
}
    ee7e:	bd08      	pop	{r3, pc}

0000ee80 <ull_scan_lll_handle_get>:
{
    ee80:	b508      	push	{r3, lr}
	return ull_scan_handle_get((void *)lll->hdr.parent);
    ee82:	6800      	ldr	r0, [r0, #0]
    ee84:	f7f8 f958 	bl	7138 <ull_scan_handle_get>
}
    ee88:	bd08      	pop	{r3, pc}

0000ee8a <ull_scan_is_enabled_get>:
{
    ee8a:	b508      	push	{r3, lr}
	scan = ull_scan_set_get(handle);
    ee8c:	f7f8 f948 	bl	7120 <ull_scan_set_get>
	if (!scan || !scan->is_enabled) {
    ee90:	b138      	cbz	r0, eea2 <ull_scan_is_enabled_get+0x18>
    ee92:	4603      	mov	r3, r0
    ee94:	f890 2038 	ldrb.w	r2, [r0, #56]	; 0x38
    ee98:	f012 0f01 	tst.w	r2, #1
    ee9c:	d003      	beq.n	eea6 <ull_scan_is_enabled_get+0x1c>
}
    ee9e:	4618      	mov	r0, r3
    eea0:	bd08      	pop	{r3, pc}
		return NULL;
    eea2:	2300      	movs	r3, #0
    eea4:	e7fb      	b.n	ee9e <ull_scan_is_enabled_get+0x14>
    eea6:	2300      	movs	r3, #0
    eea8:	e7f9      	b.n	ee9e <ull_scan_is_enabled_get+0x14>

0000eeaa <disable>:

static u8_t disable(u16_t handle)
{
    eeaa:	b538      	push	{r3, r4, r5, lr}
    eeac:	4604      	mov	r4, r0
	struct ll_scan_set *scan;
	u8_t ret;

	scan = ull_scan_is_enabled_get(handle);
    eeae:	f7ff ffec 	bl	ee8a <ull_scan_is_enabled_get>
	if (!scan) {
    eeb2:	b160      	cbz	r0, eece <disable+0x24>
    eeb4:	4605      	mov	r5, r0
	if (scan->lll.conn) {
		return BT_HCI_ERR_CMD_DISALLOWED;
	}
#endif

	ret = ull_scan_disable(handle, scan);
    eeb6:	4601      	mov	r1, r0
    eeb8:	4620      	mov	r0, r4
    eeba:	f7f8 f8c3 	bl	7044 <ull_scan_disable>
	if (ret) {
    eebe:	b928      	cbnz	r0, eecc <disable+0x22>
		return ret;
	}

	scan->is_enabled = 0U;
    eec0:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
    eec4:	f36f 0300 	bfc	r3, #0, #1
    eec8:	f885 3038 	strb.w	r3, [r5, #56]	; 0x38
		ull_filter_adv_scan_state_cb(0);
	}
#endif

	return 0;
}
    eecc:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
    eece:	200c      	movs	r0, #12
    eed0:	e7fc      	b.n	eecc <disable+0x22>

0000eed2 <ull_scan_reset>:
{
    eed2:	b510      	push	{r4, lr}
	for (handle = 0U; handle < BT_CTLR_SCAN_MAX; handle++) {
    eed4:	2400      	movs	r4, #0
    eed6:	b114      	cbz	r4, eede <ull_scan_reset+0xc>
	err = init_reset();
    eed8:	f7ff ffcc 	bl	ee74 <init_reset>
}
    eedc:	bd10      	pop	{r4, pc}
		(void)disable(handle);
    eede:	4620      	mov	r0, r4
    eee0:	f7ff ffe3 	bl	eeaa <disable>
	for (handle = 0U; handle < BT_CTLR_SCAN_MAX; handle++) {
    eee4:	3401      	adds	r4, #1
    eee6:	b2a4      	uxth	r4, r4
    eee8:	e7f5      	b.n	eed6 <ull_scan_reset+0x4>

0000eeea <ull_scan_is_disabled_get>:
{
    eeea:	b508      	push	{r3, lr}
	scan = ull_scan_set_get(handle);
    eeec:	f7f8 f918 	bl	7120 <ull_scan_set_get>
	if (!scan || scan->is_enabled) {
    eef0:	b138      	cbz	r0, ef02 <ull_scan_is_disabled_get+0x18>
    eef2:	4603      	mov	r3, r0
    eef4:	f890 2038 	ldrb.w	r2, [r0, #56]	; 0x38
    eef8:	f012 0f01 	tst.w	r2, #1
    eefc:	d103      	bne.n	ef06 <ull_scan_is_disabled_get+0x1c>
}
    eefe:	4618      	mov	r0, r3
    ef00:	bd08      	pop	{r3, pc}
		return NULL;
    ef02:	2300      	movs	r3, #0
    ef04:	e7fb      	b.n	eefe <ull_scan_is_disabled_get+0x14>
    ef06:	2300      	movs	r3, #0
    ef08:	e7f9      	b.n	eefe <ull_scan_is_disabled_get+0x14>

0000ef0a <ll_scan_params_set>:
{
    ef0a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ef0e:	b082      	sub	sp, #8
    ef10:	4604      	mov	r4, r0
    ef12:	460d      	mov	r5, r1
    ef14:	4690      	mov	r8, r2
    ef16:	461e      	mov	r6, r3
	scan = ull_scan_is_disabled_get(0);
    ef18:	2000      	movs	r0, #0
    ef1a:	f7ff ffe6 	bl	eeea <ull_scan_is_disabled_get>
	if (!scan) {
    ef1e:	b190      	cbz	r0, ef46 <ll_scan_params_set+0x3c>
	scan->own_addr_type = own_addr_type;
    ef20:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
    ef24:	f366 0342 	bfi	r3, r6, #1, #2
    ef28:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
	ull_scan_params_set(&scan->lll, type, interval, window, filter_policy);
    ef2c:	f89d 3020 	ldrb.w	r3, [sp, #32]
    ef30:	9300      	str	r3, [sp, #0]
    ef32:	4643      	mov	r3, r8
    ef34:	462a      	mov	r2, r5
    ef36:	4621      	mov	r1, r4
    ef38:	301c      	adds	r0, #28
    ef3a:	f7f1 fbed 	bl	718 <ull_scan_params_set>
	return 0;
    ef3e:	2000      	movs	r0, #0
}
    ef40:	b002      	add	sp, #8
    ef42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
    ef46:	200c      	movs	r0, #12
    ef48:	e7fa      	b.n	ef40 <ll_scan_params_set+0x36>

0000ef4a <ll_scan_enable>:
{
    ef4a:	b510      	push	{r4, lr}
	if (!enable) {
    ef4c:	b1a8      	cbz	r0, ef7a <ll_scan_enable+0x30>
	scan = ull_scan_is_disabled_get(0);
    ef4e:	2000      	movs	r0, #0
    ef50:	f7ff ffcb 	bl	eeea <ull_scan_is_disabled_get>
	if (!scan) {
    ef54:	4604      	mov	r4, r0
    ef56:	b198      	cbz	r0, ef80 <ll_scan_enable+0x36>
	if (scan->own_addr_type & 0x1) {
    ef58:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
    ef5c:	f013 0f02 	tst.w	r3, #2
    ef60:	d007      	beq.n	ef72 <ll_scan_enable+0x28>
		if (!mem_nz(ll_addr_get(1, NULL), BDADDR_SIZE)) {
    ef62:	2100      	movs	r1, #0
    ef64:	2001      	movs	r0, #1
    ef66:	f7f6 fec7 	bl	5cf8 <ll_addr_get>
    ef6a:	2106      	movs	r1, #6
    ef6c:	f7ff f9d5 	bl	e31a <mem_nz>
    ef70:	b140      	cbz	r0, ef84 <ll_scan_enable+0x3a>
	return ull_scan_enable(scan);
    ef72:	4620      	mov	r0, r4
    ef74:	f7f1 fbf4 	bl	760 <ull_scan_enable>
}
    ef78:	bd10      	pop	{r4, pc}
		return disable(0);
    ef7a:	f7ff ff96 	bl	eeaa <disable>
    ef7e:	e7fb      	b.n	ef78 <ll_scan_enable+0x2e>
		return BT_HCI_ERR_CMD_DISALLOWED;
    ef80:	200c      	movs	r0, #12
    ef82:	e7f9      	b.n	ef78 <ll_scan_enable+0x2e>
			return BT_HCI_ERR_INVALID_PARAM;
    ef84:	2012      	movs	r0, #18
    ef86:	e7f7      	b.n	ef78 <ll_scan_enable+0x2e>

0000ef88 <ull_scan_is_enabled>:
{
    ef88:	b508      	push	{r3, lr}
	scan = ull_scan_is_enabled_get(handle);
    ef8a:	f7ff ff7e 	bl	ee8a <ull_scan_is_enabled_get>
	if (!scan) {
    ef8e:	b148      	cbz	r0, efa4 <ull_scan_is_enabled+0x1c>
    ef90:	4603      	mov	r3, r0
	return (((u32_t)scan->is_enabled << scan->lll.type) |
    ef92:	f890 0038 	ldrb.w	r0, [r0, #56]	; 0x38
    ef96:	f000 0001 	and.w	r0, r0, #1
    ef9a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
    ef9e:	09db      	lsrs	r3, r3, #7
    efa0:	4098      	lsls	r0, r3
}
    efa2:	bd08      	pop	{r3, pc}
		return 0;
    efa4:	2000      	movs	r0, #0
    efa6:	e7fc      	b.n	efa2 <ull_scan_is_enabled+0x1a>

0000efa8 <ull_scan_filter_pol_get>:
{
    efa8:	b508      	push	{r3, lr}
	scan = ull_scan_is_enabled_get(handle);
    efaa:	f7ff ff6e 	bl	ee8a <ull_scan_is_enabled_get>
	if (!scan) {
    efae:	b120      	cbz	r0, efba <ull_scan_filter_pol_get+0x12>
	return scan->lll.filter_policy;
    efb0:	f890 0024 	ldrb.w	r0, [r0, #36]	; 0x24
    efb4:	f3c0 00c1 	ubfx	r0, r0, #3, #2
}
    efb8:	bd08      	pop	{r3, pc}
		return 0;
    efba:	2000      	movs	r0, #0
    efbc:	e7fc      	b.n	efb8 <ull_scan_filter_pol_get+0x10>

0000efbe <dfe_common_init>:
}
    efbe:	4770      	bx	lr

0000efc0 <dfe_packet_buffer_set>:
{
    efc0:	b510      	push	{r4, lr}
    efc2:	4604      	mov	r4, r0
	radio_dfe_samples_buffer_set(node_rx->df_data_packet.data,
    efc4:	2124      	movs	r1, #36	; 0x24
    efc6:	4408      	add	r0, r1
    efc8:	f7f9 fe3e 	bl	8c48 <radio_dfe_samples_buffer_set>
	node_rx->df_data_packet.hdr.length = 0;
    efcc:	2300      	movs	r3, #0
    efce:	8423      	strh	r3, [r4, #32]
}
    efd0:	bd10      	pop	{r4, pc}

0000efd2 <filter_clear>:
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
}

static void filter_clear(struct lll_filter *filter)
{
	filter->enable_bitmask = 0;
    efd2:	2300      	movs	r3, #0
    efd4:	7003      	strb	r3, [r0, #0]
	filter->addr_type_bitmask = 0;
    efd6:	7043      	strb	r3, [r0, #1]
}
    efd8:	4770      	bx	lr

0000efda <filter_insert>:
{
    efda:	b430      	push	{r4, r5}
	filter->enable_bitmask |= BIT(index);
    efdc:	2401      	movs	r4, #1
    efde:	fa04 f501 	lsl.w	r5, r4, r1
    efe2:	7804      	ldrb	r4, [r0, #0]
    efe4:	432c      	orrs	r4, r5
    efe6:	7004      	strb	r4, [r0, #0]
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
    efe8:	f002 0201 	and.w	r2, r2, #1
    efec:	408a      	lsls	r2, r1
    efee:	7844      	ldrb	r4, [r0, #1]
    eff0:	4322      	orrs	r2, r4
    eff2:	7042      	strb	r2, [r0, #1]
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
    eff4:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    eff8:	eb00 0041 	add.w	r0, r0, r1, lsl #1
    effc:	681a      	ldr	r2, [r3, #0]
    effe:	f8c0 2002 	str.w	r2, [r0, #2]
    f002:	889b      	ldrh	r3, [r3, #4]
    f004:	80c3      	strh	r3, [r0, #6]
}
    f006:	bc30      	pop	{r4, r5}
    f008:	4770      	bx	lr

0000f00a <filter_add>:
{
    f00a:	b570      	push	{r4, r5, r6, lr}
	if (filter->enable_bitmask == 0xFF) {
    f00c:	7805      	ldrb	r5, [r0, #0]
    f00e:	2dff      	cmp	r5, #255	; 0xff
    f010:	d00e      	beq.n	f030 <filter_add+0x26>
    f012:	460e      	mov	r6, r1
    f014:	4613      	mov	r3, r2
	for (index = 0;
    f016:	2100      	movs	r1, #0
    f018:	e000      	b.n	f01c <filter_add+0x12>
	     index++) {
    f01a:	3101      	adds	r1, #1
	     (filter->enable_bitmask & BIT(index));
    f01c:	fa25 f401 	lsr.w	r4, r5, r1
	for (index = 0;
    f020:	f014 0401 	ands.w	r4, r4, #1
    f024:	d1f9      	bne.n	f01a <filter_add+0x10>
	filter_insert(filter, index, addr_type, bdaddr);
    f026:	4632      	mov	r2, r6
    f028:	f7ff ffd7 	bl	efda <filter_insert>
}
    f02c:	4620      	mov	r0, r4
    f02e:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
    f030:	2407      	movs	r4, #7
    f032:	e7fb      	b.n	f02c <filter_add+0x22>

0000f034 <filter_remove>:
{
    f034:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!filter->enable_bitmask) {
    f036:	7803      	ldrb	r3, [r0, #0]
    f038:	b35b      	cbz	r3, f092 <filter_remove+0x5e>
    f03a:	4605      	mov	r5, r0
    f03c:	460e      	mov	r6, r1
    f03e:	4617      	mov	r7, r2
	index = 8;
    f040:	2308      	movs	r3, #8
    f042:	e000      	b.n	f046 <filter_remove+0x12>
{
    f044:	4623      	mov	r3, r4
	while (index--) {
    f046:	1e5c      	subs	r4, r3, #1
    f048:	b30b      	cbz	r3, f08e <filter_remove+0x5a>
		if ((filter->enable_bitmask & BIT(index)) &&
    f04a:	782b      	ldrb	r3, [r5, #0]
    f04c:	40e3      	lsrs	r3, r4
    f04e:	f013 0f01 	tst.w	r3, #1
    f052:	d0f7      	beq.n	f044 <filter_remove+0x10>
		    (((filter->addr_type_bitmask >> index) & 0x01) ==
    f054:	786b      	ldrb	r3, [r5, #1]
    f056:	4123      	asrs	r3, r4
    f058:	4073      	eors	r3, r6
		if ((filter->enable_bitmask & BIT(index)) &&
    f05a:	f013 0f01 	tst.w	r3, #1
    f05e:	d1f1      	bne.n	f044 <filter_remove+0x10>
		    !memcmp(filter->bdaddr[index], bdaddr, BDADDR_SIZE)) {
    f060:	eb04 0044 	add.w	r0, r4, r4, lsl #1
    f064:	eb05 0040 	add.w	r0, r5, r0, lsl #1
    f068:	2206      	movs	r2, #6
    f06a:	4639      	mov	r1, r7
    f06c:	3002      	adds	r0, #2
    f06e:	f001 fa8a 	bl	10586 <memcmp>
		     (addr_type & 0x01)) &&
    f072:	2800      	cmp	r0, #0
    f074:	d1e6      	bne.n	f044 <filter_remove+0x10>
			filter->enable_bitmask &= ~BIT(index);
    f076:	2301      	movs	r3, #1
    f078:	fa03 f404 	lsl.w	r4, r3, r4
    f07c:	782b      	ldrb	r3, [r5, #0]
    f07e:	ea23 0304 	bic.w	r3, r3, r4
    f082:	702b      	strb	r3, [r5, #0]
			filter->addr_type_bitmask &= ~BIT(index);
    f084:	786b      	ldrb	r3, [r5, #1]
    f086:	ea23 0404 	bic.w	r4, r3, r4
    f08a:	706c      	strb	r4, [r5, #1]
			return 0;
    f08c:	e000      	b.n	f090 <filter_remove+0x5c>
	return BT_HCI_ERR_INVALID_PARAM;
    f08e:	2012      	movs	r0, #18
}
    f090:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_HCI_ERR_INVALID_PARAM;
    f092:	2012      	movs	r0, #18
    f094:	e7fc      	b.n	f090 <filter_remove+0x5c>

0000f096 <ll_wl_size_get>:
}
    f096:	2008      	movs	r0, #8
    f098:	4770      	bx	lr

0000f09a <init_reset>:
}
    f09a:	2000      	movs	r0, #0
    f09c:	4770      	bx	lr

0000f09e <radio_nrf5_isr>:
ISR_DIRECT_DECLARE(radio_nrf5_isr)
    f09e:	4668      	mov	r0, sp
    f0a0:	f020 0107 	bic.w	r1, r0, #7
    f0a4:	468d      	mov	sp, r1
    f0a6:	b501      	push	{r0, lr}
	isr_radio();
    f0a8:	f7f9 fac0 	bl	862c <isr_radio>
	ISR_DIRECT_PM();
    f0ac:	f7f3 fc1e 	bl	28ec <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING
	sys_trace_isr_exit();
#endif
	if (maybe_swap) {
		z_arm_int_exit();
    f0b0:	f7f4 f8b2 	bl	3218 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(radio_nrf5_isr)
    f0b4:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    f0b8:	4685      	mov	sp, r0
    f0ba:	4770      	bx	lr

0000f0bc <swi_lll_nrf5_isr>:
{
    f0bc:	b508      	push	{r3, lr}
	mayfly_run(TICKER_USER_ID_LLL);
    f0be:	2000      	movs	r0, #0
    f0c0:	f7f6 f858 	bl	5174 <mayfly_run>
}
    f0c4:	bd08      	pop	{r3, pc}

0000f0c6 <lll_reset>:
{
    f0c6:	b508      	push	{r3, lr}
	err = init_reset();
    f0c8:	f7ff ffe7 	bl	f09a <init_reset>
}
    f0cc:	bd08      	pop	{r3, pc}

0000f0ce <lll_prepare>:
{
    f0ce:	b510      	push	{r4, lr}
    f0d0:	b082      	sub	sp, #8
	return prepare(is_abort_cb, abort_cb, prepare_cb, prio, prepare_param,
    f0d2:	2400      	movs	r4, #0
    f0d4:	9401      	str	r4, [sp, #4]
    f0d6:	9c04      	ldr	r4, [sp, #16]
    f0d8:	9400      	str	r4, [sp, #0]
    f0da:	f7f8 fa4d 	bl	7578 <prepare>
}
    f0de:	b002      	add	sp, #8
    f0e0:	bd10      	pop	{r4, pc}

0000f0e2 <lll_prepare_done>:
}
    f0e2:	2000      	movs	r0, #0
    f0e4:	4770      	bx	lr

0000f0e6 <lll_evt_offset_get>:
	} else if (evt->ticks_xtal_to_start & XON_BITMASK) {
    f0e6:	6803      	ldr	r3, [r0, #0]
    f0e8:	2b00      	cmp	r3, #0
    f0ea:	db04      	blt.n	f0f6 <lll_evt_offset_get+0x10>
		return MAX(evt->ticks_active_to_start,
    f0ec:	6840      	ldr	r0, [r0, #4]
    f0ee:	4298      	cmp	r0, r3
    f0f0:	bf38      	it	cc
    f0f2:	4618      	movcc	r0, r3
}
    f0f4:	4770      	bx	lr
		return MAX(evt->ticks_active_to_start,
    f0f6:	6883      	ldr	r3, [r0, #8]
    f0f8:	6840      	ldr	r0, [r0, #4]
    f0fa:	4298      	cmp	r0, r3
    f0fc:	bf38      	it	cc
    f0fe:	4618      	movcc	r0, r3
    f100:	4770      	bx	lr

0000f102 <lll_preempt_calc>:
{
    f102:	b510      	push	{r4, lr}
    f104:	4614      	mov	r4, r2
	u32_t ticks_now = ticker_ticks_now_get();
    f106:	f7ff fb05 	bl	e714 <ticker_ticks_now_get>
	diff = ticker_ticks_diff_get(ticks_now, ticks_at_event);
    f10a:	4621      	mov	r1, r4
    f10c:	f7ff fb06 	bl	e71c <ticker_ticks_diff_get>
	diff += HAL_TICKER_CNTR_CMP_OFFSET_MIN;
    f110:	1cc3      	adds	r3, r0, #3
	if (!(diff & BIT(HAL_TICKER_CNTR_MSBIT)) &&
    f112:	f413 0000 	ands.w	r0, r3, #8388608	; 0x800000
    f116:	d103      	bne.n	f120 <lll_preempt_calc+0x1e>
    f118:	2b09      	cmp	r3, #9
    f11a:	d902      	bls.n	f122 <lll_preempt_calc+0x20>
		return 1;
    f11c:	2001      	movs	r0, #1
    f11e:	e000      	b.n	f122 <lll_preempt_calc+0x20>
	return 0;
    f120:	2000      	movs	r0, #0
}
    f122:	bd10      	pop	{r4, pc}

0000f124 <init_reset>:
}
    f124:	2000      	movs	r0, #0
    f126:	4770      	bx	lr

0000f128 <isr_race>:
{
    f128:	b508      	push	{r3, lr}
	radio_status_reset();
    f12a:	f7f9 fa55 	bl	85d8 <radio_status_reset>
}
    f12e:	bd08      	pop	{r3, pc}

0000f130 <isr_abort>:
{
    f130:	b510      	push	{r4, lr}
    f132:	b082      	sub	sp, #8
    f134:	4604      	mov	r4, r0
	radio_status_reset();
    f136:	f7f9 fa4f 	bl	85d8 <radio_status_reset>
	radio_tmr_status_reset();
    f13a:	f7f9 fb4f 	bl	87dc <radio_tmr_status_reset>
	radio_filter_status_reset();
    f13e:	f7f9 fb23 	bl	8788 <radio_filter_status_reset>
	radio_ar_status_reset();
    f142:	f7f9 fc4b 	bl	89dc <radio_ar_status_reset>
	radio_rssi_status_reset();
    f146:	f7f9 fadb 	bl	8700 <radio_rssi_status_reset>
	ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_LLL,
    f14a:	2000      	movs	r0, #0
    f14c:	9000      	str	r0, [sp, #0]
    f14e:	4603      	mov	r3, r0
    f150:	2201      	movs	r2, #1
    f152:	4601      	mov	r1, r0
    f154:	f7f6 f998 	bl	5488 <ticker_stop>
	radio_disable();
    f158:	f7f9 fa2c 	bl	85b4 <radio_disable>
	isr_cleanup(param);
    f15c:	4620      	mov	r0, r4
    f15e:	f7f8 fe19 	bl	7d94 <isr_cleanup>
}
    f162:	b002      	add	sp, #8
    f164:	bd10      	pop	{r4, pc}

0000f166 <isr_done>:
{
    f166:	b508      	push	{r3, lr}
	isr_common_done(param);
    f168:	f7f8 fe58 	bl	7e1c <isr_common_done>
	radio_rx_enable();
    f16c:	f7f9 fa1c 	bl	85a8 <radio_rx_enable>
	radio_tmr_end_capture();
    f170:	f7f9 fc20 	bl	89b4 <radio_tmr_end_capture>
}
    f174:	bd08      	pop	{r3, pc}

0000f176 <isr_rx_scan_report>:
{
    f176:	b538      	push	{r3, r4, r5, lr}
    f178:	460d      	mov	r5, r1
	node_rx = ull_pdu_rx_alloc_peek(3);
    f17a:	2003      	movs	r0, #3
    f17c:	f7f7 fd44 	bl	6c08 <ull_pdu_rx_alloc_peek>
	if (!node_rx) {
    f180:	b1b8      	cbz	r0, f1b2 <isr_rx_scan_report+0x3c>
    f182:	4604      	mov	r4, r0
	ull_pdu_rx_alloc();
    f184:	f7f7 fd60 	bl	6c48 <ull_pdu_rx_alloc>
	node_rx->hdr.handle = 0xffff;
    f188:	f64f 73ff 	movw	r3, #65535	; 0xffff
    f18c:	80e3      	strh	r3, [r4, #6]
		node_rx->hdr.type = NODE_RX_TYPE_REPORT;
    f18e:	2304      	movs	r3, #4
    f190:	7123      	strb	r3, [r4, #4]
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
    f192:	b94d      	cbnz	r5, f1a8 <isr_rx_scan_report+0x32>
    f194:	207f      	movs	r0, #127	; 0x7f
    f196:	7720      	strb	r0, [r4, #28]
	ull_rx_put(node_rx->hdr.link, node_rx);
    f198:	4621      	mov	r1, r4
    f19a:	6820      	ldr	r0, [r4, #0]
    f19c:	f7f7 fd70 	bl	6c80 <ull_rx_put>
	ull_rx_sched();
    f1a0:	f7f7 fd76 	bl	6c90 <ull_rx_sched>
	return 0;
    f1a4:	2000      	movs	r0, #0
}
    f1a6:	bd38      	pop	{r3, r4, r5, pc}
				   (radio_rssi_get() & 0x7f)
    f1a8:	f7f9 faa4 	bl	86f4 <radio_rssi_get>
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
    f1ac:	f000 007f 	and.w	r0, r0, #127	; 0x7f
    f1b0:	e7f1      	b.n	f196 <isr_rx_scan_report+0x20>
		return 1;
    f1b2:	2001      	movs	r0, #1
    f1b4:	e7f7      	b.n	f1a6 <isr_rx_scan_report+0x30>

0000f1b6 <resume_prepare_cb>:
{
    f1b6:	b570      	push	{r4, r5, r6, lr}
    f1b8:	4604      	mov	r4, r0
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
    f1ba:	68c3      	ldr	r3, [r0, #12]
    f1bc:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
    f1be:	f7ff faa9 	bl	e714 <ticker_ticks_now_get>
    f1c2:	4605      	mov	r5, r0
    f1c4:	4630      	mov	r0, r6
    f1c6:	f7ff ff8e 	bl	f0e6 <lll_evt_offset_get>
    f1ca:	1a2d      	subs	r5, r5, r0
    f1cc:	6025      	str	r5, [r4, #0]
	p->remainder = 0;
    f1ce:	2300      	movs	r3, #0
    f1d0:	6063      	str	r3, [r4, #4]
	p->lazy = 0;
    f1d2:	8123      	strh	r3, [r4, #8]
	return prepare_cb(p);
    f1d4:	4620      	mov	r0, r4
    f1d6:	f7f8 fcf3 	bl	7bc0 <prepare_cb>
}
    f1da:	bd70      	pop	{r4, r5, r6, pc}

0000f1dc <isr_window>:
{
    f1dc:	b508      	push	{r3, lr}
	isr_common_done(param);
    f1de:	f7f8 fe1d 	bl	7e1c <isr_common_done>
	ticks_at_start = ticker_ticks_now_get() +
    f1e2:	f7ff fa97 	bl	e714 <ticker_ticks_now_get>
	remainder_us = radio_tmr_start_tick(0, ticks_at_start);
    f1e6:	1cc1      	adds	r1, r0, #3
    f1e8:	2000      	movs	r0, #0
    f1ea:	f7f9 fb93 	bl	8914 <radio_tmr_start_tick>
	radio_tmr_end_capture();
    f1ee:	f7f9 fbe1 	bl	89b4 <radio_tmr_end_capture>
}
    f1f2:	bd08      	pop	{r3, pc}

0000f1f4 <lll_scan_init>:
{
    f1f4:	b508      	push	{r3, lr}
	err = init_reset();
    f1f6:	f7ff ff95 	bl	f124 <init_reset>
}
    f1fa:	bd08      	pop	{r3, pc}

0000f1fc <lll_scan_reset>:
{
    f1fc:	b508      	push	{r3, lr}
	err = init_reset();
    f1fe:	f7ff ff91 	bl	f124 <init_reset>
}
    f202:	bd08      	pop	{r3, pc}

0000f204 <ecb_encrypt>:
	memcpy(cipher_text_be, &ecb.cipher_text[0], sizeof(ecb.cipher_text));
}

void ecb_encrypt(u8_t const *const key_le, u8_t const *const clear_text_le,
		 u8_t * const cipher_text_le, u8_t * const cipher_text_be)
{
    f204:	b570      	push	{r4, r5, r6, lr}
    f206:	b08c      	sub	sp, #48	; 0x30
    f208:	460e      	mov	r6, r1
    f20a:	4615      	mov	r5, r2
    f20c:	461c      	mov	r4, r3
	struct ecb_param ecb;

	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
    f20e:	2210      	movs	r2, #16
    f210:	4601      	mov	r1, r0
    f212:	4668      	mov	r0, sp
    f214:	f7ff f876 	bl	e304 <mem_rcopy>
	mem_rcopy(&ecb.clear_text[0], clear_text_le, sizeof(ecb.clear_text));
    f218:	2210      	movs	r2, #16
    f21a:	4631      	mov	r1, r6
    f21c:	eb0d 0002 	add.w	r0, sp, r2
    f220:	f7ff f870 	bl	e304 <mem_rcopy>

	do_ecb(&ecb);
    f224:	4668      	mov	r0, sp
    f226:	f7f9 f85f 	bl	82e8 <do_ecb>

	if (cipher_text_le) {
    f22a:	b125      	cbz	r5, f236 <ecb_encrypt+0x32>
		mem_rcopy(cipher_text_le, &ecb.cipher_text[0],
    f22c:	2210      	movs	r2, #16
    f22e:	a908      	add	r1, sp, #32
    f230:	4628      	mov	r0, r5
    f232:	f7ff f867 	bl	e304 <mem_rcopy>
			  sizeof(ecb.cipher_text));
	}

	if (cipher_text_be) {
    f236:	b12c      	cbz	r4, f244 <ecb_encrypt+0x40>
    f238:	ad08      	add	r5, sp, #32
    f23a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    f23c:	6020      	str	r0, [r4, #0]
    f23e:	6061      	str	r1, [r4, #4]
    f240:	60a2      	str	r2, [r4, #8]
    f242:	60e3      	str	r3, [r4, #12]
		memcpy(cipher_text_be, &ecb.cipher_text[0],
			 sizeof(ecb.cipher_text));
	}
}
    f244:	b00c      	add	sp, #48	; 0x30
    f246:	bd70      	pop	{r4, r5, r6, pc}

0000f248 <radio_tx_chain_delay_get>:
}
    f248:	2001      	movs	r0, #1
    f24a:	4770      	bx	lr

0000f24c <radio_rx_chain_delay_get>:
	switch (phy) {
    f24c:	2802      	cmp	r0, #2
    f24e:	d001      	beq.n	f254 <radio_rx_chain_delay_get+0x8>
		return HAL_RADIO_NRF52833_RX_CHAIN_DELAY_1M_US;
    f250:	200a      	movs	r0, #10
    f252:	4770      	bx	lr
		return HAL_RADIO_NRF52833_RX_CHAIN_DELAY_2M_US;
    f254:	2005      	movs	r0, #5
}
    f256:	4770      	bx	lr

0000f258 <radio_tmr_tifs_base_get>:
{
    f258:	b508      	push	{r3, lr}
	return radio_tmr_end_get();
    f25a:	f7f9 fbb3 	bl	89c4 <radio_tmr_end_get>
}
    f25e:	bd08      	pop	{r3, pc}

0000f260 <mayfly_prio_is_equal>:
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
    f260:	4288      	cmp	r0, r1
    f262:	d01f      	beq.n	f2a4 <mayfly_prio_is_equal+0x44>
	return (caller_id == callee_id) ||
    f264:	b908      	cbnz	r0, f26a <mayfly_prio_is_equal+0xa>
	       ((caller_id == MAYFLY_CALL_ID_LLL) &&
    f266:	2901      	cmp	r1, #1
    f268:	d01e      	beq.n	f2a8 <mayfly_prio_is_equal+0x48>
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
    f26a:	2801      	cmp	r0, #1
    f26c:	d00a      	beq.n	f284 <mayfly_prio_is_equal+0x24>
		(callee_id == MAYFLY_CALL_ID_LLL)) ||
    f26e:	b908      	cbnz	r0, f274 <mayfly_prio_is_equal+0x14>
	       ((caller_id == MAYFLY_CALL_ID_LLL) &&
    f270:	2902      	cmp	r1, #2
    f272:	d01b      	beq.n	f2ac <mayfly_prio_is_equal+0x4c>
		(callee_id == MAYFLY_CALL_ID_JOB)) ||
    f274:	2802      	cmp	r0, #2
    f276:	d009      	beq.n	f28c <mayfly_prio_is_equal+0x2c>
		(callee_id == MAYFLY_CALL_ID_LLL)) ||
    f278:	2801      	cmp	r0, #1
    f27a:	d00b      	beq.n	f294 <mayfly_prio_is_equal+0x34>
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
    f27c:	2802      	cmp	r0, #2
    f27e:	d00d      	beq.n	f29c <mayfly_prio_is_equal+0x3c>
    f280:	2000      	movs	r0, #0
    f282:	4770      	bx	lr
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
    f284:	2900      	cmp	r1, #0
    f286:	d1f2      	bne.n	f26e <mayfly_prio_is_equal+0xe>
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
    f288:	2001      	movs	r0, #1
    f28a:	4770      	bx	lr
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
    f28c:	2900      	cmp	r1, #0
    f28e:	d1f3      	bne.n	f278 <mayfly_prio_is_equal+0x18>
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
    f290:	2001      	movs	r0, #1
    f292:	4770      	bx	lr
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
    f294:	2902      	cmp	r1, #2
    f296:	d1f1      	bne.n	f27c <mayfly_prio_is_equal+0x1c>
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
    f298:	2001      	movs	r0, #1
    f29a:	4770      	bx	lr
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
    f29c:	2901      	cmp	r1, #1
    f29e:	d007      	beq.n	f2b0 <mayfly_prio_is_equal+0x50>
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
    f2a0:	2000      	movs	r0, #0
    f2a2:	4770      	bx	lr
    f2a4:	2001      	movs	r0, #1
    f2a6:	4770      	bx	lr
    f2a8:	2001      	movs	r0, #1
    f2aa:	4770      	bx	lr
    f2ac:	2001      	movs	r0, #1
    f2ae:	4770      	bx	lr
    f2b0:	2001      	movs	r0, #1
}
    f2b2:	4770      	bx	lr

0000f2b4 <hal_ticker_instance0_trigger_set>:

void hal_ticker_instance0_trigger_set(u32_t value)
{
    f2b4:	b508      	push	{r3, lr}
    f2b6:	4601      	mov	r1, r0
	cntr_cmp_set(0, value);
    f2b8:	2000      	movs	r0, #0
    f2ba:	f7f9 f80d 	bl	82d8 <cntr_cmp_set>
}
    f2be:	bd08      	pop	{r3, pc}

0000f2c0 <hci_vendor_read_static_addr>:
				 u8_t size)
{
	/* only one supported */
	ARG_UNUSED(size);

	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
    f2c0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    f2c4:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    f2c8:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    f2cc:	d008      	beq.n	f2e0 <hci_vendor_read_static_addr+0x20>
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
	     (NRF_FICR->DEVICEADDRTYPE & 0x01)) {
    f2ce:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    f2d2:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
    f2d6:	f013 0f01 	tst.w	r3, #1
    f2da:	d10c      	bne.n	f2f6 <hci_vendor_read_static_addr+0x36>
		}

		return 1;
	}

	return 0;
    f2dc:	2000      	movs	r0, #0
}
    f2de:	4770      	bx	lr
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
    f2e0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    f2e4:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
    f2e8:	b29b      	uxth	r3, r3
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
    f2ea:	f64f 72ff 	movw	r2, #65535	; 0xffff
    f2ee:	4293      	cmp	r3, r2
    f2f0:	d1ed      	bne.n	f2ce <hci_vendor_read_static_addr+0xe>
	return 0;
    f2f2:	2000      	movs	r0, #0
    f2f4:	4770      	bx	lr
		sys_put_le32(NRF_FICR->DEVICEADDR[0], &addrs[0].bdaddr.val[0]);
    f2f6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    f2fa:	f8d2 30a4 	ldr.w	r3, [r2, #164]	; 0xa4
	dst[0] = val;
    f2fe:	7003      	strb	r3, [r0, #0]
	dst[1] = val >> 8;
    f300:	f3c3 2107 	ubfx	r1, r3, #8, #8
    f304:	7041      	strb	r1, [r0, #1]
	sys_put_le16(val >> 16, &dst[2]);
    f306:	0c19      	lsrs	r1, r3, #16
	dst[0] = val;
    f308:	7081      	strb	r1, [r0, #2]
	dst[1] = val >> 8;
    f30a:	0e1b      	lsrs	r3, r3, #24
    f30c:	70c3      	strb	r3, [r0, #3]
		sys_put_le16(NRF_FICR->DEVICEADDR[1], &addrs[0].bdaddr.val[4]);
    f30e:	f8d2 30a8 	ldr.w	r3, [r2, #168]	; 0xa8
	dst[0] = val;
    f312:	7103      	strb	r3, [r0, #4]
	dst[1] = val >> 8;
    f314:	f3c3 2307 	ubfx	r3, r3, #8, #8
		BT_ADDR_SET_STATIC(&addrs[0].bdaddr);
    f318:	f063 033f 	orn	r3, r3, #63	; 0x3f
    f31c:	7143      	strb	r3, [r0, #5]
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
    f31e:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
    f322:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    f326:	d037      	beq.n	f398 <hci_vendor_read_static_addr+0xd8>
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
    f328:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
    f32c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    f330:	d032      	beq.n	f398 <hci_vendor_read_static_addr+0xd8>
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
    f332:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
    f336:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    f33a:	d02d      	beq.n	f398 <hci_vendor_read_static_addr+0xd8>
		    (NRF_FICR->IR[3] != UINT32_MAX)) {
    f33c:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
    f340:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    f344:	d028      	beq.n	f398 <hci_vendor_read_static_addr+0xd8>
			sys_put_le32(NRF_FICR->IR[0], &addrs[0].ir[0]);
    f346:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
	dst[0] = val;
    f34a:	7183      	strb	r3, [r0, #6]
	dst[1] = val >> 8;
    f34c:	f3c3 2107 	ubfx	r1, r3, #8, #8
    f350:	71c1      	strb	r1, [r0, #7]
	sys_put_le16(val >> 16, &dst[2]);
    f352:	0c19      	lsrs	r1, r3, #16
	dst[0] = val;
    f354:	7201      	strb	r1, [r0, #8]
	dst[1] = val >> 8;
    f356:	0e1b      	lsrs	r3, r3, #24
    f358:	7243      	strb	r3, [r0, #9]
			sys_put_le32(NRF_FICR->IR[1], &addrs[0].ir[4]);
    f35a:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
	dst[0] = val;
    f35e:	7283      	strb	r3, [r0, #10]
	dst[1] = val >> 8;
    f360:	f3c3 2107 	ubfx	r1, r3, #8, #8
    f364:	72c1      	strb	r1, [r0, #11]
	sys_put_le16(val >> 16, &dst[2]);
    f366:	0c19      	lsrs	r1, r3, #16
	dst[0] = val;
    f368:	7301      	strb	r1, [r0, #12]
	dst[1] = val >> 8;
    f36a:	0e1b      	lsrs	r3, r3, #24
    f36c:	7343      	strb	r3, [r0, #13]
			sys_put_le32(NRF_FICR->IR[2], &addrs[0].ir[8]);
    f36e:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
	dst[0] = val;
    f372:	7383      	strb	r3, [r0, #14]
	dst[1] = val >> 8;
    f374:	f3c3 2107 	ubfx	r1, r3, #8, #8
    f378:	73c1      	strb	r1, [r0, #15]
	sys_put_le16(val >> 16, &dst[2]);
    f37a:	0c19      	lsrs	r1, r3, #16
	dst[0] = val;
    f37c:	7401      	strb	r1, [r0, #16]
	dst[1] = val >> 8;
    f37e:	0e1b      	lsrs	r3, r3, #24
    f380:	7443      	strb	r3, [r0, #17]
			sys_put_le32(NRF_FICR->IR[3], &addrs[0].ir[12]);
    f382:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
	dst[0] = val;
    f386:	7483      	strb	r3, [r0, #18]
	dst[1] = val >> 8;
    f388:	f3c3 2207 	ubfx	r2, r3, #8, #8
    f38c:	74c2      	strb	r2, [r0, #19]
	sys_put_le16(val >> 16, &dst[2]);
    f38e:	0c1a      	lsrs	r2, r3, #16
	dst[0] = val;
    f390:	7502      	strb	r2, [r0, #20]
	dst[1] = val >> 8;
    f392:	0e1b      	lsrs	r3, r3, #24
    f394:	7543      	strb	r3, [r0, #21]
}
    f396:	e008      	b.n	f3aa <hci_vendor_read_static_addr+0xea>
__ssp_bos_icheck3(memset, void *, int)
    f398:	2300      	movs	r3, #0
    f39a:	f8c0 3006 	str.w	r3, [r0, #6]
    f39e:	f8c0 300a 	str.w	r3, [r0, #10]
    f3a2:	f8c0 300e 	str.w	r3, [r0, #14]
    f3a6:	f8c0 3012 	str.w	r3, [r0, #18]
		return 1;
    f3aa:	2001      	movs	r0, #1
    f3ac:	4770      	bx	lr

0000f3ae <hci_vendor_read_key_hierarchy_roots>:
    f3ae:	2300      	movs	r3, #0
    f3b0:	6003      	str	r3, [r0, #0]
    f3b2:	6043      	str	r3, [r0, #4]
    f3b4:	6083      	str	r3, [r0, #8]
    f3b6:	60c3      	str	r3, [r0, #12]
	 * using Read Static Addresses command.
	 */
	(void)memset(ir, 0x00, 16);

	/* Fill in ER if present */
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
    f3b8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    f3bc:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    f3c0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    f3c4:	d03f      	beq.n	f446 <hci_vendor_read_key_hierarchy_roots+0x98>
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
    f3c6:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    f3ca:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
    f3ce:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    f3d2:	d038      	beq.n	f446 <hci_vendor_read_key_hierarchy_roots+0x98>
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
    f3d4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    f3d8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
    f3dc:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    f3e0:	d031      	beq.n	f446 <hci_vendor_read_key_hierarchy_roots+0x98>
	    (NRF_FICR->ER[3] != UINT32_MAX)) {
    f3e2:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    f3e6:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
    f3ea:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    f3ee:	d02a      	beq.n	f446 <hci_vendor_read_key_hierarchy_roots+0x98>
		sys_put_le32(NRF_FICR->ER[0], &er[0]);
    f3f0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    f3f4:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
	dst[0] = val;
    f3f8:	700b      	strb	r3, [r1, #0]
	dst[1] = val >> 8;
    f3fa:	f3c3 2007 	ubfx	r0, r3, #8, #8
    f3fe:	7048      	strb	r0, [r1, #1]
	sys_put_le16(val >> 16, &dst[2]);
    f400:	0c18      	lsrs	r0, r3, #16
	dst[0] = val;
    f402:	7088      	strb	r0, [r1, #2]
	dst[1] = val >> 8;
    f404:	0e1b      	lsrs	r3, r3, #24
    f406:	70cb      	strb	r3, [r1, #3]
		sys_put_le32(NRF_FICR->ER[1], &er[4]);
    f408:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
	dst[0] = val;
    f40c:	710b      	strb	r3, [r1, #4]
	dst[1] = val >> 8;
    f40e:	f3c3 2007 	ubfx	r0, r3, #8, #8
    f412:	7148      	strb	r0, [r1, #5]
	sys_put_le16(val >> 16, &dst[2]);
    f414:	0c18      	lsrs	r0, r3, #16
	dst[0] = val;
    f416:	7188      	strb	r0, [r1, #6]
	dst[1] = val >> 8;
    f418:	0e1b      	lsrs	r3, r3, #24
    f41a:	71cb      	strb	r3, [r1, #7]
		sys_put_le32(NRF_FICR->ER[2], &er[8]);
    f41c:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
	dst[0] = val;
    f420:	720b      	strb	r3, [r1, #8]
	dst[1] = val >> 8;
    f422:	f3c3 2007 	ubfx	r0, r3, #8, #8
    f426:	7248      	strb	r0, [r1, #9]
	sys_put_le16(val >> 16, &dst[2]);
    f428:	0c18      	lsrs	r0, r3, #16
	dst[0] = val;
    f42a:	7288      	strb	r0, [r1, #10]
	dst[1] = val >> 8;
    f42c:	0e1b      	lsrs	r3, r3, #24
    f42e:	72cb      	strb	r3, [r1, #11]
		sys_put_le32(NRF_FICR->ER[3], &er[12]);
    f430:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
	dst[0] = val;
    f434:	730b      	strb	r3, [r1, #12]
	dst[1] = val >> 8;
    f436:	f3c3 2207 	ubfx	r2, r3, #8, #8
    f43a:	734a      	strb	r2, [r1, #13]
	sys_put_le16(val >> 16, &dst[2]);
    f43c:	0c1a      	lsrs	r2, r3, #16
	dst[0] = val;
    f43e:	738a      	strb	r2, [r1, #14]
	dst[1] = val >> 8;
    f440:	0e1b      	lsrs	r3, r3, #24
    f442:	73cb      	strb	r3, [r1, #15]
}
    f444:	4770      	bx	lr
    f446:	2300      	movs	r3, #0
    f448:	600b      	str	r3, [r1, #0]
    f44a:	604b      	str	r3, [r1, #4]
    f44c:	608b      	str	r3, [r1, #8]
    f44e:	60cb      	str	r3, [r1, #12]
	} else {
		/* Mark ER as invalid */
		(void)memset(er, 0x00, 16);
	}
}
    f450:	4770      	bx	lr

0000f452 <fixed_data_unref>:
}

static void fixed_data_unref(struct net_buf *buf, u8_t *data)
{
	/* Nothing needed for fixed-size data pools */
}
    f452:	4770      	bx	lr

0000f454 <data_alloc>:
};

#endif /* CONFIG_HEAP_MEM_POOL_SIZE > 0 */

static u8_t *data_alloc(struct net_buf *buf, size_t *size, k_timeout_t timeout)
{
    f454:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f458:	4604      	mov	r4, r0
    f45a:	460d      	mov	r5, r1
    f45c:	4617      	mov	r7, r2
    f45e:	461e      	mov	r6, r3
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    f460:	7980      	ldrb	r0, [r0, #6]
    f462:	f7f9 fd53 	bl	8f0c <net_buf_pool_get>

	return pool->alloc->cb->alloc(buf, size, timeout);
    f466:	6a03      	ldr	r3, [r0, #32]
    f468:	681b      	ldr	r3, [r3, #0]
    f46a:	f8d3 8000 	ldr.w	r8, [r3]
    f46e:	463a      	mov	r2, r7
    f470:	4633      	mov	r3, r6
    f472:	4629      	mov	r1, r5
    f474:	4620      	mov	r0, r4
    f476:	47c0      	blx	r8
}
    f478:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000f47c <data_unref>:

	return pool->alloc->cb->ref(buf, data);
}

static void data_unref(struct net_buf *buf, u8_t *data)
{
    f47c:	b538      	push	{r3, r4, r5, lr}
    f47e:	4604      	mov	r4, r0
    f480:	460d      	mov	r5, r1
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    f482:	7980      	ldrb	r0, [r0, #6]
    f484:	f7f9 fd42 	bl	8f0c <net_buf_pool_get>

	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
    f488:	7963      	ldrb	r3, [r4, #5]
    f48a:	f013 0f02 	tst.w	r3, #2
    f48e:	d105      	bne.n	f49c <data_unref+0x20>
		return;
	}

	pool->alloc->cb->unref(buf, data);
    f490:	6a03      	ldr	r3, [r0, #32]
    f492:	681b      	ldr	r3, [r3, #0]
    f494:	689b      	ldr	r3, [r3, #8]
    f496:	4629      	mov	r1, r5
    f498:	4620      	mov	r0, r4
    f49a:	4798      	blx	r3
}
    f49c:	bd38      	pop	{r3, r4, r5, pc}

0000f49e <fixed_data_alloc>:
{
    f49e:	b570      	push	{r4, r5, r6, lr}
    f4a0:	4604      	mov	r4, r0
    f4a2:	460d      	mov	r5, r1
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    f4a4:	7980      	ldrb	r0, [r0, #6]
    f4a6:	f7f9 fd31 	bl	8f0c <net_buf_pool_get>
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    f4aa:	6a03      	ldr	r3, [r0, #32]
    f4ac:	685b      	ldr	r3, [r3, #4]
	*size = MIN(fixed->data_size, *size);
    f4ae:	682a      	ldr	r2, [r5, #0]
    f4b0:	6819      	ldr	r1, [r3, #0]
    f4b2:	428a      	cmp	r2, r1
    f4b4:	bf28      	it	cs
    f4b6:	460a      	movcs	r2, r1
    f4b8:	602a      	str	r2, [r5, #0]
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
    f4ba:	685d      	ldr	r5, [r3, #4]
    f4bc:	681e      	ldr	r6, [r3, #0]
    f4be:	4620      	mov	r0, r4
    f4c0:	f7f9 fd2c 	bl	8f1c <net_buf_id>
}
    f4c4:	fb00 5006 	mla	r0, r0, r6, r5
    f4c8:	bd70      	pop	{r4, r5, r6, pc}

0000f4ca <net_buf_reset>:
	buf->len  = 0U;
    f4ca:	2300      	movs	r3, #0
    f4cc:	8183      	strh	r3, [r0, #12]
	buf->data = buf->__buf;
    f4ce:	6903      	ldr	r3, [r0, #16]
    f4d0:	6083      	str	r3, [r0, #8]
}
    f4d2:	4770      	bx	lr

0000f4d4 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
    f4d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f4d8:	b083      	sub	sp, #12
    f4da:	4605      	mov	r5, r0
    f4dc:	9101      	str	r1, [sp, #4]
    f4de:	4616      	mov	r6, r2
    f4e0:	461f      	mov	r7, r3
	u64_t end = z_timeout_end_calc(timeout);
    f4e2:	4610      	mov	r0, r2
    f4e4:	4619      	mov	r1, r3
    f4e6:	f000 ff97 	bl	10418 <z_timeout_end_calc>
    f4ea:	4682      	mov	sl, r0
    f4ec:	9100      	str	r1, [sp, #0]
	__asm__ volatile(
    f4ee:	f04f 0320 	mov.w	r3, #32
    f4f2:	f3ef 8b11 	mrs	fp, BASEPRI
    f4f6:	f383 8811 	msr	BASEPRI, r3
    f4fa:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
    f4fe:	8b6b      	ldrh	r3, [r5, #26]
    f500:	2b00      	cmp	r3, #0
    f502:	d03f      	beq.n	f584 <net_buf_alloc_len+0xb0>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
    f504:	8b2a      	ldrh	r2, [r5, #24]
    f506:	4293      	cmp	r3, r2
    f508:	d32f      	bcc.n	f56a <net_buf_alloc_len+0x96>
				irq_unlock(key);
				goto success;
			}
		}

		uninit_count = pool->uninit_count--;
    f50a:	8b6a      	ldrh	r2, [r5, #26]
    f50c:	1e53      	subs	r3, r2, #1
    f50e:	836b      	strh	r3, [r5, #26]
	__asm__ volatile(
    f510:	f38b 8811 	msr	BASEPRI, fp
    f514:	f3bf 8f6f 	isb	sy
	buf = &pool->__bufs[pool->buf_count - uninit_count];
    f518:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    f51a:	8b2b      	ldrh	r3, [r5, #24]
    f51c:	1a9b      	subs	r3, r3, r2
    f51e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    f522:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
	buf->pool_id = pool_id(pool);
    f526:	4628      	mov	r0, r5
    f528:	f7f9 fce4 	bl	8ef4 <pool_id>
    f52c:	71a0      	strb	r0, [r4, #6]
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
    f52e:	9b01      	ldr	r3, [sp, #4]
    f530:	2b00      	cmp	r3, #0
    f532:	d046      	beq.n	f5c2 <net_buf_alloc_len+0xee>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
    f534:	ea56 0307 	orrs.w	r3, r6, r7
    f538:	d005      	beq.n	f546 <net_buf_alloc_len+0x72>
    f53a:	f1b7 3fff 	cmp.w	r7, #4294967295	; 0xffffffff
    f53e:	bf08      	it	eq
    f540:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
    f544:	d12b      	bne.n	f59e <net_buf_alloc_len+0xca>
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
    f546:	4632      	mov	r2, r6
    f548:	463b      	mov	r3, r7
    f54a:	a901      	add	r1, sp, #4
    f54c:	4620      	mov	r0, r4
    f54e:	f7ff ff81 	bl	f454 <data_alloc>
    f552:	4605      	mov	r5, r0
    f554:	6120      	str	r0, [r4, #16]
		if (!buf->__buf) {
    f556:	2800      	cmp	r0, #0
    f558:	d135      	bne.n	f5c6 <net_buf_alloc_len+0xf2>
 *
 * @param buf Buffer to destroy.
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    f55a:	79a0      	ldrb	r0, [r4, #6]
    f55c:	f7f9 fcd6 	bl	8f0c <net_buf_pool_get>

	k_lifo_put(&pool->free, buf);
    f560:	4621      	mov	r1, r4
    f562:	f000 fcd2 	bl	ff0a <k_queue_prepend>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
    f566:	462c      	mov	r4, r5
}
    f568:	e037      	b.n	f5da <net_buf_alloc_len+0x106>
	return z_impl_k_queue_get(queue, timeout);
    f56a:	2200      	movs	r2, #0
    f56c:	2300      	movs	r3, #0
    f56e:	4628      	mov	r0, r5
    f570:	f7fb fab8 	bl	aae4 <z_impl_k_queue_get>
			if (buf) {
    f574:	4604      	mov	r4, r0
    f576:	2800      	cmp	r0, #0
    f578:	d0c7      	beq.n	f50a <net_buf_alloc_len+0x36>
    f57a:	f38b 8811 	msr	BASEPRI, fp
    f57e:	f3bf 8f6f 	isb	sy
				goto success;
    f582:	e7d4      	b.n	f52e <net_buf_alloc_len+0x5a>
    f584:	f38b 8811 	msr	BASEPRI, fp
    f588:	f3bf 8f6f 	isb	sy
    f58c:	4632      	mov	r2, r6
    f58e:	463b      	mov	r3, r7
    f590:	4628      	mov	r0, r5
    f592:	f7fb faa7 	bl	aae4 <z_impl_k_queue_get>
	if (!buf) {
    f596:	4604      	mov	r4, r0
    f598:	2800      	cmp	r0, #0
    f59a:	d1c8      	bne.n	f52e <net_buf_alloc_len+0x5a>
    f59c:	e01d      	b.n	f5da <net_buf_alloc_len+0x106>
			s64_t remaining = end - z_tick_get();
    f59e:	f7fc f8d3 	bl	b748 <z_tick_get>
    f5a2:	ebba 0800 	subs.w	r8, sl, r0
    f5a6:	9b00      	ldr	r3, [sp, #0]
    f5a8:	eb63 0901 	sbc.w	r9, r3, r1
			if (remaining <= 0) {
    f5ac:	f1b8 0f01 	cmp.w	r8, #1
    f5b0:	f179 0300 	sbcs.w	r3, r9, #0
    f5b4:	db02      	blt.n	f5bc <net_buf_alloc_len+0xe8>
				timeout = Z_TIMEOUT_TICKS(remaining);
    f5b6:	4646      	mov	r6, r8
    f5b8:	464f      	mov	r7, r9
    f5ba:	e7c4      	b.n	f546 <net_buf_alloc_len+0x72>
				timeout = K_NO_WAIT;
    f5bc:	2600      	movs	r6, #0
    f5be:	2700      	movs	r7, #0
    f5c0:	e7c1      	b.n	f546 <net_buf_alloc_len+0x72>
		}

		NET_BUF_ASSERT(req_size <= size);
	} else {
		buf->__buf = NULL;
    f5c2:	2300      	movs	r3, #0
    f5c4:	6123      	str	r3, [r4, #16]
	}

	buf->ref   = 1U;
    f5c6:	2301      	movs	r3, #1
    f5c8:	7123      	strb	r3, [r4, #4]
	buf->flags = 0U;
    f5ca:	2300      	movs	r3, #0
    f5cc:	7163      	strb	r3, [r4, #5]
	buf->frags = NULL;
    f5ce:	6023      	str	r3, [r4, #0]
	buf->size  = size;
    f5d0:	9b01      	ldr	r3, [sp, #4]
    f5d2:	81e3      	strh	r3, [r4, #14]
	net_buf_reset(buf);
    f5d4:	4620      	mov	r0, r4
    f5d6:	f7ff ff78 	bl	f4ca <net_buf_reset>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	pool->avail_count--;
	__ASSERT_NO_MSG(pool->avail_count >= 0);
#endif
	return buf;
}
    f5da:	4620      	mov	r0, r4
    f5dc:	b003      	add	sp, #12
    f5de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000f5e2 <net_buf_alloc_fixed>:
				       line);
}
#else
struct net_buf *net_buf_alloc_fixed(struct net_buf_pool *pool,
				    k_timeout_t timeout)
{
    f5e2:	b508      	push	{r3, lr}
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    f5e4:	6a01      	ldr	r1, [r0, #32]
    f5e6:	6849      	ldr	r1, [r1, #4]

	return net_buf_alloc_len(pool, fixed->data_size, timeout);
    f5e8:	6809      	ldr	r1, [r1, #0]
    f5ea:	f7ff ff73 	bl	f4d4 <net_buf_alloc_len>
}
    f5ee:	bd08      	pop	{r3, pc}

0000f5f0 <net_buf_get>:
struct net_buf *net_buf_get_debug(struct k_fifo *fifo, k_timeout_t timeout,
				  const char *func, int line)
#else
struct net_buf *net_buf_get(struct k_fifo *fifo, k_timeout_t timeout)
#endif
{
    f5f0:	b570      	push	{r4, r5, r6, lr}
	struct net_buf *buf, *frag;

	NET_BUF_DBG("%s():%d: fifo %p", func, line, fifo);

	buf = k_fifo_get(fifo, timeout);
    f5f2:	4605      	mov	r5, r0
    f5f4:	f7fb fa76 	bl	aae4 <z_impl_k_queue_get>
	if (!buf) {
    f5f8:	4606      	mov	r6, r0
    f5fa:	b190      	cbz	r0, f622 <net_buf_get+0x32>
	}

	NET_BUF_DBG("%s():%d: buf %p fifo %p", func, line, buf, fifo);

	/* Get any fragments belonging to this buffer */
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
    f5fc:	4604      	mov	r4, r0
    f5fe:	e00a      	b.n	f616 <net_buf_get+0x26>
    f600:	2200      	movs	r2, #0
    f602:	2300      	movs	r3, #0
    f604:	4628      	mov	r0, r5
    f606:	f7fb fa6d 	bl	aae4 <z_impl_k_queue_get>
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
    f60a:	6020      	str	r0, [r4, #0]
		__ASSERT_NO_MSG(frag->frags);

		/* The fragments flag is only for FIFO-internal usage */
		frag->flags &= ~NET_BUF_FRAGS;
    f60c:	7963      	ldrb	r3, [r4, #5]
    f60e:	f023 0301 	bic.w	r3, r3, #1
    f612:	7163      	strb	r3, [r4, #5]
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
    f614:	4604      	mov	r4, r0
    f616:	7963      	ldrb	r3, [r4, #5]
    f618:	f013 0f01 	tst.w	r3, #1
    f61c:	d1f0      	bne.n	f600 <net_buf_get+0x10>
	}

	/* Mark the end of the fragment list */
	frag->frags = NULL;
    f61e:	2300      	movs	r3, #0
    f620:	6023      	str	r3, [r4, #0]

	return buf;
}
    f622:	4630      	mov	r0, r6
    f624:	bd70      	pop	{r4, r5, r6, pc}

0000f626 <net_buf_simple_reserve>:
{
	__ASSERT_NO_MSG(buf);
	__ASSERT_NO_MSG(buf->len == 0U);
	NET_BUF_DBG("buf %p reserve %zu", buf, reserve);

	buf->data = buf->__buf + reserve;
    f626:	6883      	ldr	r3, [r0, #8]
    f628:	440b      	add	r3, r1
    f62a:	6003      	str	r3, [r0, #0]
}
    f62c:	4770      	bx	lr

0000f62e <net_buf_put>:

	return buf;
}

void net_buf_put(struct k_fifo *fifo, struct net_buf *buf)
{
    f62e:	b510      	push	{r4, lr}
	struct net_buf *tail;

	__ASSERT_NO_MSG(fifo);
	__ASSERT_NO_MSG(buf);

	for (tail = buf; tail->frags; tail = tail->frags) {
    f630:	460a      	mov	r2, r1
    f632:	6814      	ldr	r4, [r2, #0]
    f634:	b12c      	cbz	r4, f642 <net_buf_put+0x14>
		tail->flags |= NET_BUF_FRAGS;
    f636:	7953      	ldrb	r3, [r2, #5]
    f638:	f043 0301 	orr.w	r3, r3, #1
    f63c:	7153      	strb	r3, [r2, #5]
	for (tail = buf; tail->frags; tail = tail->frags) {
    f63e:	4622      	mov	r2, r4
    f640:	e7f7      	b.n	f632 <net_buf_put+0x4>
	}

	k_fifo_put_list(fifo, buf, tail);
    f642:	f000 fc69 	bl	ff18 <k_queue_append_list>
}
    f646:	bd10      	pop	{r4, pc}

0000f648 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
    f648:	b538      	push	{r3, r4, r5, lr}
    f64a:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(buf);

	while (buf) {
    f64c:	e00f      	b.n	f66e <net_buf_unref+0x26>
		if (--buf->ref > 0) {
			return;
		}

		if (buf->__buf) {
			data_unref(buf, buf->__buf);
    f64e:	4620      	mov	r0, r4
    f650:	f7ff ff14 	bl	f47c <data_unref>
			buf->__buf = NULL;
    f654:	2300      	movs	r3, #0
    f656:	6123      	str	r3, [r4, #16]
		}

		buf->data = NULL;
    f658:	2300      	movs	r3, #0
    f65a:	60a3      	str	r3, [r4, #8]
		buf->frags = NULL;
    f65c:	6023      	str	r3, [r4, #0]

		pool = net_buf_pool_get(buf->pool_id);
    f65e:	79a0      	ldrb	r0, [r4, #6]
    f660:	f7f9 fc54 	bl	8f0c <net_buf_pool_get>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
		pool->avail_count++;
		__ASSERT_NO_MSG(pool->avail_count <= pool->buf_count);
#endif

		if (pool->destroy) {
    f664:	69c3      	ldr	r3, [r0, #28]
    f666:	b16b      	cbz	r3, f684 <net_buf_unref+0x3c>
			pool->destroy(buf);
    f668:	4620      	mov	r0, r4
    f66a:	4798      	blx	r3
{
    f66c:	462c      	mov	r4, r5
	while (buf) {
    f66e:	b184      	cbz	r4, f692 <net_buf_unref+0x4a>
		struct net_buf *frags = buf->frags;
    f670:	6825      	ldr	r5, [r4, #0]
		if (--buf->ref > 0) {
    f672:	7923      	ldrb	r3, [r4, #4]
    f674:	3b01      	subs	r3, #1
    f676:	b2db      	uxtb	r3, r3
    f678:	7123      	strb	r3, [r4, #4]
    f67a:	b953      	cbnz	r3, f692 <net_buf_unref+0x4a>
		if (buf->__buf) {
    f67c:	6921      	ldr	r1, [r4, #16]
    f67e:	2900      	cmp	r1, #0
    f680:	d1e5      	bne.n	f64e <net_buf_unref+0x6>
    f682:	e7e9      	b.n	f658 <net_buf_unref+0x10>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    f684:	79a0      	ldrb	r0, [r4, #6]
    f686:	f7f9 fc41 	bl	8f0c <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
    f68a:	4621      	mov	r1, r4
    f68c:	f000 fc3d 	bl	ff0a <k_queue_prepend>
}
    f690:	e7ec      	b.n	f66c <net_buf_unref+0x24>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
    f692:	bd38      	pop	{r3, r4, r5, pc}

0000f694 <net_buf_ref>:
{
	__ASSERT_NO_MSG(buf);

	NET_BUF_DBG("buf %p (old) ref %u pool_id %u",
		    buf, buf->ref, buf->pool_id);
	buf->ref++;
    f694:	7902      	ldrb	r2, [r0, #4]
    f696:	3201      	adds	r2, #1
    f698:	7102      	strb	r2, [r0, #4]
	return buf;
}
    f69a:	4770      	bx	lr

0000f69c <net_buf_simple_add>:
	return buf->data + buf->len;
    f69c:	6802      	ldr	r2, [r0, #0]
    f69e:	8883      	ldrh	r3, [r0, #4]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
    f6a0:	4419      	add	r1, r3
    f6a2:	8081      	strh	r1, [r0, #4]
	return tail;
}
    f6a4:	18d0      	adds	r0, r2, r3
    f6a6:	4770      	bx	lr

0000f6a8 <net_buf_simple_add_mem>:

void *net_buf_simple_add_mem(struct net_buf_simple *buf, const void *mem,
			     size_t len)
{
    f6a8:	b538      	push	{r3, r4, r5, lr}
    f6aa:	460d      	mov	r5, r1
    f6ac:	4614      	mov	r4, r2
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	return memcpy(net_buf_simple_add(buf, len), mem, len);
    f6ae:	4611      	mov	r1, r2
    f6b0:	f7ff fff4 	bl	f69c <net_buf_simple_add>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    f6b4:	4622      	mov	r2, r4
    f6b6:	4629      	mov	r1, r5
    f6b8:	f000 ff73 	bl	105a2 <memcpy>
}
    f6bc:	bd38      	pop	{r3, r4, r5, pc}

0000f6be <net_buf_simple_pull>:

	sys_put_be64(val, net_buf_simple_push(buf, sizeof(val)));
}

void *net_buf_simple_pull(struct net_buf_simple *buf, size_t len)
{
    f6be:	4603      	mov	r3, r0
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
    f6c0:	8882      	ldrh	r2, [r0, #4]
    f6c2:	1a52      	subs	r2, r2, r1
    f6c4:	8082      	strh	r2, [r0, #4]
	return buf->data += len;
    f6c6:	6800      	ldr	r0, [r0, #0]
    f6c8:	4408      	add	r0, r1
    f6ca:	6018      	str	r0, [r3, #0]
}
    f6cc:	4770      	bx	lr

0000f6ce <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
    f6ce:	4603      	mov	r3, r0
	void *data = buf->data;
    f6d0:	6800      	ldr	r0, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
    f6d2:	889a      	ldrh	r2, [r3, #4]
    f6d4:	1a52      	subs	r2, r2, r1
    f6d6:	809a      	strh	r2, [r3, #4]
	buf->data += len;
    f6d8:	4401      	add	r1, r0
    f6da:	6019      	str	r1, [r3, #0]

	return data;
}
    f6dc:	4770      	bx	lr

0000f6de <net_buf_simple_pull_u8>:

u8_t net_buf_simple_pull_u8(struct net_buf_simple *buf)
{
    f6de:	b510      	push	{r4, lr}
	u8_t val;

	val = buf->data[0];
    f6e0:	6803      	ldr	r3, [r0, #0]
    f6e2:	781c      	ldrb	r4, [r3, #0]
	net_buf_simple_pull(buf, 1);
    f6e4:	2101      	movs	r1, #1
    f6e6:	f7ff ffea 	bl	f6be <net_buf_simple_pull>

	return val;
}
    f6ea:	4620      	mov	r0, r4
    f6ec:	bd10      	pop	{r4, pc}

0000f6ee <net_buf_simple_headroom>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
    f6ee:	6802      	ldr	r2, [r0, #0]
    f6f0:	6880      	ldr	r0, [r0, #8]
}
    f6f2:	1a10      	subs	r0, r2, r0
    f6f4:	4770      	bx	lr

0000f6f6 <gpio_nrfx_port_get_raw>:
	return port->config_info;
    f6f6:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    f6f8:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
    f6fa:	f8d3 3510 	ldr.w	r3, [r3, #1296]	; 0x510
	*value = nrf_gpio_port_in_read(reg);
    f6fe:	600b      	str	r3, [r1, #0]
}
    f700:	2000      	movs	r0, #0
    f702:	4770      	bx	lr

0000f704 <gpio_nrfx_port_set_masked_raw>:
	return port->config_info;
    f704:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    f706:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
    f708:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
    f70c:	4042      	eors	r2, r0
    f70e:	400a      	ands	r2, r1
    f710:	4042      	eors	r2, r0
    p_reg->OUT = value;
    f712:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
    f716:	2000      	movs	r0, #0
    f718:	4770      	bx	lr

0000f71a <gpio_nrfx_port_set_bits_raw>:
	return port->config_info;
    f71a:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    f71c:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
    f71e:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
}
    f722:	2000      	movs	r0, #0
    f724:	4770      	bx	lr

0000f726 <gpio_nrfx_port_clear_bits_raw>:
	return port->config_info;
    f726:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    f728:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
    f72a:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
}
    f72e:	2000      	movs	r0, #0
    f730:	4770      	bx	lr

0000f732 <gpio_nrfx_port_toggle_bits>:
	return port->config_info;
    f732:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    f734:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
    f736:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value ^ mask);
    f73a:	404b      	eors	r3, r1
    p_reg->OUT = value;
    f73c:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
}
    f740:	2000      	movs	r0, #0
    f742:	4770      	bx	lr

0000f744 <gpio_nrfx_manage_callback>:
{
    f744:	b470      	push	{r4, r5, r6}
	return port->driver_data;
    f746:	68c0      	ldr	r0, [r0, #12]
	return gpio_manage_callback(&get_port_data(port)->callbacks,
    f748:	1d05      	adds	r5, r0, #4
	return list->head;
    f74a:	6843      	ldr	r3, [r0, #4]
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
    f74c:	b1db      	cbz	r3, f786 <gpio_nrfx_manage_callback+0x42>
		if (!sys_slist_find_and_remove(callbacks, &callback->node)) {
    f74e:	460e      	mov	r6, r1
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    f750:	2400      	movs	r4, #0
    f752:	e00a      	b.n	f76a <gpio_nrfx_manage_callback+0x26>
	return node->next;
    f754:	680b      	ldr	r3, [r1, #0]
	list->head = node;
    f756:	6043      	str	r3, [r0, #4]
	return list->tail;
    f758:	686c      	ldr	r4, [r5, #4]
Z_GENLIST_REMOVE(slist, snode)
    f75a:	42a1      	cmp	r1, r4
    f75c:	d10f      	bne.n	f77e <gpio_nrfx_manage_callback+0x3a>
	list->tail = node;
    f75e:	606b      	str	r3, [r5, #4]
}
    f760:	e00d      	b.n	f77e <gpio_nrfx_manage_callback+0x3a>
	list->tail = node;
    f762:	606c      	str	r4, [r5, #4]
}
    f764:	e00b      	b.n	f77e <gpio_nrfx_manage_callback+0x3a>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    f766:	461c      	mov	r4, r3
    f768:	681b      	ldr	r3, [r3, #0]
    f76a:	b15b      	cbz	r3, f784 <gpio_nrfx_manage_callback+0x40>
    f76c:	429e      	cmp	r6, r3
    f76e:	d1fa      	bne.n	f766 <gpio_nrfx_manage_callback+0x22>
Z_GENLIST_REMOVE(slist, snode)
    f770:	2c00      	cmp	r4, #0
    f772:	d0ef      	beq.n	f754 <gpio_nrfx_manage_callback+0x10>
	return node->next;
    f774:	680b      	ldr	r3, [r1, #0]
	parent->next = child;
    f776:	6023      	str	r3, [r4, #0]
	return list->tail;
    f778:	686b      	ldr	r3, [r5, #4]
Z_GENLIST_REMOVE(slist, snode)
    f77a:	4299      	cmp	r1, r3
    f77c:	d0f1      	beq.n	f762 <gpio_nrfx_manage_callback+0x1e>
	parent->next = child;
    f77e:	2300      	movs	r3, #0
    f780:	600b      	str	r3, [r1, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    f782:	e000      	b.n	f786 <gpio_nrfx_manage_callback+0x42>
			if (!set) {
    f784:	b152      	cbz	r2, f79c <gpio_nrfx_manage_callback+0x58>
				return -EINVAL;
			}
		}
	}

	if (set) {
    f786:	b162      	cbz	r2, f7a2 <gpio_nrfx_manage_callback+0x5e>
	return list->head;
    f788:	6843      	ldr	r3, [r0, #4]
	parent->next = child;
    f78a:	600b      	str	r3, [r1, #0]
	list->head = node;
    f78c:	6041      	str	r1, [r0, #4]
	return list->tail;
    f78e:	686b      	ldr	r3, [r5, #4]
Z_GENLIST_PREPEND(slist, snode)
    f790:	b10b      	cbz	r3, f796 <gpio_nrfx_manage_callback+0x52>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
    f792:	2000      	movs	r0, #0
    f794:	e006      	b.n	f7a4 <gpio_nrfx_manage_callback+0x60>
	list->tail = node;
    f796:	6069      	str	r1, [r5, #4]
    f798:	2000      	movs	r0, #0
}
    f79a:	e003      	b.n	f7a4 <gpio_nrfx_manage_callback+0x60>
				return -EINVAL;
    f79c:	f06f 0015 	mvn.w	r0, #21
    f7a0:	e000      	b.n	f7a4 <gpio_nrfx_manage_callback+0x60>
	return 0;
    f7a2:	2000      	movs	r0, #0
}
    f7a4:	bc70      	pop	{r4, r5, r6}
    f7a6:	4770      	bx	lr

0000f7a8 <gpio_nrfx_pin_manage_callback>:
{
    f7a8:	b510      	push	{r4, lr}
	return port->driver_data;
    f7aa:	68c4      	ldr	r4, [r0, #12]
	WRITE_BIT(data->int_en, pin, enable);
    f7ac:	b13a      	cbz	r2, f7be <gpio_nrfx_pin_manage_callback+0x16>
    f7ae:	6923      	ldr	r3, [r4, #16]
    f7b0:	2201      	movs	r2, #1
    f7b2:	408a      	lsls	r2, r1
    f7b4:	4313      	orrs	r3, r2
    f7b6:	6123      	str	r3, [r4, #16]
	return gpiote_pin_int_cfg(port, pin);
    f7b8:	f7f9 fcdc 	bl	9174 <gpiote_pin_int_cfg>
}
    f7bc:	bd10      	pop	{r4, pc}
	WRITE_BIT(data->int_en, pin, enable);
    f7be:	6923      	ldr	r3, [r4, #16]
    f7c0:	2201      	movs	r2, #1
    f7c2:	408a      	lsls	r2, r1
    f7c4:	ea23 0302 	bic.w	r3, r3, r2
    f7c8:	e7f5      	b.n	f7b6 <gpio_nrfx_pin_manage_callback+0xe>

0000f7ca <gpio_nrfx_pin_disable_callback>:
{
    f7ca:	b508      	push	{r3, lr}
	return gpio_nrfx_pin_manage_callback(port, pin, false);
    f7cc:	2200      	movs	r2, #0
    f7ce:	f7ff ffeb 	bl	f7a8 <gpio_nrfx_pin_manage_callback>
}
    f7d2:	bd08      	pop	{r3, pc}

0000f7d4 <gpio_nrfx_pin_enable_callback>:
{
    f7d4:	b508      	push	{r3, lr}
	return gpio_nrfx_pin_manage_callback(port, pin, true);
    f7d6:	2201      	movs	r2, #1
    f7d8:	f7ff ffe6 	bl	f7a8 <gpio_nrfx_pin_manage_callback>
}
    f7dc:	bd08      	pop	{r3, pc}

0000f7de <uart_nrfx_config_get>:
{
    f7de:	460b      	mov	r3, r1
	return dev->driver_data;
    f7e0:	68c2      	ldr	r2, [r0, #12]
	*cfg = get_dev_data(dev)->uart_config;
    f7e2:	e892 0003 	ldmia.w	r2, {r0, r1}
    f7e6:	e883 0003 	stmia.w	r3, {r0, r1}
}
    f7ea:	2000      	movs	r0, #0
    f7ec:	4770      	bx	lr

0000f7ee <uart_nrfx_irq_tx_ready_complete>:
{
    f7ee:	b508      	push	{r3, lr}
	return event_txdrdy_check();
    f7f0:	f7f9 fede 	bl	95b0 <event_txdrdy_check>
}
    f7f4:	bd08      	pop	{r3, pc}

0000f7f6 <uart_nrfx_irq_update>:
}
    f7f6:	2001      	movs	r0, #1
    f7f8:	4770      	bx	lr

0000f7fa <uarte_nrfx_isr_int>:
	return dev->driver_data;
    f7fa:	68c2      	ldr	r2, [r0, #12]
	return dev->config_info;
    f7fc:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    f7fe:	681b      	ldr	r3, [r3, #0]
	if (data->int_driven->disable_tx_irq &&
    f800:	6891      	ldr	r1, [r2, #8]
    f802:	7b89      	ldrb	r1, [r1, #14]
    f804:	b111      	cbz	r1, f80c <uarte_nrfx_isr_int+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    f806:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    f80a:	b999      	cbnz	r1, f834 <uarte_nrfx_isr_int+0x3a>
{
    f80c:	b500      	push	{lr}
    f80e:	b083      	sub	sp, #12
    f810:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ERROR)) {
    f814:	b131      	cbz	r1, f824 <uarte_nrfx_isr_int+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    f816:	2100      	movs	r1, #0
    f818:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    f81c:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
    f820:	9301      	str	r3, [sp, #4]
    (void)dummy;
    f822:	9b01      	ldr	r3, [sp, #4]
	if (data->int_driven->cb) {
    f824:	6892      	ldr	r2, [r2, #8]
    f826:	6813      	ldr	r3, [r2, #0]
    f828:	b10b      	cbz	r3, f82e <uarte_nrfx_isr_int+0x34>
		data->int_driven->cb(data->int_driven->cb_data);
    f82a:	6850      	ldr	r0, [r2, #4]
    f82c:	4798      	blx	r3
}
    f82e:	b003      	add	sp, #12
    f830:	f85d fb04 	ldr.w	pc, [sp], #4
    p_reg->INTENCLR = mask;
    f834:	f44f 7180 	mov.w	r1, #256	; 0x100
    f838:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    f83c:	2101      	movs	r1, #1
    f83e:	60d9      	str	r1, [r3, #12]
		data->int_driven->disable_tx_irq = false;
    f840:	6893      	ldr	r3, [r2, #8]
    f842:	2200      	movs	r2, #0
    f844:	739a      	strb	r2, [r3, #14]
		return;
    f846:	4770      	bx	lr

0000f848 <uarte_nrfx_configure>:
{
    f848:	b530      	push	{r4, r5, lr}
    f84a:	b083      	sub	sp, #12
    f84c:	4605      	mov	r5, r0
    f84e:	460c      	mov	r4, r1
	switch (cfg->stop_bits) {
    f850:	794b      	ldrb	r3, [r1, #5]
    f852:	2b01      	cmp	r3, #1
    f854:	d006      	beq.n	f864 <uarte_nrfx_configure+0x1c>
    f856:	2b03      	cmp	r3, #3
    f858:	d011      	beq.n	f87e <uarte_nrfx_configure+0x36>
    f85a:	f06f 0285 	mvn.w	r2, #133	; 0x85
}
    f85e:	4610      	mov	r0, r2
    f860:	b003      	add	sp, #12
    f862:	bd30      	pop	{r4, r5, pc}
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
    f864:	2300      	movs	r3, #0
    f866:	f88d 3002 	strb.w	r3, [sp, #2]
	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
    f86a:	79a3      	ldrb	r3, [r4, #6]
    f86c:	2b03      	cmp	r3, #3
    f86e:	d149      	bne.n	f904 <uarte_nrfx_configure+0xbc>
	switch (cfg->flow_ctrl) {
    f870:	79e3      	ldrb	r3, [r4, #7]
    f872:	b143      	cbz	r3, f886 <uarte_nrfx_configure+0x3e>
    f874:	2b01      	cmp	r3, #1
    f876:	d015      	beq.n	f8a4 <uarte_nrfx_configure+0x5c>
    f878:	f06f 0285 	mvn.w	r2, #133	; 0x85
    f87c:	e7ef      	b.n	f85e <uarte_nrfx_configure+0x16>
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
    f87e:	2310      	movs	r3, #16
    f880:	f88d 3002 	strb.w	r3, [sp, #2]
		break;
    f884:	e7f1      	b.n	f86a <uarte_nrfx_configure+0x22>
		uarte_cfg.hwfc = NRF_UARTE_HWFC_DISABLED;
    f886:	2300      	movs	r3, #0
    f888:	f88d 3000 	strb.w	r3, [sp]
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
    f88c:	2300      	movs	r3, #0
    f88e:	f8ad 3004 	strh.w	r3, [sp, #4]
	switch (cfg->parity) {
    f892:	7923      	ldrb	r3, [r4, #4]
    f894:	2b01      	cmp	r3, #1
    f896:	d02d      	beq.n	f8f4 <uarte_nrfx_configure+0xac>
    f898:	2b02      	cmp	r3, #2
    f89a:	d027      	beq.n	f8ec <uarte_nrfx_configure+0xa4>
    f89c:	b14b      	cbz	r3, f8b2 <uarte_nrfx_configure+0x6a>
    f89e:	f06f 0285 	mvn.w	r2, #133	; 0x85
    f8a2:	e7dc      	b.n	f85e <uarte_nrfx_configure+0x16>
	return dev->config_info;
    f8a4:	686b      	ldr	r3, [r5, #4]
		if (get_dev_config(dev)->rts_cts_pins_set) {
    f8a6:	791b      	ldrb	r3, [r3, #4]
    f8a8:	b37b      	cbz	r3, f90a <uarte_nrfx_configure+0xc2>
			uarte_cfg.hwfc = NRF_UARTE_HWFC_ENABLED;
    f8aa:	2301      	movs	r3, #1
    f8ac:	f88d 3000 	strb.w	r3, [sp]
		break;
    f8b0:	e7ec      	b.n	f88c <uarte_nrfx_configure+0x44>
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
    f8b2:	f88d 3001 	strb.w	r3, [sp, #1]
	if (baudrate_set(dev, cfg->baudrate) != 0) {
    f8b6:	6821      	ldr	r1, [r4, #0]
    f8b8:	4628      	mov	r0, r5
    f8ba:	f7fa f927 	bl	9b0c <baudrate_set>
    f8be:	4602      	mov	r2, r0
    f8c0:	bb30      	cbnz	r0, f910 <uarte_nrfx_configure+0xc8>
	return dev->config_info;
    f8c2:	686b      	ldr	r3, [r5, #4]
	return config->uarte_regs;
    f8c4:	6819      	ldr	r1, [r3, #0]
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    f8c6:	f89d 3001 	ldrb.w	r3, [sp, #1]
                    | (uint32_t)p_cfg->stop
    f8ca:	f89d 0002 	ldrb.w	r0, [sp, #2]
    f8ce:	4303      	orrs	r3, r0
                    | (uint32_t)p_cfg->paritytype
    f8d0:	f8bd 0004 	ldrh.w	r0, [sp, #4]
    f8d4:	4303      	orrs	r3, r0
                    | (uint32_t)p_cfg->hwfc;
    f8d6:	f89d 0000 	ldrb.w	r0, [sp]
    f8da:	4303      	orrs	r3, r0
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    f8dc:	f8c1 356c 	str.w	r3, [r1, #1388]	; 0x56c
	return dev->driver_data;
    f8e0:	68eb      	ldr	r3, [r5, #12]
	get_dev_data(dev)->uart_config = *cfg;
    f8e2:	e894 0003 	ldmia.w	r4, {r0, r1}
    f8e6:	e883 0003 	stmia.w	r3, {r0, r1}
	return 0;
    f8ea:	e7b8      	b.n	f85e <uarte_nrfx_configure+0x16>
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
    f8ec:	230e      	movs	r3, #14
    f8ee:	f88d 3001 	strb.w	r3, [sp, #1]
		break;
    f8f2:	e7e0      	b.n	f8b6 <uarte_nrfx_configure+0x6e>
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
    f8f4:	230e      	movs	r3, #14
    f8f6:	f88d 3001 	strb.w	r3, [sp, #1]
		uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_ODD;
    f8fa:	f44f 7380 	mov.w	r3, #256	; 0x100
    f8fe:	f8ad 3004 	strh.w	r3, [sp, #4]
		break;
    f902:	e7d8      	b.n	f8b6 <uarte_nrfx_configure+0x6e>
		return -ENOTSUP;
    f904:	f06f 0285 	mvn.w	r2, #133	; 0x85
    f908:	e7a9      	b.n	f85e <uarte_nrfx_configure+0x16>
			return -ENOTSUP;
    f90a:	f06f 0285 	mvn.w	r2, #133	; 0x85
    f90e:	e7a6      	b.n	f85e <uarte_nrfx_configure+0x16>
		return -ENOTSUP;
    f910:	f06f 0285 	mvn.w	r2, #133	; 0x85
    f914:	e7a3      	b.n	f85e <uarte_nrfx_configure+0x16>

0000f916 <uarte_nrfx_config_get>:
{
    f916:	460b      	mov	r3, r1
	return dev->driver_data;
    f918:	68c2      	ldr	r2, [r0, #12]
	*cfg = get_dev_data(dev)->uart_config;
    f91a:	e892 0003 	ldmia.w	r2, {r0, r1}
    f91e:	e883 0003 	stmia.w	r3, {r0, r1}
}
    f922:	2000      	movs	r0, #0
    f924:	4770      	bx	lr

0000f926 <uarte_nrfx_err_check>:
	return dev->config_info;
    f926:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    f928:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
    f92a:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
    f92e:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
    f932:	4770      	bx	lr

0000f934 <uarte_nrfx_poll_in>:
{
    f934:	b410      	push	{r4}
    f936:	b083      	sub	sp, #12
	return dev->driver_data;
    f938:	68c4      	ldr	r4, [r0, #12]
	return dev->config_info;
    f93a:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    f93c:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    f93e:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
    f942:	b16a      	cbz	r2, f960 <uarte_nrfx_poll_in+0x2c>
	*c = data->rx_data;
    f944:	7c22      	ldrb	r2, [r4, #16]
    f946:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    f948:	2000      	movs	r0, #0
    f94a:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    f94e:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    f952:	9201      	str	r2, [sp, #4]
    (void)dummy;
    f954:	9a01      	ldr	r2, [sp, #4]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    f956:	2201      	movs	r2, #1
    f958:	601a      	str	r2, [r3, #0]
}
    f95a:	b003      	add	sp, #12
    f95c:	bc10      	pop	{r4}
    f95e:	4770      	bx	lr
		return -1;
    f960:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    f964:	e7f9      	b.n	f95a <uarte_nrfx_poll_in+0x26>

0000f966 <uarte_nrfx_fifo_fill>:
{
    f966:	b470      	push	{r4, r5, r6}
    f968:	b083      	sub	sp, #12
	return dev->config_info;
    f96a:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    f96c:	681e      	ldr	r6, [r3, #0]
	return dev->driver_data;
    f96e:	68c5      	ldr	r5, [r0, #12]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    f970:	f8d6 3120 	ldr.w	r3, [r6, #288]	; 0x120
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
    f974:	b1f3      	cbz	r3, f9b4 <uarte_nrfx_fifo_fill+0x4e>
	if (len > data->int_driven->tx_buff_size) {
    f976:	68ab      	ldr	r3, [r5, #8]
    f978:	8998      	ldrh	r0, [r3, #12]
    f97a:	4290      	cmp	r0, r2
    f97c:	db00      	blt.n	f980 <uarte_nrfx_fifo_fill+0x1a>
    f97e:	4610      	mov	r0, r2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    f980:	2300      	movs	r3, #0
    f982:	f8c6 3120 	str.w	r3, [r6, #288]	; 0x120
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    f986:	f8d6 2120 	ldr.w	r2, [r6, #288]	; 0x120
    f98a:	9201      	str	r2, [sp, #4]
    (void)dummy;
    f98c:	9a01      	ldr	r2, [sp, #4]
	for (int i = 0; i < len; i++) {
    f98e:	4298      	cmp	r0, r3
    f990:	dd05      	ble.n	f99e <uarte_nrfx_fifo_fill+0x38>
		data->int_driven->tx_buffer[i] = tx_data[i];
    f992:	68aa      	ldr	r2, [r5, #8]
    f994:	6892      	ldr	r2, [r2, #8]
    f996:	5ccc      	ldrb	r4, [r1, r3]
    f998:	54d4      	strb	r4, [r2, r3]
	for (int i = 0; i < len; i++) {
    f99a:	3301      	adds	r3, #1
    f99c:	e7f7      	b.n	f98e <uarte_nrfx_fifo_fill+0x28>
	nrf_uarte_tx_buffer_set(uarte, data->int_driven->tx_buffer, len);
    f99e:	68ab      	ldr	r3, [r5, #8]
    f9a0:	689b      	ldr	r3, [r3, #8]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    f9a2:	f8c6 3544 	str.w	r3, [r6, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    f9a6:	f8c6 0548 	str.w	r0, [r6, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    f9aa:	2301      	movs	r3, #1
    f9ac:	60b3      	str	r3, [r6, #8]
}
    f9ae:	b003      	add	sp, #12
    f9b0:	bc70      	pop	{r4, r5, r6}
    f9b2:	4770      	bx	lr
		return 0;
    f9b4:	2000      	movs	r0, #0
    f9b6:	e7fa      	b.n	f9ae <uarte_nrfx_fifo_fill+0x48>

0000f9b8 <uarte_nrfx_fifo_read>:
	return dev->config_info;
    f9b8:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    f9ba:	681b      	ldr	r3, [r3, #0]
	return dev->driver_data;
    f9bc:	68c0      	ldr	r0, [r0, #12]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    f9be:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
    f9c2:	b16a      	cbz	r2, f9e0 <uarte_nrfx_fifo_read+0x28>
{
    f9c4:	b082      	sub	sp, #8
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    f9c6:	2200      	movs	r2, #0
    f9c8:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    f9cc:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    f9d0:	9201      	str	r2, [sp, #4]
    (void)dummy;
    f9d2:	9a01      	ldr	r2, [sp, #4]
		rx_data[num_rx++] = (u8_t)data->rx_data;
    f9d4:	7c02      	ldrb	r2, [r0, #16]
    f9d6:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    f9d8:	2001      	movs	r0, #1
    f9da:	6018      	str	r0, [r3, #0]
}
    f9dc:	b002      	add	sp, #8
    f9de:	4770      	bx	lr
	int num_rx = 0;
    f9e0:	2000      	movs	r0, #0
}
    f9e2:	4770      	bx	lr

0000f9e4 <uarte_nrfx_irq_tx_enable>:
	return dev->config_info;
    f9e4:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    f9e6:	681b      	ldr	r3, [r3, #0]
	return dev->driver_data;
    f9e8:	68c2      	ldr	r2, [r0, #12]
	data->int_driven->disable_tx_irq = false;
    f9ea:	6892      	ldr	r2, [r2, #8]
    f9ec:	2100      	movs	r1, #0
    f9ee:	7391      	strb	r1, [r2, #14]
    p_reg->INTENSET = mask;
    f9f0:	f44f 7280 	mov.w	r2, #256	; 0x100
    f9f4:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    f9f8:	4770      	bx	lr

0000f9fa <uarte_nrfx_irq_tx_disable>:
	return dev->driver_data;
    f9fa:	68c3      	ldr	r3, [r0, #12]
	data->int_driven->disable_tx_irq = true;
    f9fc:	689b      	ldr	r3, [r3, #8]
    f9fe:	2201      	movs	r2, #1
    fa00:	739a      	strb	r2, [r3, #14]
}
    fa02:	4770      	bx	lr

0000fa04 <uarte_nrfx_irq_tx_ready_complete>:
	return dev->config_info;
    fa04:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    fa06:	681a      	ldr	r2, [r3, #0]
	return dev->driver_data;
    fa08:	68c3      	ldr	r3, [r0, #12]
	return !data->int_driven->disable_tx_irq &&
    fa0a:	689b      	ldr	r3, [r3, #8]
    fa0c:	7b9b      	ldrb	r3, [r3, #14]
	       nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX) &&
    fa0e:	b94b      	cbnz	r3, fa24 <uarte_nrfx_irq_tx_ready_complete+0x20>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    fa10:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
	return !data->int_driven->disable_tx_irq &&
    fa14:	b143      	cbz	r3, fa28 <uarte_nrfx_irq_tx_ready_complete+0x24>
    return p_reg->INTENSET & mask;
    fa16:	f8d2 3304 	ldr.w	r3, [r2, #772]	; 0x304
	       nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX) &&
    fa1a:	f413 7f80 	tst.w	r3, #256	; 0x100
    fa1e:	d005      	beq.n	fa2c <uarte_nrfx_irq_tx_ready_complete+0x28>
    fa20:	2001      	movs	r0, #1
    fa22:	4770      	bx	lr
    fa24:	2000      	movs	r0, #0
    fa26:	4770      	bx	lr
    fa28:	2000      	movs	r0, #0
    fa2a:	4770      	bx	lr
    fa2c:	2000      	movs	r0, #0
}
    fa2e:	4770      	bx	lr

0000fa30 <uarte_nrfx_irq_rx_ready>:
	return dev->config_info;
    fa30:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    fa32:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    fa34:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
}
    fa38:	3800      	subs	r0, #0
    fa3a:	bf18      	it	ne
    fa3c:	2001      	movne	r0, #1
    fa3e:	4770      	bx	lr

0000fa40 <uarte_nrfx_irq_rx_enable>:
	return dev->config_info;
    fa40:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    fa42:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
    fa44:	2210      	movs	r2, #16
    fa46:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    fa4a:	4770      	bx	lr

0000fa4c <uarte_nrfx_irq_rx_disable>:
	return dev->config_info;
    fa4c:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    fa4e:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
    fa50:	2210      	movs	r2, #16
    fa52:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
    fa56:	4770      	bx	lr

0000fa58 <uarte_nrfx_irq_err_enable>:
	return dev->config_info;
    fa58:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    fa5a:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
    fa5c:	f44f 7200 	mov.w	r2, #512	; 0x200
    fa60:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    fa64:	4770      	bx	lr

0000fa66 <uarte_nrfx_irq_err_disable>:
	return dev->config_info;
    fa66:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    fa68:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
    fa6a:	f44f 7200 	mov.w	r2, #512	; 0x200
    fa6e:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
    fa72:	4770      	bx	lr

0000fa74 <uarte_nrfx_irq_is_pending>:
{
    fa74:	b538      	push	{r3, r4, r5, lr}
    fa76:	4604      	mov	r4, r0
	return dev->config_info;
    fa78:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    fa7a:	681d      	ldr	r5, [r3, #0]
    return p_reg->INTENSET & mask;
    fa7c:	f8d5 3304 	ldr.w	r3, [r5, #772]	; 0x304
		||
    fa80:	f413 7f80 	tst.w	r3, #256	; 0x100
    fa84:	d106      	bne.n	fa94 <uarte_nrfx_irq_is_pending+0x20>
    fa86:	f8d5 3304 	ldr.w	r3, [r5, #772]	; 0x304
    fa8a:	f013 0f10 	tst.w	r3, #16
    fa8e:	d107      	bne.n	faa0 <uarte_nrfx_irq_is_pending+0x2c>
    fa90:	2000      	movs	r0, #0
}
    fa92:	bd38      	pop	{r3, r4, r5, pc}
		 uarte_nrfx_irq_tx_ready_complete(dev))
    fa94:	f7ff ffb6 	bl	fa04 <uarte_nrfx_irq_tx_ready_complete>
					    NRF_UARTE_INT_ENDTX_MASK) &&
    fa98:	2800      	cmp	r0, #0
    fa9a:	d0f4      	beq.n	fa86 <uarte_nrfx_irq_is_pending+0x12>
		||
    fa9c:	2001      	movs	r0, #1
    fa9e:	e7f8      	b.n	fa92 <uarte_nrfx_irq_is_pending+0x1e>
		 uarte_nrfx_irq_rx_ready(dev)));
    faa0:	4620      	mov	r0, r4
    faa2:	f7ff ffc5 	bl	fa30 <uarte_nrfx_irq_rx_ready>
					    NRF_UARTE_INT_ENDRX_MASK) &&
    faa6:	2800      	cmp	r0, #0
    faa8:	d0f3      	beq.n	fa92 <uarte_nrfx_irq_is_pending+0x1e>
		||
    faaa:	2001      	movs	r0, #1
    faac:	e7f1      	b.n	fa92 <uarte_nrfx_irq_is_pending+0x1e>

0000faae <uarte_nrfx_irq_update>:
}
    faae:	2001      	movs	r0, #1
    fab0:	4770      	bx	lr

0000fab2 <uarte_nrfx_irq_callback_set>:
	return dev->driver_data;
    fab2:	68c3      	ldr	r3, [r0, #12]
	data->int_driven->cb = cb;
    fab4:	6898      	ldr	r0, [r3, #8]
    fab6:	6001      	str	r1, [r0, #0]
	data->int_driven->cb_data = cb_data;
    fab8:	689b      	ldr	r3, [r3, #8]
    faba:	605a      	str	r2, [r3, #4]
}
    fabc:	4770      	bx	lr

0000fabe <uarte_nrfx_poll_out>:
{
    fabe:	b5f0      	push	{r4, r5, r6, r7, lr}
    fac0:	b085      	sub	sp, #20
    fac2:	f88d 1007 	strb.w	r1, [sp, #7]
	return dev->config_info;
    fac6:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    fac8:	681d      	ldr	r5, [r3, #0]
	return dev->driver_data;
    faca:	68c6      	ldr	r6, [r0, #12]
	if (!k_is_in_isr()) {
    facc:	f000 fbf4 	bl	102b8 <k_is_in_isr>
    fad0:	b9c8      	cbnz	r0, fb06 <uarte_nrfx_poll_out+0x48>
    fad2:	f106 040c 	add.w	r4, r6, #12
		u8_t safety_cnt = 100;
    fad6:	2764      	movs	r7, #100	; 0x64
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    fad8:	2301      	movs	r3, #1
    fada:	f3bf 8f5b 	dmb	ish
    fade:	e854 2f00 	ldrex	r2, [r4]
    fae2:	2a00      	cmp	r2, #0
    fae4:	d103      	bne.n	faee <uarte_nrfx_poll_out+0x30>
    fae6:	e844 3100 	strex	r1, r3, [r4]
    faea:	2900      	cmp	r1, #0
    faec:	d1f7      	bne.n	fade <uarte_nrfx_poll_out+0x20>
    faee:	f3bf 8f5b 	dmb	ish
		while (atomic_cas((atomic_t *) lock,
    faf2:	d00a      	beq.n	fb0a <uarte_nrfx_poll_out+0x4c>
	return z_impl_k_sleep(timeout);
    faf4:	2021      	movs	r0, #33	; 0x21
    faf6:	2100      	movs	r1, #0
    faf8:	f7fb fbce 	bl	b298 <z_impl_k_sleep>
			if (--safety_cnt == 0) {
    fafc:	3f01      	subs	r7, #1
    fafe:	f017 07ff 	ands.w	r7, r7, #255	; 0xff
    fb02:	d1e9      	bne.n	fad8 <uarte_nrfx_poll_out+0x1a>
    fb04:	e01e      	b.n	fb44 <uarte_nrfx_poll_out+0x86>
		*lock = 1;
    fb06:	2301      	movs	r3, #1
    fb08:	60f3      	str	r3, [r6, #12]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    fb0a:	2300      	movs	r3, #0
    fb0c:	f8c5 3120 	str.w	r3, [r5, #288]	; 0x120
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    fb10:	f8d5 3120 	ldr.w	r3, [r5, #288]	; 0x120
    fb14:	9303      	str	r3, [sp, #12]
    (void)dummy;
    fb16:	9b03      	ldr	r3, [sp, #12]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    fb18:	f10d 0307 	add.w	r3, sp, #7
    fb1c:	f8c5 3544 	str.w	r3, [r5, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    fb20:	2301      	movs	r3, #1
    fb22:	f8c5 3548 	str.w	r3, [r5, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    fb26:	60ab      	str	r3, [r5, #8]
	NRFX_WAIT_FOR(nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX),
    fb28:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    fb2c:	f8d5 3120 	ldr.w	r3, [r5, #288]	; 0x120
    fb30:	b923      	cbnz	r3, fb3c <uarte_nrfx_poll_out+0x7e>
    fb32:	2001      	movs	r0, #1
    fb34:	f000 f824 	bl	fb80 <nrfx_busy_wait>
    fb38:	3c01      	subs	r4, #1
    fb3a:	d1f7      	bne.n	fb2c <uarte_nrfx_poll_out+0x6e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    fb3c:	2301      	movs	r3, #1
    fb3e:	60eb      	str	r3, [r5, #12]
	*lock = 0;
    fb40:	2300      	movs	r3, #0
    fb42:	60f3      	str	r3, [r6, #12]
}
    fb44:	b005      	add	sp, #20
    fb46:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000fb48 <rng_pool_put>:
{
    fb48:	b410      	push	{r4}
	u8_t first = rngp->first_read;
    fb4a:	7842      	ldrb	r2, [r0, #1]
	u8_t last  = rngp->last;
    fb4c:	7883      	ldrb	r3, [r0, #2]
	u8_t mask  = rngp->mask;
    fb4e:	78c4      	ldrb	r4, [r0, #3]
	if (((last - first) & mask) == mask) {
    fb50:	1a9a      	subs	r2, r3, r2
    fb52:	ea34 0202 	bics.w	r2, r4, r2
    fb56:	d008      	beq.n	fb6a <rng_pool_put+0x22>
	rngp->buffer[last] = byte;
    fb58:	18c2      	adds	r2, r0, r3
    fb5a:	7151      	strb	r1, [r2, #5]
	rngp->last = (last + 1) & mask;
    fb5c:	3301      	adds	r3, #1
    fb5e:	b25b      	sxtb	r3, r3
    fb60:	4023      	ands	r3, r4
    fb62:	7083      	strb	r3, [r0, #2]
	return 0;
    fb64:	2000      	movs	r0, #0
}
    fb66:	bc10      	pop	{r4}
    fb68:	4770      	bx	lr
		return -ENOBUFS;
    fb6a:	f06f 0068 	mvn.w	r0, #104	; 0x68
    fb6e:	e7fa      	b.n	fb66 <rng_pool_put+0x1e>

0000fb70 <rng_pool_init>:
	rngp->first_alloc = 0U;
    fb70:	2300      	movs	r3, #0
    fb72:	7003      	strb	r3, [r0, #0]
	rngp->first_read  = 0U;
    fb74:	7043      	strb	r3, [r0, #1]
	rngp->last	  = 0U;
    fb76:	7083      	strb	r3, [r0, #2]
	rngp->mask	  = size - 1;
    fb78:	3901      	subs	r1, #1
    fb7a:	70c1      	strb	r1, [r0, #3]
	rngp->threshold	  = threshold;
    fb7c:	7102      	strb	r2, [r0, #4]
}
    fb7e:	4770      	bx	lr

0000fb80 <nrfx_busy_wait>:
{
	((nrfx_irq_handler_t)irq_handler)();
}

void nrfx_busy_wait(u32_t usec_to_wait)
{
    fb80:	b508      	push	{r3, lr}
	z_impl_k_busy_wait(usec_to_wait);
    fb82:	f000 fb9f 	bl	102c4 <z_impl_k_busy_wait>
	k_busy_wait(usec_to_wait);
}
    fb86:	bd08      	pop	{r3, pc}

0000fb88 <device_busy_set>:
	atomic_set_bit((atomic_t *) __device_busy_start,
		       (busy_dev - __device_start));
#else
	ARG_UNUSED(busy_dev);
#endif
}
    fb88:	4770      	bx	lr

0000fb8a <device_busy_clear>:
	atomic_clear_bit((atomic_t *) __device_busy_start,
			 (busy_dev - __device_start));
#else
	ARG_UNUSED(busy_dev);
#endif
}
    fb8a:	4770      	bx	lr

0000fb8c <arch_system_halt>:
	__asm__ volatile(
    fb8c:	f04f 0220 	mov.w	r2, #32
    fb90:	f3ef 8311 	mrs	r3, BASEPRI
    fb94:	f382 8811 	msr	BASEPRI, r2
    fb98:	f3bf 8f6f 	isb	sy
	for (;;) {
    fb9c:	e7fe      	b.n	fb9c <arch_system_halt+0x10>

0000fb9e <sys_power_save_idle>:

static void sys_power_save_idle(void)
{
    fb9e:	b510      	push	{r4, lr}
	s32_t ticks = z_get_next_timeout_expiry();
    fba0:	f000 fbf7 	bl	10392 <z_get_next_timeout_expiry>
    fba4:	4604      	mov	r4, r0
	 * periods less than that.  This seems... silly, given that it
	 * saves no power and does not improve latency.  But it's an
	 * API we need to honor...
	 */
#ifdef CONFIG_SYS_CLOCK_EXISTS
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    fba6:	2802      	cmp	r0, #2
    fba8:	dd08      	ble.n	fbbc <sys_power_save_idle+0x1e>
    fbaa:	2101      	movs	r1, #1
    fbac:	f000 fc07 	bl	103be <z_set_timeout_expiry>
#endif

	set_kernel_idle_time_in_ticks(ticks);
    fbb0:	4620      	mov	r0, r4
    fbb2:	f7fa fc6f 	bl	a494 <set_kernel_idle_time_in_ticks>
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    fbb6:	f7f2 fee7 	bl	2988 <arch_cpu_idle>
		k_cpu_idle();
	}
#else
	k_cpu_idle();
#endif
}
    fbba:	bd10      	pop	{r4, pc}
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    fbbc:	2001      	movs	r0, #1
    fbbe:	e7f4      	b.n	fbaa <sys_power_save_idle+0xc>

0000fbc0 <z_sys_power_save_idle_exit>:
#endif

void z_sys_power_save_idle_exit(s32_t ticks)
{
    fbc0:	b508      	push	{r3, lr}
	if (sys_pm_idle_exit_notify) {
		_sys_resume();
	}
#endif

	z_clock_idle_exit();
    fbc2:	f7fe f9c2 	bl	df4a <z_clock_idle_exit>
}
    fbc6:	bd08      	pop	{r3, pc}

0000fbc8 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
    fbc8:	b508      	push	{r3, lr}
    fbca:	f04f 0220 	mov.w	r2, #32
    fbce:	f3ef 8311 	mrs	r3, BASEPRI
    fbd2:	f382 8811 	msr	BASEPRI, r2
    fbd6:	f3bf 8f6f 	isb	sy
#if SMP_FALLBACK
		k_busy_wait(100);
		k_yield();
#else
		(void)arch_irq_lock();
		sys_power_save_idle();
    fbda:	f7ff ffe0 	bl	fb9e <sys_power_save_idle>
	while (true) {
    fbde:	e7f4      	b.n	fbca <idle+0x2>

0000fbe0 <k_heap_init>:
{
    fbe0:	b510      	push	{r4, lr}
	sys_dlist_init(&w->waitq);
    fbe2:	f100 040c 	add.w	r4, r0, #12
	list->head = (sys_dnode_t *)list;
    fbe6:	60c4      	str	r4, [r0, #12]
	list->tail = (sys_dnode_t *)list;
    fbe8:	6104      	str	r4, [r0, #16]
	sys_heap_init(&h->heap, mem, bytes);
    fbea:	f7fd fcd8 	bl	d59e <sys_heap_init>
}
    fbee:	bd10      	pop	{r4, pc}

0000fbf0 <k_heap_alloc>:

SYS_INIT(statics_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
    fbf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fbf4:	b085      	sub	sp, #20
    fbf6:	4680      	mov	r8, r0
    fbf8:	9103      	str	r1, [sp, #12]
	s64_t now, end = z_timeout_end_calc(timeout);
    fbfa:	4610      	mov	r0, r2
    fbfc:	4619      	mov	r1, r3
    fbfe:	f000 fc0b 	bl	10418 <z_timeout_end_calc>
    fc02:	4681      	mov	r9, r0
    fc04:	468a      	mov	sl, r1
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
    fc06:	f108 0b14 	add.w	fp, r8, #20
    fc0a:	f04f 0320 	mov.w	r3, #32
    fc0e:	f3ef 8511 	mrs	r5, BASEPRI
    fc12:	f383 8811 	msr	BASEPRI, r3
    fc16:	f3bf 8f6f 	isb	sy
	void *ret = NULL;
    fc1a:	2400      	movs	r4, #0
    fc1c:	e00f      	b.n	fc3e <k_heap_alloc+0x4e>
		now = z_tick_get();
		if ((ret != NULL) || ((end - now) <= 0)) {
			break;
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
    fc1e:	e9cd 6700 	strd	r6, r7, [sp]
    fc22:	f108 020c 	add.w	r2, r8, #12
    fc26:	4629      	mov	r1, r5
    fc28:	4658      	mov	r0, fp
    fc2a:	f7fb fa27 	bl	b07c <z_pend_curr>
    fc2e:	f04f 0320 	mov.w	r3, #32
    fc32:	f3ef 8511 	mrs	r5, BASEPRI
    fc36:	f383 8811 	msr	BASEPRI, r3
    fc3a:	f3bf 8f6f 	isb	sy
	while (ret == NULL) {
    fc3e:	b97c      	cbnz	r4, fc60 <k_heap_alloc+0x70>
		ret = sys_heap_alloc(&h->heap, bytes);
    fc40:	9903      	ldr	r1, [sp, #12]
    fc42:	4640      	mov	r0, r8
    fc44:	f7fd fc49 	bl	d4da <sys_heap_alloc>
    fc48:	4604      	mov	r4, r0
		now = z_tick_get();
    fc4a:	f7fb fd7d 	bl	b748 <z_tick_get>
		if ((ret != NULL) || ((end - now) <= 0)) {
    fc4e:	b93c      	cbnz	r4, fc60 <k_heap_alloc+0x70>
    fc50:	ebb9 0600 	subs.w	r6, r9, r0
    fc54:	eb6a 0701 	sbc.w	r7, sl, r1
    fc58:	2e01      	cmp	r6, #1
    fc5a:	f177 0300 	sbcs.w	r3, r7, #0
    fc5e:	dade      	bge.n	fc1e <k_heap_alloc+0x2e>
	__asm__ volatile(
    fc60:	f385 8811 	msr	BASEPRI, r5
    fc64:	f3bf 8f6f 	isb	sy
		key = k_spin_lock(&h->lock);
	}

	k_spin_unlock(&h->lock, key);
	return ret;
}
    fc68:	4620      	mov	r0, r4
    fc6a:	b005      	add	sp, #20
    fc6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000fc70 <k_heap_free>:

void k_heap_free(struct k_heap *h, void *mem)
{
    fc70:	b570      	push	{r4, r5, r6, lr}
    fc72:	4604      	mov	r4, r0
	k_spinlock_key_t key = k_spin_lock(&h->lock);
    fc74:	f100 0614 	add.w	r6, r0, #20
	__asm__ volatile(
    fc78:	f04f 0320 	mov.w	r3, #32
    fc7c:	f3ef 8511 	mrs	r5, BASEPRI
    fc80:	f383 8811 	msr	BASEPRI, r3
    fc84:	f3bf 8f6f 	isb	sy

	sys_heap_free(&h->heap, mem);
    fc88:	f7fd fb5e 	bl	d348 <sys_heap_free>

	if (z_unpend_all(&h->wait_q) != 0) {
    fc8c:	f104 000c 	add.w	r0, r4, #12
    fc90:	f000 faee 	bl	10270 <z_unpend_all>
    fc94:	b920      	cbnz	r0, fca0 <k_heap_free+0x30>
	__asm__ volatile(
    fc96:	f385 8811 	msr	BASEPRI, r5
    fc9a:	f3bf 8f6f 	isb	sy
		z_reschedule(&h->lock, key);
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
    fc9e:	bd70      	pop	{r4, r5, r6, pc}
		z_reschedule(&h->lock, key);
    fca0:	4629      	mov	r1, r5
    fca2:	4630      	mov	r0, r6
    fca4:	f000 f9b6 	bl	10014 <z_reschedule>
    fca8:	e7f9      	b.n	fc9e <k_heap_free+0x2e>

0000fcaa <k_mem_pool_alloc>:
 * backend.
 */

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, k_timeout_t timeout)
{
    fcaa:	b538      	push	{r3, r4, r5, lr}
    fcac:	460d      	mov	r5, r1
    fcae:	4614      	mov	r4, r2
	block->id.heap = p->heap;
    fcb0:	6800      	ldr	r0, [r0, #0]
    fcb2:	6048      	str	r0, [r1, #4]
	block->data = k_heap_alloc(p->heap, size, timeout);
    fcb4:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    fcb8:	4621      	mov	r1, r4
    fcba:	f7ff ff99 	bl	fbf0 <k_heap_alloc>
    fcbe:	6028      	str	r0, [r5, #0]

	/* The legacy API returns -EAGAIN on timeout expiration, but
	 * -ENOMEM if the timeout was K_NO_WAIT. Don't ask.
	 */
	if (size != 0 && block->data == NULL) {
    fcc0:	b164      	cbz	r4, fcdc <k_mem_pool_alloc+0x32>
    fcc2:	b108      	cbz	r0, fcc8 <k_mem_pool_alloc+0x1e>
		return K_TIMEOUT_EQ(timeout, K_NO_WAIT) ? -ENOMEM : -EAGAIN;
	} else {
		return 0;
    fcc4:	2000      	movs	r0, #0
	}
}
    fcc6:	bd38      	pop	{r3, r4, r5, pc}
		return K_TIMEOUT_EQ(timeout, K_NO_WAIT) ? -ENOMEM : -EAGAIN;
    fcc8:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
    fccc:	4323      	orrs	r3, r4
    fcce:	d102      	bne.n	fcd6 <k_mem_pool_alloc+0x2c>
    fcd0:	f06f 000b 	mvn.w	r0, #11
    fcd4:	e7f7      	b.n	fcc6 <k_mem_pool_alloc+0x1c>
    fcd6:	f06f 000a 	mvn.w	r0, #10
    fcda:	e7f4      	b.n	fcc6 <k_mem_pool_alloc+0x1c>
		return 0;
    fcdc:	2000      	movs	r0, #0
    fcde:	e7f2      	b.n	fcc6 <k_mem_pool_alloc+0x1c>

0000fce0 <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
    fce0:	b508      	push	{r3, lr}
	k_heap_free(id->heap, id->data);
    fce2:	6801      	ldr	r1, [r0, #0]
    fce4:	6840      	ldr	r0, [r0, #4]
    fce6:	f7ff ffc3 	bl	fc70 <k_heap_free>
}
    fcea:	bd08      	pop	{r3, pc}

0000fcec <create_free_list>:
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
    fcec:	68c2      	ldr	r2, [r0, #12]
    fcee:	6903      	ldr	r3, [r0, #16]
    fcf0:	431a      	orrs	r2, r3
    fcf2:	f012 0203 	ands.w	r2, r2, #3
    fcf6:	d10d      	bne.n	fd14 <create_free_list+0x28>
	slab->free_list = NULL;
    fcf8:	2100      	movs	r1, #0
    fcfa:	6141      	str	r1, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    fcfc:	e005      	b.n	fd0a <create_free_list+0x1e>
		*(char **)p = slab->free_list;
    fcfe:	6941      	ldr	r1, [r0, #20]
    fd00:	6019      	str	r1, [r3, #0]
		slab->free_list = p;
    fd02:	6143      	str	r3, [r0, #20]
		p += slab->block_size;
    fd04:	68c1      	ldr	r1, [r0, #12]
    fd06:	440b      	add	r3, r1
	for (j = 0U; j < slab->num_blocks; j++) {
    fd08:	3201      	adds	r2, #1
    fd0a:	6881      	ldr	r1, [r0, #8]
    fd0c:	4291      	cmp	r1, r2
    fd0e:	d8f6      	bhi.n	fcfe <create_free_list+0x12>
	return 0;
    fd10:	2000      	movs	r0, #0
    fd12:	4770      	bx	lr
		return -EINVAL;
    fd14:	f06f 0015 	mvn.w	r0, #21
}
    fd18:	4770      	bx	lr

0000fd1a <k_mem_slab_init>:
{
    fd1a:	b510      	push	{r4, lr}
    fd1c:	4604      	mov	r4, r0
	slab->num_blocks = num_blocks;
    fd1e:	6083      	str	r3, [r0, #8]
	slab->block_size = block_size;
    fd20:	60c2      	str	r2, [r0, #12]
	slab->buffer = buffer;
    fd22:	6101      	str	r1, [r0, #16]
	slab->num_used = 0U;
    fd24:	2300      	movs	r3, #0
    fd26:	6183      	str	r3, [r0, #24]
	rc = create_free_list(slab);
    fd28:	f7ff ffe0 	bl	fcec <create_free_list>
	if (rc < 0) {
    fd2c:	2800      	cmp	r0, #0
    fd2e:	db01      	blt.n	fd34 <k_mem_slab_init+0x1a>
	list->head = (sys_dnode_t *)list;
    fd30:	6024      	str	r4, [r4, #0]
	list->tail = (sys_dnode_t *)list;
    fd32:	6064      	str	r4, [r4, #4]
}
    fd34:	bd10      	pop	{r4, pc}

0000fd36 <k_mem_pool_malloc>:
	if (size_add_overflow(size, WB_UP(sizeof(struct k_mem_block_id)),
    fd36:	f111 0208 	adds.w	r2, r1, #8
    fd3a:	d214      	bcs.n	fd66 <k_mem_pool_malloc+0x30>
{
    fd3c:	b530      	push	{r4, r5, lr}
    fd3e:	b085      	sub	sp, #20
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
    fd40:	2400      	movs	r4, #0
    fd42:	2500      	movs	r5, #0
    fd44:	e9cd 4500 	strd	r4, r5, [sp]
    fd48:	a902      	add	r1, sp, #8
    fd4a:	f7ff ffae 	bl	fcaa <k_mem_pool_alloc>
    fd4e:	b940      	cbnz	r0, fd62 <k_mem_pool_malloc+0x2c>
	(void)memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));
    fd50:	9a02      	ldr	r2, [sp, #8]
    fd52:	ab02      	add	r3, sp, #8
    fd54:	cb03      	ldmia	r3!, {r0, r1}
    fd56:	6010      	str	r0, [r2, #0]
    fd58:	6051      	str	r1, [r2, #4]
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
    fd5a:	9802      	ldr	r0, [sp, #8]
    fd5c:	3008      	adds	r0, #8
}
    fd5e:	b005      	add	sp, #20
    fd60:	bd30      	pop	{r4, r5, pc}
		return NULL;
    fd62:	2000      	movs	r0, #0
    fd64:	e7fb      	b.n	fd5e <k_mem_pool_malloc+0x28>
		return NULL;
    fd66:	2000      	movs	r0, #0
}
    fd68:	4770      	bx	lr

0000fd6a <k_free>:
	if (ptr != NULL) {
    fd6a:	b120      	cbz	r0, fd76 <k_free+0xc>
{
    fd6c:	b508      	push	{r3, lr}
		k_mem_pool_free_id(ptr);
    fd6e:	3808      	subs	r0, #8
    fd70:	f7ff ffb6 	bl	fce0 <k_mem_pool_free_id>
}
    fd74:	bd08      	pop	{r3, pc}
    fd76:	4770      	bx	lr

0000fd78 <z_impl_k_msgq_purge>:
}
#include <syscalls/k_msgq_peek_mrsh.c>
#endif

void z_impl_k_msgq_purge(struct k_msgq *msgq)
{
    fd78:	b570      	push	{r4, r5, r6, lr}
    fd7a:	4604      	mov	r4, r0
	k_spinlock_key_t key;
	struct k_thread *pending_thread;

	key = k_spin_lock(&msgq->lock);
    fd7c:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
    fd80:	f04f 0320 	mov.w	r3, #32
    fd84:	f3ef 8611 	mrs	r6, BASEPRI
    fd88:	f383 8811 	msr	BASEPRI, r3
    fd8c:	f3bf 8f6f 	isb	sy

	/* wake up any threads that are waiting to write */
	while ((pending_thread = z_unpend_first_thread(&msgq->wait_q)) != NULL) {
    fd90:	4620      	mov	r0, r4
    fd92:	f000 fa32 	bl	101fa <z_unpend_first_thread>
    fd96:	4603      	mov	r3, r0
    fd98:	b130      	cbz	r0, fda8 <z_impl_k_msgq_purge+0x30>
    fd9a:	f06f 0222 	mvn.w	r2, #34	; 0x22
    fd9e:	671a      	str	r2, [r3, #112]	; 0x70
		arch_thread_return_value_set(pending_thread, -ENOMSG);
		z_ready_thread(pending_thread);
    fda0:	4618      	mov	r0, r3
    fda2:	f000 f982 	bl	100aa <z_ready_thread>
    fda6:	e7f3      	b.n	fd90 <z_impl_k_msgq_purge+0x18>
	}

	msgq->used_msgs = 0;
    fda8:	2300      	movs	r3, #0
    fdaa:	6223      	str	r3, [r4, #32]
	msgq->read_ptr = msgq->write_ptr;
    fdac:	69e3      	ldr	r3, [r4, #28]
    fdae:	61a3      	str	r3, [r4, #24]

	z_reschedule(&msgq->lock, key);
    fdb0:	4631      	mov	r1, r6
    fdb2:	4628      	mov	r0, r5
    fdb4:	f000 f92e 	bl	10014 <z_reschedule>
}
    fdb8:	bd70      	pop	{r4, r5, r6, pc}

0000fdba <new_prio_for_inheritance>:
	int new_prio = z_is_prio_higher(target, limit) ? target : limit;
    fdba:	4288      	cmp	r0, r1
    fdbc:	da00      	bge.n	fdc0 <new_prio_for_inheritance+0x6>
    fdbe:	4601      	mov	r1, r0
	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
    fdc0:	2900      	cmp	r1, #0
    fdc2:	db01      	blt.n	fdc8 <new_prio_for_inheritance+0xe>
    fdc4:	4608      	mov	r0, r1
    fdc6:	4770      	bx	lr
    fdc8:	2000      	movs	r0, #0
}
    fdca:	4770      	bx	lr

0000fdcc <adjust_owner_prio>:
{
    fdcc:	b508      	push	{r3, lr}
	if (mutex->owner->base.prio != new_prio) {
    fdce:	6880      	ldr	r0, [r0, #8]
    fdd0:	f990 300e 	ldrsb.w	r3, [r0, #14]
    fdd4:	428b      	cmp	r3, r1
    fdd6:	d101      	bne.n	fddc <adjust_owner_prio+0x10>
	return false;
    fdd8:	2000      	movs	r0, #0
}
    fdda:	bd08      	pop	{r3, pc}
		return z_set_prio(mutex->owner, new_prio);
    fddc:	f7fb f962 	bl	b0a4 <z_set_prio>
    fde0:	e7fb      	b.n	fdda <adjust_owner_prio+0xe>

0000fde2 <prepare_thread_to_run>:
{
    fde2:	b508      	push	{r3, lr}
    fde4:	2200      	movs	r2, #0
    fde6:	6702      	str	r2, [r0, #112]	; 0x70
    fde8:	6141      	str	r1, [r0, #20]
	z_ready_thread(thread);
    fdea:	f000 f95e 	bl	100aa <z_ready_thread>
}
    fdee:	bd08      	pop	{r3, pc}

0000fdf0 <queue_insert>:
{
    fdf0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    fdf4:	4607      	mov	r7, r0
    fdf6:	4688      	mov	r8, r1
    fdf8:	4614      	mov	r4, r2
    fdfa:	461d      	mov	r5, r3
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
    fdfc:	f100 0608 	add.w	r6, r0, #8
    fe00:	f04f 0320 	mov.w	r3, #32
    fe04:	f3ef 8911 	mrs	r9, BASEPRI
    fe08:	f383 8811 	msr	BASEPRI, r3
    fe0c:	f3bf 8f6f 	isb	sy
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
    fe10:	4630      	mov	r0, r6
    fe12:	f000 f9f2 	bl	101fa <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
    fe16:	b9b8      	cbnz	r0, fe48 <queue_insert+0x58>
	if (alloc) {
    fe18:	b9fd      	cbnz	r5, fe5a <queue_insert+0x6a>
	node->next_and_flags = flags;
    fe1a:	2300      	movs	r3, #0
    fe1c:	6023      	str	r3, [r4, #0]
Z_GENLIST_INSERT(sflist, sfnode)
    fe1e:	f1b8 0f00 	cmp.w	r8, #0
    fe22:	d02a      	beq.n	fe7a <queue_insert+0x8a>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
    fe24:	f8d8 3000 	ldr.w	r3, [r8]
Z_GENLIST_INSERT(sflist, sfnode)
    fe28:	f033 0303 	bics.w	r3, r3, #3
    fe2c:	d133      	bne.n	fe96 <queue_insert+0xa6>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
    fe2e:	6823      	ldr	r3, [r4, #0]
    fe30:	f003 0303 	and.w	r3, r3, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
    fe34:	6023      	str	r3, [r4, #0]
	return list->tail;
    fe36:	687a      	ldr	r2, [r7, #4]
Z_GENLIST_APPEND(sflist, sfnode)
    fe38:	b352      	cbz	r2, fe90 <queue_insert+0xa0>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
    fe3a:	6813      	ldr	r3, [r2, #0]
    fe3c:	f003 0303 	and.w	r3, r3, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
    fe40:	4323      	orrs	r3, r4
    fe42:	6013      	str	r3, [r2, #0]
	list->tail = node;
    fe44:	607c      	str	r4, [r7, #4]
}
    fe46:	e032      	b.n	feae <queue_insert+0xbe>
		prepare_thread_to_run(first_pending_thread, data);
    fe48:	4621      	mov	r1, r4
    fe4a:	f7ff ffca 	bl	fde2 <prepare_thread_to_run>
		z_reschedule(&queue->lock, key);
    fe4e:	4649      	mov	r1, r9
    fe50:	4630      	mov	r0, r6
    fe52:	f000 f8df 	bl	10014 <z_reschedule>
		return 0;
    fe56:	2000      	movs	r0, #0
    fe58:	e033      	b.n	fec2 <queue_insert+0xd2>
		anode = z_thread_malloc(sizeof(*anode));
    fe5a:	2008      	movs	r0, #8
    fe5c:	f7fa fca6 	bl	a7ac <z_thread_malloc>
		if (anode == NULL) {
    fe60:	b120      	cbz	r0, fe6c <queue_insert+0x7c>
		anode->data = data;
    fe62:	6044      	str	r4, [r0, #4]
	node->next_and_flags = flags;
    fe64:	2201      	movs	r2, #1
    fe66:	6002      	str	r2, [r0, #0]
		data = anode;
    fe68:	4604      	mov	r4, r0
    fe6a:	e7d8      	b.n	fe1e <queue_insert+0x2e>
	__asm__ volatile(
    fe6c:	f389 8811 	msr	BASEPRI, r9
    fe70:	f3bf 8f6f 	isb	sy
			return -ENOMEM;
    fe74:	f06f 000b 	mvn.w	r0, #11
    fe78:	e023      	b.n	fec2 <queue_insert+0xd2>
	return list->head;
    fe7a:	683a      	ldr	r2, [r7, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
    fe7c:	6823      	ldr	r3, [r4, #0]
    fe7e:	f003 0303 	and.w	r3, r3, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
    fe82:	4313      	orrs	r3, r2
    fe84:	6023      	str	r3, [r4, #0]
	list->head = node;
    fe86:	603c      	str	r4, [r7, #0]
	return list->tail;
    fe88:	687b      	ldr	r3, [r7, #4]
Z_GENLIST_PREPEND(sflist, sfnode)
    fe8a:	b983      	cbnz	r3, feae <queue_insert+0xbe>
	list->tail = node;
    fe8c:	607c      	str	r4, [r7, #4]
}
    fe8e:	e00e      	b.n	feae <queue_insert+0xbe>
	list->tail = node;
    fe90:	607c      	str	r4, [r7, #4]
	list->head = node;
    fe92:	603c      	str	r4, [r7, #0]
}
    fe94:	e00b      	b.n	feae <queue_insert+0xbe>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
    fe96:	6822      	ldr	r2, [r4, #0]
    fe98:	f002 0203 	and.w	r2, r2, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
    fe9c:	4313      	orrs	r3, r2
    fe9e:	6023      	str	r3, [r4, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
    fea0:	f8d8 3000 	ldr.w	r3, [r8]
    fea4:	f003 0303 	and.w	r3, r3, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
    fea8:	431c      	orrs	r4, r3
    feaa:	f8c8 4000 	str.w	r4, [r8]
	z_handle_obj_poll_events(&queue->poll_events, state);
    feae:	2104      	movs	r1, #4
    feb0:	f107 0010 	add.w	r0, r7, #16
    feb4:	f000 fb56 	bl	10564 <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
    feb8:	4649      	mov	r1, r9
    feba:	4630      	mov	r0, r6
    febc:	f000 f8aa 	bl	10014 <z_reschedule>
	return 0;
    fec0:	2000      	movs	r0, #0
}
    fec2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0000fec6 <z_queue_node_peek>:
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (u8_t)0)) {
    fec6:	b160      	cbz	r0, fee2 <z_queue_node_peek+0x1c>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
    fec8:	6803      	ldr	r3, [r0, #0]
    feca:	f013 0f03 	tst.w	r3, #3
    fece:	d008      	beq.n	fee2 <z_queue_node_peek+0x1c>
{
    fed0:	b510      	push	{r4, lr}
		ret = anode->data;
    fed2:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
    fed4:	b909      	cbnz	r1, feda <z_queue_node_peek+0x14>
		ret = anode->data;
    fed6:	4620      	mov	r0, r4
}
    fed8:	bd10      	pop	{r4, pc}
			k_free(anode);
    feda:	f7ff ff46 	bl	fd6a <k_free>
		ret = anode->data;
    fede:	4620      	mov	r0, r4
    fee0:	e7fa      	b.n	fed8 <z_queue_node_peek+0x12>
}
    fee2:	4770      	bx	lr

0000fee4 <z_impl_k_queue_init>:
	list->head = NULL;
    fee4:	2300      	movs	r3, #0
    fee6:	6003      	str	r3, [r0, #0]
	list->tail = NULL;
    fee8:	6043      	str	r3, [r0, #4]
    feea:	f100 0308 	add.w	r3, r0, #8
	list->head = (sys_dnode_t *)list;
    feee:	6083      	str	r3, [r0, #8]
	list->tail = (sys_dnode_t *)list;
    fef0:	60c3      	str	r3, [r0, #12]
	sys_dlist_init(&queue->poll_events);
    fef2:	f100 0310 	add.w	r3, r0, #16
	list->head = (sys_dnode_t *)list;
    fef6:	6103      	str	r3, [r0, #16]
	list->tail = (sys_dnode_t *)list;
    fef8:	6143      	str	r3, [r0, #20]
}
    fefa:	4770      	bx	lr

0000fefc <k_queue_append>:
{
    fefc:	b508      	push	{r3, lr}
    fefe:	460a      	mov	r2, r1
	(void)queue_insert(queue, sys_sflist_peek_tail(&queue->data_q),
    ff00:	2300      	movs	r3, #0
    ff02:	6841      	ldr	r1, [r0, #4]
    ff04:	f7ff ff74 	bl	fdf0 <queue_insert>
}
    ff08:	bd08      	pop	{r3, pc}

0000ff0a <k_queue_prepend>:
{
    ff0a:	b508      	push	{r3, lr}
    ff0c:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false);
    ff0e:	2300      	movs	r3, #0
    ff10:	4619      	mov	r1, r3
    ff12:	f7ff ff6d 	bl	fdf0 <queue_insert>
}
    ff16:	bd08      	pop	{r3, pc}

0000ff18 <k_queue_append_list>:
	CHECKIF(head == NULL || tail == NULL) {
    ff18:	b3a1      	cbz	r1, ff84 <k_queue_append_list+0x6c>
{
    ff1a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ff1e:	4606      	mov	r6, r0
    ff20:	4617      	mov	r7, r2
    ff22:	460c      	mov	r4, r1
	CHECKIF(head == NULL || tail == NULL) {
    ff24:	b38a      	cbz	r2, ff8a <k_queue_append_list+0x72>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
    ff26:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
    ff2a:	f04f 0320 	mov.w	r3, #32
    ff2e:	f3ef 8811 	mrs	r8, BASEPRI
    ff32:	f383 8811 	msr	BASEPRI, r3
    ff36:	f3bf 8f6f 	isb	sy
		thread = z_unpend_first_thread(&queue->wait_q);
    ff3a:	4628      	mov	r0, r5
    ff3c:	f000 f95d 	bl	101fa <z_unpend_first_thread>
    ff40:	e006      	b.n	ff50 <k_queue_append_list+0x38>
		prepare_thread_to_run(thread, head);
    ff42:	4621      	mov	r1, r4
    ff44:	f7ff ff4d 	bl	fde2 <prepare_thread_to_run>
		head = *(void **)head;
    ff48:	6824      	ldr	r4, [r4, #0]
		thread = z_unpend_first_thread(&queue->wait_q);
    ff4a:	4628      	mov	r0, r5
    ff4c:	f000 f955 	bl	101fa <z_unpend_first_thread>
	while ((head != NULL) && (thread != NULL)) {
    ff50:	b10c      	cbz	r4, ff56 <k_queue_append_list+0x3e>
    ff52:	2800      	cmp	r0, #0
    ff54:	d1f5      	bne.n	ff42 <k_queue_append_list+0x2a>
	if (head != NULL) {
    ff56:	b13c      	cbz	r4, ff68 <k_queue_append_list+0x50>
	return list->tail;
    ff58:	6872      	ldr	r2, [r6, #4]
Z_GENLIST_APPEND_LIST(sflist, sfnode)
    ff5a:	b18a      	cbz	r2, ff80 <k_queue_append_list+0x68>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
    ff5c:	6813      	ldr	r3, [r2, #0]
    ff5e:	f003 0303 	and.w	r3, r3, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
    ff62:	431c      	orrs	r4, r3
    ff64:	6014      	str	r4, [r2, #0]
	list->tail = node;
    ff66:	6077      	str	r7, [r6, #4]
	z_handle_obj_poll_events(&queue->poll_events, state);
    ff68:	2104      	movs	r1, #4
    ff6a:	f106 0010 	add.w	r0, r6, #16
    ff6e:	f000 faf9 	bl	10564 <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
    ff72:	4641      	mov	r1, r8
    ff74:	4628      	mov	r0, r5
    ff76:	f000 f84d 	bl	10014 <z_reschedule>
	return 0;
    ff7a:	2000      	movs	r0, #0
}
    ff7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	list->head = node;
    ff80:	6034      	str	r4, [r6, #0]
}
    ff82:	e7f0      	b.n	ff66 <k_queue_append_list+0x4e>
		return -EINVAL;
    ff84:	f06f 0015 	mvn.w	r0, #21
}
    ff88:	4770      	bx	lr
		return -EINVAL;
    ff8a:	f06f 0015 	mvn.w	r0, #21
    ff8e:	e7f5      	b.n	ff7c <k_queue_append_list+0x64>

0000ff90 <pended_on>:
}
    ff90:	6880      	ldr	r0, [r0, #8]
    ff92:	4770      	bx	lr

0000ff94 <z_is_t1_higher_prio_than_t2>:
	if (thread_1->base.prio < thread_2->base.prio) {
    ff94:	f990 200e 	ldrsb.w	r2, [r0, #14]
    ff98:	f991 300e 	ldrsb.w	r3, [r1, #14]
    ff9c:	429a      	cmp	r2, r3
    ff9e:	db01      	blt.n	ffa4 <z_is_t1_higher_prio_than_t2+0x10>
	return false;
    ffa0:	2000      	movs	r0, #0
    ffa2:	4770      	bx	lr
		return true;
    ffa4:	2001      	movs	r0, #1
}
    ffa6:	4770      	bx	lr

0000ffa8 <z_find_first_thread_to_unpend>:
{
    ffa8:	b538      	push	{r3, r4, r5, lr}
    ffaa:	4605      	mov	r5, r0
	LOCKED(&sched_spinlock) {
    ffac:	2300      	movs	r3, #0
    ffae:	f04f 0220 	mov.w	r2, #32
    ffb2:	f3ef 8411 	mrs	r4, BASEPRI
    ffb6:	f382 8811 	msr	BASEPRI, r2
    ffba:	f3bf 8f6f 	isb	sy
	struct k_thread *ret = NULL;
    ffbe:	4618      	mov	r0, r3
	LOCKED(&sched_spinlock) {
    ffc0:	b943      	cbnz	r3, ffd4 <z_find_first_thread_to_unpend+0x2c>
		ret = _priq_wait_best(&wait_q->waitq);
    ffc2:	4628      	mov	r0, r5
    ffc4:	f000 f86a 	bl	1009c <z_priq_dumb_best>
	__asm__ volatile(
    ffc8:	f384 8811 	msr	BASEPRI, r4
    ffcc:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    ffd0:	2301      	movs	r3, #1
    ffd2:	e7f5      	b.n	ffc0 <z_find_first_thread_to_unpend+0x18>
}
    ffd4:	bd38      	pop	{r3, r4, r5, pc}

0000ffd6 <z_unpend_thread_no_timeout>:
{
    ffd6:	b538      	push	{r3, r4, r5, lr}
    ffd8:	4604      	mov	r4, r0
	LOCKED(&sched_spinlock) {
    ffda:	2300      	movs	r3, #0
	__asm__ volatile(
    ffdc:	f04f 0220 	mov.w	r2, #32
    ffe0:	f3ef 8511 	mrs	r5, BASEPRI
    ffe4:	f382 8811 	msr	BASEPRI, r2
    ffe8:	f3bf 8f6f 	isb	sy
    ffec:	b98b      	cbnz	r3, 10012 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x13>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
    ffee:	4620      	mov	r0, r4
    fff0:	f7ff ffce 	bl	ff90 <pended_on>
    fff4:	4621      	mov	r1, r4
    fff6:	f7fa fe23 	bl	ac40 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    fffa:	7b63      	ldrb	r3, [r4, #13]
    fffc:	f023 0302 	bic.w	r3, r3, #2
   10000:	7363      	strb	r3, [r4, #13]
		thread->base.pended_on = NULL;
   10002:	2300      	movs	r3, #0
   10004:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
   10006:	f385 8811 	msr	BASEPRI, r5
   1000a:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   1000e:	2301      	movs	r3, #1
   10010:	e7ec      	b.n	ffec <z_unpend_thread_no_timeout+0x16>
}
   10012:	bd38      	pop	{r3, r4, r5, pc}

00010014 <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   10014:	4608      	mov	r0, r1
   10016:	b959      	cbnz	r1, 10030 <z_reschedule+0x1c>
{
   10018:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   1001a:	f3ef 8305 	mrs	r3, IPSR
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   1001e:	b913      	cbnz	r3, 10026 <z_reschedule+0x12>
   10020:	f7f2 fbce 	bl	27c0 <arch_swap>
	return ret;
   10024:	e003      	b.n	1002e <z_reschedule+0x1a>
   10026:	f381 8811 	msr	BASEPRI, r1
   1002a:	f3bf 8f6f 	isb	sy
}
   1002e:	bd08      	pop	{r3, pc}
   10030:	f381 8811 	msr	BASEPRI, r1
   10034:	f3bf 8f6f 	isb	sy
   10038:	4770      	bx	lr

0001003a <z_reschedule_irqlock>:
{
   1003a:	b508      	push	{r3, lr}
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   1003c:	4603      	mov	r3, r0
   1003e:	b928      	cbnz	r0, 1004c <z_reschedule_irqlock+0x12>
   10040:	f3ef 8205 	mrs	r2, IPSR
   10044:	b912      	cbnz	r2, 1004c <z_reschedule_irqlock+0x12>
	ret = arch_swap(key);
   10046:	f7f2 fbbb 	bl	27c0 <arch_swap>
	return ret;
   1004a:	e003      	b.n	10054 <z_reschedule_irqlock+0x1a>
   1004c:	f383 8811 	msr	BASEPRI, r3
   10050:	f3bf 8f6f 	isb	sy
}
   10054:	bd08      	pop	{r3, pc}

00010056 <z_unpend_thread>:
{
   10056:	b538      	push	{r3, r4, r5, lr}
   10058:	4604      	mov	r4, r0
	LOCKED(&sched_spinlock) {
   1005a:	2300      	movs	r3, #0
	__asm__ volatile(
   1005c:	f04f 0220 	mov.w	r2, #32
   10060:	f3ef 8511 	mrs	r5, BASEPRI
   10064:	f382 8811 	msr	BASEPRI, r2
   10068:	f3bf 8f6f 	isb	sy
   1006c:	b98b      	cbnz	r3, 10092 <z_unpend_thread+0x3c>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   1006e:	4620      	mov	r0, r4
   10070:	f7ff ff8e 	bl	ff90 <pended_on>
   10074:	4621      	mov	r1, r4
   10076:	f7fa fde3 	bl	ac40 <z_priq_dumb_remove>
   1007a:	7b63      	ldrb	r3, [r4, #13]
   1007c:	f023 0302 	bic.w	r3, r3, #2
   10080:	7363      	strb	r3, [r4, #13]
		thread->base.pended_on = NULL;
   10082:	2300      	movs	r3, #0
   10084:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
   10086:	f385 8811 	msr	BASEPRI, r5
   1008a:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   1008e:	2301      	movs	r3, #1
   10090:	e7ec      	b.n	1006c <z_unpend_thread+0x16>
	return z_abort_timeout(&thread->base.timeout);
   10092:	f104 0018 	add.w	r0, r4, #24
   10096:	f000 f95e 	bl	10356 <z_abort_timeout>
}
   1009a:	bd38      	pop	{r3, r4, r5, pc}

0001009c <z_priq_dumb_best>:
{
   1009c:	4603      	mov	r3, r0
	return list->head == list;
   1009e:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   100a0:	4283      	cmp	r3, r0
   100a2:	d000      	beq.n	100a6 <z_priq_dumb_best+0xa>
}
   100a4:	4770      	bx	lr
	struct k_thread *thread = NULL;
   100a6:	2000      	movs	r0, #0
	return thread;
   100a8:	e7fc      	b.n	100a4 <z_priq_dumb_best+0x8>

000100aa <z_ready_thread>:
{
   100aa:	b538      	push	{r3, r4, r5, lr}
   100ac:	4605      	mov	r5, r0
	LOCKED(&sched_spinlock) {
   100ae:	2300      	movs	r3, #0
	__asm__ volatile(
   100b0:	f04f 0220 	mov.w	r2, #32
   100b4:	f3ef 8411 	mrs	r4, BASEPRI
   100b8:	f382 8811 	msr	BASEPRI, r2
   100bc:	f3bf 8f6f 	isb	sy
   100c0:	b943      	cbnz	r3, 100d4 <z_ready_thread+0x2a>
		ready_thread(thread);
   100c2:	4628      	mov	r0, r5
   100c4:	f7fa fe24 	bl	ad10 <ready_thread>
	__asm__ volatile(
   100c8:	f384 8811 	msr	BASEPRI, r4
   100cc:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   100d0:	2301      	movs	r3, #1
   100d2:	e7f5      	b.n	100c0 <z_ready_thread+0x16>
}
   100d4:	bd38      	pop	{r3, r4, r5, pc}

000100d6 <z_thread_timeout>:
{
   100d6:	b570      	push	{r4, r5, r6, lr}
   100d8:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
   100da:	f1a0 0518 	sub.w	r5, r0, #24
	if (thread->base.pended_on != NULL) {
   100de:	f850 3c10 	ldr.w	r3, [r0, #-16]
   100e2:	b1fb      	cbz	r3, 10124 <z_thread_timeout+0x4e>
	LOCKED(&sched_spinlock) {
   100e4:	2300      	movs	r3, #0
	__asm__ volatile(
   100e6:	f04f 0220 	mov.w	r2, #32
   100ea:	f3ef 8611 	mrs	r6, BASEPRI
   100ee:	f382 8811 	msr	BASEPRI, r2
   100f2:	f3bf 8f6f 	isb	sy
   100f6:	e013      	b.n	10120 <z_thread_timeout+0x4a>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   100f8:	4628      	mov	r0, r5
   100fa:	f7ff ff49 	bl	ff90 <pended_on>
   100fe:	4629      	mov	r1, r5
   10100:	f7fa fd9e 	bl	ac40 <z_priq_dumb_remove>
   10104:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
   10108:	f023 0302 	bic.w	r3, r3, #2
   1010c:	f804 3c0b 	strb.w	r3, [r4, #-11]
		thread->base.pended_on = NULL;
   10110:	2300      	movs	r3, #0
   10112:	f844 3c10 	str.w	r3, [r4, #-16]
	__asm__ volatile(
   10116:	f386 8811 	msr	BASEPRI, r6
   1011a:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   1011e:	2301      	movs	r3, #1
   10120:	2b00      	cmp	r3, #0
   10122:	d0e9      	beq.n	100f8 <z_thread_timeout+0x22>
	thread->base.thread_state &= ~_THREAD_PRESTART;
   10124:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   10128:	f003 03eb 	and.w	r3, r3, #235	; 0xeb
   1012c:	f804 3c0b 	strb.w	r3, [r4, #-11]
	z_ready_thread(thread);
   10130:	4628      	mov	r0, r5
   10132:	f7ff ffba 	bl	100aa <z_ready_thread>
}
   10136:	bd70      	pop	{r4, r5, r6, pc}

00010138 <z_remove_thread_from_ready_q>:
{
   10138:	b538      	push	{r3, r4, r5, lr}
   1013a:	4605      	mov	r5, r0
	LOCKED(&sched_spinlock) {
   1013c:	2300      	movs	r3, #0
	__asm__ volatile(
   1013e:	f04f 0220 	mov.w	r2, #32
   10142:	f3ef 8411 	mrs	r4, BASEPRI
   10146:	f382 8811 	msr	BASEPRI, r2
   1014a:	f3bf 8f6f 	isb	sy
   1014e:	b943      	cbnz	r3, 10162 <z_remove_thread_from_ready_q+0x2a>
		unready_thread(thread);
   10150:	4628      	mov	r0, r5
   10152:	f7fa ff77 	bl	b044 <unready_thread>
	__asm__ volatile(
   10156:	f384 8811 	msr	BASEPRI, r4
   1015a:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   1015e:	2301      	movs	r3, #1
   10160:	e7f5      	b.n	1014e <z_remove_thread_from_ready_q+0x16>
}
   10162:	bd38      	pop	{r3, r4, r5, pc}

00010164 <add_to_waitq_locked>:
{
   10164:	b570      	push	{r4, r5, r6, lr}
   10166:	4605      	mov	r5, r0
   10168:	460e      	mov	r6, r1
	unready_thread(thread);
   1016a:	f7fa ff6b 	bl	b044 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   1016e:	7b6b      	ldrb	r3, [r5, #13]
   10170:	f043 0302 	orr.w	r3, r3, #2
   10174:	736b      	strb	r3, [r5, #13]
	if (wait_q != NULL) {
   10176:	b1ae      	cbz	r6, 101a4 <add_to_waitq_locked+0x40>
		thread->base.pended_on = wait_q;
   10178:	60ae      	str	r6, [r5, #8]
	return list->head == list;
   1017a:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1017c:	42a6      	cmp	r6, r4
   1017e:	d019      	beq.n	101b4 <add_to_waitq_locked+0x50>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   10180:	b15c      	cbz	r4, 1019a <add_to_waitq_locked+0x36>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
   10182:	4621      	mov	r1, r4
   10184:	4628      	mov	r0, r5
   10186:	f7ff ff05 	bl	ff94 <z_is_t1_higher_prio_than_t2>
   1018a:	b960      	cbnz	r0, 101a6 <add_to_waitq_locked+0x42>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   1018c:	b12c      	cbz	r4, 1019a <add_to_waitq_locked+0x36>
	return (node == list->tail) ? NULL : node->next;
   1018e:	6873      	ldr	r3, [r6, #4]
   10190:	429c      	cmp	r4, r3
   10192:	d002      	beq.n	1019a <add_to_waitq_locked+0x36>
   10194:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   10196:	2c00      	cmp	r4, #0
   10198:	d1f2      	bne.n	10180 <add_to_waitq_locked+0x1c>
	node->next = list;
   1019a:	602e      	str	r6, [r5, #0]
	node->prev = list->tail;
   1019c:	6873      	ldr	r3, [r6, #4]
   1019e:	606b      	str	r3, [r5, #4]
	list->tail->next = node;
   101a0:	601d      	str	r5, [r3, #0]
	list->tail = node;
   101a2:	6075      	str	r5, [r6, #4]
}
   101a4:	bd70      	pop	{r4, r5, r6, pc}
	node->prev = successor->prev;
   101a6:	6863      	ldr	r3, [r4, #4]
   101a8:	606b      	str	r3, [r5, #4]
	node->next = successor;
   101aa:	602c      	str	r4, [r5, #0]
	successor->prev->next = node;
   101ac:	6863      	ldr	r3, [r4, #4]
   101ae:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   101b0:	6065      	str	r5, [r4, #4]
}
   101b2:	e7f7      	b.n	101a4 <add_to_waitq_locked+0x40>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   101b4:	2400      	movs	r4, #0
   101b6:	e7e3      	b.n	10180 <add_to_waitq_locked+0x1c>

000101b8 <pend>:
{
   101b8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   101bc:	4605      	mov	r5, r0
   101be:	460f      	mov	r7, r1
   101c0:	4691      	mov	r9, r2
   101c2:	4698      	mov	r8, r3
	LOCKED(&sched_spinlock) {
   101c4:	2400      	movs	r4, #0
	__asm__ volatile(
   101c6:	f04f 0320 	mov.w	r3, #32
   101ca:	f3ef 8611 	mrs	r6, BASEPRI
   101ce:	f383 8811 	msr	BASEPRI, r3
   101d2:	f3bf 8f6f 	isb	sy
   101d6:	b94c      	cbnz	r4, 101ec <pend+0x34>
		add_to_waitq_locked(thread, wait_q);
   101d8:	4639      	mov	r1, r7
   101da:	4628      	mov	r0, r5
   101dc:	f7ff ffc2 	bl	10164 <add_to_waitq_locked>
	__asm__ volatile(
   101e0:	f386 8811 	msr	BASEPRI, r6
   101e4:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   101e8:	2401      	movs	r4, #1
   101ea:	e7f4      	b.n	101d6 <pend+0x1e>
	add_thread_timeout(thread, timeout);
   101ec:	464a      	mov	r2, r9
   101ee:	4643      	mov	r3, r8
   101f0:	4628      	mov	r0, r5
   101f2:	f7fa fcb3 	bl	ab5c <add_thread_timeout>
}
   101f6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000101fa <z_unpend_first_thread>:
{
   101fa:	b570      	push	{r4, r5, r6, lr}
   101fc:	4606      	mov	r6, r0
	LOCKED(&sched_spinlock) {
   101fe:	2300      	movs	r3, #0
	__asm__ volatile(
   10200:	f04f 0220 	mov.w	r2, #32
   10204:	f3ef 8511 	mrs	r5, BASEPRI
   10208:	f382 8811 	msr	BASEPRI, r2
   1020c:	f3bf 8f6f 	isb	sy
	struct k_thread *ret = NULL;
   10210:	461c      	mov	r4, r3
	LOCKED(&sched_spinlock) {
   10212:	b94b      	cbnz	r3, 10228 <z_unpend_first_thread+0x2e>
		ret = _priq_wait_best(&wait_q->waitq);
   10214:	4630      	mov	r0, r6
   10216:	f7ff ff41 	bl	1009c <z_priq_dumb_best>
   1021a:	4604      	mov	r4, r0
	__asm__ volatile(
   1021c:	f385 8811 	msr	BASEPRI, r5
   10220:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   10224:	2301      	movs	r3, #1
   10226:	e7f4      	b.n	10212 <z_unpend_first_thread+0x18>

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   10228:	b1dc      	cbz	r4, 10262 <z_unpend_first_thread+0x68>
	LOCKED(&sched_spinlock) {
   1022a:	2300      	movs	r3, #0
	__asm__ volatile(
   1022c:	f04f 0220 	mov.w	r2, #32
   10230:	f3ef 8511 	mrs	r5, BASEPRI
   10234:	f382 8811 	msr	BASEPRI, r2
   10238:	f3bf 8f6f 	isb	sy
   1023c:	b98b      	cbnz	r3, 10262 <z_unpend_first_thread+0x68>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   1023e:	4620      	mov	r0, r4
   10240:	f7ff fea6 	bl	ff90 <pended_on>
   10244:	4621      	mov	r1, r4
   10246:	f7fa fcfb 	bl	ac40 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   1024a:	7b63      	ldrb	r3, [r4, #13]
   1024c:	f023 0302 	bic.w	r3, r3, #2
   10250:	7363      	strb	r3, [r4, #13]
		thread->base.pended_on = NULL;
   10252:	2300      	movs	r3, #0
   10254:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
   10256:	f385 8811 	msr	BASEPRI, r5
   1025a:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   1025e:	2301      	movs	r3, #1
   10260:	e7ec      	b.n	1023c <z_unpend_first_thread+0x42>
	if (thread != NULL) {
   10262:	b11c      	cbz	r4, 1026c <z_unpend_first_thread+0x72>
   10264:	f104 0018 	add.w	r0, r4, #24
   10268:	f000 f875 	bl	10356 <z_abort_timeout>
}
   1026c:	4620      	mov	r0, r4
   1026e:	bd70      	pop	{r4, r5, r6, pc}

00010270 <z_unpend_all>:
{
   10270:	b538      	push	{r3, r4, r5, lr}
   10272:	4605      	mov	r5, r0
	int need_sched = 0;
   10274:	2000      	movs	r0, #0
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   10276:	e006      	b.n	10286 <z_unpend_all+0x16>
		z_unpend_thread(thread);
   10278:	4620      	mov	r0, r4
   1027a:	f7ff feec 	bl	10056 <z_unpend_thread>
		z_ready_thread(thread);
   1027e:	4620      	mov	r0, r4
   10280:	f7ff ff13 	bl	100aa <z_ready_thread>
		need_sched = 1;
   10284:	2001      	movs	r0, #1
	return list->head == list;
   10286:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   10288:	42a5      	cmp	r5, r4
   1028a:	d001      	beq.n	10290 <z_unpend_all+0x20>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   1028c:	2c00      	cmp	r4, #0
   1028e:	d1f3      	bne.n	10278 <z_unpend_all+0x8>
}
   10290:	bd38      	pop	{r3, r4, r5, pc}

00010292 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || initial_count > limit) {
   10292:	b15a      	cbz	r2, 102ac <z_impl_k_sem_init+0x1a>
   10294:	428a      	cmp	r2, r1
   10296:	d30c      	bcc.n	102b2 <z_impl_k_sem_init+0x20>
	sem->count = initial_count;
   10298:	6081      	str	r1, [r0, #8]
	sem->limit = limit;
   1029a:	60c2      	str	r2, [r0, #12]
	list->head = (sys_dnode_t *)list;
   1029c:	6000      	str	r0, [r0, #0]
	list->tail = (sys_dnode_t *)list;
   1029e:	6040      	str	r0, [r0, #4]
	sys_dlist_init(&sem->poll_events);
   102a0:	f100 0310 	add.w	r3, r0, #16
	list->head = (sys_dnode_t *)list;
   102a4:	6103      	str	r3, [r0, #16]
	list->tail = (sys_dnode_t *)list;
   102a6:	6143      	str	r3, [r0, #20]
	return 0;
   102a8:	2000      	movs	r0, #0
   102aa:	4770      	bx	lr
		return -EINVAL;
   102ac:	f06f 0015 	mvn.w	r0, #21
   102b0:	4770      	bx	lr
   102b2:	f06f 0015 	mvn.w	r0, #21
}
   102b6:	4770      	bx	lr

000102b8 <k_is_in_isr>:
   102b8:	f3ef 8005 	mrs	r0, IPSR
}
   102bc:	3800      	subs	r0, #0
   102be:	bf18      	it	ne
   102c0:	2001      	movne	r0, #1
   102c2:	4770      	bx	lr

000102c4 <z_impl_k_busy_wait>:
{
   102c4:	b508      	push	{r3, lr}
	arch_busy_wait(usec_to_wait);
   102c6:	f7f3 f93f 	bl	3548 <arch_busy_wait>
}
   102ca:	bd08      	pop	{r3, pc}

000102cc <z_impl_k_thread_name_set>:
}
   102cc:	f06f 0057 	mvn.w	r0, #87	; 0x57
   102d0:	4770      	bx	lr

000102d2 <k_thread_name_get>:
}
   102d2:	2000      	movs	r0, #0
   102d4:	4770      	bx	lr

000102d6 <z_impl_k_thread_start>:
{
   102d6:	b508      	push	{r3, lr}
	z_sched_start(thread);
   102d8:	f7fa fd56 	bl	ad88 <z_sched_start>
}
   102dc:	bd08      	pop	{r3, pc}

000102de <z_init_thread_base>:
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
   102de:	7303      	strb	r3, [r0, #12]
	thread_base->thread_state = (u8_t)initial_state;
   102e0:	7342      	strb	r2, [r0, #13]

	thread_base->prio = priority;
   102e2:	7381      	strb	r1, [r0, #14]

	thread_base->sched_locked = 0U;
   102e4:	2300      	movs	r3, #0
   102e6:	73c3      	strb	r3, [r0, #15]
	node->next = NULL;
   102e8:	6183      	str	r3, [r0, #24]
	node->prev = NULL;
   102ea:	61c3      	str	r3, [r0, #28]
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
   102ec:	4770      	bx	lr

000102ee <z_impl_k_thread_create>:
{
   102ee:	b5f0      	push	{r4, r5, r6, r7, lr}
   102f0:	b087      	sub	sp, #28
   102f2:	4604      	mov	r4, r0
   102f4:	e9dd 6712 	ldrd	r6, r7, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   102f8:	2500      	movs	r5, #0
   102fa:	9505      	str	r5, [sp, #20]
   102fc:	9d10      	ldr	r5, [sp, #64]	; 0x40
   102fe:	9504      	str	r5, [sp, #16]
   10300:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   10302:	9503      	str	r5, [sp, #12]
   10304:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   10306:	9502      	str	r5, [sp, #8]
   10308:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   1030a:	9501      	str	r5, [sp, #4]
   1030c:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   1030e:	9500      	str	r5, [sp, #0]
   10310:	f7fb f870 	bl	b3f4 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   10314:	f1b7 3fff 	cmp.w	r7, #4294967295	; 0xffffffff
   10318:	bf08      	it	eq
   1031a:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
   1031e:	d102      	bne.n	10326 <z_impl_k_thread_create+0x38>
}
   10320:	4620      	mov	r0, r4
   10322:	b007      	add	sp, #28
   10324:	bdf0      	pop	{r4, r5, r6, r7, pc}
		schedule_new_thread(new_thread, delay);
   10326:	4632      	mov	r2, r6
   10328:	463b      	mov	r3, r7
   1032a:	4620      	mov	r0, r4
   1032c:	f7fb f850 	bl	b3d0 <schedule_new_thread>
   10330:	e7f6      	b.n	10320 <z_impl_k_thread_create+0x32>

00010332 <remove_timeout>:
{
   10332:	b510      	push	{r4, lr}
   10334:	4604      	mov	r4, r0
	if (next(t) != NULL) {
   10336:	f7fb f907 	bl	b548 <next>
   1033a:	b118      	cbz	r0, 10344 <remove_timeout+0x12>
		next(t)->dticks += t->dticks;
   1033c:	68a1      	ldr	r1, [r4, #8]
   1033e:	6883      	ldr	r3, [r0, #8]
   10340:	440b      	add	r3, r1
   10342:	6083      	str	r3, [r0, #8]
	node->prev->next = node->next;
   10344:	6862      	ldr	r2, [r4, #4]
   10346:	6823      	ldr	r3, [r4, #0]
   10348:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   1034a:	6862      	ldr	r2, [r4, #4]
   1034c:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   1034e:	2300      	movs	r3, #0
   10350:	6023      	str	r3, [r4, #0]
	node->prev = NULL;
   10352:	6063      	str	r3, [r4, #4]
}
   10354:	bd10      	pop	{r4, pc}

00010356 <z_abort_timeout>:
{
   10356:	b570      	push	{r4, r5, r6, lr}
   10358:	4604      	mov	r4, r0
	LOCKED(&timeout_lock) {
   1035a:	2300      	movs	r3, #0
	__asm__ volatile(
   1035c:	f04f 0220 	mov.w	r2, #32
   10360:	f3ef 8611 	mrs	r6, BASEPRI
   10364:	f382 8811 	msr	BASEPRI, r2
   10368:	f3bf 8f6f 	isb	sy
	int ret = -EINVAL;
   1036c:	f06f 0015 	mvn.w	r0, #21
   10370:	e008      	b.n	10384 <z_abort_timeout+0x2e>
			remove_timeout(to);
   10372:	4620      	mov	r0, r4
   10374:	f7ff ffdd 	bl	10332 <remove_timeout>
			ret = 0;
   10378:	4628      	mov	r0, r5
	__asm__ volatile(
   1037a:	f386 8811 	msr	BASEPRI, r6
   1037e:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
   10382:	2301      	movs	r3, #1
   10384:	461d      	mov	r5, r3
   10386:	b91b      	cbnz	r3, 10390 <z_abort_timeout+0x3a>
	return node->next != NULL;
   10388:	6823      	ldr	r3, [r4, #0]
		if (sys_dnode_is_linked(&to->node)) {
   1038a:	2b00      	cmp	r3, #0
   1038c:	d1f1      	bne.n	10372 <z_abort_timeout+0x1c>
   1038e:	e7f4      	b.n	1037a <z_abort_timeout+0x24>
}
   10390:	bd70      	pop	{r4, r5, r6, pc}

00010392 <z_get_next_timeout_expiry>:
{
   10392:	b510      	push	{r4, lr}
	LOCKED(&timeout_lock) {
   10394:	2300      	movs	r3, #0
	__asm__ volatile(
   10396:	f04f 0220 	mov.w	r2, #32
   1039a:	f3ef 8411 	mrs	r4, BASEPRI
   1039e:	f382 8811 	msr	BASEPRI, r2
   103a2:	f3bf 8f6f 	isb	sy
	s32_t ret = (s32_t) K_TICKS_FOREVER;
   103a6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	LOCKED(&timeout_lock) {
   103aa:	b93b      	cbnz	r3, 103bc <z_get_next_timeout_expiry+0x2a>
		ret = next_timeout();
   103ac:	f7fb f8e4 	bl	b578 <next_timeout>
	__asm__ volatile(
   103b0:	f384 8811 	msr	BASEPRI, r4
   103b4:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
   103b8:	2301      	movs	r3, #1
   103ba:	e7f6      	b.n	103aa <z_get_next_timeout_expiry+0x18>
}
   103bc:	bd10      	pop	{r4, pc}

000103be <z_set_timeout_expiry>:
{
   103be:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   103c0:	4606      	mov	r6, r0
   103c2:	460f      	mov	r7, r1
	LOCKED(&timeout_lock) {
   103c4:	2300      	movs	r3, #0
	__asm__ volatile(
   103c6:	f04f 0220 	mov.w	r2, #32
   103ca:	f3ef 8511 	mrs	r5, BASEPRI
   103ce:	f382 8811 	msr	BASEPRI, r2
   103d2:	f3bf 8f6f 	isb	sy
   103d6:	e00a      	b.n	103ee <z_set_timeout_expiry+0x30>
		bool sooner = (next == K_TICKS_FOREVER) || (ticks < next);
   103d8:	2401      	movs	r4, #1
   103da:	f004 0401 	and.w	r4, r4, #1
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   103de:	2801      	cmp	r0, #1
   103e0:	dd00      	ble.n	103e4 <z_set_timeout_expiry+0x26>
   103e2:	b97c      	cbnz	r4, 10404 <z_set_timeout_expiry+0x46>
	__asm__ volatile(
   103e4:	f385 8811 	msr	BASEPRI, r5
   103e8:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
   103ec:	2301      	movs	r3, #1
   103ee:	461c      	mov	r4, r3
   103f0:	b96b      	cbnz	r3, 1040e <z_set_timeout_expiry+0x50>
		int next = next_timeout();
   103f2:	f7fb f8c1 	bl	b578 <next_timeout>
		bool sooner = (next == K_TICKS_FOREVER) || (ticks < next);
   103f6:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
   103fa:	d0ed      	beq.n	103d8 <z_set_timeout_expiry+0x1a>
   103fc:	42b0      	cmp	r0, r6
   103fe:	ddec      	ble.n	103da <z_set_timeout_expiry+0x1c>
   10400:	2401      	movs	r4, #1
   10402:	e7ea      	b.n	103da <z_set_timeout_expiry+0x1c>
			z_clock_set_timeout(ticks, idle);
   10404:	4639      	mov	r1, r7
   10406:	4630      	mov	r0, r6
   10408:	f7f2 f8da 	bl	25c0 <z_clock_set_timeout>
   1040c:	e7ea      	b.n	103e4 <z_set_timeout_expiry+0x26>
}
   1040e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00010410 <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
   10410:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
   10412:	f7fb f999 	bl	b748 <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
   10416:	bd08      	pop	{r3, pc}

00010418 <z_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
u64_t z_timeout_end_calc(k_timeout_t timeout)
{
   10418:	b538      	push	{r3, r4, r5, lr}
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   1041a:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
   1041e:	bf08      	it	eq
   10420:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
   10424:	d015      	beq.n	10452 <z_timeout_end_calc+0x3a>
   10426:	4604      	mov	r4, r0
   10428:	460d      	mov	r5, r1
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   1042a:	ea54 0105 	orrs.w	r1, r4, r5
   1042e:	d00d      	beq.n	1044c <z_timeout_end_calc+0x34>
#ifdef CONFIG_LEGACY_TIMEOUT_API
	dt = k_ms_to_ticks_ceil32(timeout);
#else
	dt = timeout.ticks;

	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   10430:	f06f 0101 	mvn.w	r1, #1
   10434:	1a0a      	subs	r2, r1, r0
   10436:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1043a:	eb61 0305 	sbc.w	r3, r1, r5
   1043e:	2a00      	cmp	r2, #0
   10440:	f173 0100 	sbcs.w	r1, r3, #0
   10444:	db09      	blt.n	1045a <z_timeout_end_calc+0x42>
		return Z_TICK_ABS(dt);
   10446:	4610      	mov	r0, r2
   10448:	4619      	mov	r1, r3
	}
#endif
	return z_tick_get() + MAX(1, dt);
}
   1044a:	bd38      	pop	{r3, r4, r5, pc}
		return z_tick_get();
   1044c:	f7fb f97c 	bl	b748 <z_tick_get>
   10450:	e7fb      	b.n	1044a <z_timeout_end_calc+0x32>
		return UINT64_MAX;
   10452:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   10456:	4601      	mov	r1, r0
   10458:	e7f7      	b.n	1044a <z_timeout_end_calc+0x32>
	return z_tick_get() + MAX(1, dt);
   1045a:	f7fb f975 	bl	b748 <z_tick_get>
   1045e:	4623      	mov	r3, r4
   10460:	462a      	mov	r2, r5
   10462:	2c01      	cmp	r4, #1
   10464:	f175 0400 	sbcs.w	r4, r5, #0
   10468:	db03      	blt.n	10472 <z_timeout_end_calc+0x5a>
   1046a:	18c0      	adds	r0, r0, r3
   1046c:	eb42 0101 	adc.w	r1, r2, r1
   10470:	e7eb      	b.n	1044a <z_timeout_end_calc+0x32>
   10472:	2301      	movs	r3, #1
   10474:	2200      	movs	r2, #0
   10476:	e7f8      	b.n	1046a <z_timeout_end_calc+0x52>

00010478 <k_timer_init>:
	timer->expiry_fn = expiry_fn;
   10478:	6181      	str	r1, [r0, #24]
	timer->stop_fn = stop_fn;
   1047a:	61c2      	str	r2, [r0, #28]
	timer->status = 0U;
   1047c:	2300      	movs	r3, #0
   1047e:	6283      	str	r3, [r0, #40]	; 0x28
   10480:	f100 0210 	add.w	r2, r0, #16
	list->head = (sys_dnode_t *)list;
   10484:	6102      	str	r2, [r0, #16]
	list->tail = (sys_dnode_t *)list;
   10486:	6142      	str	r2, [r0, #20]
	node->next = NULL;
   10488:	6003      	str	r3, [r0, #0]
	node->prev = NULL;
   1048a:	6043      	str	r3, [r0, #4]
	timer->user_data = NULL;
   1048c:	62c3      	str	r3, [r0, #44]	; 0x2c
}
   1048e:	4770      	bx	lr

00010490 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   10490:	b510      	push	{r4, lr}
   10492:	4604      	mov	r4, r0
	int inactive = z_abort_timeout(&timer->timeout) != 0;
   10494:	f7ff ff5f 	bl	10356 <z_abort_timeout>

	if (inactive) {
   10498:	b9d0      	cbnz	r0, 104d0 <z_impl_k_timer_stop+0x40>
		return;
	}

	if (timer->stop_fn != NULL) {
   1049a:	69e3      	ldr	r3, [r4, #28]
   1049c:	b10b      	cbz	r3, 104a2 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   1049e:	4620      	mov	r0, r4
   104a0:	4798      	blx	r3
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
   104a2:	2100      	movs	r1, #0
   104a4:	f104 0010 	add.w	r0, r4, #16
   104a8:	f7ff fd7e 	bl	ffa8 <z_find_first_thread_to_unpend>
	if (thread != NULL) {
   104ac:	4604      	mov	r4, r0
   104ae:	b108      	cbz	r0, 104b4 <z_impl_k_timer_stop+0x24>
		z_unpend_thread_no_timeout(thread);
   104b0:	f7ff fd91 	bl	ffd6 <z_unpend_thread_no_timeout>
	}

	struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);

	if (pending_thread != NULL) {
   104b4:	b164      	cbz	r4, 104d0 <z_impl_k_timer_stop+0x40>
		z_ready_thread(pending_thread);
   104b6:	4620      	mov	r0, r4
   104b8:	f7ff fdf7 	bl	100aa <z_ready_thread>
	__asm__ volatile(
   104bc:	f04f 0320 	mov.w	r3, #32
   104c0:	f3ef 8011 	mrs	r0, BASEPRI
   104c4:	f383 8811 	msr	BASEPRI, r3
   104c8:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   104cc:	f7ff fdb5 	bl	1003a <z_reschedule_irqlock>
		z_reschedule_unlocked();
	}
}
   104d0:	bd10      	pop	{r4, pc}

000104d2 <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, u32_t state)
{
   104d2:	b570      	push	{r4, r5, r6, lr}
   104d4:	4604      	mov	r4, r0
   104d6:	460d      	mov	r5, r1
	struct _poller *poller = event->poller;
   104d8:	6886      	ldr	r6, [r0, #8]
	int retcode = 0;

	if (poller) {
   104da:	b19e      	cbz	r6, 10504 <signal_poll_event+0x32>
		if (poller->cb != NULL) {
   104dc:	68b3      	ldr	r3, [r6, #8]
   104de:	b173      	cbz	r3, 104fe <signal_poll_event+0x2c>
			retcode = poller->cb(event, state);
   104e0:	4798      	blx	r3
		}

		poller->is_polling = false;
   104e2:	2300      	movs	r3, #0
   104e4:	7033      	strb	r3, [r6, #0]

		if (retcode < 0) {
   104e6:	2800      	cmp	r0, #0
   104e8:	db08      	blt.n	104fc <signal_poll_event+0x2a>
	event->poller = NULL;
   104ea:	2300      	movs	r3, #0
   104ec:	60a3      	str	r3, [r4, #8]
	event->state |= state;
   104ee:	68e3      	ldr	r3, [r4, #12]
   104f0:	f3c3 3104 	ubfx	r1, r3, #12, #5
   104f4:	430d      	orrs	r5, r1
   104f6:	f365 3310 	bfi	r3, r5, #12, #5
   104fa:	60e3      	str	r3, [r4, #12]
		}
	}

	set_event_ready(event, state);
	return retcode;
}
   104fc:	bd70      	pop	{r4, r5, r6, pc}
		poller->is_polling = false;
   104fe:	2000      	movs	r0, #0
   10500:	7030      	strb	r0, [r6, #0]
		if (retcode < 0) {
   10502:	e7f2      	b.n	104ea <signal_poll_event+0x18>
	int retcode = 0;
   10504:	2000      	movs	r0, #0
   10506:	e7f0      	b.n	104ea <signal_poll_event+0x18>

00010508 <k_poll_poller_cb>:
{
   10508:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = event->poller->thread;
   1050a:	6883      	ldr	r3, [r0, #8]
   1050c:	685c      	ldr	r4, [r3, #4]
	return (thread->base.thread_state & _THREAD_PENDING) != 0U;
   1050e:	7b63      	ldrb	r3, [r4, #13]
	if (!z_is_thread_pending(thread)) {
   10510:	f013 0f02 	tst.w	r3, #2
   10514:	d021      	beq.n	1055a <k_poll_poller_cb+0x52>
   10516:	460d      	mov	r5, r1
	return thread->base.timeout.dticks == _EXPIRED;
   10518:	6a23      	ldr	r3, [r4, #32]
	if (z_is_thread_timeout_expired(thread)) {
   1051a:	f113 0f02 	cmn.w	r3, #2
   1051e:	d01e      	beq.n	1055e <k_poll_poller_cb+0x56>
	z_unpend_thread(thread);
   10520:	4620      	mov	r0, r4
   10522:	f7ff fd98 	bl	10056 <z_unpend_thread>
	arch_thread_return_value_set(thread,
   10526:	2d08      	cmp	r5, #8
   10528:	d009      	beq.n	1053e <k_poll_poller_cb+0x36>
   1052a:	2300      	movs	r3, #0
   1052c:	6723      	str	r3, [r4, #112]	; 0x70
	u8_t state = thread->base.thread_state;
   1052e:	7b63      	ldrb	r3, [r4, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   10530:	f013 0f1f 	tst.w	r3, #31
   10534:	d108      	bne.n	10548 <k_poll_poller_cb+0x40>
	return node->next != NULL;
   10536:	69a3      	ldr	r3, [r4, #24]
   10538:	b123      	cbz	r3, 10544 <k_poll_poller_cb+0x3c>
   1053a:	2300      	movs	r3, #0
   1053c:	e005      	b.n	1054a <k_poll_poller_cb+0x42>
   1053e:	f06f 0303 	mvn.w	r3, #3
   10542:	e7f3      	b.n	1052c <k_poll_poller_cb+0x24>
   10544:	2301      	movs	r3, #1
   10546:	e000      	b.n	1054a <k_poll_poller_cb+0x42>
   10548:	2300      	movs	r3, #0
	if (!z_is_thread_ready(thread)) {
   1054a:	b90b      	cbnz	r3, 10550 <k_poll_poller_cb+0x48>
		return 0;
   1054c:	2000      	movs	r0, #0
   1054e:	e005      	b.n	1055c <k_poll_poller_cb+0x54>
	z_ready_thread(thread);
   10550:	4620      	mov	r0, r4
   10552:	f7ff fdaa 	bl	100aa <z_ready_thread>
	return 0;
   10556:	2000      	movs	r0, #0
   10558:	e000      	b.n	1055c <k_poll_poller_cb+0x54>
		return 0;
   1055a:	2000      	movs	r0, #0
}
   1055c:	bd38      	pop	{r3, r4, r5, pc}
		return -EAGAIN;
   1055e:	f06f 000a 	mvn.w	r0, #10
   10562:	e7fb      	b.n	1055c <k_poll_poller_cb+0x54>

00010564 <z_handle_obj_poll_events>:

void z_handle_obj_poll_events(sys_dlist_t *events, u32_t state)
{
   10564:	b508      	push	{r3, lr}
   10566:	4603      	mov	r3, r0
	return list->head == list;
   10568:	6800      	ldr	r0, [r0, #0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   1056a:	4283      	cmp	r3, r0
   1056c:	d00a      	beq.n	10584 <z_handle_obj_poll_events+0x20>
	node->prev->next = node->next;
   1056e:	6842      	ldr	r2, [r0, #4]
   10570:	6803      	ldr	r3, [r0, #0]
   10572:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   10574:	6842      	ldr	r2, [r0, #4]
   10576:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   10578:	2300      	movs	r3, #0
   1057a:	6003      	str	r3, [r0, #0]
	node->prev = NULL;
   1057c:	6043      	str	r3, [r0, #4]
	struct k_poll_event *poll_event;

	poll_event = (struct k_poll_event *)sys_dlist_get(events);
	if (poll_event != NULL) {
   1057e:	b108      	cbz	r0, 10584 <z_handle_obj_poll_events+0x20>
		(void) signal_poll_event(poll_event, state);
   10580:	f7ff ffa7 	bl	104d2 <signal_poll_event>
	}
}
   10584:	bd08      	pop	{r3, pc}

00010586 <memcmp>:
   10586:	b530      	push	{r4, r5, lr}
   10588:	3901      	subs	r1, #1
   1058a:	2400      	movs	r4, #0
   1058c:	42a2      	cmp	r2, r4
   1058e:	d101      	bne.n	10594 <memcmp+0xe>
   10590:	2000      	movs	r0, #0
   10592:	e005      	b.n	105a0 <memcmp+0x1a>
   10594:	5d03      	ldrb	r3, [r0, r4]
   10596:	3401      	adds	r4, #1
   10598:	5d0d      	ldrb	r5, [r1, r4]
   1059a:	42ab      	cmp	r3, r5
   1059c:	d0f6      	beq.n	1058c <memcmp+0x6>
   1059e:	1b58      	subs	r0, r3, r5
   105a0:	bd30      	pop	{r4, r5, pc}

000105a2 <memcpy>:
   105a2:	440a      	add	r2, r1
   105a4:	4291      	cmp	r1, r2
   105a6:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   105aa:	d100      	bne.n	105ae <memcpy+0xc>
   105ac:	4770      	bx	lr
   105ae:	b510      	push	{r4, lr}
   105b0:	f811 4b01 	ldrb.w	r4, [r1], #1
   105b4:	f803 4f01 	strb.w	r4, [r3, #1]!
   105b8:	4291      	cmp	r1, r2
   105ba:	d1f9      	bne.n	105b0 <memcpy+0xe>
   105bc:	bd10      	pop	{r4, pc}

000105be <memset>:
   105be:	4402      	add	r2, r0
   105c0:	4603      	mov	r3, r0
   105c2:	4293      	cmp	r3, r2
   105c4:	d100      	bne.n	105c8 <memset+0xa>
   105c6:	4770      	bx	lr
   105c8:	f803 1b01 	strb.w	r1, [r3], #1
   105cc:	e7f9      	b.n	105c2 <memset+0x4>

000105ce <__sfputc_r>:
   105ce:	6893      	ldr	r3, [r2, #8]
   105d0:	3b01      	subs	r3, #1
   105d2:	2b00      	cmp	r3, #0
   105d4:	b410      	push	{r4}
   105d6:	6093      	str	r3, [r2, #8]
   105d8:	da07      	bge.n	105ea <__sfputc_r+0x1c>
   105da:	6994      	ldr	r4, [r2, #24]
   105dc:	42a3      	cmp	r3, r4
   105de:	db01      	blt.n	105e4 <__sfputc_r+0x16>
   105e0:	290a      	cmp	r1, #10
   105e2:	d102      	bne.n	105ea <__sfputc_r+0x1c>
   105e4:	bc10      	pop	{r4}
   105e6:	f7fb bded 	b.w	c1c4 <__swbuf_r>
   105ea:	6813      	ldr	r3, [r2, #0]
   105ec:	1c58      	adds	r0, r3, #1
   105ee:	6010      	str	r0, [r2, #0]
   105f0:	7019      	strb	r1, [r3, #0]
   105f2:	4608      	mov	r0, r1
   105f4:	bc10      	pop	{r4}
   105f6:	4770      	bx	lr

000105f8 <__sfputs_r>:
   105f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   105fa:	4606      	mov	r6, r0
   105fc:	460f      	mov	r7, r1
   105fe:	4614      	mov	r4, r2
   10600:	18d5      	adds	r5, r2, r3
   10602:	42ac      	cmp	r4, r5
   10604:	d101      	bne.n	1060a <__sfputs_r+0x12>
   10606:	2000      	movs	r0, #0
   10608:	e007      	b.n	1061a <__sfputs_r+0x22>
   1060a:	f814 1b01 	ldrb.w	r1, [r4], #1
   1060e:	463a      	mov	r2, r7
   10610:	4630      	mov	r0, r6
   10612:	f7ff ffdc 	bl	105ce <__sfputc_r>
   10616:	1c43      	adds	r3, r0, #1
   10618:	d1f3      	bne.n	10602 <__sfputs_r+0xa>
   1061a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0001061c <_printf_common>:
   1061c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   10620:	4616      	mov	r6, r2
   10622:	4699      	mov	r9, r3
   10624:	688a      	ldr	r2, [r1, #8]
   10626:	690b      	ldr	r3, [r1, #16]
   10628:	f8dd 8020 	ldr.w	r8, [sp, #32]
   1062c:	4293      	cmp	r3, r2
   1062e:	bfb8      	it	lt
   10630:	4613      	movlt	r3, r2
   10632:	6033      	str	r3, [r6, #0]
   10634:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
   10638:	4607      	mov	r7, r0
   1063a:	460c      	mov	r4, r1
   1063c:	b10a      	cbz	r2, 10642 <_printf_common+0x26>
   1063e:	3301      	adds	r3, #1
   10640:	6033      	str	r3, [r6, #0]
   10642:	6823      	ldr	r3, [r4, #0]
   10644:	0699      	lsls	r1, r3, #26
   10646:	bf42      	ittt	mi
   10648:	6833      	ldrmi	r3, [r6, #0]
   1064a:	3302      	addmi	r3, #2
   1064c:	6033      	strmi	r3, [r6, #0]
   1064e:	6825      	ldr	r5, [r4, #0]
   10650:	f015 0506 	ands.w	r5, r5, #6
   10654:	d106      	bne.n	10664 <_printf_common+0x48>
   10656:	f104 0a19 	add.w	sl, r4, #25
   1065a:	68e3      	ldr	r3, [r4, #12]
   1065c:	6832      	ldr	r2, [r6, #0]
   1065e:	1a9b      	subs	r3, r3, r2
   10660:	42ab      	cmp	r3, r5
   10662:	dc26      	bgt.n	106b2 <_printf_common+0x96>
   10664:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
   10668:	1e13      	subs	r3, r2, #0
   1066a:	6822      	ldr	r2, [r4, #0]
   1066c:	bf18      	it	ne
   1066e:	2301      	movne	r3, #1
   10670:	0692      	lsls	r2, r2, #26
   10672:	d42b      	bmi.n	106cc <_printf_common+0xb0>
   10674:	f104 0243 	add.w	r2, r4, #67	; 0x43
   10678:	4649      	mov	r1, r9
   1067a:	4638      	mov	r0, r7
   1067c:	47c0      	blx	r8
   1067e:	3001      	adds	r0, #1
   10680:	d01e      	beq.n	106c0 <_printf_common+0xa4>
   10682:	6823      	ldr	r3, [r4, #0]
   10684:	68e5      	ldr	r5, [r4, #12]
   10686:	6832      	ldr	r2, [r6, #0]
   10688:	f003 0306 	and.w	r3, r3, #6
   1068c:	2b04      	cmp	r3, #4
   1068e:	bf08      	it	eq
   10690:	1aad      	subeq	r5, r5, r2
   10692:	68a3      	ldr	r3, [r4, #8]
   10694:	6922      	ldr	r2, [r4, #16]
   10696:	bf0c      	ite	eq
   10698:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
   1069c:	2500      	movne	r5, #0
   1069e:	4293      	cmp	r3, r2
   106a0:	bfc4      	itt	gt
   106a2:	1a9b      	subgt	r3, r3, r2
   106a4:	18ed      	addgt	r5, r5, r3
   106a6:	2600      	movs	r6, #0
   106a8:	341a      	adds	r4, #26
   106aa:	42b5      	cmp	r5, r6
   106ac:	d11a      	bne.n	106e4 <_printf_common+0xc8>
   106ae:	2000      	movs	r0, #0
   106b0:	e008      	b.n	106c4 <_printf_common+0xa8>
   106b2:	2301      	movs	r3, #1
   106b4:	4652      	mov	r2, sl
   106b6:	4649      	mov	r1, r9
   106b8:	4638      	mov	r0, r7
   106ba:	47c0      	blx	r8
   106bc:	3001      	adds	r0, #1
   106be:	d103      	bne.n	106c8 <_printf_common+0xac>
   106c0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   106c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   106c8:	3501      	adds	r5, #1
   106ca:	e7c6      	b.n	1065a <_printf_common+0x3e>
   106cc:	18e1      	adds	r1, r4, r3
   106ce:	1c5a      	adds	r2, r3, #1
   106d0:	2030      	movs	r0, #48	; 0x30
   106d2:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
   106d6:	4422      	add	r2, r4
   106d8:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
   106dc:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
   106e0:	3302      	adds	r3, #2
   106e2:	e7c7      	b.n	10674 <_printf_common+0x58>
   106e4:	2301      	movs	r3, #1
   106e6:	4622      	mov	r2, r4
   106e8:	4649      	mov	r1, r9
   106ea:	4638      	mov	r0, r7
   106ec:	47c0      	blx	r8
   106ee:	3001      	adds	r0, #1
   106f0:	d0e6      	beq.n	106c0 <_printf_common+0xa4>
   106f2:	3601      	adds	r6, #1
   106f4:	e7d9      	b.n	106aa <_printf_common+0x8e>

000106f6 <strncpy>:
   106f6:	b510      	push	{r4, lr}
   106f8:	3901      	subs	r1, #1
   106fa:	4603      	mov	r3, r0
   106fc:	b132      	cbz	r2, 1070c <strncpy+0x16>
   106fe:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   10702:	f803 4b01 	strb.w	r4, [r3], #1
   10706:	3a01      	subs	r2, #1
   10708:	2c00      	cmp	r4, #0
   1070a:	d1f7      	bne.n	106fc <strncpy+0x6>
   1070c:	441a      	add	r2, r3
   1070e:	2100      	movs	r1, #0
   10710:	4293      	cmp	r3, r2
   10712:	d100      	bne.n	10716 <strncpy+0x20>
   10714:	bd10      	pop	{r4, pc}
   10716:	f803 1b01 	strb.w	r1, [r3], #1
   1071a:	e7f9      	b.n	10710 <strncpy+0x1a>

0001071c <abort>:
   1071c:	b508      	push	{r3, lr}
   1071e:	2006      	movs	r0, #6
   10720:	f7fc f956 	bl	c9d0 <raise>
   10724:	2001      	movs	r0, #1
   10726:	f7f2 fec9 	bl	34bc <_exit>

0001072a <__sfmoreglue>:
   1072a:	b570      	push	{r4, r5, r6, lr}
   1072c:	1e4a      	subs	r2, r1, #1
   1072e:	2564      	movs	r5, #100	; 0x64
   10730:	4355      	muls	r5, r2
   10732:	460e      	mov	r6, r1
   10734:	f105 0170 	add.w	r1, r5, #112	; 0x70
   10738:	f7fb ffe0 	bl	c6fc <_malloc_r>
   1073c:	4604      	mov	r4, r0
   1073e:	b140      	cbz	r0, 10752 <__sfmoreglue+0x28>
   10740:	2100      	movs	r1, #0
   10742:	e9c0 1600 	strd	r1, r6, [r0]
   10746:	300c      	adds	r0, #12
   10748:	60a0      	str	r0, [r4, #8]
   1074a:	f105 0264 	add.w	r2, r5, #100	; 0x64
   1074e:	f7ff ff36 	bl	105be <memset>
   10752:	4620      	mov	r0, r4
   10754:	bd70      	pop	{r4, r5, r6, pc}

00010756 <_fwalk_reent>:
   10756:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1075a:	4606      	mov	r6, r0
   1075c:	4688      	mov	r8, r1
   1075e:	f100 0448 	add.w	r4, r0, #72	; 0x48
   10762:	2700      	movs	r7, #0
   10764:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
   10768:	f1b9 0901 	subs.w	r9, r9, #1
   1076c:	d505      	bpl.n	1077a <_fwalk_reent+0x24>
   1076e:	6824      	ldr	r4, [r4, #0]
   10770:	2c00      	cmp	r4, #0
   10772:	d1f7      	bne.n	10764 <_fwalk_reent+0xe>
   10774:	4638      	mov	r0, r7
   10776:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1077a:	89ab      	ldrh	r3, [r5, #12]
   1077c:	2b01      	cmp	r3, #1
   1077e:	d907      	bls.n	10790 <_fwalk_reent+0x3a>
   10780:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
   10784:	3301      	adds	r3, #1
   10786:	d003      	beq.n	10790 <_fwalk_reent+0x3a>
   10788:	4629      	mov	r1, r5
   1078a:	4630      	mov	r0, r6
   1078c:	47c0      	blx	r8
   1078e:	4307      	orrs	r7, r0
   10790:	3564      	adds	r5, #100	; 0x64
   10792:	e7e9      	b.n	10768 <_fwalk_reent+0x12>

00010794 <__swhatbuf_r>:
   10794:	b570      	push	{r4, r5, r6, lr}
   10796:	460e      	mov	r6, r1
   10798:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   1079c:	2900      	cmp	r1, #0
   1079e:	b096      	sub	sp, #88	; 0x58
   107a0:	4614      	mov	r4, r2
   107a2:	461d      	mov	r5, r3
   107a4:	da09      	bge.n	107ba <__swhatbuf_r+0x26>
   107a6:	89b3      	ldrh	r3, [r6, #12]
   107a8:	2200      	movs	r2, #0
   107aa:	f013 0080 	ands.w	r0, r3, #128	; 0x80
   107ae:	602a      	str	r2, [r5, #0]
   107b0:	d116      	bne.n	107e0 <__swhatbuf_r+0x4c>
   107b2:	f44f 6380 	mov.w	r3, #1024	; 0x400
   107b6:	6023      	str	r3, [r4, #0]
   107b8:	e015      	b.n	107e6 <__swhatbuf_r+0x52>
   107ba:	466a      	mov	r2, sp
   107bc:	f7fc f944 	bl	ca48 <_fstat_r>
   107c0:	2800      	cmp	r0, #0
   107c2:	dbf0      	blt.n	107a6 <__swhatbuf_r+0x12>
   107c4:	9a01      	ldr	r2, [sp, #4]
   107c6:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
   107ca:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
   107ce:	425a      	negs	r2, r3
   107d0:	415a      	adcs	r2, r3
   107d2:	f44f 6380 	mov.w	r3, #1024	; 0x400
   107d6:	602a      	str	r2, [r5, #0]
   107d8:	f44f 6000 	mov.w	r0, #2048	; 0x800
   107dc:	6023      	str	r3, [r4, #0]
   107de:	e002      	b.n	107e6 <__swhatbuf_r+0x52>
   107e0:	2340      	movs	r3, #64	; 0x40
   107e2:	6023      	str	r3, [r4, #0]
   107e4:	4610      	mov	r0, r2
   107e6:	b016      	add	sp, #88	; 0x58
   107e8:	bd70      	pop	{r4, r5, r6, pc}

000107ea <memmove>:
   107ea:	4288      	cmp	r0, r1
   107ec:	b510      	push	{r4, lr}
   107ee:	eb01 0402 	add.w	r4, r1, r2
   107f2:	d902      	bls.n	107fa <memmove+0x10>
   107f4:	4284      	cmp	r4, r0
   107f6:	4623      	mov	r3, r4
   107f8:	d807      	bhi.n	1080a <memmove+0x20>
   107fa:	1e43      	subs	r3, r0, #1
   107fc:	42a1      	cmp	r1, r4
   107fe:	d008      	beq.n	10812 <memmove+0x28>
   10800:	f811 2b01 	ldrb.w	r2, [r1], #1
   10804:	f803 2f01 	strb.w	r2, [r3, #1]!
   10808:	e7f8      	b.n	107fc <memmove+0x12>
   1080a:	4402      	add	r2, r0
   1080c:	4601      	mov	r1, r0
   1080e:	428a      	cmp	r2, r1
   10810:	d100      	bne.n	10814 <memmove+0x2a>
   10812:	bd10      	pop	{r4, pc}
   10814:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
   10818:	f802 4d01 	strb.w	r4, [r2, #-1]!
   1081c:	e7f7      	b.n	1080e <memmove+0x24>

0001081e <_realloc_r>:
   1081e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10820:	4607      	mov	r7, r0
   10822:	4614      	mov	r4, r2
   10824:	460e      	mov	r6, r1
   10826:	b921      	cbnz	r1, 10832 <_realloc_r+0x14>
   10828:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   1082c:	4611      	mov	r1, r2
   1082e:	f7fb bf65 	b.w	c6fc <_malloc_r>
   10832:	b922      	cbnz	r2, 1083e <_realloc_r+0x20>
   10834:	f7fb ff14 	bl	c660 <_free_r>
   10838:	4625      	mov	r5, r4
   1083a:	4628      	mov	r0, r5
   1083c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1083e:	f000 f8de 	bl	109fe <_malloc_usable_size_r>
   10842:	42a0      	cmp	r0, r4
   10844:	d20f      	bcs.n	10866 <_realloc_r+0x48>
   10846:	4621      	mov	r1, r4
   10848:	4638      	mov	r0, r7
   1084a:	f7fb ff57 	bl	c6fc <_malloc_r>
   1084e:	4605      	mov	r5, r0
   10850:	2800      	cmp	r0, #0
   10852:	d0f2      	beq.n	1083a <_realloc_r+0x1c>
   10854:	4631      	mov	r1, r6
   10856:	4622      	mov	r2, r4
   10858:	f7ff fea3 	bl	105a2 <memcpy>
   1085c:	4631      	mov	r1, r6
   1085e:	4638      	mov	r0, r7
   10860:	f7fb fefe 	bl	c660 <_free_r>
   10864:	e7e9      	b.n	1083a <_realloc_r+0x1c>
   10866:	4635      	mov	r5, r6
   10868:	e7e7      	b.n	1083a <_realloc_r+0x1c>

0001086a <__ssputs_r>:
   1086a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1086e:	688e      	ldr	r6, [r1, #8]
   10870:	429e      	cmp	r6, r3
   10872:	4682      	mov	sl, r0
   10874:	460c      	mov	r4, r1
   10876:	4690      	mov	r8, r2
   10878:	461f      	mov	r7, r3
   1087a:	d838      	bhi.n	108ee <__ssputs_r+0x84>
   1087c:	898a      	ldrh	r2, [r1, #12]
   1087e:	f412 6f90 	tst.w	r2, #1152	; 0x480
   10882:	d032      	beq.n	108ea <__ssputs_r+0x80>
   10884:	6825      	ldr	r5, [r4, #0]
   10886:	6909      	ldr	r1, [r1, #16]
   10888:	eba5 0901 	sub.w	r9, r5, r1
   1088c:	6965      	ldr	r5, [r4, #20]
   1088e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   10892:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   10896:	3301      	adds	r3, #1
   10898:	444b      	add	r3, r9
   1089a:	106d      	asrs	r5, r5, #1
   1089c:	429d      	cmp	r5, r3
   1089e:	bf38      	it	cc
   108a0:	461d      	movcc	r5, r3
   108a2:	0553      	lsls	r3, r2, #21
   108a4:	d531      	bpl.n	1090a <__ssputs_r+0xa0>
   108a6:	4629      	mov	r1, r5
   108a8:	f7fb ff28 	bl	c6fc <_malloc_r>
   108ac:	4606      	mov	r6, r0
   108ae:	b950      	cbnz	r0, 108c6 <__ssputs_r+0x5c>
   108b0:	230c      	movs	r3, #12
   108b2:	f8ca 3000 	str.w	r3, [sl]
   108b6:	89a3      	ldrh	r3, [r4, #12]
   108b8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   108bc:	81a3      	strh	r3, [r4, #12]
   108be:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   108c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   108c6:	6921      	ldr	r1, [r4, #16]
   108c8:	464a      	mov	r2, r9
   108ca:	f7ff fe6a 	bl	105a2 <memcpy>
   108ce:	89a3      	ldrh	r3, [r4, #12]
   108d0:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
   108d4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   108d8:	81a3      	strh	r3, [r4, #12]
   108da:	6126      	str	r6, [r4, #16]
   108dc:	6165      	str	r5, [r4, #20]
   108de:	444e      	add	r6, r9
   108e0:	eba5 0509 	sub.w	r5, r5, r9
   108e4:	6026      	str	r6, [r4, #0]
   108e6:	60a5      	str	r5, [r4, #8]
   108e8:	463e      	mov	r6, r7
   108ea:	42be      	cmp	r6, r7
   108ec:	d900      	bls.n	108f0 <__ssputs_r+0x86>
   108ee:	463e      	mov	r6, r7
   108f0:	4632      	mov	r2, r6
   108f2:	6820      	ldr	r0, [r4, #0]
   108f4:	4641      	mov	r1, r8
   108f6:	f7ff ff78 	bl	107ea <memmove>
   108fa:	68a3      	ldr	r3, [r4, #8]
   108fc:	6822      	ldr	r2, [r4, #0]
   108fe:	1b9b      	subs	r3, r3, r6
   10900:	4432      	add	r2, r6
   10902:	60a3      	str	r3, [r4, #8]
   10904:	6022      	str	r2, [r4, #0]
   10906:	2000      	movs	r0, #0
   10908:	e7db      	b.n	108c2 <__ssputs_r+0x58>
   1090a:	462a      	mov	r2, r5
   1090c:	f7ff ff87 	bl	1081e <_realloc_r>
   10910:	4606      	mov	r6, r0
   10912:	2800      	cmp	r0, #0
   10914:	d1e1      	bne.n	108da <__ssputs_r+0x70>
   10916:	6921      	ldr	r1, [r4, #16]
   10918:	4650      	mov	r0, sl
   1091a:	f7fb fea1 	bl	c660 <_free_r>
   1091e:	e7c7      	b.n	108b0 <__ssputs_r+0x46>

00010920 <_raise_r>:
   10920:	291f      	cmp	r1, #31
   10922:	b538      	push	{r3, r4, r5, lr}
   10924:	4604      	mov	r4, r0
   10926:	460d      	mov	r5, r1
   10928:	d904      	bls.n	10934 <_raise_r+0x14>
   1092a:	2316      	movs	r3, #22
   1092c:	6003      	str	r3, [r0, #0]
   1092e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   10932:	bd38      	pop	{r3, r4, r5, pc}
   10934:	6c42      	ldr	r2, [r0, #68]	; 0x44
   10936:	b112      	cbz	r2, 1093e <_raise_r+0x1e>
   10938:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   1093c:	b94b      	cbnz	r3, 10952 <_raise_r+0x32>
   1093e:	4620      	mov	r0, r4
   10940:	f000 f816 	bl	10970 <_getpid_r>
   10944:	462a      	mov	r2, r5
   10946:	4601      	mov	r1, r0
   10948:	4620      	mov	r0, r4
   1094a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1094e:	f7fc b847 	b.w	c9e0 <_kill_r>
   10952:	2b01      	cmp	r3, #1
   10954:	d00a      	beq.n	1096c <_raise_r+0x4c>
   10956:	1c59      	adds	r1, r3, #1
   10958:	d103      	bne.n	10962 <_raise_r+0x42>
   1095a:	2316      	movs	r3, #22
   1095c:	6003      	str	r3, [r0, #0]
   1095e:	2001      	movs	r0, #1
   10960:	e7e7      	b.n	10932 <_raise_r+0x12>
   10962:	2400      	movs	r4, #0
   10964:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
   10968:	4628      	mov	r0, r5
   1096a:	4798      	blx	r3
   1096c:	2000      	movs	r0, #0
   1096e:	e7e0      	b.n	10932 <_raise_r+0x12>

00010970 <_getpid_r>:
   10970:	f7fd bbc9 	b.w	e106 <_getpid>

00010974 <__sread>:
   10974:	b510      	push	{r4, lr}
   10976:	460c      	mov	r4, r1
   10978:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   1097c:	f7fc f898 	bl	cab0 <_read_r>
   10980:	2800      	cmp	r0, #0
   10982:	bfab      	itete	ge
   10984:	6d63      	ldrge	r3, [r4, #84]	; 0x54
   10986:	89a3      	ldrhlt	r3, [r4, #12]
   10988:	181b      	addge	r3, r3, r0
   1098a:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
   1098e:	bfac      	ite	ge
   10990:	6563      	strge	r3, [r4, #84]	; 0x54
   10992:	81a3      	strhlt	r3, [r4, #12]
   10994:	bd10      	pop	{r4, pc}

00010996 <__swrite>:
   10996:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1099a:	461f      	mov	r7, r3
   1099c:	898b      	ldrh	r3, [r1, #12]
   1099e:	05db      	lsls	r3, r3, #23
   109a0:	4605      	mov	r5, r0
   109a2:	460c      	mov	r4, r1
   109a4:	4616      	mov	r6, r2
   109a6:	d505      	bpl.n	109b4 <__swrite+0x1e>
   109a8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   109ac:	2302      	movs	r3, #2
   109ae:	2200      	movs	r2, #0
   109b0:	f7fc f86c 	bl	ca8c <_lseek_r>
   109b4:	89a3      	ldrh	r3, [r4, #12]
   109b6:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   109ba:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   109be:	81a3      	strh	r3, [r4, #12]
   109c0:	4632      	mov	r2, r6
   109c2:	463b      	mov	r3, r7
   109c4:	4628      	mov	r0, r5
   109c6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   109ca:	f7fc b81b 	b.w	ca04 <_write_r>

000109ce <__sseek>:
   109ce:	b510      	push	{r4, lr}
   109d0:	460c      	mov	r4, r1
   109d2:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   109d6:	f7fc f859 	bl	ca8c <_lseek_r>
   109da:	1c43      	adds	r3, r0, #1
   109dc:	89a3      	ldrh	r3, [r4, #12]
   109de:	bf15      	itete	ne
   109e0:	6560      	strne	r0, [r4, #84]	; 0x54
   109e2:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
   109e6:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
   109ea:	81a3      	strheq	r3, [r4, #12]
   109ec:	bf18      	it	ne
   109ee:	81a3      	strhne	r3, [r4, #12]
   109f0:	bd10      	pop	{r4, pc}

000109f2 <__sclose>:
   109f2:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   109f6:	f7fc b817 	b.w	ca28 <_close_r>

000109fa <__malloc_lock>:
   109fa:	4770      	bx	lr

000109fc <__malloc_unlock>:
   109fc:	4770      	bx	lr

000109fe <_malloc_usable_size_r>:
   109fe:	f851 3c04 	ldr.w	r3, [r1, #-4]
   10a02:	1f18      	subs	r0, r3, #4
   10a04:	2b00      	cmp	r3, #0
   10a06:	bfbc      	itt	lt
   10a08:	580b      	ldrlt	r3, [r1, r0]
   10a0a:	18c0      	addlt	r0, r0, r3
   10a0c:	4770      	bx	lr
